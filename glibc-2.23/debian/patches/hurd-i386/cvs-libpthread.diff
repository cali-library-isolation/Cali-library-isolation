git snapshot 733616d782505a538bc2df900fe211a4e5a68b54
from git.savannah.gnu.org:/srv/git/hurd/libpthread.git/
thus by construction only libpthread/ files, thus hurd-only
Date:   Sun Mar 22 23:26:51 2015 +0100

---
 ChangeLog                                     |    6 
 Makeconfig                                    |   12 
 Makefile                                      |  340 +++++++++++
 TODO                                          |  131 ++++
 Versions                                      |  139 ++++
 configure.in                                  |    4 
 forward.c                                     |  232 +++++++
 include/libc-symbols.h                        |  395 +++++++++++++
 include/pthread.h                             |    7 
 include/pthread/pthread.h                     |  755 ++++++++++++++++++++++++++
 include/pthread/pthreadtypes.h                |  125 ++++
 include/semaphore.h                           |   69 ++
 include/set-hooks.h                           |   72 ++
 libc_pthread_init.c                           |   34 +
 libpthread.a                                  |   23 
 libpthread_pic.a                              |   23 
 lockfile.c                                    |   65 ++
 not-in-libc.h                                 |   11 
 pthread/Versions                              |   15 
 pthread/cthreads-compat.c                     |  107 +++
 pthread/pt-alloc.c                            |  219 +++++++
 pthread/pt-cancel.c                           |   63 ++
 pthread/pt-cleanup.c                          |   28 
 pthread/pt-create.c                           |  251 ++++++++
 pthread/pt-dealloc.c                          |   69 ++
 pthread/pt-detach.c                           |   80 ++
 pthread/pt-exit.c                             |  112 +++
 pthread/pt-getattr.c                          |   51 +
 pthread/pt-initialize.c                       |   78 ++
 pthread/pt-internal.h                         |  339 +++++++++++
 pthread/pt-join.c                             |   76 ++
 pthread/pt-self.c                             |   34 +
 pthread/pt-setcancelstate.c                   |   47 +
 pthread/pt-setcanceltype.c                    |   47 +
 pthread/pt-sigmask.c                          |   33 +
 pthread/pt-spin-inlines.c                     |   34 +
 pthread/pt-testcancel.c                       |   36 +
 pthread/pt-yield.c                            |   26 
 pthread/pthread-functions.h                   |  116 +++
 shlib-versions                                |    1 
 sysdeps/pthread/bits/barrier-attr.h           |   32 +
 sysdeps/pthread/bits/barrier.h                |   39 +
 sysdeps/pthread/bits/cancelation.h            |   51 +
 sysdeps/pthread/bits/condition-attr.h         |   34 +
 sysdeps/pthread/bits/condition.h              |   39 +
 sysdeps/pthread/bits/mutex-attr.h             |   41 +
 sysdeps/pthread/bits/mutex.h                  |   75 ++
 sysdeps/pthread/bits/once.h                   |   34 +
 sysdeps/pthread/bits/pthread-np.h             |   27 
 sysdeps/pthread/bits/pthread.h                |   38 +
 sysdeps/pthread/bits/pthreadtypes.h           |   29 
 sysdeps/pthread/bits/rwlock-attr.h            |   32 +
 sysdeps/pthread/bits/rwlock.h                 |   46 +
 sysdeps/pthread/bits/semaphore.h              |   43 +
 sysdeps/pthread/bits/thread-attr.h            |   44 +
 sysdeps/pthread/bits/thread-specific.h        |   25 
 sysdeps/generic/killpg.c                      |   27 
 sysdeps/generic/pt-atfork.c                   |   29 
 sysdeps/generic/pt-attr-destroy.c             |   28 
 sysdeps/generic/pt-attr-getdetachstate.c      |   31 +
 sysdeps/generic/pt-attr-getguardsize.c        |   29 
 sysdeps/generic/pt-attr-getinheritsched.c     |   31 +
 sysdeps/generic/pt-attr-getschedparam.c       |   34 +
 sysdeps/generic/pt-attr-getschedpolicy.c      |   31 +
 sysdeps/generic/pt-attr-getscope.c            |   31 +
 sysdeps/generic/pt-attr-getstack.c            |   31 +
 sysdeps/generic/pt-attr-getstackaddr.c        |   29 
 sysdeps/generic/pt-attr-getstacksize.c        |   29 
 sysdeps/generic/pt-attr-init.c                |   29 
 sysdeps/generic/pt-attr-setdetachstate.c      |   40 +
 sysdeps/generic/pt-attr-setguardsize.c        |   29 
 sysdeps/generic/pt-attr-setinheritsched.c     |   40 +
 sysdeps/generic/pt-attr-setschedparam.c       |   40 +
 sysdeps/generic/pt-attr-setschedpolicy.c      |   44 +
 sysdeps/generic/pt-attr-setscope.c            |   43 +
 sysdeps/generic/pt-attr-setstack.c            |   51 +
 sysdeps/generic/pt-attr-setstackaddr.c        |   29 
 sysdeps/generic/pt-attr-setstacksize.c        |   30 +
 sysdeps/generic/pt-attr.c                     |   41 +
 sysdeps/generic/pt-barrier-destroy.c          |   27 
 sysdeps/generic/pt-barrier-init.c             |   53 +
 sysdeps/generic/pt-barrier-wait.c             |   69 ++
 sysdeps/generic/pt-barrier.c                  |   26 
 sysdeps/generic/pt-barrierattr-destroy.c      |   27 
 sysdeps/generic/pt-barrierattr-getpshared.c   |   29 
 sysdeps/generic/pt-barrierattr-init.c         |   28 
 sysdeps/generic/pt-barrierattr-setpshared.c   |   39 +
 sysdeps/generic/pt-cond-brdcast.c             |   45 +
 sysdeps/generic/pt-cond-destroy.c             |   29 
 sysdeps/generic/pt-cond-init.c                |   47 +
 sysdeps/generic/pt-cond-signal.c              |   43 +
 sysdeps/generic/pt-cond-timedwait.c           |  178 ++++++
 sysdeps/generic/pt-cond-wait.c                |   39 +
 sysdeps/generic/pt-cond.c                     |   29 
 sysdeps/generic/pt-condattr-destroy.c         |   29 
 sysdeps/generic/pt-condattr-getclock.c        |   31 +
 sysdeps/generic/pt-condattr-getpshared.c      |   29 
 sysdeps/generic/pt-condattr-init.c            |   30 +
 sysdeps/generic/pt-condattr-setclock.c        |   52 +
 sysdeps/generic/pt-condattr-setpshared.c      |   39 +
 sysdeps/generic/pt-destroy-specific.c         |   28 
 sysdeps/generic/pt-equal.c                    |   31 +
 sysdeps/generic/pt-getconcurrency.c           |   27 
 sysdeps/generic/pt-getcpuclockid.c            |   35 +
 sysdeps/generic/pt-getschedparam.c            |   31 +
 sysdeps/generic/pt-getspecific.c              |   27 
 sysdeps/generic/pt-init-specific.c            |   27 
 sysdeps/generic/pt-key-create.c               |   29 
 sysdeps/generic/pt-key-delete.c               |   29 
 sysdeps/generic/pt-key.h                      |   22 
 sysdeps/generic/pt-kill.c                     |   32 +
 sysdeps/generic/pt-mutex-destroy.c            |   39 +
 sysdeps/generic/pt-mutex-getprioceiling.c     |   30 +
 sysdeps/generic/pt-mutex-init.c               |   50 +
 sysdeps/generic/pt-mutex-lock.c               |   37 +
 sysdeps/generic/pt-mutex-setprioceiling.c     |   30 +
 sysdeps/generic/pt-mutex-timedlock.c          |  196 ++++++
 sysdeps/generic/pt-mutex-transfer-np.c        |   66 ++
 sysdeps/generic/pt-mutex-trylock.c            |  112 +++
 sysdeps/generic/pt-mutex-unlock.c             |  108 +++
 sysdeps/generic/pt-mutexattr-destroy.c        |   27 
 sysdeps/generic/pt-mutexattr-getprioceiling.c |   30 +
 sysdeps/generic/pt-mutexattr-getprotocol.c    |   29 
 sysdeps/generic/pt-mutexattr-getpshared.c     |   29 
 sysdeps/generic/pt-mutexattr-gettype.c        |   28 
 sysdeps/generic/pt-mutexattr-init.c           |   28 
 sysdeps/generic/pt-mutexattr-setprioceiling.c |   30 +
 sysdeps/generic/pt-mutexattr-setprotocol.c    |   42 +
 sysdeps/generic/pt-mutexattr-setpshared.c     |   39 +
 sysdeps/generic/pt-mutexattr-settype.c        |   37 +
 sysdeps/generic/pt-mutexattr.c                |   45 +
 sysdeps/generic/pt-once.c                     |   43 +
 sysdeps/generic/pt-rwlock-attr.c              |   26 
 sysdeps/generic/pt-rwlock-destroy.c           |   29 
 sysdeps/generic/pt-rwlock-init.c              |   45 +
 sysdeps/generic/pt-rwlock-rdlock.c            |   32 +
 sysdeps/generic/pt-rwlock-timedrdlock.c       |  120 ++++
 sysdeps/generic/pt-rwlock-timedwrlock.c       |  103 +++
 sysdeps/generic/pt-rwlock-tryrdlock.c         |   56 +
 sysdeps/generic/pt-rwlock-trywrlock.c         |   46 +
 sysdeps/generic/pt-rwlock-unlock.c            |   98 +++
 sysdeps/generic/pt-rwlock-wrlock.c            |   34 +
 sysdeps/generic/pt-rwlockattr-destroy.c       |   27 
 sysdeps/generic/pt-rwlockattr-getpshared.c    |   29 
 sysdeps/generic/pt-rwlockattr-init.c          |   28 
 sysdeps/generic/pt-rwlockattr-setpshared.c    |   39 +
 sysdeps/generic/pt-setconcurrency.c           |   34 +
 sysdeps/generic/pt-setschedparam.c            |   31 +
 sysdeps/generic/pt-setschedprio.c             |   29 
 sysdeps/generic/pt-setspecific.c              |   27 
 sysdeps/generic/pt-startup.c                  |   25 
 sysdeps/generic/raise.c                       |   41 +
 sysdeps/generic/sem-close.c                   |   32 +
 sysdeps/generic/sem-destroy.c                 |   38 +
 sysdeps/generic/sem-getvalue.c                |   33 +
 sysdeps/generic/sem-init.c                    |   46 +
 sysdeps/generic/sem-open.c                    |   32 +
 sysdeps/generic/sem-post.c                    |   62 ++
 sysdeps/generic/sem-timedwait.c               |  100 +++
 sysdeps/generic/sem-trywait.c                 |   42 +
 sysdeps/generic/sem-unlink.c                  |   32 +
 sysdeps/generic/sem-wait.c                    |   32 +
 sysdeps/generic/sigaddset.c                   |   35 +
 sysdeps/generic/sigdelset.c                   |   35 +
 sysdeps/generic/sigemptyset.c                 |   29 
 sysdeps/generic/sigfillset.c                  |   29 
 sysdeps/generic/siginterrupt.c                |   36 +
 sysdeps/generic/sigismember.c                 |   36 +
 sysdeps/generic/signal.c                      |   44 +
 sysdeps/generic/sigwait.c                     |   34 +
 sysdeps/hurd/pt-destroy-specific.c            |   79 ++
 sysdeps/hurd/pt-getspecific.c                 |   39 +
 sysdeps/hurd/pt-init-specific.c               |   30 +
 sysdeps/hurd/pt-key-create.c                  |  111 +++
 sysdeps/hurd/pt-key-delete.c                  |   64 ++
 sysdeps/hurd/pt-key.h                         |   76 ++
 sysdeps/hurd/pt-kill.c                        |   52 +
 sysdeps/hurd/pt-setspecific.c                 |   47 +
 sysdeps/i386/bits/memory.h                    |   40 +
 sysdeps/i386/bits/pt-atomic.h                 |   66 ++
 sysdeps/i386/bits/spin-lock-inline.h          |   98 +++
 sysdeps/i386/bits/spin-lock.h                 |   39 +
 sysdeps/i386/machine-sp.h                     |   30 +
 sysdeps/i386/pt-machdep.h                     |   29 
 sysdeps/mach/bits/spin-lock-inline.h          |   90 +++
 sysdeps/mach/bits/spin-lock.h                 |   38 +
 sysdeps/mach/hurd/Implies                     |    2 
 sysdeps/mach/hurd/bits/pthread-np.h           |   38 +
 sysdeps/mach/hurd/i386/pt-machdep.c           |   83 ++
 sysdeps/mach/hurd/i386/pt-setup.c             |  110 +++
 sysdeps/mach/hurd/pt-attr-setstackaddr.c      |   29 
 sysdeps/mach/hurd/pt-attr-setstacksize.c      |   29 
 sysdeps/mach/hurd/pt-docancel.c               |   66 ++
 sysdeps/mach/hurd/pt-hurd-cond-timedwait.c    |  169 +++++
 sysdeps/mach/hurd/pt-hurd-cond-wait.c         |   41 +
 sysdeps/mach/hurd/pt-sigstate-destroy.c       |   28 
 sysdeps/mach/hurd/pt-sigstate-init.c          |   44 +
 sysdeps/mach/hurd/pt-sigstate.c               |   69 ++
 sysdeps/mach/hurd/pt-sysdep.c                 |   70 ++
 sysdeps/mach/hurd/pt-sysdep.h                 |   67 ++
 sysdeps/mach/pt-block.c                       |   39 +
 sysdeps/mach/pt-spin.c                        |   36 +
 sysdeps/mach/pt-stack-alloc.c                 |   69 ++
 sysdeps/mach/pt-thread-alloc.c                |   95 +++
 sysdeps/mach/pt-thread-start.c                |   51 +
 sysdeps/mach/pt-thread-terminate.c            |   85 ++
 sysdeps/mach/pt-timedblock.c                  |   68 ++
 sysdeps/mach/pt-wakeup.c                      |   38 +
 sysdeps/posix/pt-spin.c                       |   54 +
 sysdeps/pthread/Makefile                      |    4 
 tests/.cvsignore                              |    1 
 tests/Makefile                                |   40 +
 tests/README                                  |    6 
 tests/test-1.c                                |   50 +
 tests/test-10.c                               |   46 +
 tests/test-11.c                               |  143 ++++
 tests/test-12.c                               |   29 
 tests/test-13.c                               |   66 ++
 tests/test-14.c                               |   44 +
 tests/test-15.c                               |   87 ++
 tests/test-16.c                               |   71 ++
 tests/test-17.c                               |   57 +
 tests/test-2.c                                |   39 +
 tests/test-3.c                                |   55 +
 tests/test-4.c                                |   86 ++
 tests/test-5.c                                |   75 ++
 tests/test-6.c                                |   96 +++
 tests/test-7.c                                |   70 ++
 tests/test-8.c                                |   60 ++
 tests/test-9.c                                |   88 +++
 tests/test-__pthread_destroy_specific-skip.c  |   83 ++
 231 files changed, 13251 insertions(+)
Index: glibc-2.21/libpthread/ChangeLog
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/ChangeLog
@@ -0,0 +1,6 @@
+51839d398b0f9885a17ab5c0768b8dec4dd9eb79 is the last commit imported from CVS.
+All commits after that one have valid author and committer information.
+
+Use this to examine the change log for earlier changes:
+
+    $ git show 51839d398b0f9885a17ab5c0768b8dec4dd9eb79:ChangeLog
Index: glibc-2.21/libpthread/configure.in
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/configure.in
@@ -0,0 +1,4 @@
+GLIBC_PROVIDES
+
+libc_add_on_canonical=libpthread
+libc_add_on_subdirs=.
Index: glibc-2.21/libpthread/forward.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/forward.c
@@ -0,0 +1,245 @@
+/* Copyright (C) 2002, 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <shlib-compat.h>
+#include <pthread-functions.h>
+
+/* Pointers to the libc functions.  */
+struct pthread_functions __libc_pthread_functions attribute_hidden;
+int __libc_pthread_functions_init attribute_hidden;
+
+
+# define FORWARD2(name, rettype, decl, params, defaction) \
+rettype									      \
+name decl								      \
+{									      \
+  if (!__libc_pthread_functions_init)			      \
+    defaction;								      \
+									      \
+  return PTHFCT_CALL (ptr_##name, params);			      \
+}
+
+/* Same as FORWARD2, only without return.  */
+# define FORWARD_NORETURN(name, rettype, decl, params, defaction) \
+rettype									      \
+name decl								      \
+{									      \
+  if (!__libc_pthread_functions_init)			      \
+    defaction;								      \
+									      \
+  PTHFCT_CALL (ptr_##name, params);			      \
+}
+
+# define FORWARD(name, decl, params, defretval) \
+  FORWARD2 (name, int, decl, params, return defretval)
+
+FORWARD (pthread_attr_destroy, (pthread_attr_t *attr), (attr), 0)
+
+FORWARD (pthread_attr_init, (pthread_attr_t *attr), (attr), 0)
+
+FORWARD (pthread_attr_getdetachstate,
+	 (const pthread_attr_t *attr, int *detachstate), (attr, detachstate),
+	 0)
+FORWARD (pthread_attr_setdetachstate, (pthread_attr_t *attr, int detachstate),
+	 (attr, detachstate), 0)
+
+FORWARD (pthread_attr_getinheritsched,
+	 (const pthread_attr_t *attr, int *inherit), (attr, inherit), 0)
+FORWARD (pthread_attr_setinheritsched, (pthread_attr_t *attr, int inherit),
+	 (attr, inherit), 0)
+
+FORWARD (pthread_attr_getschedparam,
+	 (const pthread_attr_t *attr, struct sched_param *param),
+	 (attr, param), 0)
+FORWARD (pthread_attr_setschedparam,
+	 (pthread_attr_t *attr, const struct sched_param *param),
+	 (attr, param), 0)
+
+FORWARD (pthread_attr_getschedpolicy,
+	 (const pthread_attr_t *attr, int *policy), (attr, policy), 0)
+FORWARD (pthread_attr_setschedpolicy, (pthread_attr_t *attr, int policy),
+	 (attr, policy), 0)
+
+FORWARD (pthread_attr_getscope,
+	 (const pthread_attr_t *attr, int *scope), (attr, scope), 0)
+FORWARD (pthread_attr_setscope, (pthread_attr_t *attr, int scope),
+	 (attr, scope), 0)
+
+
+FORWARD (pthread_condattr_destroy, (pthread_condattr_t *attr), (attr), 0)
+FORWARD (pthread_condattr_init, (pthread_condattr_t *attr), (attr), 0)
+
+
+FORWARD (pthread_cond_broadcast, (pthread_cond_t *cond), (cond), 0)
+FORWARD (pthread_cond_destroy, (pthread_cond_t *cond), (cond), 0)
+FORWARD (pthread_cond_init,
+	 (pthread_cond_t *cond, const pthread_condattr_t *cond_attr),
+	 (cond, cond_attr), 0)
+FORWARD (pthread_cond_signal, (pthread_cond_t *cond), (cond), 0)
+FORWARD (pthread_cond_wait, (pthread_cond_t *cond, pthread_mutex_t *mutex),
+	 (cond, mutex), 0)
+FORWARD (pthread_cond_timedwait,
+	 (pthread_cond_t *cond, pthread_mutex_t *mutex,
+	  const struct timespec *abstime), (cond, mutex, abstime), 0)
+
+FORWARD (pthread_equal, (pthread_t thread1, pthread_t thread2),
+	 (thread1, thread2), 1)
+
+
+/* Use an alias to avoid warning, as pthread_exit is declared noreturn.  */
+FORWARD_NORETURN (__pthread_exit, void, (void *retval), (retval), exit (EXIT_SUCCESS))
+strong_alias (__pthread_exit, pthread_exit);
+
+
+FORWARD (pthread_getschedparam,
+	 (pthread_t target_thread, int *policy, struct sched_param *param),
+	 (target_thread, policy, param), 0)
+FORWARD (pthread_setschedparam,
+	 (pthread_t target_thread, int policy,
+	  const struct sched_param *param), (target_thread, policy, param), 0)
+
+
+FORWARD (pthread_mutex_destroy, (pthread_mutex_t *mutex), (mutex), 0)
+
+FORWARD (pthread_mutex_init,
+	 (pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr),
+	 (mutex, mutexattr), 0)
+
+FORWARD (pthread_mutex_lock, (pthread_mutex_t *mutex), (mutex), 0)
+
+FORWARD (pthread_mutex_unlock, (pthread_mutex_t *mutex), (mutex), 0)
+
+
+FORWARD2 (pthread_self, pthread_t, (void), (), return 0)
+
+
+FORWARD (pthread_setcancelstate, (int state, int *oldstate), (state, oldstate),
+	 0)
+
+FORWARD (pthread_setcanceltype, (int type, int *oldtype), (type, oldtype), 0)
+
+struct __pthread_cancelation_handler *dummy_list;
+FORWARD2 (__pthread_get_cleanup_stack, struct __pthread_cancelation_handler **, (void), (), return &dummy_list);
+
+
+/* Fork interaction */
+
+struct atfork {
+  void (*prepare) (void);
+  void (*parent) (void);
+  void (*child) (void);
+  struct atfork *prev;
+  struct atfork *next;
+};
+
+/* TODO: better locking */
+static struct mutex atfork_lock;
+static struct atfork *fork_handlers, *fork_last_handler;
+
+static void
+atfork_pthread_prepare (void)
+{
+  struct atfork *handlers, *last_handler;
+
+  __mutex_lock (&atfork_lock);
+  handlers = fork_handlers;
+  last_handler = fork_last_handler;
+  __mutex_unlock (&atfork_lock);
+
+  if (!last_handler)
+    return;
+
+  while(1)
+  {
+    if (last_handler->prepare != NULL)
+      last_handler->prepare ();
+    if (last_handler == handlers)
+      break;
+    last_handler = last_handler->prev;
+  }
+}
+text_set_element (_hurd_atfork_prepare_hook, atfork_pthread_prepare);
+
+static void
+atfork_pthread_parent (void)
+{
+  struct atfork *handlers;
+
+  __mutex_lock (&atfork_lock);
+  handlers = fork_handlers;
+  __mutex_unlock (&atfork_lock);
+
+  while (handlers)
+  {
+    if (handlers->parent != NULL)
+      handlers->parent ();
+    handlers = handlers->next;
+  }
+}
+text_set_element (_hurd_atfork_parent_hook, atfork_pthread_parent);
+
+static void
+atfork_pthread_child (void)
+{
+  struct atfork *handlers;
+
+  __mutex_lock (&atfork_lock);
+  handlers = fork_handlers;
+  __mutex_unlock (&atfork_lock);
+
+  while (handlers)
+  {
+    if (handlers->child != NULL)
+      handlers->child ();
+    handlers = handlers->next;
+  }
+}
+text_set_element (_hurd_atfork_child_hook, atfork_pthread_child);
+
+int
+__register_atfork (
+    void (*prepare) (void),
+    void (*parent) (void),
+    void (*child) (void))
+{
+  struct atfork *new = malloc (sizeof (*new));
+  if (!new)
+    return errno;
+
+  new->prepare = prepare;
+  new->parent = parent;
+  new->child = child;
+  new->prev = NULL;
+
+  __mutex_lock (&atfork_lock);
+  new->next = fork_handlers;
+  if (fork_handlers)
+  	fork_handlers->prev = new;
+  fork_handlers = new;
+  if (!fork_last_handler)
+    fork_last_handler = new;
+  __mutex_unlock (&atfork_lock);
+
+  return 0;
+}
+
+/* TODO: unregister_atfork, and define UNREGISTER_ATFORK, for module unload support */
Index: glibc-2.21/libpthread/include/libc-symbols.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/include/libc-symbols.h
@@ -0,0 +1,395 @@
+/* Support macros for making weak and strong aliases for symbols,
+   and for using symbol sets and linker warnings with GNU ld.
+   Copyright (C) 1995, 1996, 1997, 1998, 2000, 2001, 2002, 2008
+     Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _LIBC_SYMBOLS_H
+#define _LIBC_SYMBOLS_H	1
+
+/* This file's macros are included implicitly in the compilation of every
+   file in the C library by -imacros.
+
+   We include config.h which is generated by configure.
+   It should define for us the following symbols:
+
+   * HAVE_ASM_SET_DIRECTIVE if we have `.set B, A' instead of `A = B'.
+   * ASM_GLOBAL_DIRECTIVE with `.globl' or `.global'.
+   * HAVE_GNU_LD if using GNU ld, with support for weak symbols in a.out,
+   and for symbol set and warning messages extensions in a.out and ELF.
+   * HAVE_ELF if using ELF, which supports weak symbols using `.weak'.
+   * HAVE_ASM_WEAK_DIRECTIVE if we have weak symbols using `.weak'.
+   * HAVE_ASM_WEAKEXT_DIRECTIVE if we have weak symbols using `.weakext'.
+
+   */
+
+/* This is defined for the compilation of all C library code.  features.h
+   tests this to avoid inclusion of stubs.h while compiling the library,
+   before stubs.h has been generated.  Some library code that is shared
+   with other packages also tests this symbol to see if it is being
+   compiled as part of the C library.  We must define this before including
+   config.h, because it makes some definitions conditional on whether libc
+   itself is being compiled, or just some generator program.  */
+// #define _LIBC	1
+
+/* Enable declarations of GNU extensions, since we are compiling them.  */
+#define _GNU_SOURCE	1
+/* And we also need the data for the reentrant functions.  */
+#define _REENTRANT	1
+
+// #include <config.h>
+#define HAVE_ASM_WEAK_DIRECTIVE
+#define HAVE_WEAK_SYMBOLS
+#define HAVE_ASM_SET_DIRECTIVE
+#define HAVE_BUILTIN_EXPECT
+#define HAVE_GNU_LD
+#define HAVE_ELF
+#define HAVE_SECTION_QUOTES
+#define HAVE_VISIBILITY_ATTRIBUTE
+#define HAVE_ASM_PREVIOUS_DIRECTIVE
+// #define SHARED
+
+/* The symbols in all the user (non-_) macros are C symbols.
+   HAVE_GNU_LD without HAVE_ELF implies a.out.  */
+
+#if defined HAVE_ASM_WEAK_DIRECTIVE || defined HAVE_ASM_WEAKEXT_DIRECTIVE
+# define HAVE_WEAK_SYMBOLS
+#endif
+
+#ifndef __SYMBOL_PREFIX
+# ifdef NO_UNDERSCORES
+#  define __SYMBOL_PREFIX
+# else
+#  define __SYMBOL_PREFIX "_"
+# endif
+#endif
+
+#ifndef C_SYMBOL_NAME
+# ifdef NO_UNDERSCORES
+#  define C_SYMBOL_NAME(name) name
+# else
+#  define C_SYMBOL_NAME(name) _##name
+# endif
+#endif
+
+#ifndef ASM_LINE_SEP
+# define ASM_LINE_SEP ;
+#endif
+
+#ifndef C_SYMBOL_DOT_NAME
+# define C_SYMBOL_DOT_NAME(name) .##name
+#endif
+
+#ifndef __ASSEMBLER__
+/* GCC understands weak symbols and aliases; use its interface where
+   possible, instead of embedded assembly language.  */
+
+/* Define ALIASNAME as a strong alias for NAME.  */
+# define strong_alias(name, aliasname) _strong_alias(name, aliasname)
+# define _strong_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+
+/* This comes between the return type and function name in
+   a function definition to make that definition weak.  */
+# define weak_function __attribute__ ((weak))
+# define weak_const_function __attribute__ ((weak, __const__))
+
+# ifdef HAVE_WEAK_SYMBOLS
+
+/* Define ALIASNAME as a weak alias for NAME.
+   If weak aliases are not available, this defines a strong alias.  */
+#  define weak_alias(name, aliasname) _weak_alias (name, aliasname)
+#  define _weak_alias(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((weak, alias (#name)));
+
+/* Declare SYMBOL as weak undefined symbol (resolved to 0 if not defined).  */
+#  define weak_extern(symbol) _weak_extern (symbol)
+#  ifdef HAVE_ASM_WEAKEXT_DIRECTIVE
+#   define _weak_extern(symbol) asm (".weakext " __SYMBOL_PREFIX #symbol);
+#  else
+#   define _weak_extern(symbol)    asm (".weak " __SYMBOL_PREFIX #symbol);
+#  endif
+
+# else
+
+#  define weak_alias(name, aliasname) strong_alias(name, aliasname)
+#  define weak_extern(symbol) /* Nothing. */
+
+# endif
+
+#else /* __ASSEMBLER__ */
+
+# ifdef HAVE_ASM_SET_DIRECTIVE
+#  define strong_alias(original, alias)		\
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME (alias) ASM_LINE_SEP	\
+  .set C_SYMBOL_NAME (alias),C_SYMBOL_NAME (original)
+# else
+#  ifdef HAVE_ASM_GLOBAL_DOT_NAME
+#   define strong_alias(original, alias)	\
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME (alias) ASM_LINE_SEP	\
+  C_SYMBOL_NAME (alias) = C_SYMBOL_NAME (original) ASM_LINE_SEP	\
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_DOT_NAME (alias) ASM_LINE_SEP	\
+  C_SYMBOL_DOT_NAME (alias) = C_SYMBOL_DOT_NAME (original)
+#  else
+#   define strong_alias(original, alias)	\
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_NAME (alias) ASM_LINE_SEP	\
+  C_SYMBOL_NAME (alias) = C_SYMBOL_NAME (original)
+#  endif
+# endif
+
+# ifdef HAVE_WEAK_SYMBOLS
+#  ifdef HAVE_ASM_WEAKEXT_DIRECTIVE
+#   define weak_alias(original, alias)	\
+  .weakext C_SYMBOL_NAME (alias), C_SYMBOL_NAME (original)
+#   define weak_extern(symbol)	\
+  .weakext C_SYMBOL_NAME (symbol)
+
+#  else /* ! HAVE_ASM_WEAKEXT_DIRECTIVE */
+
+#   ifdef HAVE_ASM_GLOBAL_DOT_NAME
+#    define weak_alias(original, alias)	\
+  .weak C_SYMBOL_NAME (alias) ASM_LINE_SEP			\
+  C_SYMBOL_NAME (alias) = C_SYMBOL_NAME (original) ASM_LINE_SEP	\
+  ASM_GLOBAL_DIRECTIVE C_SYMBOL_DOT_NAME (alias) ASM_LINE_SEP	\
+  C_SYMBOL_DOT_NAME (alias) = C_SYMBOL_DOT_NAME (original)
+#   else
+#    define weak_alias(original, alias)	\
+  .weak C_SYMBOL_NAME (alias) ASM_LINE_SEP	\
+  C_SYMBOL_NAME (alias) = C_SYMBOL_NAME (original)
+#   endif
+
+#   define weak_extern(symbol)	\
+  .weak C_SYMBOL_NAME (symbol)
+
+#  endif /* ! HAVE_ASM_WEAKEXT_DIRECTIVE */
+
+# else /* ! HAVE_WEAK_SYMBOLS */
+
+#  define weak_alias(original, alias) strong_alias(original, alias)
+#  define weak_extern(symbol) /* Nothing */
+# endif /* ! HAVE_WEAK_SYMBOLS */
+
+#endif /* __ASSEMBLER__ */
+
+/* On some platforms we can make internal function calls (i.e., calls of
+   functions not exported) a bit faster by using a different calling
+   convention.  */
+#ifndef internal_function
+# define internal_function	/* empty */
+#endif
+
+/* Prepare for the case that `__builtin_expect' is not available.  */
+#ifndef HAVE_BUILTIN_EXPECT
+# define __builtin_expect(expr, val) (expr)
+#endif
+
+/* Determine the return address.  */
+#define RETURN_ADDRESS(nr) \
+  __builtin_extract_return_addr (__builtin_return_address (nr))
+
+/* When a reference to SYMBOL is encountered, the linker will emit a
+   warning message MSG.  */
+#ifdef HAVE_GNU_LD
+# ifdef HAVE_ELF
+
+/* We want the .gnu.warning.SYMBOL section to be unallocated.  */
+#  ifdef HAVE_ASM_PREVIOUS_DIRECTIVE
+#   define __make_section_unallocated(section_string)	\
+  asm (".section " section_string "\n\t.previous");
+#  elif defined HAVE_ASM_POPSECTION_DIRECTIVE
+#   define __make_section_unallocated(section_string)	\
+  asm (".pushsection " section_string "\n\t.popsection");
+#  else
+#   define __make_section_unallocated(section_string)
+#  endif
+
+/* Tacking on "\n\t#" to the section name makes gcc put it's bogus
+   section attributes on what looks like a comment to the assembler.  */
+#  ifdef HAVE_SECTION_QUOTES
+#   define link_warning(symbol, msg) \
+  __make_section_unallocated (".gnu.warning." #symbol) \
+  static const char __evoke_link_warning_##symbol[]	\
+    __attribute__ ((unused, section (".gnu.warning." #symbol "\"\n\t#\""))) \
+    = msg;
+#  else
+#   define link_warning(symbol, msg) \
+  __make_section_unallocated (".gnu.warning." #symbol) \
+  static const char __evoke_link_warning_##symbol[]	\
+    __attribute__ ((unused, section (".gnu.warning." #symbol "\n\t#"))) = msg;
+#  endif
+# else /* Not ELF: a.out */
+#  ifdef HAVE_XCOFF
+/* XCOFF does not support .stabs.
+   The native aix linker will remove the .stab and .stabstr sections
+   The gnu linker will have a fatal error if there is a relocation for
+   symbol in the .stab section.  Silently disable this macro.  */
+#   define link_warning(symbol, msg)
+#  else
+#   define link_warning(symbol, msg)		\
+     asm (".stabs \"" msg "\",30,0,0,0\n\t"	\
+          ".stabs \"" __SYMBOL_PREFIX #symbol "\",1,0,0,0\n");
+#  endif /* XCOFF */
+# endif
+#else
+/* We will never be heard; they will all die horribly.  */
+# define link_warning(symbol, msg)
+#endif
+
+/* A canned warning for sysdeps/stub functions.  */
+#define	stub_warning(name) \
+  link_warning (name, \
+		"warning: " #name " is not implemented and will always fail")
+
+/*
+
+*/
+
+#ifdef HAVE_GNU_LD
+
+/* Symbol set support macros.  */
+
+# ifdef HAVE_ELF
+
+/* Make SYMBOL, which is in the text segment, an element of SET.  */
+#  define text_set_element(set, symbol)	_elf_set_element(set, symbol)
+/* Make SYMBOL, which is in the data segment, an element of SET.  */
+#  define data_set_element(set, symbol)	_elf_set_element(set, symbol)
+/* Make SYMBOL, which is in the bss segment, an element of SET.  */
+#  define bss_set_element(set, symbol)	_elf_set_element(set, symbol)
+
+/* These are all done the same way in ELF.
+   There is a new section created for each set.  */
+#  ifdef SHARED
+/* When building a shared library, make the set section writable,
+   because it will need to be relocated at run time anyway.  */
+#   define _elf_set_element(set, symbol) \
+  static const void *__elf_set_##set##_element_##symbol##__ \
+    __attribute__ ((unused, section (#set))) = &(symbol)
+#  else
+#   define _elf_set_element(set, symbol) \
+  static const void *const __elf_set_##set##_element_##symbol##__ \
+    __attribute__ ((unused, section (#set))) = &(symbol)
+#  endif
+
+/* Define SET as a symbol set.  This may be required (it is in a.out) to
+   be able to use the set's contents.  */
+#  define symbol_set_define(set)	symbol_set_declare(set)
+
+/* Declare SET for use in this module, if defined in another module.  */
+#  define symbol_set_declare(set) \
+  extern void *const __start_##set __attribute__ ((__weak__));		\
+  extern void *const __stop_##set __attribute__ ((__weak__));		\
+  weak_extern (__start_##set) weak_extern (__stop_##set)
+
+/* Return a pointer (void *const *) to the first element of SET.  */
+#  define symbol_set_first_element(set)	(&__start_##set)
+
+/* Return true iff PTR (a void *const *) has been incremented
+   past the last element in SET.  */
+#  define symbol_set_end_p(set, ptr)	((ptr) >= &__stop_##set)
+
+# else	/* Not ELF: a.out.  */
+
+#  ifdef HAVE_XCOFF
+/* XCOFF does not support .stabs.
+   The native aix linker will remove the .stab and .stabstr sections
+   The gnu linker will have a fatal error if there is a relocation for
+   symbol in the .stab section.  Silently disable these macros.  */
+#   define text_set_element(set, symbol)
+#   define data_set_element(set, symbol)
+#   define bss_set_element(set, symbol)
+#  else
+#   define text_set_element(set, symbol)	\
+    asm (".stabs \"" __SYMBOL_PREFIX #set "\",23,0,0," __SYMBOL_PREFIX #symbol)
+#   define data_set_element(set, symbol)	\
+    asm (".stabs \"" __SYMBOL_PREFIX #set "\",25,0,0," __SYMBOL_PREFIX #symbol)
+#   define bss_set_element(set, symbol)	?error Must use initialized data.
+#  endif /* XCOFF */
+#  define symbol_set_define(set)	void *const (set)[1];
+#  define symbol_set_declare(set)	extern void *const (set)[1];
+
+#  define symbol_set_first_element(set)	&(set)[1]
+#  define symbol_set_end_p(set, ptr)	(*(ptr) == 0)
+
+# endif	/* ELF.  */
+#else
+/* We cannot do anything in generial.  */
+# define text_set_element(set, symbol) asm ("")
+# define data_set_element(set, symbol) asm ("")
+# define bss_set_element(set, symbol) asm ("")
+# define symbol_set_define(set)		void *const (set)[1];
+# define symbol_set_declare(set)	extern void *const (set)[1];
+
+# define symbol_set_first_element(set)	&(set)[1]
+# define symbol_set_end_p(set, ptr)	(*(ptr) == 0)
+#endif	/* Have GNU ld.  */
+
+#if DO_VERSIONING
+# define symbol_version(real, name, version) \
+     _symbol_version(real, name, version)
+# define default_symbol_version(real, name, version) \
+     _default_symbol_version(real, name, version)
+# ifdef __ASSEMBLER__
+#  define _symbol_version(real, name, version) \
+     .symver real, name##@##version
+#  define _default_symbol_version(real, name, version) \
+     .symver real, name##@##@##version
+# else
+#  define _symbol_version(real, name, version) \
+     __asm__ (".symver " #real "," #name "@" #version)
+#  define _default_symbol_version(real, name, version) \
+     __asm__ (".symver " #real "," #name "@@" #version)
+# endif
+#else
+# define symbol_version(real, name, version)
+# define default_symbol_version(real, name, version) \
+  strong_alias(real, name)
+#endif
+
+#if defined HAVE_VISIBILITY_ATTRIBUTE && defined SHARED
+# define attribute_hidden __attribute__ ((visibility ("hidden")))
+#else
+# define attribute_hidden
+#endif
+
+/* Handling on non-exported internal names.  We have to do this only
+   for shared code.  */
+#ifdef SHARED
+# define INTUSE(name) name##_internal
+# define INTDEF(name) strong_alias (name, name##_internal)
+# define INTVARDEF(name) \
+  _INTVARDEF (name, name##_internal)
+# if defined HAVE_VISIBILITY_ATTRIBUTE
+#  define _INTVARDEF(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name), \
+						   visibility ("hidden")));
+# else
+#  define _INTVARDEF(name, aliasname) \
+  extern __typeof (name) aliasname __attribute__ ((alias (#name)));
+# endif
+# define INTDEF2(name, newname) strong_alias (name, newname##_internal)
+# define INTVARDEF2(name, newname) _INTVARDEF (name, newname##_internal)
+#else
+# define INTUSE(name) name
+# define INTDEF(name)
+# define INTVARDEF(name)
+# define INTDEF2(name, newname)
+# define INTVARDEF2(name, newname)
+#endif
+
+#endif /* libc-symbols.h */
Index: glibc-2.21/libpthread/include/pthread/pthread.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/include/pthread/pthread.h
@@ -0,0 +1,755 @@
+/* Copyright (C) 2000, 2002, 2005, 2006, 2007, 2008, 2009, 2010
+     Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ *	POSIX Threads Extension: ???			<pthread.h>
+ */
+
+#ifndef _PTHREAD_H
+#define _PTHREAD_H	1
+
+#include <features.h>
+
+#include <sys/cdefs.h>
+#ifndef __extern_inline
+/* GCC 4.3 and above with -std=c99 or -std=gnu99 implements ISO C99
+   inline semantics, unless -fgnu89-inline is used.  */
+# if !defined __cplusplus || __GNUC_PREREQ (4,3)
+#  if defined __GNUC_STDC_INLINE__ || defined __cplusplus
+#   define __extern_inline extern __inline __attribute__ ((__gnu_inline__))
+#   if __GNUC_PREREQ (4,3)
+#    define __extern_always_inline \
+   extern __always_inline __attribute__ ((__gnu_inline__, __artificial__))
+#   else
+#    define __extern_always_inline \
+   extern __always_inline __attribute__ ((__gnu_inline__))
+#   endif
+#  else
+#   define __extern_inline extern __inline
+#   define __extern_always_inline extern __always_inline
+#  endif
+# endif
+#endif
+
+#include <sched.h>
+#include <time.h>
+
+__BEGIN_DECLS
+
+#include <pthread/pthreadtypes.h>
+
+#include <bits/pthread.h>
+
+/* Possible values for the process shared attribute.  */
+#define PTHREAD_PROCESS_PRIVATE __PTHREAD_PROCESS_PRIVATE
+#define PTHREAD_PROCESS_SHARED __PTHREAD_PROCESS_SHARED
+
+
+/* Thread attributes.  */
+
+/* Possible values for the inheritsched attribute.  */
+#define PTHREAD_EXPLICIT_SCHED __PTHREAD_EXPLICIT_SCHED
+#define PTHREAD_INHERIT_SCHED __PTHREAD_INHERIT_SCHED
+
+/* Possible values for the `contentionscope' attribute.  */
+#define PTHREAD_SCOPE_SYSTEM __PTHREAD_SCOPE_SYSTEM
+#define PTHREAD_SCOPE_PROCESS __PTHREAD_SCOPE_PROCESS
+
+/* Possible values for the `detachstate' attribute.  */
+#define PTHREAD_CREATE_JOINABLE __PTHREAD_CREATE_JOINABLE
+#define PTHREAD_CREATE_DETACHED __PTHREAD_CREATE_DETACHED
+
+#include <bits/thread-attr.h>
+
+/* Initialize the thread attribute object in *ATTR to the default
+   values.  */
+extern int pthread_attr_init (pthread_attr_t *attr);
+
+/* Destroy the thread attribute object in *ATTR.  */
+extern int pthread_attr_destroy (pthread_attr_t *attr);
+
+
+/* Return the value of the inheritsched attribute in *ATTR in
+   *INHERITSCHED.  */
+extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict attr,
+					 int *__restrict inheritsched);
+
+/* Set the value of the inheritsched attribute in *ATTR to
+   INHERITSCHED.  */
+extern int pthread_attr_setinheritsched (pthread_attr_t *attr,
+					 int inheritsched);
+
+
+/* Return the value of the schedparam attribute in *ATTR in *PARAM.  */
+extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict attr,
+				       struct sched_param *__restrict param);
+
+/* Set the value of the schedparam attribute in *ATTR to PARAM.  */
+extern int pthread_attr_setschedparam (pthread_attr_t *__restrict attr,
+				       const struct sched_param *__restrict param);
+
+
+/* Return the value of the schedpolicy attribute in *ATTR to *POLICY.  */
+extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict attr,
+					int *__restrict policy);
+
+/* Set the value of the schedpolicy attribute in *ATTR to POLICY.  */
+extern int pthread_attr_setschedpolicy (pthread_attr_t *attr,
+					int policy);
+
+
+/* Return the value of the contentionscope attribute in *ATTR in
+   *CONTENTIONSCOPE.  */
+extern int pthread_attr_getscope (const pthread_attr_t *__restrict attr,
+				  int *__restrict contentionscope);
+
+/* Set the value of the contentionscope attribute in *ATTR to
+   CONTENTIONSCOPE.  */
+extern int pthread_attr_setscope (pthread_attr_t *attr,
+				  int contentionscope);
+
+
+/* Return the value of the stackaddr attribute in *ATTR in
+   *STACKADDR.  */
+extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict attr,
+				      void **__restrict stackaddr);
+
+/* Set the value of the stackaddr attribute in *ATTR to STACKADDR.  */
+extern int pthread_attr_setstackaddr (pthread_attr_t *attr,
+				      void *stackaddr);
+
+
+#ifdef __USE_XOPEN2K
+/* Return the value of the stackaddr and stacksize attributes in *ATTR
+   in *STACKADDR and *STACKSIZE respectively.  */
+extern int pthread_attr_getstack (const pthread_attr_t *__restrict attr,
+				  void **__restrict stackaddr,
+				  size_t *__restrict stacksize);
+
+/* Set the value of the stackaddr and stacksize attributes in *ATTR to
+   STACKADDR and STACKSIZE respectively.  */
+extern int pthread_attr_setstack (pthread_attr_t *attr,
+				  void *stackaddr,
+				  size_t stacksize);
+#endif
+
+
+/* Return the value of the detachstate attribute in *ATTR in
+   *DETACHSTATE.  */
+extern int pthread_attr_getdetachstate (const pthread_attr_t *attr,
+					int *detachstate);
+
+/* Set the value of the detachstate attribute in *ATTR to
+   DETACHSTATE.  */
+extern int pthread_attr_setdetachstate (pthread_attr_t *attr,
+					int detachstate);
+
+
+/* Return the value of the guardsize attribute in *ATTR in
+   *GUARDSIZE.  */
+extern int pthread_attr_getguardsize (const pthread_attr_t *__restrict attr,
+				      size_t *__restrict guardsize);
+
+/* Set the value of the guardsize attribute in *ATTR to GUARDSIZE.  */
+extern int pthread_attr_setguardsize (pthread_attr_t *attr,
+				      size_t guardsize);
+
+
+/* Return the value of the stacksize attribute in *ATTR in
+   *STACKSIZE.  */
+extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict attr,
+				      size_t *__restrict stacksize);
+
+/* Set the value of the stacksize attribute in *ATTR to STACKSIZE.  */
+extern int pthread_attr_setstacksize (pthread_attr_t *attr,
+				      size_t stacksize);
+
+#ifdef __USE_GNU
+/* Initialize thread attribute *ATTR with attributes corresponding to the
+   already running thread THREAD.  It shall be called on an uninitialized ATTR
+   and destroyed with pthread_attr_destroy when no longer needed.  */
+extern int pthread_getattr_np (pthread_t thread, pthread_attr_t *attr);
+#endif
+
+
+/* Create a thread with attributes given by ATTR, executing
+   START_ROUTINE with argument ARG.  */
+extern int pthread_create (pthread_t *__restrict __threadp,
+			   __const pthread_attr_t *__restrict __attr,
+			   void *(*__start_routine)(void *),
+			   void *__restrict __arg);
+
+/* Terminate the current thread and make STATUS available to any
+   thread that might join us.  */
+extern void pthread_exit (void *__status) __attribute__ ((noreturn));
+
+/* Make calling thread wait for termination of thread THREAD.  Return
+   the exit status of the thread in *STATUS.  */
+extern int pthread_join (pthread_t __threadp, void **__status);
+
+/* Indicate that the storage for THREAD can be reclaimed when it
+   terminates.  */
+extern int pthread_detach (pthread_t __threadp);
+
+/* Compare thread IDs T1 and T2.  Return nonzero if they are equal, 0
+   if they are not.  */
+extern int pthread_equal (pthread_t __t1, pthread_t __t2);
+
+# ifdef __USE_EXTERN_INLINES
+
+__extern_inline int
+pthread_equal (pthread_t __t1, pthread_t __t2)
+{
+  return __pthread_equal (__t1, __t2);
+}
+
+# endif /* Use extern inlines.  */
+
+
+/* Return the thread ID of the calling thread.  */
+extern pthread_t pthread_self (void);
+
+
+/* Mutex attributes.  */
+
+#define PTHREAD_PRIO_NONE_NP __PTHREAD_PRIO_NONE
+#define PTHREAD_PRIO_INHERIT_NP __PTHREAD_PRIO_INHERIT
+#define PTHREAD_PRIO_PROTECT_NP __PTHREAD_PRIO_PROTECT
+#ifdef __USE_UNIX98
+#define PTHREAD_PRIO_NONE PTHREAD_PRIO_NONE_NP
+#define PTHREAD_PRIO_INHERIT PTHREAD_PRIO_INHERIT_NP
+#define PTHREAD_PRIO_PROTECT PTHREAD_PRIO_PROTECT_NP
+#endif
+
+#define PTHREAD_MUTEX_TIMED_NP __PTHREAD_MUTEX_TIMED
+#define PTHREAD_MUTEX_ERRORCHECK_NP __PTHREAD_MUTEX_ERRORCHECK
+#define PTHREAD_MUTEX_RECURSIVE_NP __PTHREAD_MUTEX_RECURSIVE
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+#define PTHREAD_MUTEX_NORMAL PTHREAD_MUTEX_TIMED_NP
+#define PTHREAD_MUTEX_ERRORCHECK PTHREAD_MUTEX_ERRORCHECK_NP
+#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
+#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL
+#endif
+#ifdef __USE_GNU
+/* For compatibility.  */
+#define PTHREAD_MUTEX_FAST_NP PTHREAD_MUTEX_TIMED_NP
+#endif
+
+#include <bits/mutex-attr.h>
+
+/* Initialize the mutex attribute object in *ATTR to the default
+   values.  */
+extern int pthread_mutexattr_init(pthread_mutexattr_t *attr);
+
+/* Destroy the mutex attribute structure in *ATTR.  */
+extern int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
+
+
+#ifdef __USE_UNIX98
+/* Return the value of the prioceiling attribute in *ATTR in
+   *PRIOCEILING.  */
+extern int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t *__restrict attr,
+					    int *__restrict prioceiling);
+
+/* Set the value of the prioceiling attribute in *ATTR to
+   PRIOCEILING.  */
+extern int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *attr,
+					    int prioceiling);
+
+
+/* Return the value of the protocol attribute in *ATTR in
+   *PROTOCOL.  */
+extern int pthread_mutexattr_getprotocol(const pthread_mutexattr_t *__restrict attr,
+					 int *__restrict protocol);
+
+/* Set the value of the protocol attribute in *ATTR to PROTOCOL.  */
+extern int pthread_mutexattr_setprotocol(pthread_mutexattr_t *attr,
+					 int protocol);
+#endif
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_mutexattr_getpshared(const pthread_mutexattr_t *__restrict attr,
+					int *__restrict pshared);
+
+/* Set the value of the process shared attribute in *ATTR to
+   PSHARED.  */
+extern int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
+					int pshared);
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+/* Return the value of the type attribute in *ATTR in *TYPE.  */
+extern int pthread_mutexattr_gettype(const pthread_mutexattr_t *__restrict attr,
+				     int *__restrict type);
+
+/* Set the value of the type attribute in *ATTR to TYPE.  */
+extern int pthread_mutexattr_settype(pthread_mutexattr_t *attr,
+				     int type);
+#endif
+
+
+/* Mutexes.  */
+
+#include <bits/mutex.h>
+
+#define PTHREAD_MUTEX_INITIALIZER __PTHREAD_MUTEX_INITIALIZER
+/* Static initializer for recursive mutexes.  */
+
+#ifdef __USE_GNU
+# define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP \
+  __PTHREAD_ERRORCHECK_MUTEX_INITIALIZER
+# define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP \
+  __PTHREAD_RECURSIVE_MUTEX_INITIALIZER
+#endif
+
+/* Create a mutex with attributes given by ATTR and store it in
+   *__MUTEX.  */
+extern int pthread_mutex_init (struct __pthread_mutex *__restrict __mutex,
+			       const pthread_mutexattr_t *__restrict attr);
+
+/* Destroy the mutex __MUTEX.  */
+extern int pthread_mutex_destroy (struct __pthread_mutex *__mutex);
+
+/* Wait until lock for MUTEX becomes available and lock it.  */
+extern int pthread_mutex_lock (pthread_mutex_t *__mutex);
+
+/* Try to lock MUTEX.  */
+extern int pthread_mutex_trylock (pthread_mutex_t *__mutex);
+
+#ifdef __USE_XOPEN2K
+/* Try to lock MUTEX, block until *ABSTIME if it is already held.  */
+extern int pthread_mutex_timedlock (struct __pthread_mutex *__restrict mutex,
+				    const struct timespec *__restrict abstime);
+#endif
+
+/* Unlock MUTEX.  */
+extern int pthread_mutex_unlock (pthread_mutex_t *__mutex);
+
+/* Transfer ownership of the mutex MUTEX to the thread TID.  The
+   caller must own the lock.  */
+extern int __pthread_mutex_transfer_np (struct __pthread_mutex *mutex,
+					pthread_t tid);
+
+
+#ifdef __USE_UNIX98
+/* Return the priority ceiling of mutex *MUTEX in *PRIOCEILING.  */
+extern int pthread_mutex_getprioceiling (const pthread_mutex_t *__restrict mutex,
+					 int *__restrict prioceiling);
+
+/* After acquiring the mutex *MUTEX, set its priority ceiling to PRIO
+   and return the old priority ceiling in *OLDPRIO.  Before returning,
+   release the mutex.  */
+extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict mutex,
+					 int prio, int *__restrict oldprio);
+#endif
+
+
+
+/* Condition attributes.  */
+
+#include <bits/condition-attr.h>
+
+/* Initialize the condition attribute in *ATTR to the default
+   values.  */
+extern int pthread_condattr_init (pthread_condattr_t *attr);
+
+/* Destroy the condition attribute structure in *ATTR.  */
+extern int pthread_condattr_destroy (pthread_condattr_t *attr);
+
+
+#ifdef __USE_XOPEN2K
+/* Return the value of the clock attribute in *ATTR in *CLOCK_ID.  */
+extern int pthread_condattr_getclock (const pthread_condattr_t *__restrict attr,
+				      __clockid_t *__restrict clock_id);
+
+/* Set the value of the clock attribute in *ATTR to CLOCK_ID.  */
+extern int pthread_condattr_setclock (pthread_condattr_t *attr,
+				      __clockid_t clock_id);
+#endif
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_condattr_getpshared (const pthread_condattr_t *__restrict attr,
+					int *__restrict pshared);
+
+/* Set the value of the process shared attribute in *ATTR to
+   PSHARED.  */
+extern int pthread_condattr_setpshared (pthread_condattr_t *attr,
+					int pshared);
+
+
+/* Condition variables.  */
+
+#include <bits/condition.h>
+
+#define PTHREAD_COND_INITIALIZER __PTHREAD_COND_INITIALIZER
+
+extern int pthread_cond_init (pthread_cond_t *__restrict cond,
+			      const pthread_condattr_t *__restrict attr);
+
+extern int pthread_cond_destroy (pthread_cond_t *cond);
+
+/* Unblock at least one of the threads that are blocked on condition
+   variable COND.  */
+extern int pthread_cond_signal (pthread_cond_t *__cond);
+
+/* Unblock all threads that are blocked on condition variable COND.  */
+extern int pthread_cond_broadcast (pthread_cond_t *__cond);
+
+/* Block on condition variable COND.  MUTEX should be held by the
+   calling thread.  On success, MUTEX will be held by the calling
+   thread.  */
+extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
+			      pthread_mutex_t *__restrict __mutex);
+
+/* Block on condition variable COND.  MUTEX should be held by the
+   calling thread. On success, MUTEX will be held by the calling
+   thread.  If the time specified by ABSTIME passes, ETIMEDOUT is
+   returned, and MUTEX will nevertheless be held.  */
+extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
+				   pthread_mutex_t *__restrict __mutex,
+				   __const struct timespec *__restrict __abstime);
+
+
+/* Spin locks.  */
+
+#ifdef __USE_XOPEN2K
+
+# include <bits/spin-lock.h>
+
+#define PTHREAD_SPINLOCK_INITIALIZER __PTHREAD_SPIN_LOCK_INITIALIZER
+
+/* Destroy the spin lock object LOCK.  */
+extern int pthread_spin_destroy (pthread_spinlock_t *__lock);
+
+/* Initialize the spin lock object LOCK.  PSHARED determines whether
+   the spin lock can be operated upon by multiple processes.  */
+extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared);
+
+/* Lock the spin lock object LOCK.  If the lock is held by another
+   thread spin until it becomes available.  */
+extern int pthread_spin_lock (pthread_spinlock_t *__lock);
+
+/* Lock the spin lock object LOCK.  Fail if the lock is held by
+   another thread.  */
+extern int pthread_spin_trylock (pthread_spinlock_t *__lock);
+
+/* Unlock the spin lock object LOCK.  */
+extern int pthread_spin_unlock (pthread_spinlock_t *__lock);
+
+# ifdef __USE_EXTERN_INLINES
+
+# include <bits/spin-lock-inline.h>
+
+__extern_inline int
+pthread_spin_destroy (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_destroy (__lock);
+}
+
+__extern_inline int
+pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
+{
+  return __pthread_spin_init (__lock, __pshared);
+}
+
+__extern_inline int
+pthread_spin_lock (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_lock (__lock);
+}
+
+__extern_inline int
+pthread_spin_trylock (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_trylock (__lock);
+}
+
+__extern_inline int
+pthread_spin_unlock (pthread_spinlock_t *__lock)
+{
+  return __pthread_spin_unlock (__lock);
+}
+
+# endif /* Use extern inlines.  */
+
+#endif /* XPG6.  */
+
+
+/* rwlock attributes.  */
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+
+#include <bits/rwlock-attr.h>
+
+/* Initialize rwlock attribute object in *ATTR to the default
+   values.  */
+extern int pthread_rwlockattr_init (pthread_rwlockattr_t *attr);
+
+/* Destroy the rwlock attribute object in *ATTR.  */
+extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr);
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *__restrict attr,
+					  int *__restrict pshared);
+
+/* Set the value of the process shared atrribute in *ATTR to
+   PSHARED.  */
+extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr,
+					  int pshared);
+
+
+/* rwlocks.  */
+
+#include <bits/rwlock.h>
+
+#define PTHREAD_RWLOCK_INITIALIZER __PTHREAD_RWLOCK_INITIALIZER
+/* Create a rwlock object with attributes given by ATTR and strore the
+   result in *RWLOCK.  */
+extern int pthread_rwlock_init (pthread_rwlock_t *__restrict rwlock,
+				const pthread_rwlockattr_t *__restrict attr);
+
+/* Destroy the rwlock *RWLOCK.  */
+extern int pthread_rwlock_destroy (pthread_rwlock_t *rwlock);
+
+/* Acquire the rwlock *RWLOCK for reading.  */
+extern int pthread_rwlock_rdlock (pthread_rwlock_t *rwlock);
+
+/* Acquire the rwlock *RWLOCK for reading.  */
+extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *rwlock);
+
+# ifdef __USE_XOPEN2K
+/* Acquire the rwlock *RWLOCK for reading blocking until *ABSTIME if
+   it is already held.  */
+extern int pthread_rwlock_timedrdlock (struct __pthread_rwlock *__restrict rwlock,
+				       const struct timespec *__restrict abstime);
+# endif
+
+/* Acquire the rwlock *RWLOCK for writing.  */
+extern int pthread_rwlock_wrlock (pthread_rwlock_t *rwlock);
+
+/* Try to acquire the rwlock *RWLOCK for writing.  */
+extern int pthread_rwlock_trywrlock (pthread_rwlock_t *rwlock);
+
+# ifdef __USE_XOPEN2K
+/* Acquire the rwlock *RWLOCK for writing blocking until *ABSTIME if
+   it is already held.  */
+extern int pthread_rwlock_timedwrlock (struct __pthread_rwlock *__restrict rwlock,
+				       const struct timespec *__restrict abstime);
+# endif
+
+/* Release the lock held by the current thread on *RWLOCK.  */
+extern int pthread_rwlock_unlock (pthread_rwlock_t *rwlock);
+
+#endif /* __USE_UNIX98 || __USE_XOPEN2K */
+
+
+
+/* Cancelation.  */
+
+/* Register a cleanup handler.  */
+extern void pthread_cleanup_push (void (*routine) (void *), void *arg);
+
+/* Unregister a cleanup handler.  */
+extern void pthread_cleanup_pop (int execute);
+
+#include <bits/cancelation.h>
+
+#define pthread_cleanup_push(rt, rtarg) __pthread_cleanup_push(rt, rtarg)
+#define pthread_cleanup_pop(execute) __pthread_cleanup_pop(execute)
+
+#define PTHREAD_CANCEL_DISABLE 0
+#define PTHREAD_CANCEL_ENABLE 1
+
+/* Return the calling thread's cancelation state in *OLDSTATE and set
+   its state to STATE.  */
+extern int pthread_setcancelstate (int state, int *oldstate);
+
+#define PTHREAD_CANCEL_DEFERRED 0
+#define PTHREAD_CANCEL_ASYNCHRONOUS 1
+
+/* Return the calling thread's cancelation type in *OLDTYPE and set
+   its type to TYPE.  */
+extern int pthread_setcanceltype (int type, int *oldtype);
+
+/* Value returned by pthread_join if the target thread was
+   canceled.  */
+#define PTHREAD_CANCELED ((void *) -1)
+
+/* Cancel THEAD.  */
+extern int pthread_cancel (pthread_t thread);
+
+/* Add an explicit cancelation point.  */
+extern void pthread_testcancel (void);
+
+
+/* Barriers attributes.  */
+
+#ifdef __USE_XOPEN2K
+
+#include <bits/barrier-attr.h>
+
+/* Initialize barrier attribute object in *ATTR to the default
+   values.  */
+extern int pthread_barrierattr_init (pthread_barrierattr_t *attr);
+
+/* Destroy the barrier attribute object in *ATTR.  */
+extern int pthread_barrierattr_destroy (pthread_barrierattr_t *attr);
+
+
+/* Return the value of the process shared attribute in *ATTR in
+   *PSHARED.  */
+extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *__restrict attr,
+					   int *__restrict pshared);
+
+/* Set the value of the process shared atrribute in *ATTR to
+   PSHARED.  */
+extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *attr,
+					   int pshared);
+
+
+/* Barriers.  */
+
+#include <bits/barrier.h>
+
+/* Returned by pthread_barrier_wait to exactly one thread each time a
+   barrier is passed.  */
+#define PTHREAD_BARRIER_SERIAL_THREAD -1
+
+/* Initialize barrier BARRIER.  */
+extern int pthread_barrier_init (pthread_barrier_t *__restrict barrier,
+				const pthread_barrierattr_t *__restrict attr,
+				unsigned count);
+
+/* Destroy barrier BARRIER.  */
+extern int pthread_barrier_destroy (pthread_barrier_t *barrier);
+
+/* Wait on barrier BARRIER.  */
+extern int pthread_barrier_wait (pthread_barrier_t *barrier);
+
+#endif /* __USE_XOPEN2K */
+
+
+
+/* Thread specific data.  */
+
+#include <bits/thread-specific.h>
+
+/* Create a thread specific data key in KEY visible to all threads.
+   On thread destruction, DESTRUCTOR shall be called with the thread
+   specific data associate with KEY if it is not NULL.  */
+extern int pthread_key_create (pthread_key_t *key,
+			       void (*destructor) (void *));
+
+/* Delete the thread specific data key KEY.  The associated destructor
+   function is not called.  */
+extern int pthread_key_delete (pthread_key_t key);
+
+/* Return the caller thread's thread specific value of KEY.  */
+extern void *pthread_getspecific (pthread_key_t key);
+
+/* Set the caller thread's thread specific value of KEY to VALUE.  */
+extern int pthread_setspecific (pthread_key_t key, const void *value);
+
+
+/* Dynamic package initialization.  */
+
+#include <bits/once.h>
+
+#define PTHREAD_ONCE_INIT __PTHREAD_ONCE_INIT
+
+/* Call INIT_ROUTINE if this function has never been called with
+   *ONCE_CONTROL, otherwise do nothing.  */
+extern int pthread_once (pthread_once_t *once_control,
+			 void (*init_routine) (void));
+
+
+/* Concurrency.  */
+
+#ifdef __USE_UNIX98
+/* Set the desired concurrency level to NEW_LEVEL.  */
+extern int pthread_setconcurrency (int new_level);
+
+/* Get the current concurrency level.  */
+extern int pthread_getconcurrency (void);
+#endif
+
+
+/* Forking.  */
+
+/* Register the function PREPARE to be run before the process forks,
+   the function PARENT to be run after a fork in the parent and the
+   function CHILD to be run in the child after the fork.  If no
+   handling is desired then any of PREPARE, PARENT and CHILD may be
+   NULL.  The prepare handles will be called in the reverse order
+   which they were registered and the parent and child handlers in the
+   order in which they were registered.  */
+extern int pthread_atfork (void (*prepare) (void), void (*parent) (void),
+			   void (*child) (void));
+
+
+/* Signals (should be in <signal.h>).  */
+
+/* Send signal SIGNO to thread THREAD.  */
+extern int pthread_kill (pthread_t thread, int signo);
+
+
+/* Time.  */
+
+#ifdef __USE_XOPEN2K
+/* Return the thread cpu clock.  */
+extern int pthread_getcpuclockid (pthread_t thread, __clockid_t *clock);
+#endif
+
+
+/* Scheduling.  */
+
+/* Return thread THREAD's scheduling paramters.  */
+extern int pthread_getschedparam (pthread_t thread, int *__restrict policy,
+				  struct sched_param *__restrict param);
+
+/* Set thread THREAD's scheduling paramters.  */
+extern int pthread_setschedparam (pthread_t thread, int policy,
+				  const struct sched_param *param);
+
+/* Set thread THREAD's scheduling priority.  */
+extern int pthread_setschedprio (pthread_t thread, int prio);
+
+#ifdef __USE_GNU
+/* Yield the processor to another thread or process.
+   This function is similar to the POSIX `sched_yield' function but
+   might be differently implemented in the case of a m-on-n thread
+   implementation.  */
+extern int pthread_yield (void);
+#endif
+
+
+/* Kernel-specific interfaces.  */
+
+#include <bits/pthread-np.h>
+
+
+__END_DECLS
+
+#endif /* pthread.h */
Index: glibc-2.21/libpthread/include/pthread/pthreadtypes.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/include/pthread/pthreadtypes.h
@@ -0,0 +1,125 @@
+/* Copyright (C) 2000, 2002, 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ *	POSIX Threads Extension: ???			<pthreadtypes.h>
+ */
+
+#ifndef _PTHREADTYPES_H
+#define _PTHREADTYPES_H	1
+
+#include <features.h>
+
+#include <bits/types.h>
+
+__BEGIN_DECLS
+
+#include <bits/pthread.h>
+typedef __pthread_t pthread_t;
+
+/* Possible values for the process shared attribute.  */
+enum __pthread_process_shared
+  {
+    __PTHREAD_PROCESS_PRIVATE = 0,
+    __PTHREAD_PROCESS_SHARED
+  };
+
+/* Possible values for the inheritsched attribute.  */
+enum __pthread_inheritsched
+  {
+    __PTHREAD_EXPLICIT_SCHED = 0,
+    __PTHREAD_INHERIT_SCHED
+  };
+
+/* Possible values for the `contentionscope' attribute.  */
+enum __pthread_contentionscope
+  {
+    __PTHREAD_SCOPE_SYSTEM = 0,
+    __PTHREAD_SCOPE_PROCESS
+  };
+
+/* Possible values for the `detachstate' attribute.  */
+enum __pthread_detachstate
+  {
+    __PTHREAD_CREATE_JOINABLE = 0,
+    __PTHREAD_CREATE_DETACHED
+  };
+
+#include <bits/thread-attr.h>
+typedef struct __pthread_attr pthread_attr_t;
+
+enum __pthread_mutex_protocol
+  {
+    __PTHREAD_PRIO_NONE= 0,
+    __PTHREAD_PRIO_INHERIT,
+    __PTHREAD_PRIO_PROTECT
+  };
+
+enum __pthread_mutex_type
+  {
+    __PTHREAD_MUTEX_TIMED,
+    __PTHREAD_MUTEX_ERRORCHECK,
+    __PTHREAD_MUTEX_RECURSIVE
+  };
+
+#include <bits/mutex-attr.h>
+typedef struct __pthread_mutexattr pthread_mutexattr_t;
+
+#include <bits/mutex.h>
+typedef struct __pthread_mutex pthread_mutex_t;
+
+#include <bits/condition-attr.h>
+typedef struct __pthread_condattr pthread_condattr_t;
+
+#include <bits/condition.h>
+typedef struct __pthread_cond pthread_cond_t;
+
+#ifdef __USE_XOPEN2K
+# include <bits/spin-lock.h>
+typedef __pthread_spinlock_t pthread_spinlock_t;
+#endif /* XPG6.  */
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+
+#include <bits/rwlock-attr.h>
+typedef struct __pthread_rwlockattr pthread_rwlockattr_t;
+
+#include <bits/rwlock.h>
+typedef struct __pthread_rwlock pthread_rwlock_t;
+
+#endif /* __USE_UNIX98 || __USE_XOPEN2K */
+
+#ifdef __USE_XOPEN2K
+
+#include <bits/barrier-attr.h>
+typedef struct __pthread_barrierattr pthread_barrierattr_t;
+
+#include <bits/barrier.h>
+typedef struct __pthread_barrier pthread_barrier_t;
+
+#endif /* __USE_XOPEN2K */
+
+#include <bits/thread-specific.h>
+typedef __pthread_key pthread_key_t;
+
+#include <bits/once.h>
+typedef struct __pthread_once pthread_once_t;
+
+__END_DECLS
+
+#endif /* pthreadtypes.h */
Index: glibc-2.21/libpthread/include/pthread.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/include/pthread.h
@@ -0,0 +1,7 @@
+#ifndef _PTHREAD_H
+#include <pthread/pthread.h>
+
+extern int __pthread_mutex_lock (pthread_mutex_t *__mutex);
+extern int __pthread_mutex_unlock (pthread_mutex_t *__mutex);
+
+#endif
Index: glibc-2.21/libpthread/include/semaphore.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/include/semaphore.h
@@ -0,0 +1,69 @@
+/* Copyright (C) 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _SEMAPHORE_H
+#define _SEMAPHORE_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+#include <bits/semaphore.h>
+
+#define SEM_FAILED ((void *) 0)
+
+typedef struct __semaphore sem_t;
+
+/* Initialize semaphore *SEM with value VALUE.  */
+extern int sem_init (sem_t *sem, int pshared, unsigned value);
+
+/* Destroy semaphore *SEM created with sem_init.  */
+extern int sem_destroy (sem_t *sem);
+
+/* Store the value of semaphore *SEM in *VALUE.  */
+extern int sem_getvalue (sem_t *__restrict sem, int *__restrict value);
+
+/* Perform a down operation on semaphore *SEM.  */
+extern int sem_wait (sem_t *sem);
+
+/* Perform a down operation on semaphore *SEM if it can be done so
+   without blocking.  */
+extern int sem_trywait (sem_t *sem);
+
+#ifdef __USE_XOPEN2K
+/* Perform a down operation on semaphore *SEM but don't wait longer
+   than TIMEOUT.  */
+extern int sem_timedwait (sem_t *__restrict sem,
+			  const struct timespec *__restrict timeout);
+#endif
+
+/* Perform an up operation on semaphore *SEM.  */
+extern int sem_post (sem_t *sem);
+
+/* Open a named semaphore.  */
+extern sem_t *sem_open (const char *name, int open_flags, ...);
+
+/* Close a semaphore returned by sem_open.  */
+extern int sem_close (sem_t *sem);
+
+/* Unlink a named semaphore.  */
+extern int sem_unlink (const char *name);
+
+__END_DECLS
+
+#endif /* semaphore.h */
Index: glibc-2.21/libpthread/include/set-hooks.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/include/set-hooks.h
@@ -0,0 +1,72 @@
+/* Macros for using symbol sets for running lists of functions.
+   Copyright (C) 1994, 1995, 1997, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SET_HOOKS_H
+#define _SET_HOOKS_H 1
+
+#define __need_size_t
+#include <stddef.h>
+// #include <sys/cdefs.h>
+#define __unbounded
+
+#ifdef symbol_set_define
+/* Define a hook variable called NAME.  Functions put on this hook take
+   arguments described by PROTO.  Use `text_set_element (NAME, FUNCTION)'
+   from gnu-stabs.h to add a function to the hook.  */
+
+# define DEFINE_HOOK(NAME, PROTO)		\
+  typedef void __##NAME##_hook_function_t PROTO; \
+  symbol_set_define (NAME)
+
+# define DECLARE_HOOK(NAME, PROTO)		\
+  typedef void __##NAME##_hook_function_t PROTO;\
+  symbol_set_declare (NAME)
+
+/* Run all the functions hooked on the set called NAME.
+   Each function is called like this: `function ARGS'.  */
+
+# define RUN_HOOK(NAME, ARGS)				\
+do {							\
+  void *const *__unbounded ptr;				\
+  for (ptr = symbol_set_first_element (NAME);		\
+       ! symbol_set_end_p (NAME, ptr); ++ptr)		\
+    (*(__##NAME##_hook_function_t *) *ptr) ARGS;	\
+} while (0)
+
+/* Define a hook variable with NAME and PROTO, and a function called RUNNER
+   which calls each function on the hook in turn, with ARGS.  */
+
+# define DEFINE_HOOK_RUNNER(name, runner, proto, args) \
+DEFINE_HOOK (name, proto); \
+extern void runner proto; void runner proto { RUN_HOOK (name, args); }
+
+#else
+
+/* The system does not provide necessary support for this.  */
+# define DEFINE_HOOK(NAME, PROTO)
+
+# define DECLARE_HOOK(NAME, PROTO)
+
+# define RUN_HOOK(NAME, ARGS)
+
+# define DEFINE_HOOK_RUNNER(name, runner, proto, args)
+
+#endif
+
+#endif /* set-hooks.h */
Index: glibc-2.21/libpthread/libc_pthread_init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/libc_pthread_init.c
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <pthread-functions.h>
+
+void
+__libc_pthread_init (functions)
+     const struct pthread_functions *functions;
+{
+#ifdef SHARED
+  /* We copy the content of the variable pointed to by the FUNCTIONS
+     parameter to one in libc.so since this means access to the array
+     can be done with one memory access instead of two.  */
+  memcpy (&__libc_pthread_functions, functions,
+	  sizeof (__libc_pthread_functions));
+  __libc_pthread_functions_init = 1;
+#endif
+}
Index: glibc-2.21/libpthread/libpthread.a
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/libpthread.a
@@ -0,0 +1,23 @@
+/* pthread initializer is weak in glibc.  It must be included if glibc
+   is to start threading. */
+EXTERN(_cthread_init_routine)
+
+/* Weak references in glibc that must be filled if glibc is to be
+   thread safe.  */
+EXTERN(cthread_detach)
+EXTERN(cthread_fork)
+EXTERN(cthread_keycreate)
+EXTERN(cthread_getspecific)
+EXTERN(__libc_getspecific)
+EXTERN(cthread_setspecific)
+EXTERN(__mutex_lock_solid)
+EXTERN(__mutex_unlock_solid)
+/* For libio stream locking.  */
+EXTERN(_cthreads_flockfile)
+EXTERN(_cthreads_funlockfile)
+EXTERN(_cthreads_ftrylockfile)
+/* To get the sigthread stack layout on fork */
+EXTERN(pthread_getattr_np)
+EXTERN(pthread_attr_getstack)
+
+GROUP(-lpthread2 -lihash -lrt)
Index: glibc-2.21/libpthread/libpthread_pic.a
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/libpthread_pic.a
@@ -0,0 +1,23 @@
+/* pthread initializer is weak in glibc.  It must be included if glibc
+   is to start threading. */
+EXTERN(_cthread_init_routine)
+
+/* Weak references in glibc that must be filled if glibc is to be
+   thread safe.  */
+EXTERN(cthread_detach)
+EXTERN(cthread_fork)
+EXTERN(cthread_keycreate)
+EXTERN(cthread_getspecific)
+EXTERN(__libc_getspecific)
+EXTERN(cthread_setspecific)
+EXTERN(__mutex_lock_solid)
+EXTERN(__mutex_unlock_solid)
+/* For libio stream locking.  */
+EXTERN(_cthreads_flockfile)
+EXTERN(_cthreads_funlockfile)
+EXTERN(_cthreads_ftrylockfile)
+/* To get the sigthread stack layout on fork */
+EXTERN(pthread_getattr_np)
+EXTERN(pthread_attr_getstack)
+
+GROUP(-lpthread2_pic -lihash_pic)
Index: glibc-2.21/libpthread/lockfile.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/lockfile.c
@@ -0,0 +1,65 @@
+/* lockfile - Handle locking and unlocking of streams.  Hurd cthreads version.
+   Copyright (C) 2000,01,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <cthreads.h>
+#include <pthread.h>		/* Must come before <stdio.h>! */
+#include <stdio.h>
+
+#ifdef _STDIO_USES_IOSTREAM
+
+void
+_cthreads_flockfile (_IO_FILE *fp)
+{
+  _IO_lock_lock (*fp->_lock);
+}
+
+void
+_cthreads_funlockfile (_IO_FILE *fp)
+{
+  _IO_lock_unlock (*fp->_lock);
+}
+
+int
+_cthreads_ftrylockfile (_IO_FILE *fp)
+{
+  return __libc_lock_trylock_recursive (*fp->_lock);
+}
+
+# undef 	_IO_flockfile
+# undef 	_IO_funlockfile
+# undef 	_IO_ftrylockfile
+# undef		flockfile
+# undef		funlockfile
+# undef		ftrylockfile
+
+void _IO_flockfile (_IO_FILE *)
+     __attribute__ ((alias ("_cthreads_flockfile")));
+void _IO_funlockfile (_IO_FILE *)
+     __attribute__ ((alias ("_cthreads_funlockfile")));
+int _IO_ftrylockfile (_IO_FILE *)
+     __attribute__ ((alias ("_cthreads_ftrylockfile")));
+
+void flockfile (_IO_FILE *)
+     __attribute__ ((alias ("_cthreads_flockfile")));
+void funlockfile (_IO_FILE *)
+     __attribute__ ((alias ("_cthreads_funlockfile")));
+int ftrylockfile (_IO_FILE *)
+     __attribute__ ((alias ("_cthreads_ftrylockfile")));
+
+#endif /* _STDIO_USES_IOSTREAM */
Index: glibc-2.21/libpthread/Makeconfig
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/Makeconfig
@@ -0,0 +1,12 @@
+# Makeconfig fragment for Hurd libpthread add-on.
+# This gets included at the end of the main glibc Makeconfig.
+
+have-thread-library = yes
+
+shared-thread-library = $(common-objpfx)libpthread/libpthread.so
+static-thread-library = $(common-objpfx)libpthread/libpthread.a
+bounded-thread-library = $(static-thread-library)
+
+rpath-dirs += libpthread
+
++includes += -I$(..)libpthread/include
Index: glibc-2.21/libpthread/Makefile
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/Makefile
@@ -0,0 +1,339 @@
+#
+#   Copyright (C) 1994, 1995, 1996, 1997, 2000, 2002, 2004, 2005, 2006, 2007,
+#     2008, 2011 Free Software Foundation, Inc.
+#
+#   This program is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU General Public License as
+#   published by the Free Software Foundation; either version 2, or (at
+#   your option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+ifeq ($(..),)
+# non-glibc build
+IN_GLIBC = no
+else
+# glibc build
+IN_GLIBC = yes
+# set elf=yes, to retain compatibility with glibc < 2.16
+ifeq ($(elf),)
+elf = yes
+endif
+endif
+
+ifeq ($(IN_GLIBC),no)
+dir := libpthread
+makemode := library
+else
+subdir := libpthread
+
+pthread-version := 0.3
+
+srcdir = .
+endif
+
+MICROKERNEL := mach
+SYSDEPS := lockfile
+
+LCLHDRS :=
+
+libpthread-routines := pt-attr pt-attr-destroy pt-attr-getdetachstate	    \
+	pt-attr-getguardsize pt-attr-getinheritsched			    \
+	pt-attr-getschedparam pt-attr-getschedpolicy pt-attr-getscope	    \
+	pt-attr-getstack pt-attr-getstackaddr pt-attr-getstacksize	    \
+	pt-attr-init pt-attr-setdetachstate pt-attr-setguardsize	    \
+	pt-attr-setinheritsched pt-attr-setschedparam			    \
+	pt-attr-setschedpolicy pt-attr-setscope pt-attr-setstack	    \
+	pt-attr-setstackaddr pt-attr-setstacksize			    \
+									    \
+	pt-barrier-destroy pt-barrier-init pt-barrier-wait		    \
+	pt-barrier pt-barrierattr-destroy pt-barrierattr-init		    \
+	pt-barrierattr-getpshared pt-barrierattr-setpshared		    \
+									    \
+	pt-destroy-specific pt-init-specific				    \
+	pt-key-create pt-key-delete					    \
+	pt-getspecific pt-setspecific					    \
+									    \
+	pt-once								    \
+									    \
+	pt-alloc							    \
+	pt-create							    \
+	pt-getattr							    \
+	pt-equal							    \
+	pt-dealloc							    \
+	pt-detach							    \
+	pt-exit								    \
+	pt-initialize							    \
+	pt-join								    \
+	pt-self								    \
+	pt-sigmask							    \
+	pt-spin-inlines							    \
+	pt-cleanup							    \
+	pt-setcancelstate						    \
+	pt-setcanceltype						    \
+	pt-testcancel							    \
+	pt-cancel							    \
+									    \
+	pt-mutexattr							    \
+	pt-mutexattr-destroy pt-mutexattr-init				    \
+	pt-mutexattr-getprioceiling pt-mutexattr-getprotocol		    \
+	pt-mutexattr-getpshared pt-mutexattr-gettype			    \
+	pt-mutexattr-setprioceiling pt-mutexattr-setprotocol		    \
+	pt-mutexattr-setpshared pt-mutexattr-settype			    \
+									    \
+	pt-mutex-init pt-mutex-destroy					    \
+	pt-mutex-lock pt-mutex-trylock pt-mutex-timedlock		    \
+	pt-mutex-unlock							    \
+	pt-mutex-transfer-np						    \
+	pt-mutex-getprioceiling pt-mutex-setprioceiling			    \
+									    \
+	pt-rwlock-attr							    \
+	pt-rwlockattr-init pt-rwlockattr-destroy			    \
+	pt-rwlockattr-getpshared pt-rwlockattr-setpshared		    \
+									    \
+	pt-rwlock-init pt-rwlock-destroy				    \
+	pt-rwlock-rdlock pt-rwlock-tryrdlock				    \
+	pt-rwlock-trywrlock pt-rwlock-wrlock				    \
+	pt-rwlock-timedrdlock pt-rwlock-timedwrlock			    \
+	pt-rwlock-unlock						    \
+									    \
+	pt-cond								    \
+	pt-condattr-init pt-condattr-destroy				    \
+	pt-condattr-getclock pt-condattr-getpshared			    \
+	pt-condattr-setclock pt-condattr-setpshared			    \
+									    \
+	pt-cond-destroy pt-cond-init					    \
+	pt-cond-brdcast							    \
+	pt-cond-signal							    \
+	pt-cond-wait							    \
+	pt-cond-timedwait						    \
+	pt-hurd-cond-wait						    \
+	pt-hurd-cond-timedwait						    \
+									    \
+	pt-stack-alloc							    \
+	pt-thread-alloc							    \
+	pt-thread-start							    \
+	pt-thread-terminate						    \
+	pt-startup							    \
+									    \
+	pt-getconcurrency pt-setconcurrency				    \
+									    \
+	pt-block							    \
+	pt-timedblock							    \
+	pt-wakeup							    \
+	pt-docancel							    \
+	pt-sysdep							    \
+	pt-setup							    \
+	pt-machdep							    \
+	pt-spin								    \
+									    \
+	pt-sigstate-init						    \
+	pt-sigstate-destroy						    \
+	pt-sigstate							    \
+									    \
+	pt-atfork							    \
+	pt-kill								    \
+	pt-getcpuclockid						    \
+									    \
+	pt-getschedparam pt-setschedparam pt-setschedprio		    \
+	pt-yield							    \
+									    \
+	sem-close sem-destroy sem-getvalue sem-init sem-open		    \
+	sem-post sem-timedwait sem-trywait sem-unlink			    \
+	sem-wait							    \
+									    \
+	shm-directory							    \
+									    \
+	cthreads-compat							    \
+	$(SYSDEPS)
+
+ifeq ($(IN_GLIBC),no)
+SRCS := $(addsuffix .c,$(libpthread-routines))
+OBJS = $(addsuffix .o,$(basename $(notdir $(SRCS))))
+
+OTHERTAGS = 
+
+libname = libpthread
+endif
+
+headers :=				\
+              pthread.h				\
+              pthread/pthread.h			\
+              pthread/pthreadtypes.h		\
+	      semaphore.h			\
+						\
+              bits/pthread.h			\
+              bits/pthread-np.h			\
+              bits/pthreadtypes.h		\
+              bits/mutex.h			\
+              bits/condition.h			\
+              bits/condition-attr.h		\
+              bits/spin-lock.h			\
+              bits/spin-lock-inline.h		\
+              bits/cancelation.h		\
+              bits/thread-attr.h		\
+              bits/barrier-attr.h		\
+              bits/barrier.h			\
+              bits/thread-specific.h		\
+              bits/once.h			\
+              bits/mutex-attr.h			\
+              bits/rwlock.h			\
+              bits/rwlock-attr.h		\
+	      bits/semaphore.h
+
+ifeq ($(IN_GLIBC),yes)
+distribute :=
+
+routines := forward libc_pthread_init
+shared-only-routines = forward
+
+vpath %.c
+
+extra-libs := libpthread
+extra-libs-others := $(extra-libs)
+install-lib-ldscripts := libpthread.so
+
+include ../Makeconfig
+endif
+
+SYSDEP_PATH = $(srcdir)/sysdeps/$(MICROKERNEL)/hurd/i386	\
+	 $(srcdir)/sysdeps/$(MICROKERNEL)/i386			\
+	 $(srcdir)/sysdeps/i386					\
+	 $(srcdir)/sysdeps/$(MICROKERNEL)/hurd			\
+	 $(srcdir)/sysdeps/$(MICROKERNEL)			\
+	 $(srcdir)/sysdeps/hurd					\
+	 $(srcdir)/sysdeps/generic				\
+	 $(srcdir)/sysdeps/posix				\
+	 $(srcdir)/pthread					\
+	 $(srcdir)/include
+
+VPATH += $(SYSDEP_PATH)
+
+ifeq ($(IN_GLIBC),no)
+HURDLIBS = ihash
+else
+LDLIBS-pthread.so = -lihash
+endif
+
+ifeq ($(IN_GLIBC),no)
+installhdrs :=
+installhdrsubdir := .
+
+include ../Makeconf
+endif
+
+CPPFLAGS += \
+	  -DENABLE_TLS					\
+	  $(addprefix -I, $(SYSDEP_PATH))		\
+	  -imacros $(srcdir)/not-in-libc.h
+
+ifeq ($(IN_GLIBC),no)
+CPPFLAGS += \
+	  -imacros $(srcdir)/include/libc-symbols.h
+endif
+
+ifeq ($(IN_GLIBC),yes)
+CFLAGS-lockfile.c = -D_IO_MTSAFE_IO
+
+all: # Make this the default target; it will be defined in Rules.
+endif
+
+ifeq ($(IN_GLIBC),no)
+inst_libdir = $(libdir)
+endif
+
+ifeq ($(IN_GLIBC),no)
+install: install-headers
+install-headers: $(addprefix $(includedir)/, $(headers))
+
+install: $(inst_libdir)/libpthread2.a $(inst_libdir)/libpthread2_pic.a
+else
+subdir_install: $(inst_libdir)/libpthread2.a
+endif
+
+# XXX: If $(inst_libdir)/libpthread2.a is installed and
+# $(inst_libdir)/libpthread is not, we can have some issues.
+.PHONY: $(inst_libdir)/libpthread.a $(inst_libdir)/libpthread_pic.a
+
+# XXX: These rules are a hack.  But it is better than messing with
+# ../Makeconf at the moment.  Note that the linker scripts
+# $(srcdir)/libpthread.a and $(srcdir)/libpthread_pic.a get overwritten
+# when building in $(srcdir) and not a seperate build directory.
+$(inst_libdir)/libpthread2.a: $(inst_libdir)/libpthread.a
+	mv $< $@
+	$(INSTALL_DATA) $(srcdir)/libpthread.a $<
+
+$(inst_libdir)/libpthread2_pic.a: $(inst_libdir)/libpthread_pic.a
+	mv $< $@
+	$(INSTALL_DATA) $(srcdir)/libpthread_pic.a $<
+
+ifeq ($(IN_GLIBC),yes)
+$(inst_libdir)/libpthread.so: $(objpfx)libpthread.so$(libpthread.so-version) \
+			      $(+force)
+	ln -sf $(slibdir)/libpthread.so$(libpthread.so-version) $@
+
+libc-link.so = $(common-objpfx)libc.so
+
+extra-B-pthread.so = -B$(common-objpfx)libpthread/
+
+include ../Rules
+
+# Depend on libc.so so a DT_NEEDED is generated in the shared objects.
+# This ensures they will load libc.so for needed symbols if loaded by
+# a statically-linked program that hasn't already loaded it.
+# Depend on ld.so too to get proper versions of ld.so symbols.
+$(objpfx)libpthread.so: $(libc-link.so) $(common-objpfx)libc_nonshared.a \
+			$(if $(filter yes,$(elf)), $(elf-objpfx)/ld.so) \
+			$(common-objpfx)/mach/libmachuser.so \
+			$(common-objpfx)/hurd/libhurduser.so
+endif
+
+ifeq ($(IN_GLIBC),no)
+.PHONY: $(addprefix $(includedir)/, $(headers))
+
+$(addprefix $(includedir)/, $(headers)):
+	@set -e;							\
+	t="$@";								\
+	t=$${t#$(includedir)/};						\
+	header_ok=0;							\
+	for dir in $(SYSDEP_PATH);					\
+	do								\
+	  if test -e "$$dir/$$t";					\
+	  then								\
+	    tdir=`dirname "$@"`;					\
+	    if test ! -e $$tdir;					\
+	    then							\
+	      mkdir $$tdir;						\
+	    fi;								\
+	    echo $(INSTALL_DATA) "$$dir/$$t" "$@";			\
+	    $(INSTALL_DATA) "$$dir/$$t" "$@";				\
+	    header_ok=1;						\
+	    break;							\
+	  fi;								\
+	done;								\
+	if test "$${header_ok}" -ne 1;					\
+	then								\
+	  echo;								\
+	  echo '*** 'The header file \`$@\' is required, but not	\
+provided, by;								\
+	  echo '*** 'this configuration.  Please report this to the	\
+maintainer.;								\
+	  echo;								\
+	  false;							\
+	fi
+
+#  ifeq ($(VERSIONING),yes)
+#  
+#  # Adding this dependency gets it included in the command line,
+#  # where ld will read it as a linker script.
+#  $(libname).so.$(hurd-version): $(srcdir)/$(libname).map
+#  
+#  endif
+endif
Index: glibc-2.21/libpthread/not-in-libc.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/not-in-libc.h
@@ -0,0 +1,12 @@
+#define __mach_port_insert_right mach_port_insert_right
+#define __mach_port_allocate	mach_port_allocate
+#define __mig_init		mig_init
+#define __thread_create		thread_create
+#define __thread_get_state	thread_get_state
+#define __thread_resume		thread_resume
+#define __thread_set_state	thread_set_state
+#define __thread_terminate	thread_terminate
+#define __thread_terminate_release	thread_terminate_release
+#define __vm_allocate		vm_allocate
+#define __vm_deallocate		vm_deallocate
+#define __sched_yield           sched_yield
Index: glibc-2.21/libpthread/pthread/cthreads-compat.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/cthreads-compat.c
@@ -0,0 +1,107 @@
+/* Compatibility routines for cthreads.
+   Copyright (C) 2000, 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <pthread.h>
+
+typedef void *cthread_t;
+typedef void *(*cthread_fn_t) (void *arg);
+typedef int cthread_key_t;
+
+#define	CTHREAD_KEY_INVALID (cthread_key_t) -1
+
+void
+cthread_detach (cthread_t thread)
+{
+  int err;
+
+  err = pthread_detach ((pthread_t) thread);
+  assert_perror (err);
+}
+
+cthread_t
+cthread_fork (cthread_fn_t func, void *arg)
+{
+  pthread_t thread;
+  int err;
+
+  err = pthread_create (&thread, NULL, func, arg);
+  assert_perror (err);
+
+  return (cthread_t) thread;
+}
+
+int
+cthread_keycreate (cthread_key_t *key)
+{
+  error_t err;
+
+  err = pthread_key_create (key, 0);
+  if (err)
+    {
+      errno = err;
+      *key = CTHREAD_KEY_INVALID;
+      err = -1;
+    }
+
+  return err;
+}
+
+int
+cthread_getspecific (cthread_key_t key, void **val)
+{
+  *val = pthread_getspecific (key);
+  return 0;
+}
+
+void *
+__libc_getspecific (cthread_key_t key)
+{
+  return pthread_getspecific (key);
+}
+
+int
+cthread_setspecific (cthread_key_t key, void *val)
+{
+  error_t err;
+
+  err = pthread_setspecific (key, (const void *) val);
+  if (err)
+    {
+      errno = err;
+      err = -1;
+    }
+
+  return err;
+}
+
+void
+__mutex_lock_solid (void *lock)
+{
+  __pthread_mutex_lock (lock);
+}
+
+void
+__mutex_unlock_solid (void *lock)
+{
+  if (__pthread_spin_trylock (lock) != 0)
+    /* Somebody already got the lock, that one will manage waking up others */
+    return;
+  __pthread_mutex_unlock (lock);
+}
Index: glibc-2.21/libpthread/pthread/pt-alloc.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-alloc.c
@@ -0,0 +1,219 @@
+/* Allocate a new thread structure.
+   Copyright (C) 2000, 2002, 2005, 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <pt-internal.h>
+
+/* This braindamage is necessary because the standard says that some
+   of the threads functions "shall fail" if "No thread could be found
+   corresponding to that specified by the given thread ID."  */
+   
+/* Thread ID lookup table.  */
+struct __pthread **__pthread_threads;
+
+/* The size of the thread ID lookup table.  */
+int __pthread_max_threads;
+
+/* The total number of thread IDs currently in use, or on the list of
+   available thread IDs.  */
+int __pthread_num_threads;
+
+/* A lock for the table, and the other variables above.  */
+pthread_rwlock_t __pthread_threads_lock;
+
+/* List of thread structures corresponding to free thread IDs.  */
+struct __pthread *__pthread_free_threads;
+pthread_mutex_t __pthread_free_threads_lock;
+
+static inline error_t
+initialize_pthread (struct __pthread *new)
+{
+  error_t err;
+
+  err = __pthread_init_specific (new);
+  if (err)
+    return err;
+
+  new->nr_refs = 1;
+  new->cancel_lock = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
+  new->cancel_hook = NULL;
+  new->cancel_hook_arg = NULL;
+  new->cancel_state = PTHREAD_CANCEL_ENABLE;
+  new->cancel_type = PTHREAD_CANCEL_DEFERRED;
+  new->cancel_pending = 0;
+
+  new->state_lock = (pthread_mutex_t) PTHREAD_MUTEX_INITIALIZER;
+  new->state_cond = (pthread_cond_t) PTHREAD_COND_INITIALIZER;
+
+  new->cancelation_handlers = 0;
+
+  memset (&new->res_state, '\0', sizeof (new->res_state));
+
+#ifdef ENABLE_TLS
+  new->tcb = NULL;
+#endif
+
+  new->next = 0;
+  new->prevp = 0;
+
+  return 0;
+}
+
+
+/* Allocate a new thread structure and its pthread thread ID (but not
+   a kernel thread).  */
+int
+__pthread_alloc (struct __pthread **pthread)
+{
+  error_t err;
+
+  struct __pthread *new;
+  struct __pthread **threads;
+  struct __pthread **old_threads;
+  int max_threads;
+  int new_max_threads;
+
+  pthread_mutex_lock (&__pthread_free_threads_lock);
+  for (new = __pthread_free_threads; new; new = new->next)
+    {
+      /* There is no need to take NEW->STATE_LOCK: if NEW is on this
+	 list, then it is protected by __PTHREAD_FREE_THREADS_LOCK
+	 except in __pthread_dealloc where after it is added to the
+	 list (with the lock held), it drops the lock and then sets
+	 NEW->STATE and immediately stops using NEW.  */
+      if (new->state == PTHREAD_TERMINATED)
+	{
+	  __pthread_dequeue (new);
+	  break;
+	}
+    }
+  pthread_mutex_unlock (&__pthread_free_threads_lock);
+
+  if (new)
+    {
+#ifdef ENABLE_TLS
+      if (new->tcb)
+	{
+	  /* Drop old values */
+	  _dl_deallocate_tls (new->tcb, 1);
+	}
+#endif /* ENABLE_TLS */
+
+      err = initialize_pthread (new);
+      if (! err)
+	*pthread = new;
+      return err;
+    }
+
+  /* Allocate a new thread structure.  */
+  new = malloc (sizeof (struct __pthread));
+  if (new == NULL)
+    return ENOMEM;
+
+  err = initialize_pthread (new);
+  if (err)
+    {
+      free (new);
+      return err;
+    }
+
+ retry:
+  pthread_rwlock_wrlock (&__pthread_threads_lock);
+
+  if (__pthread_num_threads < __pthread_max_threads)
+    {
+      /* We have a free slot.  Use the slot number plus one as the
+         thread ID for the new thread.  */
+      new->thread = 1 + __pthread_num_threads++;
+      __pthread_threads[new->thread - 1] = NULL;
+
+      pthread_rwlock_unlock (&__pthread_threads_lock);
+
+      *pthread = new;
+      return 0;
+    }
+#ifdef PTHREAD_THREADS_MAX
+  else if (__pthread_num_threads >= PTHREAD_THREADS_MAX)
+    {
+      /* We have reached the limit on the number of threads per process.  */
+      pthread_rwlock_unlock (&__pthread_threads_lock);
+
+      free (new);
+      return EAGAIN;
+    }
+#endif
+
+  /* We are going to enlarge the threads table.  Save its current
+     size.  We're going to release the lock before doing the necessary
+     memory allocation, since that's a potentially blocking operation.  */
+  max_threads = __pthread_max_threads;
+
+  pthread_rwlock_unlock (&__pthread_threads_lock);
+
+  /* Allocate a new lookup table that's twice as large.  */
+  new_max_threads
+    = max_threads > 0 ? max_threads * 2 : _POSIX_THREAD_THREADS_MAX;
+  threads = malloc (new_max_threads * sizeof (struct __pthread *));
+  if (threads == NULL)
+    {
+      free (new);
+      return ENOMEM;
+    }
+
+  pthread_rwlock_wrlock (&__pthread_threads_lock);
+
+  /* Check if nobody else has already enlarged the table.  */
+  if (max_threads != __pthread_max_threads)
+    {
+      /* Yep, they did.  */
+      pthread_rwlock_unlock (&__pthread_threads_lock);
+
+      /* Free the newly allocated table and try again to allocate a slot.  */
+      free (threads);
+      goto retry;
+    }
+
+  /* Copy over the contents of the old table.  */
+  memcpy (threads, __pthread_threads,
+	  __pthread_max_threads * sizeof (struct __pthread *));
+
+  /* Save the location of the old table.  We want to deallocate its
+     storage after we released the lock.  */
+  old_threads = __pthread_threads;
+
+  /* Replace the table with the new one.  */
+  __pthread_max_threads = new_max_threads;
+  __pthread_threads = threads;
+
+  /* And allocate ourselves one of the newly created slots.  */
+  new->thread = 1 + __pthread_num_threads++;
+  __pthread_threads[new->thread - 1] = NULL;
+
+  pthread_rwlock_unlock (&__pthread_threads_lock);
+
+  free (old_threads);
+
+  *pthread = new;
+  return 0;
+}
Index: glibc-2.21/libpthread/pthread/pt-cancel.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-cancel.c
@@ -0,0 +1,63 @@
+/* Cancel a thread.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+int
+pthread_cancel (pthread_t t)
+{
+  int err = 0;
+  struct __pthread *p;
+
+  p = __pthread_getid (t);
+  if (! p)
+    return ESRCH;
+
+  __pthread_mutex_lock (&p->cancel_lock);
+  if (p->cancel_pending)
+    {
+      __pthread_mutex_unlock (&p->cancel_lock);
+      return 0;
+    }
+
+  p->cancel_pending = 1;
+
+  if (p->cancel_state != PTHREAD_CANCEL_ENABLE)
+    {
+      __pthread_mutex_unlock (&p->cancel_lock);
+      return 0;
+    }
+
+  if (p->cancel_type == PTHREAD_CANCEL_ASYNCHRONOUS)
+    /* CANCEL_LOCK is unlocked by this call.  */
+    err = __pthread_do_cancel (p);
+  else
+    {
+      if (p->cancel_hook != NULL)
+	/* Thread blocking on a cancellation point.  Invoke hook to unblock.
+	   See __pthread_cond_timedwait_internal.  */
+	p->cancel_hook (p->cancel_hook_arg);
+
+      __pthread_mutex_unlock (&p->cancel_lock);
+    }
+
+  return err;
+}
Index: glibc-2.21/libpthread/pthread/pt-cleanup.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-cleanup.c
@@ -0,0 +1,28 @@
+/* Add a cancelation handler to the stack.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+struct __pthread_cancelation_handler **
+__pthread_get_cleanup_stack (void)
+{
+  return &_pthread_self ()->cancelation_handlers;
+}
Index: glibc-2.21/libpthread/pthread/pt-create.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-create.c
@@ -0,0 +1,254 @@
+/* Thread creation.
+   Copyright (C) 2000, 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <pthread.h>
+#include <signal.h>
+#include <resolv.h>
+
+#include <bits/pt-atomic.h>
+#include <hurd/resource.h>
+
+#include <pt-internal.h>
+
+#if IS_IN (libpthread)
+# include <ctype.h>
+#endif
+#ifdef HAVE_USELOCALE
+# include <locale.h>
+#endif
+
+/* The total number of pthreads currently active.  This is defined
+   here since it would be really stupid to have a threads-using
+   program that doesn't call `pthread_create'.  */
+__atomic_t __pthread_total;
+
+
+/* The entry-point for new threads.  */
+static void
+entry_point (struct __pthread *self, void *(*start_routine)(void *), void *arg)
+{
+#ifdef ENABLE_TLS
+  ___pthread_self = self;
+  __resp = &self->res_state;
+#endif
+
+#if IS_IN (libpthread)
+  /* Initialize pointers to locale data.  */
+  __ctype_init ();
+#endif
+#ifdef HAVE_USELOCALE
+  /* A fresh thread needs to be bound to the global locale.  */
+  uselocale (LC_GLOBAL_LOCALE);
+#endif
+
+  __pthread_startup ();
+
+  pthread_exit (start_routine (arg));
+}
+
+/* Create a thread with attributes given by ATTR, executing
+   START_ROUTINE with argument ARG.  */
+int
+pthread_create (pthread_t *thread, const pthread_attr_t *attr,
+		void *(*start_routine)(void *), void *arg)
+{
+  int err;
+  struct __pthread *pthread;
+
+  err = __pthread_create_internal (&pthread, attr, start_routine, arg);
+  if (! err)
+    *thread = pthread->thread;
+  else if (err == ENOMEM)
+    err = EAGAIN;
+
+  return err;
+}
+
+/* Internal version of pthread_create.  See comment in
+   pt-internal.h.  */
+int
+__pthread_create_internal (struct __pthread **thread,
+			   const pthread_attr_t *attr,
+			   void *(*start_routine)(void *), void *arg)
+{
+  int err;
+  struct __pthread *pthread;
+  const struct __pthread_attr *setup;
+  sigset_t sigset;
+  size_t stacksize;
+
+  /* Allocate a new thread structure.  */
+  err = __pthread_alloc (&pthread);
+  if (err)
+    goto failed;
+
+  /* Use the default attributes if ATTR is NULL.  */
+  setup = attr ? attr : &__pthread_default_attr;
+
+  stacksize = setup->__stacksize;
+  if (!stacksize)
+    {
+      struct rlimit rlim;
+      getrlimit(RLIMIT_STACK, &rlim);
+      if (rlim.rlim_cur != RLIM_INFINITY)
+	stacksize = rlim.rlim_cur;
+      if (!stacksize)
+	stacksize = PTHREAD_STACK_DEFAULT;
+    }
+
+  /* Initialize the thread state.  */
+  pthread->state = (setup->__detachstate == PTHREAD_CREATE_DETACHED
+		    ? PTHREAD_DETACHED : PTHREAD_JOINABLE);
+
+  if (setup->__stackaddr)
+    {
+      pthread->stackaddr = setup->__stackaddr;
+
+      /* If the user supplied a stack, it is not our responsibility to
+	 setup a stack guard.  */
+      pthread->guardsize = 0;
+      pthread->stack = 0;
+    }
+  else
+    {
+      /* Allocate a stack.  */
+      err = __pthread_stack_alloc (&pthread->stackaddr,
+				   ((setup->__guardsize + __vm_page_size-1)
+				    / __vm_page_size) * __vm_page_size
+				   + stacksize);
+      if (err)
+	goto failed_stack_alloc;
+
+      pthread->guardsize = setup->__guardsize;
+      pthread->stack = 1;
+    }
+
+  pthread->stacksize = stacksize;
+
+  /* Allocate the kernel thread and other required resources.  */
+  err = __pthread_thread_alloc (pthread);
+  if (err)
+    goto failed_thread_alloc;
+
+#ifdef ENABLE_TLS
+  pthread->tcb = _dl_allocate_tls (NULL);
+  if (!pthread->tcb)
+    {
+      err = ENOMEM;
+      goto failed_thread_tls_alloc;
+    }
+  pthread->tcb->tcb = pthread->tcb;
+#endif /* ENABLE_TLS */
+
+  /* And initialize the rest of the machine context.  This may include
+     additional machine- and system-specific initializations that
+     prove convenient.  */
+  err = __pthread_setup (pthread, entry_point, start_routine, arg);
+  if (err)
+    goto failed_setup;
+
+  /* Initialize the system-specific signal state for the new
+     thread.  */
+  err = __pthread_sigstate_init (pthread);
+  if (err)
+    goto failed_sigstate;
+
+  /* If the new thread is joinable, add a reference for the caller.  */
+  if (pthread->state == PTHREAD_JOINABLE)
+    pthread->nr_refs++;
+
+  /* Set the new thread's signal mask and set the pending signals to
+     empty.  POSIX says: "The signal mask shall be inherited from the
+     creating thread.  The set of signals pending for the new thread
+     shall be empty."  If the currnet thread is not a pthread then we
+     just inherit the process' sigmask.  */
+  if (__pthread_num_threads == 1)
+    err = sigprocmask (0, 0, &sigset);
+  else
+    err = __pthread_sigstate (_pthread_self (), 0, 0, &sigset, 0);
+  assert_perror (err);
+   
+  err = __pthread_sigstate (pthread, SIG_SETMASK, &sigset, 0, 1);
+  assert_perror (err);
+
+  /* Increase the total number of threads.  We do this before actually
+     starting the new thread, since the new thread might immediately
+     call `pthread_exit' which decreases the number of threads and
+     calls `exit' if the number of threads reaches zero.  Increasing
+     the number of threads from within the new thread isn't an option
+     since this thread might return and call `pthread_exit' before the
+     new thread runs.  */
+  __atomic_inc (&__pthread_total);
+
+  /* Store a pointer to this thread in the thread ID lookup table.  We
+     could use __thread_setid, however, we only lock for reading as no
+     other thread should be using this entry (we also assume that the
+     store is atomic).  */
+  pthread_rwlock_rdlock (&__pthread_threads_lock);
+  __pthread_threads[pthread->thread - 1] = pthread;
+  pthread_rwlock_unlock (&__pthread_threads_lock);
+
+  /* At this point it is possible to guess our pthread ID.  We have to
+     make sure that all functions taking a pthread_t argument can
+     handle the fact that this thread isn't really running yet.  Since
+     the new thread might be passed its ID through pthread_create (to
+     avoid calling pthread_self), read it before starting the thread.  */
+  *thread = pthread;
+
+  /* Schedule the new thread.  */
+  err = __pthread_thread_start (pthread);
+  if (err)
+    goto failed_starting;
+
+
+  return 0;
+
+ failed_starting:
+  /* If joinable, a reference was added for the caller.  */
+  if (pthread->state == PTHREAD_JOINABLE)
+    __pthread_dealloc (pthread);
+
+  __pthread_setid (pthread->thread, NULL);
+  __atomic_dec (&__pthread_total);
+ failed_sigstate:
+  __pthread_sigstate_destroy (pthread);
+ failed_setup:
+#ifdef ENABLE_TLS
+  _dl_deallocate_tls (pthread->tcb, 1);
+  pthread->tcb = NULL;
+ failed_thread_tls_alloc:
+#endif /* ENABLE_TLS */
+  __pthread_thread_terminate (pthread);
+
+  /* __pthread_thread_terminate has taken care of deallocating the stack and
+     the thread structure.  */
+  goto failed;
+ failed_thread_alloc:
+  if (pthread->stack)
+    __pthread_stack_dealloc (pthread->stackaddr,
+			     ((setup->__guardsize + __vm_page_size-1)
+			      / __vm_page_size) * __vm_page_size
+			     + stacksize);
+ failed_stack_alloc:
+  __pthread_dealloc (pthread);
+ failed:
+  return err;
+}
Index: glibc-2.21/libpthread/pthread/pt-dealloc.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-dealloc.c
@@ -0,0 +1,69 @@
+/* Deallocate a thread structure.
+   Copyright (C) 2000, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <pthread.h>
+#include <stdlib.h>
+
+#include <pt-internal.h>
+
+#include <bits/pt-atomic.h>
+
+/* List of thread structures corresponding to free thread IDs.  */
+extern struct __pthread *__pthread_free_threads;
+extern pthread_mutex_t __pthread_free_threads_lock;
+
+
+/* Deallocate the thread structure for PTHREAD.  */
+void
+__pthread_dealloc (struct __pthread *pthread)
+{
+  assert (pthread->state != PTHREAD_TERMINATED);
+
+  if (! __atomic_dec_and_test (&pthread->nr_refs))
+    return;
+
+  /* Withdraw this thread from the thread ID lookup table.  */
+  __pthread_setid (pthread->thread, NULL);
+
+  /* Mark the thread as terminated.  We broadcast the condition
+     here to prevent pthread_join from waiting for this thread to
+     exit where it was never really started.  Such a call to
+     pthread_join is completely bogus, but unfortunately allowed
+     by the standards.  */
+  __pthread_mutex_lock (&pthread->state_lock);
+  if (pthread->state != PTHREAD_EXITED)
+    pthread_cond_broadcast (&pthread->state_cond);
+  __pthread_mutex_unlock (&pthread->state_lock);
+
+  /* We do not actually deallocate the thread structure, but add it to
+     a list of re-usable thread structures.  */
+  pthread_mutex_lock (&__pthread_free_threads_lock);
+  __pthread_enqueue (&__pthread_free_threads, pthread);
+  pthread_mutex_unlock (&__pthread_free_threads_lock);
+
+  /* Setting PTHREAD->STATE to PTHREAD_TERMINATED makes this TCB
+     available for reuse.  After that point, we can no longer assume
+     that PTHREAD is valid.
+
+     Note that it is safe to not lock this update to PTHREAD->STATE:
+     the only way that it can now be accessed is in __pthread_alloc,
+     which reads this variable.  */
+  pthread->state = PTHREAD_TERMINATED;
+}
Index: glibc-2.21/libpthread/pthread/pt-detach.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-detach.c
@@ -0,0 +1,80 @@
+/* Detach a thread.
+   Copyright (C) 2000, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <stddef.h>
+
+#include <pt-internal.h>
+
+/* Indicate that the storage for THREAD can be reclaimed when it
+   terminates.  */
+int
+pthread_detach (pthread_t thread)
+{
+  struct __pthread *pthread;
+  int err = 0;
+
+  /* Lookup the thread structure for THREAD.  */
+  pthread = __pthread_getid (thread);
+  if (pthread == NULL)
+    return ESRCH;
+
+  __pthread_mutex_lock (&pthread->state_lock);
+
+  switch (pthread->state)
+    {
+    case PTHREAD_JOINABLE:
+      /* THREAD still running.  Mark it as detached such that its
+         resources can be reclaimed as soon as the thread exits.  */
+      pthread->state = PTHREAD_DETACHED;
+
+      /* Broadcast the condition.  This will make threads that are
+	 waiting to join THREAD continue with hopefully disastrous
+	 consequences instead of blocking indefinitely.  */
+      pthread_cond_broadcast (&pthread->state_cond);
+      __pthread_mutex_unlock (&pthread->state_lock);
+
+      __pthread_dealloc (pthread);
+      break;
+
+    case PTHREAD_EXITED:
+      __pthread_mutex_unlock (&pthread->state_lock);
+
+      /* THREAD has already exited.  PTHREAD remained after the thread
+	 exited in order to provide the exit status, but it turns out
+	 it won't be needed.  */
+      __pthread_dealloc (pthread);
+      break;
+
+    case PTHREAD_TERMINATED:
+      /* Pretend THREAD wasn't there in the first place.  */
+      __pthread_mutex_unlock (&pthread->state_lock);
+      err = ESRCH;
+      break;
+
+    default:
+      /* Thou shalt not detach non-joinable threads!  */
+      __pthread_mutex_unlock (&pthread->state_lock);
+      err = EINVAL;
+      break;
+    }
+
+  return err;
+}
Index: glibc-2.21/libpthread/pthread/pt-exit.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-exit.c
@@ -0,0 +1,112 @@
+/* Thread termination.
+   Copyright (C) 2000, 2002, 2005, 2007, 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <pthread.h>
+#include <stdlib.h>
+
+#include <pt-internal.h>
+
+#include <bits/pt-atomic.h>
+
+
+/* Terminate the current thread and make STATUS available to any
+   thread that might join it.  */
+void
+__pthread_exit (void *status)
+{
+  struct __pthread *self = _pthread_self ();
+  struct __pthread_cancelation_handler **handlers;
+  int oldstate;
+
+  /* Run any cancelation handlers.  According to POSIX, the
+     cancellation cleanup handlers should be called with cancellation
+     disabled.  */
+  pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &oldstate);
+
+  for (handlers = __pthread_get_cleanup_stack ();
+       *handlers;
+       *handlers = (*handlers)->__next)
+    (*handlers)->__handler ((*handlers)->__arg);
+
+  pthread_setcancelstate (oldstate, &oldstate);
+
+  /* Decrease the number of threads.  We use an atomic operation to
+     make sure that only the last thread calls `exit'.  */
+  if (__atomic_dec_and_test (&__pthread_total))
+    /* We are the last thread.  */
+    exit (0);
+
+  /* Note that after this point the process can be terminated at any
+     point if another thread calls `pthread_exit' and happens to be
+     the last thread.  */
+
+  __pthread_mutex_lock (&self->state_lock);
+
+  if (self->cancel_state == PTHREAD_CANCEL_ENABLE && self->cancel_pending)
+    status = PTHREAD_CANCELED;
+
+  switch (self->state)
+    {
+    default:
+      assert (! "Consistency error: unexpected self->state");
+      abort ();
+      break;
+
+    case PTHREAD_DETACHED:
+      __pthread_mutex_unlock (&self->state_lock);
+
+      break;
+
+    case PTHREAD_JOINABLE:
+      /* We need to stay around for a while since another thread
+         might want to join us.  */
+      self->state = PTHREAD_EXITED;
+
+      /* We need to remember the exit status.  A thread joining us
+         might ask for it.  */
+      self->status = status;
+
+      /* Broadcast the condition.  This will wake up threads that are
+         waiting to join us.  */
+      pthread_cond_broadcast (&self->state_cond);
+      __pthread_mutex_unlock (&self->state_lock);
+
+      break;
+    }
+
+  /* Destroy any thread specific data.  */
+  __pthread_destroy_specific (self);
+
+  /* Destroy any signal state.  */
+  __pthread_sigstate_destroy (self);
+
+  /* Self terminating requires TLS, so defer the release of the TCB until
+     the thread structure is reused.  */
+
+  /* Release kernel resources, including the kernel thread and the stack,
+     and drop the self reference.  */
+  __pthread_thread_terminate (self);
+
+  /* NOTREACHED */
+  abort ();
+}
+
+strong_alias (__pthread_exit, pthread_exit);
Index: glibc-2.21/libpthread/pthread/pt-getattr.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-getattr.c
@@ -0,0 +1,51 @@
+/* Thread attributes retrieval.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+/* Initialize thread attribute *ATTR with attributes corresponding to the
+   already running thread THREAD.  It shall be called on an uninitialized ATTR
+   and destroyed with pthread_attr_destroy when no longer needed.  */
+int
+pthread_getattr_np (pthread_t thread, pthread_attr_t *attr)
+{
+  struct __pthread *pthread;
+
+  pthread = __pthread_getid(thread);
+  if (pthread == NULL)
+    return ESRCH;
+
+  /* Some attributes (schedparam, inheritsched, contentionscope and schedpolicy)
+     are not supported yet, so fill them with our default values.  */
+  *attr = __pthread_default_attr;
+
+  attr->__stackaddr = pthread->stackaddr +
+		      ((pthread->guardsize + __vm_page_size-1)
+		       / __vm_page_size * __vm_page_size);
+  attr->__stacksize = pthread->stacksize;
+  attr->__guardsize = pthread->guardsize;
+  attr->__detachstate = (pthread->state == PTHREAD_DETACHED
+		       ? PTHREAD_CREATE_DETACHED : PTHREAD_CREATE_JOINABLE);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/pthread/pt-initialize.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-initialize.c
@@ -0,0 +1,88 @@
+/* Initialize pthreads library.
+   Copyright (C) 2000,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <string.h>
+
+#include <pt-internal.h>
+#include <set-hooks.h>
+
+#include <pthread.h>
+#include <pthread-functions.h>
+
+DEFINE_HOOK (__pthread_init, (void));
+
+#if IS_IN (libpthread)
+static const struct pthread_functions pthread_functions =
+  {
+    .ptr_pthread_attr_destroy = __pthread_attr_destroy,
+    .ptr_pthread_attr_init = __pthread_attr_init,
+    .ptr_pthread_attr_getdetachstate = __pthread_attr_getdetachstate,
+    .ptr_pthread_attr_setdetachstate = __pthread_attr_setdetachstate,
+    .ptr_pthread_attr_getinheritsched = __pthread_attr_getinheritsched,
+    .ptr_pthread_attr_setinheritsched = __pthread_attr_setinheritsched,
+    .ptr_pthread_attr_getschedparam = __pthread_attr_getschedparam,
+    .ptr_pthread_attr_setschedparam = __pthread_attr_setschedparam,
+    .ptr_pthread_attr_getschedpolicy = __pthread_attr_getschedpolicy,
+    .ptr_pthread_attr_setschedpolicy = __pthread_attr_setschedpolicy,
+    .ptr_pthread_attr_getscope = __pthread_attr_getscope,
+    .ptr_pthread_attr_setscope = __pthread_attr_setscope,
+    .ptr_pthread_condattr_destroy = __pthread_condattr_destroy,
+    .ptr_pthread_condattr_init = __pthread_condattr_init,
+    .ptr_pthread_cond_broadcast = __pthread_cond_broadcast,
+    .ptr_pthread_cond_destroy = __pthread_cond_destroy,
+    .ptr_pthread_cond_init = __pthread_cond_init,
+    .ptr_pthread_cond_signal = __pthread_cond_signal,
+    .ptr_pthread_cond_wait = __pthread_cond_wait,
+    .ptr_pthread_cond_timedwait = __pthread_cond_timedwait,
+    .ptr_pthread_equal = __pthread_equal,
+    .ptr___pthread_exit = __pthread_exit,
+    .ptr_pthread_getschedparam = __pthread_getschedparam,
+    .ptr_pthread_setschedparam = __pthread_setschedparam,
+    .ptr_pthread_mutex_destroy = _pthread_mutex_destroy,
+    .ptr_pthread_mutex_init = _pthread_mutex_init,
+    .ptr_pthread_mutex_lock = __pthread_mutex_lock,
+    .ptr_pthread_mutex_trylock = __pthread_mutex_trylock,
+    .ptr_pthread_mutex_unlock = __pthread_mutex_unlock,
+    .ptr_pthread_self = __pthread_self,
+    .ptr_pthread_setcancelstate = __pthread_setcancelstate,
+    .ptr_pthread_setcanceltype = __pthread_setcanceltype,
+    .ptr___pthread_get_cleanup_stack = __pthread_get_cleanup_stack,
+    .ptr_pthread_once = __pthread_once,
+    .ptr_pthread_rwlock_rdlock = __pthread_rwlock_rdlock,
+    .ptr_pthread_rwlock_wrlock = __pthread_rwlock_wrlock,
+    .ptr_pthread_rwlock_unlock = __pthread_rwlock_unlock,
+    .ptr_pthread_key_create = __pthread_key_create,
+    .ptr_pthread_getspecific = __pthread_getspecific,
+    .ptr_pthread_setspecific = __pthread_setspecific,
+    .ptr__IO_flockfile = _cthreads_flockfile,
+    .ptr__IO_funlockfile = _cthreads_funlockfile,
+    .ptr__IO_ftrylockfile = _cthreads_ftrylockfile,
+  };
+#endif /* IS_IN (libpthread) */
+
+/* Initialize the pthreads library.  */
+void
+___pthread_init (void)
+{
+#if IS_IN (libpthread)
+  __libc_pthread_init(&pthread_functions);
+#endif
+  RUN_HOOK (__pthread_init, ());
+}
Index: glibc-2.21/libpthread/pthread/pt-internal.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-internal.h
@@ -0,0 +1,330 @@
+/* Internal defenitions for pthreads library.
+   Copyright (C) 2000, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_INTERNAL_H
+#define _PT_INTERNAL_H	1
+
+#include <pthread.h>
+#include <stddef.h>
+#include <sched.h>
+#include <signal.h>
+#include <assert.h>
+#define __need_res_state
+#include <resolv.h>
+
+#include <bits/pt-atomic.h>
+
+#include <pt-key.h>
+
+#include <pt-sysdep.h>
+#include <pt-machdep.h>
+
+#if IS_IN (libpthread)
+# include <ldsodefs.h>
+#endif
+
+/* Thread state.  */
+enum pthread_state
+{
+  /* The thread is running and joinable.  */
+  PTHREAD_JOINABLE = 0,
+  /* The thread is running and detached.  */
+  PTHREAD_DETACHED,
+  /* A joinable thread exited and its return code is available.  */
+  PTHREAD_EXITED,
+  /* The thread structure is unallocated and available for reuse.  */
+  PTHREAD_TERMINATED
+};
+
+#ifndef PTHREAD_KEY_MEMBERS
+# define PTHREAD_KEY_MEMBERS
+#endif
+
+#ifndef PTHREAD_SYSDEP_MEMBERS
+# define PTHREAD_SYSDEP_MEMBERS
+#endif
+
+#if !(IS_IN (libpthread))
+#ifdef ENABLE_TLS
+/* Type of the TCB.  */
+typedef struct
+{
+  void *tcb;			/* Points to this structure.  */
+  void *dtv;			/* Vector of pointers to TLS data.  */
+  thread_t self;		/* This thread's control port.  */
+} tcbhead_t;
+#endif /* ENABLE_TLS */
+#endif /* ! IS_IN (libpthread) */
+
+/* This structure describes a POSIX thread.  */
+struct __pthread
+{
+  /* Thread ID.  */
+  pthread_t thread;
+
+  __atomic_t nr_refs;   /* Detached threads have a self reference only,
+			   while joinable threads have two references.
+			   These are used to keep the structure valid at
+			   thread destruction.  Detaching/joining a thread
+			   drops a reference.  */
+
+  /* Cancellation.  */
+  pthread_mutex_t cancel_lock;  /* Protect cancel_xxx members.  */
+  void (*cancel_hook)(void *);	/* Called to unblock a thread blocking
+				   in a cancellation point (namely,
+				   __pthread_cond_timedwait_internal).  */
+  void *cancel_hook_arg;
+  int cancel_state;
+  int cancel_type;
+  int cancel_pending;
+  struct __pthread_cancelation_handler *cancelation_handlers;
+
+  /* Thread stack.  */
+  void *stackaddr;
+  size_t stacksize;
+  size_t guardsize;
+  int stack;			/* Nonzero if the stack was allocated.  */
+
+  /* Exit status.  */
+  void *status;
+
+  /* Thread state.  */
+  enum pthread_state state;
+  pthread_mutex_t state_lock;	/* Locks the state.  */
+  pthread_cond_t state_cond;	/* Signalled when the state changes.  */
+
+  /* Resolver state.  */
+  struct __res_state res_state;
+
+  /* Thread context.  */
+  struct pthread_mcontext mcontext;
+
+  PTHREAD_KEY_MEMBERS
+
+  PTHREAD_SYSDEP_MEMBERS
+
+#ifdef ENABLE_TLS
+  tcbhead_t *tcb;
+#endif /* ENABLE_TLS */
+
+  /* Queue links.  Since PREVP is used to determine if a thread has been
+     awaken, it must be protected by the queue lock.  */
+  struct __pthread *next, **prevp;
+};
+
+/* Enqueue an element THREAD on the queue *HEAD.  */
+static inline void
+__pthread_enqueue (struct __pthread **head, struct __pthread *thread)
+{
+  assert (thread->prevp == 0);
+
+  thread->next = *head;
+  thread->prevp = head;
+  if (*head)
+    (*head)->prevp = &thread->next;
+  *head = thread;
+}
+
+/* Dequeue the element THREAD from the queue it is connected to.  */
+static inline void
+__pthread_dequeue (struct __pthread *thread)
+{
+  assert (thread);
+  assert (thread->prevp);
+
+  if (thread->next)
+    thread->next->prevp = thread->prevp;
+  *thread->prevp = thread->next;
+  thread->prevp = 0;
+}
+
+/* Iterate over QUEUE storing each element in ELEMENT.  */
+#define __pthread_queue_iterate(queue, element)				\
+  for (struct __pthread *__pdi_next = (queue);				\
+       ((element) = __pdi_next)						\
+	 && ((__pdi_next = __pdi_next->next),				\
+	     1);							\
+       )
+
+/* Iterate over QUEUE dequeuing each element, storing it in
+   ELEMENT.  */
+#define __pthread_dequeuing_iterate(queue, element)			\
+  for (struct __pthread *__pdi_next = (queue);				\
+       ((element) = __pdi_next)						\
+	 && ((__pdi_next = __pdi_next->next),				\
+	     ((element)->prevp = 0),					\
+	     1);							\
+       )
+
+/* The total number of threads currently active.  */
+extern __atomic_t __pthread_total;
+
+/* The total number of thread IDs currently in use, or on the list of
+   available thread IDs.  */
+extern int __pthread_num_threads;
+
+/* Concurrency hint.  */
+extern int __pthread_concurrency;
+
+/* Array of __pthread structures and its lock.  Indexed by the pthread
+   id minus one.  (Why not just use the pthread id?  Because some
+   brain-dead users of the pthread interface incorrectly assume that 0
+   is an invalid pthread id.)  */
+extern struct __pthread **__pthread_threads;
+extern pthread_rwlock_t __pthread_threads_lock;
+
+#define __pthread_getid(thread) \
+  ({ struct __pthread *__t;                                                  \
+     pthread_rwlock_rdlock (&__pthread_threads_lock);                        \
+     __t = __pthread_threads[thread - 1];                                    \
+     pthread_rwlock_unlock (&__pthread_threads_lock);                        \
+     __t; })
+
+#define __pthread_setid(thread, pthread) \
+  pthread_rwlock_wrlock (&__pthread_threads_lock);                           \
+  __pthread_threads[thread - 1] = pthread;                                   \
+  pthread_rwlock_unlock (&__pthread_threads_lock);
+
+/* Similar to pthread_self, but returns the thread descriptor instead
+   of the thread ID.  */
+#ifndef _pthread_self
+extern struct __pthread *_pthread_self (void);
+#endif
+
+
+/* Initialize the pthreads library.  */
+extern void ___pthread_init (void);
+
+/* Internal version of pthread_create.  Rather than return the new
+   tid, we return the whole __pthread structure in *PTHREAD.  */
+extern int __pthread_create_internal (struct __pthread **__restrict pthread,
+				      const pthread_attr_t *__restrict attr,
+				      void *(*start_routine)(void *),
+				      void *__restrict arg);
+
+/* Allocate a new thread structure and a pthread thread ID (but not a
+   kernel thread or a stack).  THREAD has one reference.  */
+extern int __pthread_alloc (struct __pthread **thread);
+
+/* Deallocate the thread structure.  This is the dual of
+   __pthread_alloc (N.B. it does not call __pthread_stack_dealloc nor
+   __pthread_thread_terminate).  THREAD loses one reference and is
+   released if the reference counter drops to 0.  */
+extern void __pthread_dealloc (struct __pthread *thread);
+
+
+/* Allocate a stack of size STACKSIZE.  The stack base shall be
+   returned in *STACKADDR.  */
+extern int __pthread_stack_alloc (void **stackaddr, size_t stacksize);
+
+/* Deallocate the stack STACKADDR of size STACKSIZE.  */
+extern void __pthread_stack_dealloc (void *stackaddr, size_t stacksize);
+
+
+/* Setup thread THREAD's context.  */
+extern int __pthread_setup (struct __pthread *__restrict thread,
+				  void (*entry_point)(struct __pthread *,
+						      void *(*)(void *),
+						      void *),
+				  void *(*start_routine)(void *),
+				  void *__restrict arg);
+
+
+/* Allocate a kernel thread (and any miscellaneous system dependent
+   resources) for THREAD; it must not be placed on the run queue.  */
+extern int __pthread_thread_alloc (struct __pthread *thread);
+
+/* Start THREAD making it eligible to run.  */
+extern int __pthread_thread_start (struct __pthread *thread);
+
+/* Terminate the kernel thread associated with THREAD, and deallocate its
+   stack as well as any other kernel resource associated with it.
+   In addition, THREAD looses one reference.
+
+   This function can be called by any thread, including the target thread.
+   Since some resources that are destroyed along the kernel thread are
+   stored in thread-local variables, the conditions required for this
+   function to behave correctly are a bit unusual : as long as the target
+   thread hasn't been started, any thread can terminate it, but once it
+   has started, no other thread can terminate it, so that thread-local
+   variables created by that thread are correctly released.  */
+extern void __pthread_thread_terminate (struct __pthread *thread);
+
+
+/* Called by a thread just before it calls the provided start
+   routine.  */
+extern void __pthread_startup (void);
+
+/* Block THREAD.  */
+extern void __pthread_block (struct __pthread *thread);
+
+/* Block THREAD until *ABSTIME is reached.  */
+extern error_t __pthread_timedblock (struct __pthread *__restrict thread,
+				     const struct timespec *__restrict abstime,
+				     clockid_t clock_id);
+
+/* Wakeup THREAD.  */
+extern void __pthread_wakeup (struct __pthread *thread);
+
+
+/* Perform a cancelation.  The CANCEL_LOCK member of the given thread must
+   be locked before calling this function, which must unlock it.  */
+extern int __pthread_do_cancel (struct __pthread *thread);
+
+
+/* Initialize the thread specific data structures.  THREAD must be the
+   calling thread.  */
+extern error_t __pthread_init_specific (struct __pthread *thread);
+
+/* Call the destructors on all of the thread specific data in THREAD.
+   THREAD must be the calling thread.  */
+extern void __pthread_destroy_specific (struct __pthread *thread);
+
+
+/* Initialize newly create thread *THREAD's signal state data
+   structures.  */
+extern error_t __pthread_sigstate_init (struct __pthread *thread);
+
+/* Destroy the signal state data structures associcated with thread
+   *THREAD.  */
+extern void __pthread_sigstate_destroy (struct __pthread *thread);
+
+/* Modify thread *THREAD's signal state.  */
+extern error_t __pthread_sigstate (struct __pthread *__restrict thread, int how,
+				   const sigset_t *__restrict set,
+				   sigset_t *__restrict oset,
+				   int clear_pending);
+
+
+/* Default thread attributes.  */
+extern const struct __pthread_attr __pthread_default_attr;
+
+/* Default barrier attributes.  */
+extern const struct __pthread_barrierattr __pthread_default_barrierattr;
+
+/* Default mutex attributes.  */
+extern const struct __pthread_mutexattr __pthread_default_mutexattr;
+
+/* Default rdlock attributes.  */
+const struct __pthread_rwlockattr __pthread_default_rwlockattr;
+
+/* Default condition attributes.  */
+const struct __pthread_condattr __pthread_default_condattr;
+
+#endif /* pt-internal.h */
Index: glibc-2.21/libpthread/pthread/pt-join.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-join.c
@@ -0,0 +1,76 @@
+/* Wait for thread termination.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <stddef.h>
+
+#include <pt-internal.h>
+
+/* Make calling thread wait for termination of thread THREAD.  Return
+   the exit status of the thread in *STATUS.  */
+int
+pthread_join (pthread_t thread, void **status)
+{
+  struct __pthread *pthread;
+  int err = 0;
+
+  /* Lookup the thread structure for THREAD.  */
+  pthread = __pthread_getid (thread);
+  if (pthread == NULL)
+    return ESRCH;
+
+  __pthread_mutex_lock (&pthread->state_lock);
+  pthread_cleanup_push ((void (*)(void *)) __pthread_mutex_unlock,
+			&pthread->state_lock);
+
+  /* Rely on pthread_cond_wait being a cancellation point to make
+     pthread_join one too.  */
+  while (pthread->state == PTHREAD_JOINABLE)
+    pthread_cond_wait (&pthread->state_cond, &pthread->state_lock);
+
+  pthread_cleanup_pop (0);
+
+  switch (pthread->state)
+    {
+    case PTHREAD_EXITED:
+      /* THREAD has already exited.  Salvage its exit status.  */
+      if (status)
+	*status = pthread->status;
+
+      __pthread_mutex_unlock (&pthread->state_lock);
+
+      __pthread_dealloc (pthread);
+      break;
+
+    case PTHREAD_TERMINATED:
+      /* Pretend THREAD wasn't there in the first place.  */
+      __pthread_mutex_unlock (&pthread->state_lock);
+      err = ESRCH;
+      break;
+
+    default:
+      /* Thou shalt not join non-joinable threads!  */
+      __pthread_mutex_unlock (&pthread->state_lock);
+      err = EINVAL;
+      break;
+    }
+
+  return err;
+}
Index: glibc-2.21/libpthread/pthread/pt-self.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-self.c
@@ -0,0 +1,34 @@
+/* Get calling thread's ID.
+   Copyright (C) 2000, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+/* Return the thread ID of the calling thread.  */
+pthread_t
+__pthread_self (void)
+{
+  struct __pthread *self = _pthread_self ();
+  assert (self);
+
+  return self->thread;
+}
+
+strong_alias (__pthread_self, pthread_self);
Index: glibc-2.21/libpthread/pthread/pt-setcancelstate.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-setcancelstate.c
@@ -0,0 +1,47 @@
+/* Set the cancel state for the calling thread.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_setcancelstate (int state, int *oldstate)
+{
+  struct __pthread *p = _pthread_self ();
+
+  switch (state)
+    {
+    default:
+      return EINVAL;
+    case PTHREAD_CANCEL_ENABLE:
+    case PTHREAD_CANCEL_DISABLE:
+      break;
+    }
+
+  __pthread_mutex_lock (&p->cancel_lock);
+  if (oldstate)
+    *oldstate = p->cancel_state;
+  p->cancel_state = state;
+  __pthread_mutex_unlock (&p->cancel_lock);
+
+  return 0;
+}
+
+strong_alias (__pthread_setcancelstate, pthread_setcancelstate);
Index: glibc-2.21/libpthread/pthread/pt-setcanceltype.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-setcanceltype.c
@@ -0,0 +1,47 @@
+/* Set the cancel type for the calling thread.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_setcanceltype (int type, int *oldtype)
+{
+  struct __pthread *p = _pthread_self ();
+
+  switch (type)
+    {
+    default:
+      return EINVAL;
+    case PTHREAD_CANCEL_DEFERRED:
+    case PTHREAD_CANCEL_ASYNCHRONOUS:
+      break;
+    }
+
+  __pthread_mutex_lock (&p->cancel_lock);
+  if (oldtype)
+    *oldtype = p->cancel_type;
+  p->cancel_type = type;
+  __pthread_mutex_unlock (&p->cancel_lock);
+
+  return 0;
+}
+
+strong_alias (__pthread_setcanceltype, pthread_setcanceltype);
Index: glibc-2.21/libpthread/pthread/pt-sigmask.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-sigmask.c
@@ -0,0 +1,33 @@
+/* Get or set a thread's signal mask.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <signal.h>
+
+#include <pt-internal.h>
+
+int
+pthread_sigmask (int how, const sigset_t *set,
+		 sigset_t *oset)
+{
+  struct __pthread *self = _pthread_self ();
+
+  /* Do not clear SELF's pending signals.  */
+  return __pthread_sigstate (self, how, set, oset, 0);
+}
Index: glibc-2.21/libpthread/pthread/pt-spin-inlines.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-spin-inlines.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* <bits/spin-lock.h> declares some extern inline functions.  These
+   functions are declared additionally here for use when inlining is
+   not possible.  */
+
+#define _FORCE_INLINES
+#define __PT_SPIN_INLINE /* empty */
+
+#include <pthread.h>
+
+/* Weak aliases for the spin lock functions.  Note that
+   pthread_spin_lock is left out deliberately.  We already provide an
+   implementation for it in pt-spin.c.  */
+weak_alias (__pthread_spin_destroy, pthread_spin_destroy);
+weak_alias (__pthread_spin_init, pthread_spin_init);
+weak_alias (__pthread_spin_trylock, pthread_spin_trylock);
+weak_alias (__pthread_spin_unlock, pthread_spin_unlock);
Index: glibc-2.21/libpthread/pthread/pt-testcancel.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-testcancel.c
@@ -0,0 +1,36 @@
+/* Add an explicit cancelation point.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+void
+pthread_testcancel (void)
+{
+  struct __pthread *p = _pthread_self ();
+  int cancelled;
+
+  __pthread_mutex_lock (&p->cancel_lock);
+  cancelled = (p->cancel_state == PTHREAD_CANCEL_ENABLE) && p->cancel_pending;
+  __pthread_mutex_unlock (&p->cancel_lock);
+
+  if (cancelled)
+    pthread_exit (PTHREAD_CANCELED);
+}
Index: glibc-2.21/libpthread/pthread/pt-yield.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/pt-yield.c
@@ -0,0 +1,26 @@
+/* Yield the processor to another thread or process.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <sched.h>
+
+int pthread_yield(void)
+{
+  return sched_yield ();
+}
Index: glibc-2.21/libpthread/pthread/Versions
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/pthread/Versions
@@ -0,0 +1,15 @@
+libc {
+  GLIBC_2.2 {
+    # XXX
+    __vm_deallocate; __mach_port_insert_right; __mach_reply_port;
+    __mig_init; __vm_allocate;
+
+    # functions used in inline functions or macros
+    __pthread_spin_destroy; __pthread_spin_init; __pthread_spin_lock;
+    _pthread_spin_lock; __pthread_spin_trylock; __pthread_spin_unlock;
+
+    # p*
+    pthread_spin_destroy; pthread_spin_init; pthread_spin_lock;
+    pthread_spin_trylock; pthread_spin_unlock;
+  }
+}
Index: glibc-2.21/libpthread/shlib-versions
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/shlib-versions
@@ -0,0 +1 @@
+.*-.*-.*	libpthread=0.3
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/barrier-attr.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/barrier-attr.h
@@ -0,0 +1,32 @@
+/* Thread barrier attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_BARRIER_ATTR_H
+#define _BITS_BARRIER_ATTR_H	1
+
+enum __pthread_process_shared;
+
+/* This structure describes the attributes of a POSIX thread barrier.
+   Note that not all of them are supported on all systems.  */
+struct __pthread_barrierattr
+{
+  enum __pthread_process_shared __pshared;
+};
+
+#endif /* bits/barrier-attr.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/barrier.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/barrier.h
@@ -0,0 +1,39 @@
+/* Thread barrier attribute type.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_BARRIER_H
+#define _BITS_BARRIER_H	1
+
+#include <bits/spin-lock.h>
+
+/* This structure describes the attributes of a POSIX barrier.  */
+struct __pthread_barrier
+{
+  __pthread_spinlock_t __lock;
+  struct __pthread *__queue; /* List of waiters.  */
+  unsigned __pending;	/* Number of that still need to wait on
+			   barrier.  */
+  unsigned __count;	/* Number of threads that must wait before
+			   barrier is passed.  */
+  struct __pthread_barrierattr *__attr;
+  void *__data;
+};
+
+
+#endif /* bits/barrier.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/cancelation.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/cancelation.h
@@ -0,0 +1,51 @@
+/* Cancelation.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_CANCELATION_H
+#define _BITS_CANCELATION_H	1
+
+struct __pthread_cancelation_handler
+{
+  void (*__handler)(void *);
+  void *__arg;
+  struct __pthread_cancelation_handler *__next;
+};
+
+/* Returns the thread local location of the cleanup handler stack.  */
+struct __pthread_cancelation_handler **__pthread_get_cleanup_stack (void);
+
+#define __pthread_cleanup_push(rt, rtarg) \
+	{ \
+	  struct __pthread_cancelation_handler **__handlers \
+	    = __pthread_get_cleanup_stack (); \
+	  struct __pthread_cancelation_handler __handler = \
+	    { \
+	      (rt), \
+	      (rtarg), \
+	      *__handlers \
+	    }; \
+	  *__handlers = &__handler;
+	  
+#define __pthread_cleanup_pop(execute) \
+	  if (execute) \
+	    __handler.__handler (__handler.__arg); \
+	  *__handlers = __handler.__next; \
+	}
+
+#endif /* _BITS_CANCELATION_H */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/condition-attr.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/condition-attr.h
@@ -0,0 +1,34 @@
+/* Condition attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_CONDITION_ATTR_H
+#define _BITS_CONDITION_ATTR_H	1
+
+#include <bits/types.h>
+
+enum __pthread_process_shared;
+
+/* User visible part of a condition attribute variable.  */
+struct __pthread_condattr
+  {
+    enum __pthread_process_shared __pshared;
+    __clockid_t __clock;
+  };
+
+#endif /* bits/condition.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/condition.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/condition.h
@@ -0,0 +1,39 @@
+/* Condition type.  Generic version.
+   Copyright (C) 2000, 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_CONDITION_H
+#define _BITS_CONDITION_H	1
+
+#include <bits/spin-lock.h>
+
+/* User visible part of a condition variable.  */
+struct __pthread_cond
+  {
+    __pthread_spinlock_t __lock;
+    struct __pthread *__queue;
+    struct __pthread_condattr *__attr;
+    struct __pthread_condimpl *__impl;
+    void *__data;
+  };
+
+/* Initializer for a condition variable.  */
+#define __PTHREAD_COND_INITIALIZER \
+  { __PTHREAD_SPIN_LOCK_INITIALIZER, NULL, NULL, NULL, NULL }
+
+#endif /* bits/condition.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/mutex-attr.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/mutex-attr.h
@@ -0,0 +1,41 @@
+/* Mutex attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_MUTEX_ATTR_H
+#define _BITS_MUTEX_ATTR_H	1
+
+enum __pthread_mutex_protocol;
+enum __pthread_process_shared;
+enum __pthread_mutex_type;
+
+/* This structure describes the attributes of a POSIX mutex
+   attribute.  */
+struct __pthread_mutexattr
+{
+  int __prioceiling;
+  enum __pthread_mutex_protocol __protocol;
+  enum __pthread_process_shared __pshared;
+  enum __pthread_mutex_type __mutex_type;
+};
+
+/* Attributes for a recursive mutex.  */
+extern const struct __pthread_mutexattr __pthread_errorcheck_mutexattr;
+extern const struct __pthread_mutexattr __pthread_recursive_mutexattr;
+
+#endif /* bits/mutex-attr.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/mutex.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/mutex.h
@@ -0,0 +1,75 @@
+/* Mutex type.  Generic version.
+
+   Copyright (C) 2000, 2002, 2005, 2006, 2007, 2008, 2009
+     Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_MUTEX_H
+
+#ifndef __need_pthread_mutex
+# define _BITS_MUTEX_H	1
+#endif
+
+#ifndef __pthread_mutex_defined
+# if defined __need_pthread_mutex || defined _BITS_MUTEX_H
+#  undef __need_pthread_mutex
+#  define __pthread_mutex_defined
+
+#  include <bits/spin-lock.h>
+#  include <bits/mutex-attr.h>
+
+/* User visible part of a mutex.  */
+struct __pthread_mutex
+  {
+    __pthread_spinlock_t __held;
+    __pthread_spinlock_t __lock;
+    /* In cthreads, mutex_init does not initialized thre third
+       pointer, as such, we cannot rely on its value for anything.  */
+    char *__cthreadscompat1;
+    struct __pthread *__queue;
+    struct __pthread_mutexattr *__attr;
+    void *__data;
+    /*  Up to this point, we are completely compatible with cthreads
+	and what libc expects.  */
+    void *__owner;
+    unsigned __locks;
+    /* If NULL then the default attributes apply.  */
+  };
+
+/* Initializer for a mutex.  N.B.  this also happens to be compatible
+   with the cthread mutex initializer.  */
+#  define __PTHREAD_MUTEX_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0, 0, 0, 0, 0 }
+
+#  define __PTHREAD_ERRORCHECK_MUTEXATTR ((struct __pthread_mutexattr *) ((unsigned long) __PTHREAD_MUTEX_ERRORCHECK + 1))
+
+#  define __PTHREAD_ERRORCHECK_MUTEX_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0,	\
+	__PTHREAD_ERRORCHECK_MUTEXATTR, 0, 0, 0 }
+
+#  define __PTHREAD_RECURSIVE_MUTEXATTR ((struct __pthread_mutexattr *) ((unsigned long) __PTHREAD_MUTEX_RECURSIVE + 1))
+
+#  define __PTHREAD_RECURSIVE_MUTEX_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0,	\
+	__PTHREAD_RECURSIVE_MUTEXATTR, 0, 0, 0 }
+
+# endif
+#endif /* Not __pthread_mutex_defined.  */
+
+#endif /* bits/mutex.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/once.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/once.h
@@ -0,0 +1,34 @@
+/* Dynamic package initialization data structures.  Generic version.
+   Copyright (C) 2002, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_ONCE_H
+#define _BITS_ONCE_H	1
+
+#include <bits/spin-lock.h>
+
+struct __pthread_once
+{
+  int __run;
+  __pthread_spinlock_t __lock;
+};
+
+#define __PTHREAD_ONCE_INIT \
+	{ 0, __PTHREAD_SPIN_LOCK_INITIALIZER }
+
+#endif /* bits/once.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/pthread.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/pthread.h
@@ -0,0 +1,38 @@
+/* Pthread data structures.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_PTHREAD_H
+#define _BITS_PTHREAD_H	1
+
+typedef int __pthread_t;
+
+/* Return true if __T1 and __T2 both name the same thread.  Otherwise,
+   false.  */
+extern int
+__pthread_equal (__pthread_t __t1, __pthread_t __t2);
+
+#ifdef __USE_EXTERN_INLINES
+__extern_inline int
+__pthread_equal (__pthread_t __t1, __pthread_t __t2)
+{
+  return __t1 == __t2;
+}
+#endif
+
+#endif /* bits/pthread.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/pthread-np.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/pthread-np.h
@@ -0,0 +1,27 @@
+/* Non-portable functions. Generic version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Never include this file directly; use <pthread.h> or <cthreads.h> instead.
+ */
+
+#ifndef _BITS_PTHREAD_NP_H
+#define _BITS_PTHREAD_NP_H	1
+
+#endif /* bits/pthread-np.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/pthreadtypes.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/pthreadtypes.h
@@ -0,0 +1,29 @@
+/* 
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#if !defined _BITS_TYPES_H && !defined _PTHREAD_H
+# error "Never include <bits/pthreadtypes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H    1
+
+#include <pthread/pthreadtypes.h>
+
+#endif /* bits/pthreadtypes.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/rwlock-attr.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/rwlock-attr.h
@@ -0,0 +1,32 @@
+/* Thread rwlock attribute type.  Generic version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_RWLOCK_ATTR_H
+#define _BITS_RWLOCK_ATTR_H	1
+
+enum __pthread_process_shared;
+
+/* This structure describes the attributes of a POSIX thread rwlock.
+   Note that not all of them are supported on all systems.  */
+struct __pthread_rwlockattr
+{
+  enum __pthread_process_shared __pshared;
+};
+
+#endif /* bits/rwlock-attr.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/rwlock.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/rwlock.h
@@ -0,0 +1,46 @@
+/* rwlock type.  Generic version.
+   Copyright (C) 2002, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_RWLOCK_H
+#define _BITS_RWLOCK_H
+
+#include <bits/spin-lock.h>
+
+/* User visible part of a rwlock.  If __held is not held and readers
+   is 0, then the lock is unlocked.  If __held is held and readers is
+   0, then the lock is held by a writer.  If __held is held and
+   readers is greater than 0, then the lock is held by READERS
+   readers.  */
+struct __pthread_rwlock
+  {
+    __pthread_spinlock_t __held;
+    __pthread_spinlock_t __lock;
+    int __readers;
+    struct __pthread *__readerqueue;
+    struct __pthread *__writerqueue;
+    struct __pthread_rwlockattr *__attr;
+    void *__data;
+  };
+
+/* Initializer for a rwlock.  */
+#define __PTHREAD_RWLOCK_INITIALIZER \
+    { __PTHREAD_SPIN_LOCK_INITIALIZER, __PTHREAD_SPIN_LOCK_INITIALIZER, 0, 0, 0, 0, 0 }
+
+
+#endif /* bits/rwlock.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/semaphore.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/semaphore.h
@@ -0,0 +1,43 @@
+/* Semaphore type.  Generic version.
+   Copyright (C) 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_SEMAPHORE_H
+#define _BITS_SEMAPHORE_H	1
+
+#ifndef _SEMAPHORE_H
+#error Never include <bits/semaphore.h> directly.
+#endif
+
+#include <pthread.h>
+
+/* User visible part of a semaphore.  */
+struct __semaphore
+  {
+    __pthread_spinlock_t __lock;
+    struct __pthread *__queue;
+    int __pshared;
+    int __value;
+    void *__data;
+  };
+
+/* Initializer for a semaphore.  */
+#define __SEMAPHORE_INITIALIZER(pshared, value) \
+  { __PTHREAD_SPIN_LOCK_INITIALIZER, NULL, (pshared), (value), NULL }
+
+#endif /* bits/mutex.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/thread-attr.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/thread-attr.h
@@ -0,0 +1,47 @@
+/* Thread attribute type.  Generic version.
+   Copyright (C) 2000, 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_THREAD_ATTR_H
+#define _BITS_THREAD_ATTR_H	1
+
+#define __need_schedparam
+#include <bits/sched.h>
+
+#define __need_size_t
+#include <stddef.h>
+
+enum __pthread_detachstate;
+enum __pthread_inheritsched;
+enum __pthread_contentionscope;
+
+/* This structure describes the attributes of a POSIX thread.  Note
+   that not all of them are supported on all systems.  */
+struct __pthread_attr
+{
+  struct __sched_param __schedparam;
+  void *__stackaddr;
+  size_t __stacksize;
+  size_t __guardsize;
+  enum __pthread_detachstate __detachstate;
+  enum __pthread_inheritsched __inheritsched;
+  enum __pthread_contentionscope __contentionscope;
+  int __schedpolicy;
+};
+
+#endif /* bits/thread-attr.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/thread-specific.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/thread-specific.h
@@ -0,0 +1,25 @@
+/* Thread specific data.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_THREAD_SPECIFIC_H
+#define _BITS_THREAD_SPECIFIC_H	1
+
+typedef int __pthread_key;
+
+#endif /* bits/thread-specific.h */
Index: glibc-2.21/libpthread/sysdeps/generic/killpg.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/killpg.c
@@ -0,0 +1,27 @@
+/* killpg.c - Generic killpg implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+killpg (pid_t pid, int sig)
+{
+  return kill (-pid, sig);
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-atfork.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-atfork.c
@@ -0,0 +1,29 @@
+/* Register fork handlers.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_atfork (void (*prepare) (void),
+		void (*parent) (void),
+		void (*child) (void))
+{
+  return __register_atfork (prepare, parent, child);
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr.c
@@ -0,0 +1,41 @@
+/* Default attributes.  Generic version.
+   Copyright (C) 2000,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <sched.h>
+#include <stddef.h>
+#include <limits.h>
+
+#include <pt-internal.h>
+
+const struct __pthread_attr __pthread_default_attr =
+{
+  __schedparam: { sched_priority: 0 },
+  __stacksize: 0,
+  __stackaddr: NULL,
+#ifdef PAGESIZE
+  __guardsize: PAGESIZE,
+#else
+  __guardsize: 1,
+#endif /* PAGESIZE */
+  __detachstate: PTHREAD_CREATE_JOINABLE,
+  __inheritsched: PTHREAD_EXPLICIT_SCHED,
+  __contentionscope: PTHREAD_SCOPE_SYSTEM,
+  __schedpolicy: SCHED_OTHER
+};
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-destroy.c
@@ -0,0 +1,28 @@
+/* pthread_attr_destroy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_destroy (pthread_attr_t *attr)
+{
+  return 0;
+}
+strong_alias (__pthread_attr_destroy, pthread_attr_destroy);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getdetachstate.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getdetachstate.c
@@ -0,0 +1,31 @@
+/* pthread_attr_getdetachstate.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_getdetachstate (const pthread_attr_t *attr,
+			     int *detachstate)
+{
+  *detachstate = attr->__detachstate;
+  return 0;
+}
+
+strong_alias (__pthread_attr_getdetachstate, pthread_attr_getdetachstate);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getguardsize.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getguardsize.c
@@ -0,0 +1,29 @@
+/* pthread_attr_getguardsize.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_getguardsize (const pthread_attr_t *attr,
+			   size_t *guardsize)
+{
+  *guardsize = attr->__guardsize;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getinheritsched.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getinheritsched.c
@@ -0,0 +1,31 @@
+/* pthread_attr_getinheritsched.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_getinheritsched (const pthread_attr_t *attr,
+			      int *inheritsched)
+{
+  *inheritsched = attr->__inheritsched;
+  return 0;
+}
+
+strong_alias (__pthread_attr_getinheritsched, pthread_attr_getinheritsched);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getschedparam.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getschedparam.c
@@ -0,0 +1,34 @@
+/* pthread_attr_getschedparam.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <sched.h>
+#include <string.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_attr_getschedparam (const pthread_attr_t *attr,
+			    struct sched_param *param)
+{
+  memcpy (param, &attr->__schedparam, sizeof *param);
+  return 0;
+}
+
+strong_alias (__pthread_attr_getschedparam, pthread_attr_getschedparam);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getschedpolicy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getschedpolicy.c
@@ -0,0 +1,31 @@
+/* pthread_attr_getschedpolicy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_getschedpolicy (const pthread_attr_t *attr,
+			     int *policy)
+{
+  *policy = attr->__schedpolicy;
+  return 0;
+}
+
+strong_alias (__pthread_attr_getschedpolicy, pthread_attr_getschedpolicy);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getscope.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getscope.c
@@ -0,0 +1,31 @@
+/* pthread_attr_getscope.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_getscope (const pthread_attr_t *attr,
+		       int *contentionscope)
+{
+  *contentionscope = attr->__contentionscope;
+  return 0;
+}
+
+strong_alias (__pthread_attr_getscope, pthread_attr_getscope);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getstackaddr.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getstackaddr.c
@@ -0,0 +1,29 @@
+/* pthread_attr_getstackaddr.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_getstackaddr (const pthread_attr_t *attr,
+			   void **stackaddr)
+{
+  *stackaddr = attr->__stackaddr;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getstack.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getstack.c
@@ -0,0 +1,31 @@
+/* pthread_attr_getstack.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_getstack (const pthread_attr_t *attr,
+		       void **stackaddr,
+		       size_t *stacksize)
+{
+  pthread_attr_getstackaddr (attr, stackaddr);
+  pthread_attr_getstacksize (attr, stacksize);
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-getstacksize.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-getstacksize.c
@@ -0,0 +1,29 @@
+/* pthread_attr_getstacksize.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_getstacksize (const pthread_attr_t *attr,
+			   size_t *stacksize)
+{
+  *stacksize = attr->__stacksize;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-init.c
@@ -0,0 +1,29 @@
+/* pthread_attr_init.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_init (pthread_attr_t *attr)
+{
+  *attr = __pthread_default_attr;
+  return 0;
+}
+strong_alias (__pthread_attr_init, pthread_attr_init);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setdetachstate.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setdetachstate.c
@@ -0,0 +1,40 @@
+/* pthread_attr_setdetachstate.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_setdetachstate (pthread_attr_t *attr,
+			     int detachstate)
+{
+  switch (detachstate)
+    {
+    case PTHREAD_CREATE_DETACHED:
+    case PTHREAD_CREATE_JOINABLE:
+      attr->__detachstate = detachstate;
+      break;
+    default:
+      return EINVAL;
+    }
+
+  return 0;
+}
+
+strong_alias (__pthread_attr_setdetachstate, pthread_attr_setdetachstate);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setguardsize.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setguardsize.c
@@ -0,0 +1,29 @@
+/* pthread_attr_setguardsize.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_setguardsize (pthread_attr_t *attr,
+			   size_t guardsize)
+{
+  attr->__guardsize = guardsize;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setinheritsched.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setinheritsched.c
@@ -0,0 +1,40 @@
+/* pthread_attr_setinheritsched.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_setinheritsched (pthread_attr_t *attr,
+			      int inheritsched)
+{
+  switch (inheritsched)
+    {
+    case PTHREAD_INHERIT_SCHED:
+    case PTHREAD_EXPLICIT_SCHED:
+      attr->__inheritsched = inheritsched;
+      break;
+    default:
+      return EINVAL;
+    }
+
+  return 0;
+}
+
+strong_alias (__pthread_attr_setinheritsched, pthread_attr_setinheritsched);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setschedparam.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setschedparam.c
@@ -0,0 +1,40 @@
+/* pthread_attr_getschedparam.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <sched.h>
+#include <string.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_attr_setschedparam (pthread_attr_t *attr,
+			    const struct sched_param *param)
+{
+  if (memcmp (param, &__pthread_default_attr.__schedparam,
+	      sizeof *param) == 0)
+    {
+      memcpy (&attr->__schedparam, param, sizeof *param);
+      return 0;
+    }
+
+  return ENOTSUP;
+}
+
+strong_alias (__pthread_attr_setschedparam, pthread_attr_setschedparam);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setschedpolicy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setschedpolicy.c
@@ -0,0 +1,44 @@
+/* pthread_attr_getschedpolicy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_setschedpolicy (pthread_attr_t *attr,
+			     int policy)
+{
+  switch (policy)
+    {
+    case SCHED_OTHER:
+      attr->__schedpolicy = policy;
+      break;
+
+    case SCHED_FIFO:
+    case SCHED_RR:
+      return ENOTSUP;
+
+    default:
+      return EINVAL;
+    }
+
+  return 0;
+}
+
+strong_alias (__pthread_attr_setschedpolicy, pthread_attr_setschedpolicy);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setscope.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setscope.c
@@ -0,0 +1,43 @@
+/* pthread_attr_setscope.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_attr_setscope (pthread_attr_t *attr,
+		       int contentionscope)
+{
+  if (contentionscope == __pthread_default_attr.__contentionscope)
+    {
+      attr->__contentionscope = contentionscope;
+      return 0;
+    }
+
+  switch (contentionscope)
+    {
+    case PTHREAD_SCOPE_PROCESS:
+    case PTHREAD_SCOPE_SYSTEM:
+      return ENOTSUP;
+    default:
+      return EINVAL;
+    }
+}
+
+strong_alias (__pthread_attr_setscope, pthread_attr_setscope);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setstackaddr.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setstackaddr.c
@@ -0,0 +1,29 @@
+/* pthread_attr_setstackaddr.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_setstackaddr (pthread_attr_t *attr,
+			   void *stackaddr)
+{
+  attr->__stackaddr = stackaddr;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setstack.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setstack.c
@@ -0,0 +1,51 @@
+/* pthread_attr_setstack.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+pthread_attr_setstack (pthread_attr_t *attr,
+		       void *stackaddr,
+		       size_t stacksize)
+{
+  int err;
+  size_t s;
+
+  /* pthread_attr_setstack should always succeed, thus we set the size
+     first as it is more discriminating.  */
+  pthread_attr_getstacksize (attr, &s);
+
+  err = pthread_attr_setstacksize (attr, stacksize);
+  if (err)
+    return err;
+
+  err = pthread_attr_setstackaddr (attr, stackaddr);
+  if (err)
+    {
+      int e = pthread_attr_setstacksize (attr, s);
+      assert_perror (e);
+
+      return err;
+    }
+      
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-attr-setstacksize.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-attr-setstacksize.c
@@ -0,0 +1,30 @@
+/* pthread_attr_setstacksize.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_setstacksize (pthread_attr_t *attr,
+			   size_t stacksize)
+{
+  attr->__stacksize = stacksize;
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-destroy.c
@@ -0,0 +1,27 @@
+/* pthread_barrierattr_destroy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_barrierattr_destroy (pthread_barrierattr_t *attr)
+{
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-getpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-getpshared.c
@@ -0,0 +1,29 @@
+/* pthread_barrierattr_getpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_barrierattr_getpshared (const pthread_barrierattr_t *attr,
+				int *pshared)
+{
+  *pshared = attr->__pshared;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-init.c
@@ -0,0 +1,28 @@
+/* pthread_barrierattr_init.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_barrierattr_init (pthread_barrierattr_t *attr)
+{
+  *attr = __pthread_default_barrierattr;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-setpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrierattr-setpshared.c
@@ -0,0 +1,39 @@
+/* pthread_barrierattr_setpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_barrierattr_setpshared (pthread_barrierattr_t *attr,
+				int pshared)
+{
+  switch (pshared)
+    {
+    case PTHREAD_PROCESS_PRIVATE:
+      attr->__pshared = pshared;
+      return 0;
+
+    case PTHREAD_PROCESS_SHARED:
+      return ENOTSUP;
+
+    default:
+      return EINVAL;
+    }
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrier.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrier.c
@@ -0,0 +1,26 @@
+/* Default barrier attributes.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+const struct __pthread_barrierattr __pthread_default_barrierattr =
+{
+  __pshared: PTHREAD_PROCESS_PRIVATE
+};
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrier-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrier-destroy.c
@@ -0,0 +1,27 @@
+/* pthread_barrier_destroy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_barrier_destroy (pthread_barrier_t *barrier)
+{
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrier-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrier-init.c
@@ -0,0 +1,53 @@
+/* pthread_barrier_init.  Generic version.
+   Copyright (C) 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <string.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+pthread_barrier_init (pthread_barrier_t *barrier,
+		      const pthread_barrierattr_t *attr,
+		      unsigned count)
+{
+  if (count == 0)
+    return EINVAL;
+
+  memset (barrier, 0, sizeof *barrier);
+
+  barrier->__lock = PTHREAD_SPINLOCK_INITIALIZER;
+  barrier->__pending = count;
+  barrier->__count = count;
+
+  if (! attr
+      || memcmp (attr, &__pthread_default_barrierattr, sizeof (*attr) == 0))
+    /* Use the default attributes.  */
+    return 0;
+
+  /* Non-default attributes.  */
+
+  barrier->__attr = malloc (sizeof *attr);
+  if (! barrier->__attr)
+    return ENOMEM;
+
+  *barrier->__attr = *attr;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-barrier-wait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-barrier-wait.c
@@ -0,0 +1,69 @@
+/* pthread_barrier_wait.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+pthread_barrier_wait (pthread_barrier_t *barrier)
+{
+  __pthread_spin_lock (&barrier->__lock);
+  if (-- barrier->__pending == 0)
+    {
+      barrier->__pending = barrier->__count;
+
+      if (barrier->__count > 1)
+	{
+	  struct __pthread *wakeup;
+	  unsigned n = 0;
+
+	  __pthread_queue_iterate (barrier->__queue, wakeup)
+	    n ++;
+
+	  {
+	    struct __pthread *wakeups[n];
+	    unsigned i = 0;
+
+	    __pthread_dequeuing_iterate (barrier->__queue, wakeup)
+	      wakeups[i ++] = wakeup;
+
+	    barrier->__queue = NULL;
+	    __pthread_spin_unlock (&barrier->__lock);
+
+	    for (i = 0; i < n; i ++)
+	      __pthread_wakeup (wakeups[i]);
+	  }
+	}
+
+      return PTHREAD_BARRIER_SERIAL_THREAD;
+    }
+  else
+    {
+      struct __pthread *self = _pthread_self ();
+
+      /* Add ourselves to the list of waiters.  */
+      __pthread_enqueue (&barrier->__queue, self);
+      __pthread_spin_unlock (&barrier->__lock);
+
+      __pthread_block (self);
+      return 0;
+    }
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-condattr-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-condattr-destroy.c
@@ -0,0 +1,29 @@
+/* pthread_condattr_destroy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_condattr_destroy (pthread_condattr_t *cond)
+{
+  return 0;
+}
+
+strong_alias (__pthread_condattr_destroy, pthread_condattr_destroy);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-condattr-getclock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-condattr-getclock.c
@@ -0,0 +1,31 @@
+/* pthread_condattr_getclock.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <time.h>
+
+#include <pt-internal.h>
+
+int
+pthread_condattr_getclock (const pthread_condattr_t *attr,
+			   clockid_t *clock)
+{
+  *clock = attr->__clock;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-condattr-getpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-condattr-getpshared.c
@@ -0,0 +1,29 @@
+/* pthread_condattr_getpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_condattr_getpshared (const pthread_condattr_t *attr,
+			     int *pshared)
+{
+  *pshared = attr->__pshared;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-condattr-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-condattr-init.c
@@ -0,0 +1,30 @@
+/* pthread_condattr_init.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_condattr_init (pthread_condattr_t *attr)
+{
+  *attr = __pthread_default_condattr;
+  return 0;
+}
+
+strong_alias (__pthread_condattr_init, pthread_condattr_init);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-condattr-setclock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-condattr-setclock.c
@@ -0,0 +1,52 @@
+/* pthread_condattr_setclock.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_condattr_setclock (pthread_condattr_t *attr, clockid_t clock)
+{
+  /* Only a few clocks are allowed.  CLOCK_REALTIME is always allowed.
+     CLOCK_MONOTONIC only if the kernel has the necessary support.  */
+  if (clock == CLOCK_MONOTONIC)
+    {
+      /* Check whether the clock is available.  */
+      static int avail;
+
+      if (avail == 0)
+	{
+	  struct timespec ts;
+	  int res;
+
+	  res = clock_gettime (CLOCK_MONOTONIC, &ts);
+	  avail = res < 0 ? -1 : 1;
+	}
+
+      if (avail < 0)
+	/* Not available.  */
+	return EINVAL;
+    }
+  else if (clock != CLOCK_REALTIME)
+    return EINVAL;
+
+  attr->__clock = clock;
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-condattr-setpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-condattr-setpshared.c
@@ -0,0 +1,39 @@
+/* pthread_condattr_setpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_condattr_setpshared (pthread_condattr_t *attr,
+			     int pshared)
+{
+  switch (pshared)
+    {
+    case PTHREAD_PROCESS_PRIVATE:
+      attr->__pshared = pshared;
+      return 0;
+
+    case PTHREAD_PROCESS_SHARED:
+      return ENOTSUP;
+
+    default:
+      return EINVAL;
+    }
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-cond-brdcast.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-cond-brdcast.c
@@ -0,0 +1,45 @@
+/* Broadcast a condition.  Generic version.
+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+/* Unblock all threads that are blocked on condition variable COND.  */
+int
+__pthread_cond_broadcast (pthread_cond_t *cond)
+{
+  struct __pthread *wakeup;
+
+  __pthread_spin_lock (&cond->__lock);
+  while ((wakeup = cond->__queue))
+    {
+      __pthread_dequeue (wakeup);
+      __pthread_spin_unlock (&cond->__lock);
+      /* Wake it up without spin held, so it may have a chance to really
+        preempt us */
+      __pthread_wakeup (wakeup);
+      __pthread_spin_lock (&cond->__lock);
+    }
+  __pthread_spin_unlock (&cond->__lock);
+
+  return 0;
+}
+
+strong_alias (__pthread_cond_broadcast, pthread_cond_broadcast);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-cond.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-cond.c
@@ -0,0 +1,29 @@
+/* Default condition attributes.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <time.h>
+
+#include <pt-internal.h>
+
+const struct __pthread_condattr __pthread_default_condattr =
+{
+  __pshared: PTHREAD_PROCESS_PRIVATE,
+  __clock: CLOCK_REALTIME
+};
Index: glibc-2.21/libpthread/sysdeps/generic/pt-cond-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-cond-destroy.c
@@ -0,0 +1,29 @@
+/* pthread_cond_destroy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_cond_destroy (pthread_cond_t *cond)
+{
+  return 0;
+}
+
+strong_alias (__pthread_cond_destroy, pthread_cond_destroy);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-cond-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-cond-init.c
@@ -0,0 +1,47 @@
+/* pthread_cond_init.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+#include <string.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_cond_init (pthread_cond_t *cond,
+		   const pthread_condattr_t *attr)
+{
+  *cond = (pthread_cond_t) __PTHREAD_COND_INITIALIZER;
+
+  if (! attr
+      || memcmp (attr, &__pthread_default_condattr, sizeof (*attr) == 0))
+    /* Use the default attributes.  */
+    return 0;
+
+  /* Non-default attributes.  */
+
+  cond->__attr = malloc (sizeof *attr);
+  if (! cond->__attr)
+    return ENOMEM;
+
+  *cond->__attr = *attr;
+  return 0;
+}
+
+strong_alias (__pthread_cond_init, pthread_cond_init);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-cond-signal.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-cond-signal.c
@@ -0,0 +1,43 @@
+/* Signal a condition.  Generic version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+/* Unblock at least one of the threads that are blocked on condition
+   variable COND.  */
+int
+__pthread_cond_signal (pthread_cond_t *cond)
+{
+  struct __pthread *wakeup;
+  
+  __pthread_spin_lock (&cond->__lock);
+  wakeup = cond->__queue;
+  if (wakeup)
+    __pthread_dequeue (wakeup);
+  __pthread_spin_unlock (&cond->__lock);
+
+  if (wakeup)
+    __pthread_wakeup (wakeup);
+
+  return 0;
+}
+
+strong_alias (__pthread_cond_signal, pthread_cond_signal);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-cond-timedwait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-cond-timedwait.c
@@ -0,0 +1,178 @@
+/* Wait on a condition.  Generic version.
+   Copyright (C) 2000, 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+extern int __pthread_cond_timedwait_internal (pthread_cond_t *cond,
+					      pthread_mutex_t *mutex,
+					      const struct timespec *abstime);
+
+int
+__pthread_cond_timedwait (pthread_cond_t *cond,
+			pthread_mutex_t *mutex,
+			const struct timespec *abstime)
+{
+  return __pthread_cond_timedwait_internal (cond, mutex, abstime);
+}
+
+strong_alias (__pthread_cond_timedwait, pthread_cond_timedwait);
+
+struct cancel_ctx
+  {
+    struct __pthread *wakeup;
+    pthread_cond_t *cond;
+  };
+
+static void
+cancel_hook (void *arg)
+{
+  struct cancel_ctx *ctx = arg;
+  struct __pthread *wakeup = ctx->wakeup;
+  pthread_cond_t *cond = ctx->cond;
+  int unblock;
+
+  __pthread_spin_lock (&cond->__lock);
+  /* The thread only needs to be awaken if it's blocking or about to block.
+     If it was already unblocked, it's not queued any more.  */
+  unblock = wakeup->prevp != NULL;
+  if (unblock)
+    __pthread_dequeue (wakeup);
+  __pthread_spin_unlock (&cond->__lock);
+
+  if (unblock)
+    __pthread_wakeup (wakeup);
+}
+
+/* Block on condition variable COND until ABSTIME.  As a GNU
+   extension, if ABSTIME is NULL, then wait forever.  MUTEX should be
+   held by the calling thread.  On return, MUTEX will be held by the
+   calling thread.  */
+int
+__pthread_cond_timedwait_internal (pthread_cond_t *cond,
+				   pthread_mutex_t *mutex,
+				   const struct timespec *abstime)
+{
+  error_t err;
+  int cancelled, oldtype, drain;
+  clockid_t clock_id = __pthread_default_condattr.__clock;
+
+  if (abstime && (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000))
+    return EINVAL;
+
+  struct __pthread *self = _pthread_self ();
+  struct cancel_ctx ctx;
+  ctx.wakeup= self;
+  ctx.cond = cond;
+
+  /* Test for a pending cancellation request, switch to deferred mode for
+     safer resource handling, and prepare the hook to call in case we're
+     cancelled while blocking.  Once CANCEL_LOCK is released, the cancellation
+     hook can be called by another thread at any time.  Whatever happens,
+     this function must exit with MUTEX locked.
+
+     This function contains inline implementations of pthread_testcancel and
+     pthread_setcanceltype to reduce locking overhead.  */
+  __pthread_mutex_lock (&self->cancel_lock);
+  cancelled = (self->cancel_state == PTHREAD_CANCEL_ENABLE)
+	      && self->cancel_pending;
+
+  if (! cancelled)
+    {
+      self->cancel_hook = cancel_hook;
+      self->cancel_hook_arg = &ctx;
+      oldtype = self->cancel_type;
+
+      if (oldtype != PTHREAD_CANCEL_DEFERRED)
+	self->cancel_type = PTHREAD_CANCEL_DEFERRED;
+
+      /* Add ourselves to the list of waiters.  This is done while setting
+	 the cancellation hook to simplify the cancellation procedure, i.e.
+	 if the thread is queued, it can be cancelled, otherwise it is
+	 already unblocked, progressing on the return path.  */
+      __pthread_spin_lock (&cond->__lock);
+      __pthread_enqueue (&cond->__queue, self);
+      if (cond->__attr)
+	clock_id = cond->__attr->__clock;
+      __pthread_spin_unlock (&cond->__lock);
+    }
+  __pthread_mutex_unlock (&self->cancel_lock);
+
+  if (cancelled)
+    pthread_exit (PTHREAD_CANCELED);
+
+  /* Release MUTEX before blocking.  */
+  __pthread_mutex_unlock (mutex);
+
+  /* Block the thread.  */
+  if (abstime)
+    err = __pthread_timedblock (self, abstime, clock_id);
+  else
+    {
+      err = 0;
+      __pthread_block (self);
+    }
+
+  __pthread_spin_lock (&cond->__lock);
+  if (! self->prevp)
+    {
+      /* Another thread removed us from the list of waiters, which means a
+	 wakeup message has been sent.  It was either consumed while we were
+	 blocking, or queued after we timed out and before we acquired the
+	 condition lock, in which case the message queue must be drained.  */
+      if (! err)
+	drain = 0;
+      else
+	{
+	  assert (err == ETIMEDOUT);
+	  drain = 1;
+	}
+    }
+  else
+    {
+      /* We're still in the list of waiters.  Noone attempted to wake us up,
+	 i.e. we timed out.  */
+      assert (err == ETIMEDOUT);
+      __pthread_dequeue (self);
+      drain = 0;
+    }
+  __pthread_spin_unlock (&cond->__lock);
+
+  if (drain)
+    __pthread_block (self);
+
+  /* We're almost done.  Remove the unblock hook, restore the previous
+     cancellation type, and check for a pending cancellation request.  */
+  __pthread_mutex_lock (&self->cancel_lock);
+  self->cancel_hook = NULL;
+  self->cancel_hook_arg = NULL;
+  self->cancel_type = oldtype;
+  cancelled = (self->cancel_state == PTHREAD_CANCEL_ENABLE)
+	      && self->cancel_pending;
+  __pthread_mutex_unlock (&self->cancel_lock);
+
+  /* Reacquire MUTEX before returning/cancelling.  */
+  __pthread_mutex_lock (mutex);
+
+  if (cancelled)
+    pthread_exit (PTHREAD_CANCELED);
+
+  return err;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-cond-wait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-cond-wait.c
@@ -0,0 +1,39 @@
+/* Wait on a condition.  Generic version.
+   Copyright (C) 2000,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+/* Implemented in pt-cond-timedwait.c.  */
+extern int __pthread_cond_timedwait_internal (pthread_cond_t *cond,
+					      pthread_mutex_t *mutex,
+					      const struct timespec *abstime);
+
+
+/* Block on condition variable COND.  MUTEX should be held by the
+   calling thread.  On return, MUTEX will be held by the calling
+   thread.  */
+int
+__pthread_cond_wait (pthread_cond_t *cond, pthread_mutex_t *mutex)
+{
+  return __pthread_cond_timedwait_internal (cond, mutex, 0);
+}
+
+strong_alias (__pthread_cond_wait, pthread_cond_wait);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-destroy-specific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-destroy-specific.c
@@ -0,0 +1,28 @@
+/* __pthread_destory_specific.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+void
+__pthread_destory_specifc (struct __pthread *thread)
+{
+  /* Not support, thus there cannot be any.  */
+  return;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-equal.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-equal.c
@@ -0,0 +1,31 @@
+/* Default attributes.  Generic version.
+   Copyright (C) 2000,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+/* Return true if __T1 and __T2 both name the same thread.  Otherwise,
+   false.  */
+int
+__pthread_equal (pthread_t __t1, pthread_t __t2)
+{
+  return __t1 == __t2;
+}
+
+strong_alias (__pthread_equal, pthread_equal);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-getconcurrency.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-getconcurrency.c
@@ -0,0 +1,27 @@
+/* Get the current level of desired concurrency.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_getconcurrency (void)
+{
+  return __pthread_concurrency;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-getcpuclockid.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-getcpuclockid.c
@@ -0,0 +1,35 @@
+/* Return a thread's cpu clockid.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <time.h>
+
+#include <pt-internal.h>
+
+int
+pthread_getcpuclockid (pthread_t thread, clockid_t *clock)
+{
+#ifdef CLOCK_THREAD_CPUTIME_ID
+  *clock = CLOCK_THREAD_CPUTIME_ID;
+  return 0;
+#else
+  return ENOSYS;
+stub_warning (pthread_getcpuclockid)
+#endif
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-getschedparam.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-getschedparam.c
@@ -0,0 +1,31 @@
+/* Get the scheduling parameters for a thread.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_getschedparam (pthread_t thread, int *policy,
+		       struct sched_param *param)
+{
+  return ENOSYS;
+}
+
+strong_alias (__pthread_getschedparam, pthread_getschedparam);
+stub_warning (pthread_getschedparam)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-getspecific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-getspecific.c
@@ -0,0 +1,27 @@
+/* pthread_getspecific.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_getspecific (pthread_key_t key)
+{
+  return EINVAL;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-init-specific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-init-specific.c
@@ -0,0 +1,27 @@
+/* __pthread_init_specific.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+error_t
+__pthread_init_specific (struct __pthread *thread)
+{
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-key-create.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-key-create.c
@@ -0,0 +1,29 @@
+/* pthread_key_create.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_key_create (pthread_key_t *key, void (*destructor) (void *))
+{
+  return ENOSYS;
+}
+
+stub_warning (pthread_key_create)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-key-delete.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-key-delete.c
@@ -0,0 +1,29 @@
+/* pthread_key_delete.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_key_delete (pthread_key_t key)
+{
+  return ENOSYS;
+}
+
+stub_warning (pthread_key_delete)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-key.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-key.h
@@ -0,0 +1,22 @@
+/* pthread_key internal declatations.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#define PTHREAD_KEY_MEMBERS
Index: glibc-2.21/libpthread/sysdeps/generic/pt-kill.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-kill.c
@@ -0,0 +1,32 @@
+/* pthread-kill.c - Generic pthread-kill implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+pthread_kill (pthread_t tid, int signo)
+{
+  siginfo_t si;
+  memset (&si, 0, sizeof (si));
+  si.si_signo = signo;
+
+  return pthread_kill_siginfo_np (tid, si);
+}
+
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr.c
@@ -0,0 +1,45 @@
+/* Default mutex attributes.  Generic version.
+   Copyright (C) 2000, 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+const struct __pthread_mutexattr __pthread_default_mutexattr =
+{
+  __prioceiling: 0,
+  __protocol: PTHREAD_PRIO_NONE,
+  __pshared: PTHREAD_PROCESS_PRIVATE,
+  __mutex_type: PTHREAD_MUTEX_DEFAULT
+};
+
+const struct __pthread_mutexattr __pthread_errorcheck_mutexattr =
+{
+  __prioceiling: 0,
+  __protocol: PTHREAD_PRIO_NONE,
+  __pshared: PTHREAD_PROCESS_PRIVATE,
+  __mutex_type: PTHREAD_MUTEX_ERRORCHECK
+};
+
+const struct __pthread_mutexattr __pthread_recursive_mutexattr =
+{
+  __prioceiling: 0,
+  __protocol: PTHREAD_PRIO_NONE,
+  __pshared: PTHREAD_PROCESS_PRIVATE,
+  __mutex_type: PTHREAD_MUTEX_RECURSIVE
+};
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-destroy.c
@@ -0,0 +1,27 @@
+/* pthread_mutexattr_destroy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_destroy (pthread_mutexattr_t *attr)
+{
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-getprioceiling.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-getprioceiling.c
@@ -0,0 +1,30 @@
+/* pthread_mutexattr_getprioceiling.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *attr,
+				  int *prioceiling)
+{
+  return ENOSYS;
+}
+
+stub_warning (pthread_mutexattr_getprioceiling)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-getprotocol.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-getprotocol.c
@@ -0,0 +1,29 @@
+/* pthread_mutexattr_getprotocol.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_getprotocol (const pthread_mutexattr_t *attr,
+			       int *protocol)
+{
+  *protocol = attr->__protocol;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-getpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-getpshared.c
@@ -0,0 +1,29 @@
+/* pthread_mutexattr_getpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_getpshared (const pthread_mutexattr_t *attr,
+			      int *pshared)
+{
+  *pshared = attr->__pshared;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-gettype.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-gettype.c
@@ -0,0 +1,28 @@
+/* pthread_mutexattr_gettype.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_gettype (const pthread_mutexattr_t *attr, int *type)
+{
+  *type = attr->__mutex_type;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-init.c
@@ -0,0 +1,28 @@
+/* pthread_mutexattr_init.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_init (pthread_mutexattr_t *attr)
+{
+  *attr = __pthread_default_mutexattr;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-setprioceiling.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-setprioceiling.c
@@ -0,0 +1,30 @@
+/* pthread_mutexattr_setprioceiling.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_setprioceiling (pthread_mutexattr_t *attr,
+				  int prioceiling)
+{
+  return ENOSYS;
+}
+
+stub_warning (pthread_mutexattr_setprioceiling)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-setprotocol.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-setprotocol.c
@@ -0,0 +1,42 @@
+/* pthread_mutexattr_setprotocol.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_setprotocol (pthread_mutexattr_t *attr,
+			       int protocol)
+{
+  if (protocol == __pthread_default_mutexattr.__protocol)
+    {
+      attr->__protocol = protocol;
+      return 0;
+    }
+
+  switch (protocol)
+    {
+    case PTHREAD_PRIO_NONE:
+    case PTHREAD_PRIO_INHERIT:
+    case PTHREAD_PRIO_PROTECT:
+      return ENOTSUP;
+    default:
+      return EINVAL;
+    }
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-setpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-setpshared.c
@@ -0,0 +1,39 @@
+/* pthread_mutexattr_setpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_setpshared (pthread_mutexattr_t *attr,
+			      int pshared)
+{
+  switch (pshared)
+    {
+    case PTHREAD_PROCESS_PRIVATE:
+      attr->__pshared = pshared;
+      return 0;
+
+    case PTHREAD_PROCESS_SHARED:
+      return ENOTSUP;
+
+    default:
+      return EINVAL;
+    }
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-settype.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutexattr-settype.c
@@ -0,0 +1,37 @@
+/* pthread_mutexattr_settype.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutexattr_settype (pthread_mutexattr_t *attr, int type)
+{
+  switch (type)
+    {
+    case PTHREAD_MUTEX_NORMAL:
+    case PTHREAD_MUTEX_ERRORCHECK:
+    case PTHREAD_MUTEX_RECURSIVE:
+      attr->__mutex_type = type;
+      return 0;
+
+    default:
+      return EINVAL;
+    }
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-destroy.c
@@ -0,0 +1,39 @@
+/* Destroy a mutex.  Generic version.
+   Copyright (C) 2000, 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+_pthread_mutex_destroy (pthread_mutex_t *mutex)
+{
+  if (mutex->__attr == __PTHREAD_ERRORCHECK_MUTEXATTR
+   || mutex->__attr == __PTHREAD_RECURSIVE_MUTEXATTR)
+    /* Static attributes.  */
+    ;
+  else
+    free (mutex->__attr);
+
+  return 0;
+}
+
+strong_alias (_pthread_mutex_destroy, pthread_mutex_destroy);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-getprioceiling.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-getprioceiling.c
@@ -0,0 +1,30 @@
+/* Get a mutex' priority ceiling.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutex_getprioceiling (const pthread_mutex_t *mutex,
+			      int *prioceiling)
+{
+  return ENOSYS;
+}
+
+stub_warning (pthread_mutex_getprioceiling)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-init.c
@@ -0,0 +1,50 @@
+/* Initialize a mutex.  Generic version.
+   Copyright (C) 2000, 2002, 2005, 2006, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <string.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+_pthread_mutex_init (pthread_mutex_t *mutex,
+		     const pthread_mutexattr_t *attr)
+{
+  *mutex = (pthread_mutex_t) __PTHREAD_MUTEX_INITIALIZER;
+
+  if (! attr
+      || memcmp (attr, &__pthread_default_mutexattr, sizeof (*attr) == 0))
+    /* The default attributes.  */
+    return 0;
+
+  if (! mutex->__attr
+      || mutex->__attr == __PTHREAD_ERRORCHECK_MUTEXATTR
+      || mutex->__attr == __PTHREAD_RECURSIVE_MUTEXATTR)
+    mutex->__attr = malloc (sizeof *attr);
+
+  if (! mutex->__attr)
+    return ENOMEM;
+
+  *mutex->__attr = *attr;
+  return 0;
+}
+
+strong_alias (_pthread_mutex_init, pthread_mutex_init);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-lock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-lock.c
@@ -0,0 +1,37 @@
+/* Lock a mutex.  Generic version.
+   Copyright (C) 2000, 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+/* Implemented in pt-mutex-timedlock.c.  */
+extern int __pthread_mutex_timedlock_internal (struct __pthread_mutex *mutex,
+					       const struct timespec *abstime);
+
+/* Lock MUTEX, block if we can't get it.  */
+int
+__pthread_mutex_lock (struct __pthread_mutex *mutex)
+{
+  return __pthread_mutex_timedlock_internal (mutex, 0);
+}
+
+strong_alias (__pthread_mutex_lock, _pthread_mutex_lock);
+strong_alias (__pthread_mutex_lock, pthread_mutex_lock);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-setprioceiling.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-setprioceiling.c
@@ -0,0 +1,30 @@
+/* Set a mutex' priority ceiling.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_mutex_setprioceiling (pthread_mutex_t *mutex, int prio,
+			      int *oldprio)
+{
+  return ENOSYS;
+}
+
+stub_warning (pthread_mutex_setprioceiling)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-timedlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-timedlock.c
@@ -0,0 +1,196 @@
+/* Lock a mutex with a timeout.  Generic version.
+   Copyright (C) 2000, 2002, 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+#define LOSE do { * (int *) 0 = 0; } while (1)
+
+/* Try to lock MUTEX, block until *ABSTIME if it is already held.  As
+   a GNU extension, if TIMESPEC is NULL then wait forever.  */
+int
+__pthread_mutex_timedlock_internal (struct __pthread_mutex *mutex,
+				    const struct timespec *abstime)
+{
+  error_t err;
+  int drain;
+  struct __pthread *self;
+  const struct __pthread_mutexattr *attr = mutex->__attr;
+
+  if (attr == __PTHREAD_ERRORCHECK_MUTEXATTR)
+    attr = &__pthread_errorcheck_mutexattr;
+  if (attr == __PTHREAD_RECURSIVE_MUTEXATTR)
+    attr = &__pthread_recursive_mutexattr;
+
+  __pthread_spin_lock (&mutex->__lock);
+  if (__pthread_spin_trylock (&mutex->__held) == 0)
+    /* Successfully acquired the lock.  */
+    {
+#ifdef ALWAYS_TRACK_MUTEX_OWNER
+#ifndef NDEBUG
+      self = _pthread_self ();
+      if (self)
+	/* The main thread may take a lock before the library is fully
+	   initialized, in particular, before the main thread has a
+	   TCB.  */
+	{
+	  assert (! mutex->__owner);
+	  mutex->__owner = _pthread_self ();
+	}
+#endif
+#endif
+
+      if (attr)
+	switch (attr->__mutex_type)
+	  {
+	  case PTHREAD_MUTEX_NORMAL:
+	    break;
+
+	  case PTHREAD_MUTEX_RECURSIVE:
+	    mutex->__locks = 1;
+	  case PTHREAD_MUTEX_ERRORCHECK:
+	    mutex->__owner = _pthread_self ();
+	    break;
+
+	  default:
+	    LOSE;
+	  }
+
+      __pthread_spin_unlock (&mutex->__lock);
+      return 0;
+    }
+
+  /* The lock is busy.  */
+
+  self = _pthread_self ();
+  assert (self);
+
+  if (! attr || attr->__mutex_type == PTHREAD_MUTEX_NORMAL)
+    {
+#if defined(ALWAYS_TRACK_MUTEX_OWNER)
+      assert (mutex->__owner != self);
+#endif
+    }
+  else
+    {
+      switch (attr->__mutex_type)
+	{
+	case PTHREAD_MUTEX_ERRORCHECK:
+	  if (mutex->__owner == self)
+	    {
+	      __pthread_spin_unlock (&mutex->__lock);
+	      return EDEADLK;
+	    }
+	  break;
+
+	case PTHREAD_MUTEX_RECURSIVE:
+	  if (mutex->__owner == self)
+	    {
+	      mutex->__locks ++;
+	      __pthread_spin_unlock (&mutex->__lock);
+	      return 0;
+	    }
+	  break;
+
+	default:
+	  LOSE;
+	}
+    }
+
+#if !defined(ALWAYS_TRACK_MUTEX_OWNER)
+  if (attr && attr->__mutex_type != PTHREAD_MUTEX_NORMAL)
+#endif
+    assert (mutex->__owner);
+
+  if (abstime && (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000))
+    return EINVAL;
+
+  /* Add ourselves to the queue.  */
+  __pthread_enqueue (&mutex->__queue, self);
+  __pthread_spin_unlock (&mutex->__lock);
+
+  /* Block the thread.  */
+  if (abstime)
+    err = __pthread_timedblock (self, abstime, CLOCK_REALTIME);
+  else
+    {
+      err = 0;
+      __pthread_block (self);
+    }
+
+  __pthread_spin_lock (&mutex->__lock);
+  if (! self->prevp)
+    /* Another thread removed us from the queue, which means a wakeup message
+       has been sent.  It was either consumed while we were blocking, or
+       queued after we timed out and before we acquired the mutex lock, in
+       which case the message queue must be drained.  */
+    drain = err ? 1 : 0;
+  else
+    {
+      /* We're still in the queue.  Noone attempted to wake us up, i.e. we
+	 timed out.  */
+      __pthread_dequeue (self);
+      drain = 0;
+    }
+  __pthread_spin_unlock (&mutex->__lock);
+
+  if (drain)
+    __pthread_block (self);
+
+  if (err)
+    {
+      assert (err == ETIMEDOUT);
+      return err;
+    }
+
+#if !defined(ALWAYS_TRACK_MUTEX_OWNER)
+  if (attr && attr->__mutex_type != PTHREAD_MUTEX_NORMAL)
+#endif
+    {
+      assert (mutex->__owner == self);
+    }
+
+  if (attr)
+    switch (attr->__mutex_type)
+      {
+      case PTHREAD_MUTEX_NORMAL:
+	break;
+
+      case PTHREAD_MUTEX_RECURSIVE:
+	assert (mutex->__locks == 0);
+	mutex->__locks = 1;
+      case PTHREAD_MUTEX_ERRORCHECK:
+	mutex->__owner = self;
+	break;
+
+      default:
+	LOSE;
+      }
+
+  return 0;
+}
+
+int
+pthread_mutex_timedlock (struct __pthread_mutex *mutex,
+			 const struct timespec *abstime)
+{
+  return __pthread_mutex_timedlock_internal (mutex, abstime);
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-transfer-np.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-transfer-np.c
@@ -0,0 +1,66 @@
+/* Transfer ownership of a mutex.  Generic version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_mutex_transfer_np (struct __pthread_mutex *mutex, pthread_t tid)
+{
+  assert (mutex->__owner == _pthread_self ());
+
+  struct __pthread *thread = __pthread_getid (tid);
+  const struct __pthread_mutexattr *attr = mutex->__attr;
+
+  if (! thread)
+    return ESRCH;
+
+  if (thread == _pthread_self ())
+    return 0;
+
+  if (attr == __PTHREAD_ERRORCHECK_MUTEXATTR)
+    attr = &__pthread_errorcheck_mutexattr;
+  if (attr == __PTHREAD_RECURSIVE_MUTEXATTR)
+    attr = &__pthread_recursive_mutexattr;
+
+  if (attr && attr->__mutex_type == PTHREAD_MUTEX_ERRORCHECK)
+    {
+
+      if (mutex->__owner != _pthread_self ())
+	return EPERM;
+
+      mutex->__owner = thread;
+    }
+
+#ifndef NDEBUG
+# if !defined(ALWAYS_TRACK_MUTEX_OWNER)
+  if (attr && attr->__mutex_type != PTHREAD_MUTEX_NORMAL)
+# endif
+    {
+      mutex->__owner = thread;
+    }
+#endif
+
+  return 0;
+}
+
+strong_alias (__pthread_mutex_transfer_np, pthread_mutex_transfer_np)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-trylock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-trylock.c
@@ -0,0 +1,112 @@
+/* Try to Lock a mutex.  Generic version.
+   Copyright (C) 2002, 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+#define LOSE do { * (int *) 0 = 0; } while (1)
+
+/* Lock MUTEX, return EBUSY if we can't get it.  */
+int
+__pthread_mutex_trylock (struct __pthread_mutex *mutex)
+{
+  int err;
+  struct __pthread *self;
+  const struct __pthread_mutexattr *attr = mutex->__attr;
+
+  if (attr == __PTHREAD_ERRORCHECK_MUTEXATTR)
+    attr = &__pthread_errorcheck_mutexattr;
+  if (attr == __PTHREAD_RECURSIVE_MUTEXATTR)
+    attr = &__pthread_recursive_mutexattr;
+
+  __pthread_spin_lock (&mutex->__lock);
+  if (__pthread_spin_trylock (&mutex->__held) == 0)
+    /* Acquired the lock.  */
+    {
+#if defined(ALWAYS_TRACK_MUTEX_OWNER)
+#ifndef NDEBUG
+      self = _pthread_self ();
+      if (self)
+	/* The main thread may take a lock before the library is fully
+	   initialized, in particular, before the main thread has a
+	   TCB.  */
+	{
+	  assert (! mutex->__owner);
+	  mutex->__owner = _pthread_self ();
+	}
+#endif
+#endif
+
+      if (attr)
+	switch (attr->__mutex_type)
+	  {
+	  case PTHREAD_MUTEX_NORMAL:
+	    break;
+
+	  case PTHREAD_MUTEX_RECURSIVE:
+	    mutex->__locks = 1;
+	  case PTHREAD_MUTEX_ERRORCHECK:
+	    mutex->__owner = _pthread_self ();
+	    break;
+
+	  default:
+	    LOSE;
+	  }
+
+      __pthread_spin_unlock (&mutex->__lock);
+      return 0;
+    }
+
+  err = EBUSY;
+
+  if (attr)
+    {
+      self = _pthread_self ();
+      switch (attr->__mutex_type)
+	{
+	case PTHREAD_MUTEX_NORMAL:
+	  break;
+
+	case PTHREAD_MUTEX_ERRORCHECK:
+	  /* We could check if MUTEX->OWNER is SELF, however, POSIX
+	     does not permit pthread_mutex_trylock to return EDEADLK
+	     instead of EBUSY, only pthread_mutex_lock.  */
+	  break;
+
+	case PTHREAD_MUTEX_RECURSIVE:
+	  if (mutex->__owner == self)
+	    {
+	      mutex->__locks ++;
+	      err = 0;
+	    }
+	  break;
+
+	default:
+	  LOSE;
+	}
+    }
+
+  __pthread_spin_unlock (&mutex->__lock);
+
+  return err;
+}
+
+strong_alias (__pthread_mutex_trylock, _pthread_mutex_trylock);
+strong_alias (__pthread_mutex_trylock, pthread_mutex_trylock);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-mutex-unlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-mutex-unlock.c
@@ -0,0 +1,108 @@
+/* Unlock a mutex.  Generic version.
+   Copyright (C) 2000, 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+#define LOSE do { * (int *) 0 = 0; } while (1)
+
+/* Unlock MUTEX, rescheduling a waiting thread.  */
+int
+__pthread_mutex_unlock (pthread_mutex_t *mutex)
+{
+  struct __pthread *wakeup;
+  const struct __pthread_mutexattr *attr = mutex->__attr;
+
+  if (attr == __PTHREAD_ERRORCHECK_MUTEXATTR)
+    attr = &__pthread_errorcheck_mutexattr;
+  if (attr == __PTHREAD_RECURSIVE_MUTEXATTR)
+    attr = &__pthread_recursive_mutexattr;
+
+  __pthread_spin_lock (&mutex->__lock);
+
+  if (! attr || attr->__mutex_type == PTHREAD_MUTEX_NORMAL)
+    {
+#if defined(ALWAYS_TRACK_MUTEX_OWNER)
+# ifndef NDEBUG
+      if (_pthread_self ())
+	{
+	  assert (mutex->__owner);
+	  assert (mutex->__owner == _pthread_self ());
+	  mutex->__owner = NULL;
+	}
+# endif
+#endif
+    }
+  else
+    switch (attr->__mutex_type)
+      {
+      case PTHREAD_MUTEX_ERRORCHECK:
+      case PTHREAD_MUTEX_RECURSIVE:
+	if (mutex->__owner != _pthread_self ())
+	  {
+	    __pthread_spin_unlock (&mutex->__lock);
+	    return EPERM;
+	  }
+
+	if (attr->__mutex_type == PTHREAD_MUTEX_RECURSIVE)
+	  if (--mutex->__locks > 0)
+	    {
+	      __pthread_spin_unlock (&mutex->__lock);
+	      return 0;
+	    }
+
+	mutex->__owner = 0;
+	break;
+
+      default:
+	LOSE;
+      }
+
+
+  if (mutex->__queue == NULL)
+    {
+      __pthread_spin_unlock (&mutex->__held);
+      __pthread_spin_unlock (&mutex->__lock);
+      return 0;
+    }
+
+  wakeup = mutex->__queue;
+  __pthread_dequeue (wakeup);
+
+#ifndef NDEBUG
+# if !defined (ALWAYS_TRACK_MUTEX_OWNER)
+  if (attr && attr->__mutex_type != PTHREAD_MUTEX_NORMAL)
+# endif
+    {
+      mutex->__owner = wakeup;
+    }
+#endif
+
+  /* We do not unlock MUTEX->held: we are transferring the ownership
+     to the thread that we are waking up.  */
+
+  __pthread_spin_unlock (&mutex->__lock);
+  __pthread_wakeup (wakeup);
+
+  return 0;
+}
+
+strong_alias (__pthread_mutex_unlock, _pthread_mutex_unlock);
+strong_alias (__pthread_mutex_unlock, pthread_mutex_unlock);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-once.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-once.c
@@ -0,0 +1,44 @@
+/* pthread_once.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <bits/memory.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))
+{
+  if (once_control->__run == 0)
+    {
+      __pthread_spin_lock (&once_control->__lock);
+
+      if (once_control->__run == 0)
+	{
+	  init_routine ();
+	  __memory_barrier ();
+	  once_control->__run = 1;
+	}
+
+      __pthread_spin_unlock (&once_control->__lock);
+    }
+
+  return 0;
+}
+strong_alias (__pthread_once, pthread_once);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-attr.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-attr.c
@@ -0,0 +1,26 @@
+/* Default rwlock attributes.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+const struct __pthread_rwlockattr __pthread_default_rwlockattr =
+{
+  __pshared: PTHREAD_PROCESS_PRIVATE
+};
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-destroy.c
@@ -0,0 +1,27 @@
+/* pthread_rwlockattr_destroy.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr)
+{
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-getpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-getpshared.c
@@ -0,0 +1,29 @@
+/* pthread_rwlockattr_getpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr,
+			       int *pshared)
+{
+  *pshared = attr->__pshared;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-init.c
@@ -0,0 +1,28 @@
+/* pthread_rwlockattr_init.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_rwlockattr_init (pthread_rwlockattr_t *attr)
+{
+  *attr = __pthread_default_rwlockattr;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-setpshared.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlockattr-setpshared.c
@@ -0,0 +1,39 @@
+/* pthread_rwlockattr_setpshared.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr,
+			       int pshared)
+{
+  switch (pshared)
+    {
+    case PTHREAD_PROCESS_PRIVATE:
+      attr->__pshared = pshared;
+      return 0;
+
+    case PTHREAD_PROCESS_SHARED:
+      return ENOTSUP;
+
+    default:
+      return EINVAL;
+    }
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-destroy.c
@@ -0,0 +1,29 @@
+/* Destroy a rwlock.  Generic version.
+   Copyright (C) 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+_pthread_rwlock_destroy (pthread_rwlock_t *rwlock)
+{
+  return 0;
+}
+
+strong_alias (_pthread_rwlock_destroy, pthread_rwlock_destroy);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-init.c
@@ -0,0 +1,45 @@
+/* Initialize a rwlock.  Generic version.
+   Copyright (C) 2002, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <string.h>
+#include <pt-internal.h>
+
+int
+_pthread_rwlock_init (pthread_rwlock_t *rwlock,
+		      const pthread_rwlockattr_t *attr)
+{
+  *rwlock = (pthread_rwlock_t) __PTHREAD_RWLOCK_INITIALIZER;
+
+  if (! attr
+      || memcmp (attr, &__pthread_default_rwlockattr, sizeof (*attr) == 0))
+    /* Use the default attributes.  */
+    return 0;
+
+  /* Non-default attributes.  */
+
+  rwlock->__attr = malloc (sizeof *attr);
+  if (! rwlock->__attr)
+    return ENOMEM;
+
+  *rwlock->__attr = *attr;
+  return 0;
+}
+
+strong_alias (_pthread_rwlock_init, pthread_rwlock_init);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-rdlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-rdlock.c
@@ -0,0 +1,33 @@
+/* Acquire a rwlock for reading.  Generic version.
+   Copyright (C) 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+/* Implemented in pt-rwlock-timedrdlock.c.  */
+extern int __pthread_rwlock_timedrdlock_internal (struct __pthread_rwlock *rwlock,
+						  const struct timespec *abstime);
+
+/* Acquire RWLOCK for reading, block if we can't get it.  */
+int
+__pthread_rwlock_rdlock (struct __pthread_rwlock *rwlock)
+{
+  return __pthread_rwlock_timedrdlock_internal (rwlock, 0);
+}
+strong_alias (__pthread_rwlock_rdlock, pthread_rwlock_rdlock);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-timedrdlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-timedrdlock.c
@@ -0,0 +1,120 @@
+/* Acquire a rwlock for reading.  Generic version.
+   Copyright (C) 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+/* Acquire the rwlock *RWLOCK for reading blocking until *ABSTIME if
+   it is already held.  As a GNU extension, if TIMESPEC is NULL then
+   wait forever.  */
+int
+__pthread_rwlock_timedrdlock_internal (struct __pthread_rwlock *rwlock,
+				       const struct timespec *abstime)
+{
+  error_t err;
+  int drain;
+  struct __pthread *self;
+
+  __pthread_spin_lock (&rwlock->__lock);
+  if (__pthread_spin_trylock (&rwlock->__held) == 0)
+    /* Successfully acquired the lock.  */
+    {
+      assert (rwlock->__readerqueue == 0);
+      assert (rwlock->__writerqueue == 0);
+      assert (rwlock->__readers == 0);
+
+      rwlock->__readers = 1;
+      __pthread_spin_unlock (&rwlock->__lock);
+      return 0;
+    }
+  else
+    /* Lock is held, but is held by a reader?  */
+    if (rwlock->__readers > 0)
+      /* Just add ourself to number of readers.  */
+      {
+	assert (rwlock->__readerqueue == 0);
+	rwlock->__readers ++;
+	__pthread_spin_unlock (&rwlock->__lock);
+	return 0;
+      }
+
+  /* The lock is busy.  */
+
+  /* Better be blocked by a writer.  */
+  assert (rwlock->__readers == 0);
+
+  if (abstime && (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000))
+    return EINVAL;
+
+  self = _pthread_self ();
+
+  /* Add ourself to the queue.  */
+  __pthread_enqueue (&rwlock->__readerqueue, self);
+  __pthread_spin_unlock (&rwlock->__lock);
+
+  /* Block the thread.  */
+  if (abstime)
+    err = __pthread_timedblock (self, abstime, CLOCK_REALTIME);
+  else
+    {
+      err = 0;
+      __pthread_block (self);
+    }
+
+  __pthread_spin_lock (&rwlock->__lock);
+  if (! self->prevp)
+    /* Another thread removed us from the queue, which means a wakeup message
+       has been sent.  It was either consumed while we were blocking, or
+       queued after we timed out and before we acquired the rwlock lock, in
+       which case the message queue must be drained.  */
+    drain = err ? 1 : 0;
+  else
+    {
+      /* We're still in the queue.  Noone attempted to wake us up, i.e. we
+	 timed out.  */
+      __pthread_dequeue (self);
+      drain = 0;
+    }
+  __pthread_spin_unlock (&rwlock->__lock);
+
+  if (drain)
+    __pthread_block (self);
+
+  if (err)
+    {
+      assert (err == ETIMEDOUT);
+      return err;
+    }
+
+  /* The reader count has already been increment by whoever woke us
+     up.  */
+
+  assert (rwlock->__readers > 0);
+
+  return 0;
+}
+
+int
+pthread_rwlock_timedrdlock (struct __pthread_rwlock *rwlock,
+			    const struct timespec *abstime)
+{
+  return __pthread_rwlock_timedrdlock_internal (rwlock, abstime);
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-timedwrlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-timedwrlock.c
@@ -0,0 +1,103 @@
+/* Acquire a rwlock for writing.  Generic version.
+   Copyright (C) 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+/* Acquire RWLOCK for writing blocking until *ABSTIME if we cannot get
+   it.  As a special GNU extension, if ABSTIME is NULL then the wait
+   shall not time out.  */
+int
+__pthread_rwlock_timedwrlock_internal (struct __pthread_rwlock *rwlock,
+				       const struct timespec *abstime)
+{
+  error_t err;
+  int drain;
+  struct __pthread *self;
+
+  __pthread_spin_lock (&rwlock->__lock);
+  if (__pthread_spin_trylock (&rwlock->__held) == 0)
+    /* Successfully acquired the lock.  */
+    {
+      assert (rwlock->__readerqueue == 0);
+      assert (rwlock->__writerqueue == 0);
+      assert (rwlock->__readers == 0);
+
+      __pthread_spin_unlock (&rwlock->__lock);
+      return 0;
+    }
+
+  /* The lock is busy.  */
+
+  if (abstime && (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000))
+    return EINVAL;
+
+  self = _pthread_self ();
+
+  /* Add ourselves to the queue.  */
+  __pthread_enqueue (&rwlock->__writerqueue, self);
+  __pthread_spin_unlock (&rwlock->__lock);
+
+  /* Block the thread.  */
+  if (abstime)
+    err = __pthread_timedblock (self, abstime, CLOCK_REALTIME);
+  else
+    {
+      err = 0;
+      __pthread_block (self);
+    }
+
+  __pthread_spin_lock (&rwlock->__lock);
+  if (! self->prevp)
+    /* Another thread removed us from the queue, which means a wakeup message
+       has been sent.  It was either consumed while we were blocking, or
+       queued after we timed out and before we acquired the rwlock lock, in
+       which case the message queue must be drained.  */
+    drain = err ? 1 : 0;
+  else
+    {
+      /* We're still in the queue.  Noone attempted to wake us up, i.e. we
+	 timed out.  */
+      __pthread_dequeue (self);
+      drain = 0;
+    }
+  __pthread_spin_unlock (&rwlock->__lock);
+
+  if (drain)
+    __pthread_block (self);
+
+  if (err)
+    {
+      assert (err == ETIMEDOUT);
+      return err;
+    }
+
+  assert (rwlock->__readers == 0);
+
+  return 0;
+}
+
+int
+pthread_rwlock_timedwrlock (struct __pthread_rwlock *rwlock,
+			    const struct timespec *abstime)
+{
+  return __pthread_rwlock_timedwrlock_internal (rwlock, abstime);
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-tryrdlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-tryrdlock.c
@@ -0,0 +1,56 @@
+/* Try to acquire a rwlock for reading.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+/* Try to acquire RWLOCK.  */
+int
+pthread_rwlock_tryrdlock (struct __pthread_rwlock *rwlock)
+{
+  __pthread_spin_lock (&rwlock->__lock);
+  if (__pthread_spin_trylock (&rwlock->__held) == 0)
+    /* Successfully acquired the lock.  */
+    {
+      assert (rwlock->__readerqueue == 0);
+      assert (rwlock->__writerqueue == 0);
+      assert (rwlock->__readers == 0);
+
+      rwlock->__readers = 1;
+      __pthread_spin_unlock (&rwlock->__lock);
+      return 0;
+    }
+  else
+    /* Lock is held, but is held by a reader?  */
+    if (rwlock->__readers > 0)
+      {
+	assert (rwlock->__readerqueue == 0);
+	rwlock->__readers ++;
+	__pthread_spin_unlock (&rwlock->__lock);
+	return 0;
+      }
+
+  /* The lock is busy.  */
+
+  __pthread_spin_unlock (&rwlock->__lock);
+
+  return EBUSY;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-trywrlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-trywrlock.c
@@ -0,0 +1,46 @@
+/* Try to acquire a rwlock for writing.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+/* Try to acquire RWLOCK for writing.  */
+int
+pthread_rwlock_trywrlock (struct __pthread_rwlock *rwlock)
+{
+  __pthread_spin_lock (&rwlock->__lock);
+  if (__pthread_spin_trylock (&rwlock->__held) == 0)
+    /* Successfully acquired the lock.  */
+    {
+      assert (rwlock->__readerqueue == 0);
+      assert (rwlock->__writerqueue == 0);
+      assert (rwlock->__readers == 0);
+
+      __pthread_spin_unlock (&rwlock->__lock);
+      return 0;
+    }
+
+  /* The lock is busy.  */
+
+  __pthread_spin_unlock (&rwlock->__lock);
+
+  return EBUSY;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-unlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-unlock.c
@@ -0,0 +1,99 @@
+/* Unlock a rwlock.  Generic version.
+   Copyright (C) 2000,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+/* Unlock *RWLOCK, rescheduling a waiting writer thread or, if there
+   are no threads waiting for a write lock, rescheduling the reader
+   threads.  */
+int
+__pthread_rwlock_unlock (pthread_rwlock_t *rwlock)
+{
+  struct __pthread *wakeup;
+  
+  __pthread_spin_lock (&rwlock->__lock);
+
+  assert (__pthread_spin_trylock (&rwlock->__held) == EBUSY);
+
+  if (rwlock->__readers > 1)
+    /* There are other readers.  */
+    {
+      rwlock->__readers --;
+      __pthread_spin_unlock (&rwlock->__lock);
+      return 0;
+    }
+
+  if (rwlock->__readers == 1)
+    /* Last reader.  */
+    rwlock->__readers = 0;
+      
+
+  /* Wake someone else up.  Try the writer queue first, then the
+     reader queue if that is empty.  */
+
+  if (rwlock->__writerqueue)
+    {
+      wakeup = rwlock->__writerqueue;
+      __pthread_dequeue (wakeup);
+
+      /* We do not unlock RWLOCK->held: we are transferring the ownership
+	 to the thread that we are waking up.  */
+
+      __pthread_spin_unlock (&rwlock->__lock);
+      __pthread_wakeup (wakeup);
+
+      return 0;
+    }
+
+  if (rwlock->__readerqueue)
+    {
+      unsigned n = 0;
+
+      __pthread_queue_iterate (rwlock->__readerqueue, wakeup)
+        n ++;
+
+      {
+	struct __pthread *wakeups[n];
+	unsigned i = 0;
+
+	__pthread_dequeuing_iterate (rwlock->__readerqueue, wakeup)
+	    wakeups[i ++] = wakeup;
+
+	rwlock->__readers += n;
+	rwlock->__readerqueue = 0;
+
+	__pthread_spin_unlock (&rwlock->__lock);
+
+	for (i = 0; i < n; i ++)
+	  __pthread_wakeup (wakeups[i]);
+      }
+
+      return 0;
+    }
+
+
+  /* Noone is waiting.  Just unlock it.  */
+
+  __pthread_spin_unlock (&rwlock->__held);
+  __pthread_spin_unlock (&rwlock->__lock);
+  return 0;
+}
+strong_alias (__pthread_rwlock_unlock, pthread_rwlock_unlock);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-wrlock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-rwlock-wrlock.c
@@ -0,0 +1,35 @@
+/* Acquire a rwlock for writing.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+/* Implemented in pt-rwlock-timedwrlock.c.  */
+extern int __pthread_rwlock_timedwrlock_internal (struct __pthread_rwlock *rwlock,
+						  const struct timespec *abstime);
+
+/* Acquire RWLOCK for writing.  */
+int
+__pthread_rwlock_wrlock (struct __pthread_rwlock *rwlock)
+{
+  return __pthread_rwlock_timedwrlock_internal (rwlock, 0);
+}
+strong_alias (__pthread_rwlock_wrlock, pthread_rwlock_wrlock);
Index: glibc-2.21/libpthread/sysdeps/generic/pt-setconcurrency.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-setconcurrency.c
@@ -0,0 +1,34 @@
+/* Set the desired level of concurrency.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int __pthread_concurrency;
+
+int
+pthread_setconcurrency (int new_level)
+{
+  if (new_level < 0)
+    return EINVAL;
+
+  __pthread_concurrency = new_level;
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-setschedparam.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-setschedparam.c
@@ -0,0 +1,31 @@
+/* Set the scheduling parameters for a thread.  Generic version.
+   Copyright (C) 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+__pthread_setschedparam (pthread_t thread, int policy,
+		       const struct sched_param *param)
+{
+  return ENOSYS;
+}
+
+strong_alias (__pthread_setschedparam, pthread_setschedparam);
+stub_warning (pthread_setschedparam)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-setschedprio.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-setschedprio.c
@@ -0,0 +1,29 @@
+/* Set the scheduling priority of a thread.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_setschedprio (pthread_t thread, int prio)
+{
+  return ENOSYS;
+}
+
+stub_warning (pthread_setschedprio)
Index: glibc-2.21/libpthread/sysdeps/generic/pt-setspecific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-setspecific.c
@@ -0,0 +1,27 @@
+/* pthread_setspecific.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_setspecific (pthread_key_t key, const void *value)
+{
+  return EINVAL;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/pt-startup.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/pt-startup.c
@@ -0,0 +1,25 @@
+/* Thread initialization.  Generic version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pt-internal.h>
+
+void
+__pthread_startup (void)
+{
+}
Index: glibc-2.21/libpthread/sysdeps/generic/raise.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/raise.c
@@ -0,0 +1,41 @@
+/* raise.c - Generic raise implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+raise (int signo)
+{
+  /* According to POSIX, if we implement threads (and we do), then
+     "the effect of the raise() function shall be equivalent to
+     calling: pthread_kill(pthread_self(), sig);"  */
+
+debug (0, "");
+  int err = pthread_kill (pthread_self (), signo);
+debug (0, "");
+  if (err)
+    {
+      errno = err;
+      return -1;
+    }
+
+  return 0;
+}
+
Index: glibc-2.21/libpthread/sysdeps/generic/sem-close.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-close.c
@@ -0,0 +1,32 @@
+/* Close a named semaphore.  Generic version.
+   Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <errno.h>
+
+#include <pt-internal.h>
+
+int
+__sem_close (sem_t *sem)
+{
+  errno = EOPNOTSUPP;
+  return -1;
+}
+
+strong_alias (__sem_close, sem_close);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-destroy.c
@@ -0,0 +1,38 @@
+/* Destroy a semaphore.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <errno.h>
+
+#include <pt-internal.h>
+
+int
+__sem_destroy (sem_t *sem)
+{
+  if (sem->__queue)
+    /* There are threads waiting on *SEM.  */
+    {
+      errno = EBUSY;
+      return -1;
+    }
+
+  return 0;
+}
+
+strong_alias (__sem_destroy, sem_destroy);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-getvalue.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-getvalue.c
@@ -0,0 +1,33 @@
+/* Get the value of a semaphore.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <pt-internal.h>
+
+int
+__sem_getvalue (sem_t *restrict sem, int *restrict value)
+{
+  __pthread_spin_lock (&sem->__lock);
+  *value = sem->__value;
+  __pthread_spin_unlock (&sem->__lock);
+
+  return 0;
+}
+
+strong_alias (__sem_getvalue, sem_getvalue);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-init.c
@@ -0,0 +1,46 @@
+/* Initialize a semaphore.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <errno.h>
+
+#include <pt-internal.h>
+
+int
+__sem_init (sem_t *sem, int pshared, unsigned value)
+{
+  if (pshared != 0)
+    {
+      errno = EOPNOTSUPP;
+      return -1;
+    }
+
+#ifdef SEM_VALUE_MAX
+  if (value > SEM_VALUE_MAX)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+#endif
+
+  *sem = (sem_t) __SEMAPHORE_INITIALIZER (pshared, value);
+  return 0;
+}
+
+strong_alias (__sem_init, sem_init);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-open.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-open.c
@@ -0,0 +1,32 @@
+/* Open a named semaphore.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <errno.h>
+
+#include <pt-internal.h>
+
+sem_t *
+__sem_open (const char *name, int open_flags, ...)
+{
+  errno = EOPNOTSUPP;
+  return SEM_FAILED;
+}
+
+strong_alias (__sem_open, sem_open);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-post.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-post.c
@@ -0,0 +1,62 @@
+/* Post a semaphore.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+__sem_post (sem_t *sem)
+{
+  struct __pthread *wakeup;
+
+  __pthread_spin_lock (&sem->__lock);
+  if (sem->__value > 0)
+    /* Do a quick up.  */
+    {
+      assert (! sem->__queue);
+      sem->__value ++;
+      __pthread_spin_unlock (&sem->__lock);
+      return 0;
+    }
+
+  if (! sem->__queue)
+    /* No one waiting.  */
+    {
+      sem->__value = 1;
+      __pthread_spin_unlock (&sem->__lock);
+      return 0;
+    }
+
+  /* Wake someone up.  */
+
+  /* First dequeue someone.  */
+  wakeup = sem->__queue;
+  __pthread_dequeue (wakeup);
+
+  /* Then drop the lock and transfer control.  */
+  __pthread_spin_unlock (&sem->__lock);
+
+  __pthread_wakeup (wakeup);
+
+  return 0;
+}
+
+strong_alias (__sem_post, sem_post);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-timedwait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-timedwait.c
@@ -0,0 +1,100 @@
+/* Wait on a semaphore with a timeout.  Generic version.
+   Copyright (C) 2005, 2006, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <errno.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+int
+__sem_timedwait_internal (sem_t *restrict sem,
+			  const struct timespec *restrict timeout)
+{
+  error_t err;
+  int drain;
+  struct __pthread *self;
+
+  __pthread_spin_lock (&sem->__lock);
+  if (sem->__value > 0)
+    /* Successful down.  */
+    {
+      sem->__value --;
+      __pthread_spin_unlock (&sem->__lock);
+      return 0;
+    }
+
+  if (timeout && (timeout->tv_nsec < 0 || timeout->tv_nsec >= 1000000000))
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  /* Add ourselves to the queue.  */
+  self = _pthread_self ();
+
+  __pthread_enqueue (&sem->__queue, self);
+  __pthread_spin_unlock (&sem->__lock);
+
+  /* Block the thread.  */
+  if (timeout)
+    err = __pthread_timedblock (self, timeout, CLOCK_REALTIME);
+  else
+    {
+      err = 0;
+      __pthread_block (self);
+    }
+
+  __pthread_spin_lock (&sem->__lock);
+  if (! self->prevp)
+    /* Another thread removed us from the queue, which means a wakeup message
+       has been sent.  It was either consumed while we were blocking, or
+       queued after we timed out and before we acquired the semaphore lock, in
+       which case the message queue must be drained.  */
+    drain = err ? 1 : 0;
+  else
+    {
+      /* We're still in the queue.  Noone attempted to wake us up, i.e. we
+	 timed out.  */
+      __pthread_dequeue (self);
+      drain = 0;
+    }
+  __pthread_spin_unlock (&sem->__lock);
+
+  if (drain)
+    __pthread_block (self);
+
+  if (err)
+    {
+      assert (err == ETIMEDOUT);
+      errno = err;
+      return -1;
+    }
+
+  return 0;
+}
+
+int
+__sem_timedwait (sem_t *restrict sem,
+		 const struct timespec *restrict timeout)
+{
+  return __sem_timedwait_internal (sem, timeout);
+}
+
+strong_alias (__sem_timedwait, sem_timedwait);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-trywait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-trywait.c
@@ -0,0 +1,42 @@
+/* Lock a semaphore if it does not require blocking.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <errno.h>
+
+#include <pt-internal.h>
+
+int
+__sem_trywait (sem_t *sem)
+{
+  __pthread_spin_lock (&sem->__lock);
+  if (sem->__value > 0)
+    /* Successful down.  */
+    {
+      sem->__value --;
+      __pthread_spin_unlock (&sem->__lock);
+      return 0;
+    }
+  __pthread_spin_unlock (&sem->__lock);
+
+  errno = EAGAIN;
+  return -1;
+}
+
+strong_alias (__sem_trywait, sem_trywait);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-unlink.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-unlink.c
@@ -0,0 +1,32 @@
+/* Unlink a named semaphore.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <errno.h>
+
+#include <pt-internal.h>
+
+int
+__sem_unlink (const char *name)
+{
+  errno = EOPNOTSUPP;
+  return -1;
+}
+
+strong_alias (__sem_unlink, sem_unlink);
Index: glibc-2.21/libpthread/sysdeps/generic/sem-wait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sem-wait.c
@@ -0,0 +1,32 @@
+/* Wait on a semaphore.  Generic version.
+   Copyright (C) 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <semaphore.h>
+#include <pt-internal.h>
+
+extern int __sem_timedwait_internal (sem_t *restrict sem,
+				     const struct timespec *restrict timeout);
+
+int
+__sem_wait (sem_t *sem)
+{
+  return __sem_timedwait_internal (sem, 0);
+}
+
+strong_alias (__sem_wait, sem_wait);
Index: glibc-2.21/libpthread/sysdeps/generic/sigaddset.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sigaddset.c
@@ -0,0 +1,35 @@
+/* sigaddset.c - Generic sigaddset implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+sigaddset (sigset_t *sigset, int signo)
+{
+  if (signo <= 0 || signo >= NSIG)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  *sigset |= sigmask (signo);
+  return 0;
+}
+
Index: glibc-2.21/libpthread/sysdeps/generic/sigdelset.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sigdelset.c
@@ -0,0 +1,35 @@
+/* sigdelset.c - Generic sigdelset implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+sigdelset (sigset_t *sigset, int signo)
+{
+  if (signo <= 0 || signo >= NSIG)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  *sigset &= ~sigmask (signo);
+  return 0;
+}
+
Index: glibc-2.21/libpthread/sysdeps/generic/sigemptyset.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sigemptyset.c
@@ -0,0 +1,29 @@
+/* sigemptyset.c - Generic sigemptyset implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <signal.h>
+
+int
+sigemptyset (sigset_t *sigset)
+{
+  *sigset = 0;
+  return 0;
+}
+
Index: glibc-2.21/libpthread/sysdeps/generic/sigfillset.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sigfillset.c
@@ -0,0 +1,29 @@
+/* sigfillset.c - Generic sigfillset implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <signal.h>
+
+int
+sigfillset (sigset_t *sigset)
+{
+  *sigset = (1ULL << (NSIG - 1)) - 1;
+  return 0;
+}
+
Index: glibc-2.21/libpthread/sysdeps/generic/siginterrupt.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/siginterrupt.c
@@ -0,0 +1,36 @@
+/* siginterrupt.c - Generic siginterrupt implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+siginterrupt (int sig, int flag)
+{
+  int ret;
+  struct sigaction act;
+
+  sigaction (sig, NULL, &act);
+  if (flag)
+    act.sa_flags &= ~SA_RESTART;
+  else
+    act.sa_flags |= SA_RESTART;
+  ret = sigaction(sig, &act, NULL);
+  return ret;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/sigismember.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sigismember.c
@@ -0,0 +1,36 @@
+/* sigismember.c - Generic sigismember implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+sigismember (const sigset_t *sigset, int signo)
+{
+  if (signo <= 0 || signo >= NSIG)
+    {
+      errno = EINVAL;
+      return -1;
+    }
+
+  if (*sigset & sigmask (signo))
+    return 1;
+  else
+    return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/generic/signal.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/signal.c
@@ -0,0 +1,44 @@
+/* signal.c - Generic signal implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+void (*signal (int sig, void (*handler)(int)))(int)
+{
+  struct sigaction sa;
+
+  sa.sa_handler = handler;
+  sa.sa_flags = SA_RESTART;
+
+  if (sigemptyset (&sa.sa_mask) < 0
+      || sigaddset (&sa.sa_mask, sig) < 0)
+    return SIG_ERR;
+
+  struct sigaction osa;
+  if (sigaction (sig, &sa, &osa) < 0)
+    return SIG_ERR;
+
+  return osa.sa_handler;
+}
+
+void (*bsd_signal (int sig, void (*func)(int)))(int)
+{
+  return signal (sig, func);
+}
Index: glibc-2.21/libpthread/sysdeps/generic/sigwait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/generic/sigwait.c
@@ -0,0 +1,34 @@
+/* sigwait.c - Generic sigwait implementation.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   Written by Neal H. Walfield <neal@gnu.org>.
+
+   This file is part of the GNU Hurd.
+
+   The GNU Hurd is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 3 of
+   the License, or (at your option) any later version.
+
+   The GNU Hurd is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "sig-internal.h"
+
+int
+sigwait (const sigset_t *restrict set, int *restrict signo)
+{
+  siginfo_t info;
+
+  if (sigwaitinfo (set, &info) < 0)
+    return -1;
+
+  *signo = info.si_signo;
+  return 0;
+}
+
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-destroy-specific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-destroy-specific.c
@@ -0,0 +1,79 @@
+/* __pthread_destory_specific.  Hurd version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <stdlib.h>
+#include <hurd/ihash.h>
+
+#include <pt-internal.h>
+
+void
+__pthread_destroy_specific (struct __pthread *thread)
+{
+  error_t err;
+  int i;
+  int seen_one;
+
+  /* Check if there is any thread specific data.  */
+  if (! thread->thread_specifics)
+    return;
+
+  __pthread_key_lock_ready ();
+
+  /* Iterate and call the destructors on any thread specific data.  */
+  for (;;)
+    {
+      seen_one = 0;
+
+      __pthread_mutex_lock (&__pthread_key_lock);
+
+      for (i = 0; i < __pthread_key_count; i ++)
+	{
+	  void *value;
+
+	  if (__pthread_key_destructors[i] == PTHREAD_KEY_INVALID)
+	    continue;
+
+	  value = hurd_ihash_find (thread->thread_specifics, i);
+	  if (value)
+	    {
+	      err = hurd_ihash_remove (thread->thread_specifics, i);
+	      assert (err == 1);
+
+	      if (__pthread_key_destructors[i])
+		{
+		  seen_one = 1;
+		  __pthread_key_destructors[i] (value);
+		}
+	    }
+	}
+
+      __pthread_mutex_unlock (&__pthread_key_lock);
+
+      if (! seen_one)
+	break;
+
+      /* This may take a very long time.  Let those blocking on
+	 pthread_key_create or pthread_key_delete make progress.  */
+      sched_yield ();
+    }
+
+  hurd_ihash_free (thread->thread_specifics);
+  thread->thread_specifics = 0;
+}
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-getspecific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-getspecific.c
@@ -0,0 +1,40 @@
+/* pthread_getspecific.  Hurd version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <hurd/ihash.h>
+
+#include <pt-internal.h>
+
+void *
+__pthread_getspecific (pthread_key_t key)
+{
+  struct __pthread *self;
+
+  if (key < 0 || key >= __pthread_key_count
+      || __pthread_key_destructors[key] == PTHREAD_KEY_INVALID)
+    return NULL;
+
+  self = _pthread_self ();
+  if (! self->thread_specifics)
+    return 0;
+
+  return hurd_ihash_find (self->thread_specifics, key);
+}
+strong_alias (__pthread_getspecific, pthread_getspecific);
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-init-specific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-init-specific.c
@@ -0,0 +1,30 @@
+/* __pthread_init_specific.  Hurd version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <stdlib.h>
+
+#include <pt-internal.h>
+
+error_t
+__pthread_init_specific (struct __pthread *thread)
+{
+  thread->thread_specifics = 0;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-key-create.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-key-create.c
@@ -0,0 +1,111 @@
+/* pthread_key_create.  Hurd version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <stdlib.h>
+#include <assert.h>
+
+#include <pt-internal.h>
+
+pthread_mutex_t __pthread_key_lock;
+
+void (**__pthread_key_destructors) (void *arg);
+int __pthread_key_size;
+int __pthread_key_count;
+int __pthread_key_invalid_count;
+
+int
+__pthread_key_create (pthread_key_t *key, void (*destructor) (void *))
+{
+  /* Where to look for the next key slot.  */
+  static int index;
+
+  __pthread_key_lock_ready ();
+
+  __pthread_mutex_lock (&__pthread_key_lock);
+
+ do_search:
+  /* Use the search hint and try to find a free slot.  */
+  for (; index < __pthread_key_count
+	 && __pthread_key_destructors[index] != PTHREAD_KEY_INVALID;
+       index ++)
+    ;
+
+  /* See if we actually found a free element.  */
+  if (index < __pthread_key_count)
+    {
+      assert (__pthread_key_destructors[index] == PTHREAD_KEY_INVALID);
+      assert (__pthread_key_invalid_count > 0);
+
+      __pthread_key_invalid_count --;
+      __pthread_key_destructors[index] = destructor;
+      *key = index ++;
+
+      __pthread_mutex_unlock (&__pthread_key_lock);
+      return 0;
+    }
+
+  assert (index == __pthread_key_count);
+
+  /* No space at the end.  */
+  if (__pthread_key_size == __pthread_key_count)
+    {
+      /* See if it is worth looking for a free element.  */
+      if (__pthread_key_invalid_count > 4
+	  && __pthread_key_invalid_count > __pthread_key_size / 8)
+	{
+	  index = 0;
+	  goto do_search;
+	}
+
+
+      /* Resize the array.  */
+      {
+	void *t;
+	int newsize;
+
+	if (__pthread_key_size == 0)
+	  newsize = 8;
+	else
+	  newsize = __pthread_key_size * 2;
+
+	t = realloc (__pthread_key_destructors,
+		     newsize * sizeof (*__pthread_key_destructors));
+	if (! t)
+	  {
+	    __pthread_mutex_unlock (&__pthread_key_lock);
+	    return ENOMEM;
+	  }
+
+	__pthread_key_size = newsize;
+	__pthread_key_destructors = t;
+      }
+    }
+
+  __pthread_key_destructors[index] = destructor;
+  *key = index;
+
+  index ++;
+  __pthread_key_count ++;
+
+  __pthread_mutex_unlock (&__pthread_key_lock);
+  return 0;
+}
+strong_alias (__pthread_key_create, pthread_key_create)
+hidden_def (__pthread_key_create)
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-key-delete.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-key-delete.c
@@ -0,0 +1,64 @@
+/* pthread_key_delete.  Hurd version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+int
+pthread_key_delete (pthread_key_t key)
+{
+  error_t err = 0;
+
+  __pthread_key_lock_ready ();
+
+  __pthread_mutex_lock (&__pthread_key_lock);
+
+  if (key < 0 || key >= __pthread_key_count
+      || __pthread_key_destructors[key] == PTHREAD_KEY_INVALID)
+    err = EINVAL;
+  else
+    {
+      int i;
+
+      __pthread_key_destructors[key] = PTHREAD_KEY_INVALID;
+      __pthread_key_invalid_count ++;
+
+      pthread_rwlock_rdlock (&__pthread_threads_lock);
+      for (i = 0; i < __pthread_num_threads; ++i)
+	{
+	  struct __pthread *t;
+
+	  t = __pthread_threads[i];
+
+	  if (t == NULL)
+	    continue;
+
+	  /* Just remove the key, no need to care whether it was
+	     already there. */
+	  if (t->thread_specifics)
+	    hurd_ihash_remove (t->thread_specifics, key);
+	}
+      pthread_rwlock_unlock (&__pthread_threads_lock);
+    }
+
+  __pthread_mutex_unlock (&__pthread_key_lock);
+
+  return err;
+}
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-key.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-key.h
@@ -0,0 +1,76 @@
+/* pthread_key internal declatations for the Hurd version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <hurd/ihash.h>
+
+#define PTHREAD_KEY_MEMBERS \
+  hurd_ihash_t thread_specifics;
+
+#define PTHREAD_KEY_INVALID (void *) (-1)
+
+
+/* __PTHREAD_KEY_DESTRUCTORS is an array of destructors with
+   __PTHREAD_KEY_SIZE elements.  If an element with index less than
+   __PTHREAD_KEY_COUNT is invalid, it shall contain the value
+   PTHREAD_KEY_INVALID which shall be distinct from NULL.  
+
+   Normally, we just add new keys to the end of the array and realloc
+   it as necessary.  The pthread_key_create routine may decide to
+   rescan the array if __PTHREAD_KEY_FREE is large.  */
+extern void (**__pthread_key_destructors) (void *arg);
+extern int __pthread_key_size;
+extern int __pthread_key_count;
+/* Number of invalid elements in the array.  Does not include elements
+   for which memory has been allocated but which have not yet been
+   used (i.e. those elements with indexes greater than
+   __PTHREAD_KEY_COUNT).  */
+extern int __pthread_key_invalid_count;
+
+/* Protects the above variables.  This must be a recursive lock: the
+   destructors may call pthread_key_delete.  */
+extern pthread_mutex_t __pthread_key_lock;
+
+#include <assert.h>
+
+static inline void
+__pthread_key_lock_ready (void)
+{
+  static pthread_once_t o = PTHREAD_ONCE_INIT;
+
+  void do_init (void)
+    {
+      int err;
+      pthread_mutexattr_t attr;
+
+      err = pthread_mutexattr_init (&attr);
+      assert_perror (err);
+
+      err = pthread_mutexattr_settype (&attr, PTHREAD_MUTEX_RECURSIVE);
+      assert_perror (err);
+
+      err = pthread_mutex_init (&__pthread_key_lock, &attr);
+      assert_perror (err);
+
+      err = pthread_mutexattr_destroy (&attr);
+      assert_perror (err);
+    }
+
+  pthread_once (&o, do_init);
+}
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-kill.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-kill.c
@@ -0,0 +1,52 @@
+/* pthread_kill.  Hurd version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+#include <signal.h>
+#include <hurd/signal.h>
+
+#include <pt-internal.h>
+
+int
+pthread_kill (pthread_t thread, int sig)
+{
+  struct __pthread *pthread;
+  struct hurd_signal_detail detail;
+  struct hurd_sigstate *ss;
+
+  /* Lookup the thread structure for THREAD.  */
+  pthread = __pthread_getid (thread);
+  if (pthread == NULL)
+    return ESRCH;
+
+  ss = _hurd_thread_sigstate (pthread->kernel_thread);
+  assert (ss);
+
+  if (!sig)
+    return 0;
+
+  detail.exc = 0;
+  detail.code = sig;
+  detail.error = 0;
+
+  _hurd_raise_signal (ss, sig, &detail);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/hurd/pt-setspecific.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/hurd/pt-setspecific.c
@@ -0,0 +1,48 @@
+/* pthread_setspecific.  Generic version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <hurd/ihash.h>
+
+#include <pt-internal.h>
+
+int
+__pthread_setspecific (pthread_key_t key, const void *value)
+{
+  error_t err;
+  struct __pthread *self = _pthread_self ();
+
+  if (key < 0 || key >= __pthread_key_count
+      || __pthread_key_destructors[key] == PTHREAD_KEY_INVALID)
+    return EINVAL;
+
+  if (! self->thread_specifics)
+    {
+      err = hurd_ihash_create (&self->thread_specifics, HURD_IHASH_NO_LOCP);
+      if (err)
+	return ENOMEM;
+    }
+
+  err = hurd_ihash_add (self->thread_specifics, key, (void *) value);
+  if (err)
+    return ENOMEM;
+      
+  return 0;
+}
+strong_alias (__pthread_setspecific, pthread_setspecific);
Index: glibc-2.21/libpthread/sysdeps/i386/bits/memory.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/i386/bits/memory.h
@@ -0,0 +1,40 @@
+/* Memory barrier operations.  i386 version.
+   Copyright (C) 2002, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_MEMORY_H
+#define _BITS_MEMORY_H	1
+
+/* Prevent read and write reordering across this function.  */
+static inline void
+__memory_barrier (void)
+{
+  int i;
+
+  /* Any lock'ed instruction will do.  We just do a simple
+     increment.  */
+  __asm__ __volatile ("lock; incl %0" : "=m" (i) : "m" (i) : "memory");
+}
+
+/* Prevent read reordering across this function.  */
+#define __memory_read_barrier __memory_barrier
+
+/* Prevent write reordering across this function.  */
+#define __memory_write_barrier __memory_barrier
+
+#endif
Index: glibc-2.21/libpthread/sysdeps/i386/bits/pt-atomic.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/i386/bits/pt-atomic.h
@@ -0,0 +1,66 @@
+/* Atomic operations.  i386 version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _BITS_ATOMIC_H
+#define _BITS_ATOMIC_H	1
+
+typedef __volatile int __atomic_t;
+
+static inline void
+__atomic_inc (__atomic_t *__var)
+{
+  __asm__ __volatile ("lock; incl %0" : "=m" (*__var) : "m" (*__var));
+}
+
+static inline void
+__atomic_dec (__atomic_t *__var)
+{
+  __asm__ __volatile ("lock; decl %0" : "=m" (*__var) : "m" (*__var));
+}
+
+static inline int
+__atomic_dec_and_test (__atomic_t *__var)
+{
+  unsigned char __ret;
+
+  __asm__ __volatile ("lock; decl %0; sete %1"
+		      : "=m" (*__var), "=qm" (__ret) : "m" (*__var));
+  return __ret != 0;
+}
+
+/* We assume that an __atomicptr_t is only used for pointers to
+   word-aligned objects, and use the lowest bit for a simple lock.  */
+typedef __volatile int * __atomicptr_t;
+
+/* Actually we don't implement that yet, and assume that we run on
+   something that has the i486 instruction set.  */
+static inline int
+__atomicptr_compare_and_swap (__atomicptr_t *__ptr, void *__oldval,
+			      void * __newval)
+{
+  char __ret;
+  int __dummy;
+
+  __asm__ __volatile ("lock; cmpxchgl %3, %1; sete %0"
+		      : "=q" (__ret), "=m" (*__ptr), "=a" (__dummy)
+		      : "r" (__newval), "m" (*__ptr), "a" (__oldval));
+  return __ret;
+}
+
+#endif
Index: glibc-2.21/libpthread/sysdeps/i386/bits/spin-lock.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/i386/bits/spin-lock.h
@@ -0,0 +1,39 @@
+/* Machine-specific definitions for spin locks.  i386 version.
+   Copyright (C) 2000, 2005, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Never include this file directly; use <pthread.h> or <cthreads.h> instead.
+ */
+
+#ifndef _BITS_SPIN_LOCK_H
+#define _BITS_SPIN_LOCK_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* The type of a spin lock object.  */
+typedef __volatile int __pthread_spinlock_t;
+
+/* Initializer for a spin lock object.  */
+# define __PTHREAD_SPIN_LOCK_INITIALIZER ((__pthread_spinlock_t) 0)
+
+__END_DECLS
+
+#endif /* bits/spin-lock.h */
Index: glibc-2.21/libpthread/sysdeps/i386/bits/spin-lock-inline.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/i386/bits/spin-lock-inline.h
@@ -0,0 +1,98 @@
+/* Machine-specific definitions for spin locks.  i386 version.
+   Copyright (C) 2000, 2005, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Never include this file directly; use <pthread.h> or <cthreads.h> instead.
+ */
+
+#ifndef _BITS_SPIN_LOCK_INLINE_H
+#define _BITS_SPIN_LOCK_INLINE_H	1
+
+#include <features.h>
+#include <bits/spin-lock.h>
+
+__BEGIN_DECLS
+
+#if defined __USE_EXTERN_INLINES || defined _FORCE_INLINES
+
+# ifndef __EBUSY
+#  include <errno.h>
+#  define __EBUSY EBUSY
+# endif
+
+# ifndef __PT_SPIN_INLINE
+#  define __PT_SPIN_INLINE __extern_inline
+# endif
+
+__PT_SPIN_INLINE int __pthread_spin_destroy (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_destroy (__pthread_spinlock_t *__lock)
+{
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_init (__pthread_spinlock_t *__lock,
+					  int __pshared);
+
+__PT_SPIN_INLINE int
+__pthread_spin_init (__pthread_spinlock_t *__lock, int __pshared)
+{
+  *__lock = __PTHREAD_SPIN_LOCK_INITIALIZER;
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_trylock (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_trylock (__pthread_spinlock_t *__lock)
+{
+  int __locked;
+  __asm__ __volatile ("xchgl %0, %1"
+		      : "=&r" (__locked), "=m" (*__lock) : "0" (1) : "memory");
+  return __locked ? __EBUSY : 0;
+}
+
+__extern_inline int __pthread_spin_lock (__pthread_spinlock_t *__lock);
+extern int _pthread_spin_lock (__pthread_spinlock_t *__lock);
+
+__extern_inline int
+__pthread_spin_lock (__pthread_spinlock_t *__lock)
+{
+  if (__pthread_spin_trylock (__lock))
+    return _pthread_spin_lock (__lock);
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_unlock (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_unlock (__pthread_spinlock_t *__lock)
+{
+  int __unlocked;
+  __asm__ __volatile ("xchgl %0, %1"
+		      : "=&r" (__unlocked), "=m" (*__lock) : "0" (0) : "memory");
+  return 0;
+}
+
+#endif /* Use extern inlines or force inlines.  */
+
+__END_DECLS
+
+#endif /* bits/spin-lock.h */
Index: glibc-2.21/libpthread/sysdeps/i386/machine-sp.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/i386/machine-sp.h
@@ -0,0 +1,30 @@
+/* Machine-specific function to return the stack pointer.  i386 version.
+   Copyright (C) 1994, 1997, 2001, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _MACHINE_SP_H
+#define _MACHINE_SP_H
+
+/* Return the current stack pointer.  */
+
+#define __thread_stack_pointer() ({					      \
+  register void *__sp__ asm("esp");					      \
+  __sp__;								      \
+})
+
+#endif	/* machine-sp.h */
Index: glibc-2.21/libpthread/sysdeps/i386/pt-machdep.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/i386/pt-machdep.h
@@ -0,0 +1,29 @@
+/* Machine dependent pthreads internal defenitions.  i386 version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_MACHDEP_H
+#define _PT_MACHDEP_H	1
+
+struct pthread_mcontext
+{
+  void *pc;
+  void *sp;
+};
+
+#endif /* pt-machdep.h */
Index: glibc-2.21/libpthread/sysdeps/mach/bits/spin-lock.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/bits/spin-lock.h
@@ -0,0 +1,38 @@
+/* Definitions of user-visible names for spin locks.
+   Copyright (C) 1994, 1997, 2002, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SPIN_LOCK_H
+#define _BITS_SPIN_LOCK_H	1
+
+#include <features.h>
+#include <machine-lock.h>	/* This does all the work.  */
+
+__BEGIN_DECLS
+
+/* The type of a spin lock object.  */
+typedef __spin_lock_t __pthread_spinlock_t;
+
+/* Initializer for a spin lock object.  */
+#ifndef __PTHREAD_SPIN_LOCK_INITIALIZER
+#error __PTHREAD_SPIN_LOCK_INITIALIZER undefined: should be defined by <lock-intern.h>.
+#endif
+
+__END_DECLS
+
+#endif /* bits/spin-lock.h */
Index: glibc-2.21/libpthread/sysdeps/mach/bits/spin-lock-inline.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/bits/spin-lock-inline.h
@@ -0,0 +1,90 @@
+/* Definitions of user-visible names for spin locks.
+   Copyright (C) 1994, 1997, 2002, 2008, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SPIN_LOCK_INLINE_H
+#define _BITS_SPIN_LOCK_INLINE_H	1
+
+#include <features.h>
+#include <bits/spin-lock.h>
+#include <machine-lock.h>	/* This does all the work.  */
+
+__BEGIN_DECLS
+
+#if defined __USE_EXTERN_INLINES || defined _FORCE_INLINES
+
+# ifndef __EBUSY
+#  include <errno.h>
+#  define __EBUSY EBUSY
+# endif
+
+# ifndef __PT_SPIN_INLINE
+#  define __PT_SPIN_INLINE __extern_inline
+# endif
+
+__PT_SPIN_INLINE int __pthread_spin_destroy (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_destroy (__pthread_spinlock_t *__lock)
+{
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_init (__pthread_spinlock_t *__lock,
+					  int __pshared);
+
+__PT_SPIN_INLINE int
+__pthread_spin_init (__pthread_spinlock_t *__lock, int __pshared)
+{
+  *__lock = __PTHREAD_SPIN_LOCK_INITIALIZER;
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_trylock (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_trylock (__pthread_spinlock_t *__lock)
+{
+  return __spin_try_lock (__lock) ? 0 : __EBUSY;
+}
+
+__extern_inline int __pthread_spin_lock (__pthread_spinlock_t *__lock);
+extern int _pthread_spin_lock (__pthread_spinlock_t *__lock);
+
+__extern_inline int
+__pthread_spin_lock (__pthread_spinlock_t *__lock)
+{
+  if (__pthread_spin_trylock (__lock))
+    return _pthread_spin_lock (__lock);
+  return 0;
+}
+
+__PT_SPIN_INLINE int __pthread_spin_unlock (__pthread_spinlock_t *__lock);
+
+__PT_SPIN_INLINE int
+__pthread_spin_unlock (__pthread_spinlock_t *__lock)
+{
+  __spin_unlock (__lock);
+  return 0;
+}
+
+#endif /* Use extern inlines or force inlines.  */
+
+__END_DECLS
+
+#endif /* bits/spin-lock.h */
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/bits/pthread-np.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/bits/pthread-np.h
@@ -0,0 +1,38 @@
+/* Non-portable functions. Hurd on Mach version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/*
+ * Never include this file directly; use <pthread.h> or <cthreads.h> instead.
+ */
+
+#ifndef _BITS_PTHREAD_NP_H
+#define _BITS_PTHREAD_NP_H	1
+
+/* Same as pthread_cond_wait, but for Hurd-specific cancellation.
+   See hurd_thread_cancel.  */
+extern int pthread_hurd_cond_wait_np (pthread_cond_t *__restrict __cond,
+				      pthread_mutex_t *__restrict __mutex);
+
+/* Same as pthread_cond_timedwait, but for Hurd-specific cancellation.
+   See hurd_thread_cancel.  */
+extern int pthread_hurd_cond_timedwait_np (pthread_cond_t *__restrict __cond,
+					   pthread_mutex_t *__restrict __mutex,
+					   const struct timespec *abstime);
+
+#endif /* bits/pthread-np.h */
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/i386/pt-machdep.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/i386/pt-machdep.c
@@ -0,0 +1,83 @@
+/* Machine dependent pthreads code.  Hurd/i386 version.
+   Copyright (C) 2000, 2002, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+
+#include <mach.h>
+#include <mach/i386/thread_status.h>
+#include <mach/i386/mach_i386.h>
+#include <mach/mig_errors.h>
+#include <mach/thread_status.h>
+
+#define HURD_TLS_DESC_DECL(desc, tcb)					      \
+  struct descriptor desc =						      \
+    {				/* low word: */				      \
+      0xffff			/* limit 0..15 */			      \
+      | (((unsigned int) (tcb)) << 16) /* base 0..15 */			      \
+      ,				/* high word: */			      \
+      ((((unsigned int) (tcb)) >> 16) & 0xff) /* base 16..23 */		      \
+      | ((0x12 | 0x60 | 0x80) << 8) /* access = ACC_DATA_W|ACC_PL_U|ACC_P */  \
+      | (0xf << 16)		/* limit 16..19 */			      \
+      | ((4 | 8) << 20)		/* granularity = SZ_32|SZ_G */		      \
+      | (((unsigned int) (tcb)) & 0xff000000) /* base 24..31 */		      \
+    }
+
+int
+__thread_set_pcsptp (thread_t thread,
+		   int set_ip, void *ip,
+		   int set_sp, void *sp,
+		   int set_tp, void *tp)
+{
+  error_t err;
+  struct i386_thread_state state;
+  mach_msg_type_number_t state_count;
+
+  state_count = i386_THREAD_STATE_COUNT;
+
+  err = __thread_get_state (thread, i386_REGS_SEGS_STATE,
+			    (thread_state_t) &state, &state_count);
+  if (err)
+    return err;
+
+  if (set_sp)
+    state.uesp = (unsigned int) sp;
+  if (set_ip)
+    state.eip = (unsigned int) ip;
+  if (set_tp) {
+    HURD_TLS_DESC_DECL(desc, tp);
+    int sel;
+
+    asm ("mov %%gs, %w0" : "=q" (sel) : "0" (0));
+    if (__builtin_expect (sel, 0x48) & 4) /* LDT selector */
+      err = __i386_set_ldt (thread, sel, &desc, 1);
+    else
+      err = __i386_set_gdt (thread, &sel, desc);
+    if (err)
+      return err;
+    state.gs = sel;
+  }
+
+  err = __thread_set_state (thread, i386_REGS_SEGS_STATE,
+			    (thread_state_t) &state,
+			    i386_THREAD_STATE_COUNT);
+  if (err)
+    return err;
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/i386/pt-setup.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/i386/pt-setup.c
@@ -0,0 +1,110 @@
+/* Setup thread stack.  Hurd/i386 version.
+   Copyright (C) 2000, 2002, 2005, 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <stdint.h>
+#include <assert.h>
+#include <mach.h>
+
+#include <pt-internal.h>
+
+/* The stack layout used on the i386 is:
+
+    -----------------
+   |  ARG            |
+    -----------------
+   |  START_ROUTINE  |
+    -----------------
+   |  0              |
+    -----------------
+ */
+
+/* Set up the stack for THREAD, such that it appears as if
+   START_ROUTINE and ARG were passed to the new thread's entry-point.
+   Return the stack pointer for the new thread.  */
+static void *
+stack_setup (struct __pthread *thread,
+	     void *(*start_routine)(void *), void *arg)
+{
+  error_t err;
+  uintptr_t *bottom, *top;
+
+  /* Calculate the top of the new stack.  */
+  bottom = thread->stackaddr;
+  top = (uintptr_t *) ((uintptr_t) bottom + thread->stacksize
+        + ((thread->guardsize + __vm_page_size-1)
+	   / __vm_page_size) * __vm_page_size);
+
+  if (start_routine)
+    {
+      /* And then the call frame.  */
+      top -= 3;
+      top = (uintptr_t *) ((uintptr_t) top & ~0xf);
+      top[2] = (uintptr_t) arg;	/* Argument to START_ROUTINE.  */
+      top[1] = (uintptr_t) start_routine;
+      top[0] = (uintptr_t) thread;
+      *--top = 0;		/* Fake return address.  */
+    }
+
+  if (thread->guardsize)
+    {
+      err = __vm_protect (__mach_task_self (), (vm_address_t) bottom,
+			  thread->guardsize, 0, 0);
+      assert_perror (err);
+    }
+
+  return top;
+}
+
+int
+__pthread_setup (struct __pthread *thread,
+		 void (*entry_point)(struct __pthread *, void *(*)(void *), void *),
+		 void *(*start_routine)(void *), void *arg)
+{
+  tcbhead_t *tcb;
+  error_t err;
+  mach_port_t ktid;
+
+  thread->mcontext.pc = entry_point;
+  thread->mcontext.sp = stack_setup (thread, start_routine, arg);
+
+  ktid = __mach_thread_self ();
+  if (thread->kernel_thread == ktid)
+    /* Fix up the TCB for the main thread.  The C library has already
+       installed a TCB, which we want to keep using.  This TCB must not
+       be freed so don't register it in the thread structure.  On the
+       other hand, it's not yet possible to reliably release a TCB.
+       Leave the unused one registered so that it doesn't leak.  The
+       only thing left to do is to correctly set the `self' member in
+       the already existing TCB.  */
+    tcb = THREAD_SELF;
+  else
+    {
+      err = __thread_set_pcsptp (thread->kernel_thread,
+			       1, thread->mcontext.pc,
+			       1, thread->mcontext.sp,
+			       1, thread->tcb);
+      assert_perror (err);
+      tcb = thread->tcb;
+    }
+  __mach_port_deallocate (__mach_task_self (), ktid);
+
+  tcb->self = thread->kernel_thread;
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/Implies
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/Implies
@@ -0,0 +1,2 @@
+hurd
+pthread
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-attr-setstackaddr.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-attr-setstackaddr.c
@@ -0,0 +1,29 @@
+/* pthread_attr_setstackaddr.  Hurd on Mach version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_setstackaddr (pthread_attr_t *attr,
+			   void *stackaddr)
+{
+  attr->__stackaddr = stackaddr;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-attr-setstacksize.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-attr-setstacksize.c
@@ -0,0 +1,29 @@
+/* pthread_attr_setstacksize.  Hurd on Mach version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+int
+pthread_attr_setstacksize (pthread_attr_t *attr,
+			   size_t stacksize)
+{
+  attr->__stacksize = stacksize;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-docancel.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-docancel.c
@@ -0,0 +1,66 @@
+/* Cancel a thread.
+   Copyright (C) 2002, 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+static void
+call_exit (void)
+{
+  pthread_exit (0);
+}
+
+int
+__pthread_do_cancel (struct __pthread *p)
+{
+  mach_port_t ktid;
+  int me;
+
+  assert (p->cancel_pending == 1);
+  assert (p->cancel_state == PTHREAD_CANCEL_ENABLE);
+
+  __pthread_mutex_unlock (&p->cancel_lock);
+
+  ktid = __mach_thread_self ();
+  me = p->kernel_thread == ktid;
+  __mach_port_deallocate (__mach_task_self (), ktid);
+
+  if (me)
+    call_exit ();
+  else
+    {
+      error_t err;
+      
+      err = __thread_suspend (p->kernel_thread);
+      assert_perror (err);
+
+      err = __thread_abort (p->kernel_thread);
+      assert_perror (err);
+
+      err = __thread_set_pcsptp (p->kernel_thread,
+			       1, (void *) call_exit, 0, 0, 0, 0);
+      assert_perror (err);
+
+      err = __thread_resume (p->kernel_thread);
+      assert_perror (err);
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-hurd-cond-timedwait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-hurd-cond-timedwait.c
@@ -0,0 +1,169 @@
+/* pthread_hurd_cond_timedwait_np.  Hurd-specific wait on a condition.
+   Copyright (C) 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+#include <hurd/signal.h>
+
+#include <pt-internal.h>
+
+extern int __pthread_hurd_cond_timedwait_internal (pthread_cond_t *cond,
+						   pthread_mutex_t *mutex,
+						   const struct timespec *abstime);
+
+int
+__pthread_hurd_cond_timedwait_np (pthread_cond_t *cond,
+				  pthread_mutex_t *mutex,
+				  const struct timespec *abstime)
+{
+  return __pthread_hurd_cond_timedwait_internal (cond, mutex, abstime);
+}
+
+strong_alias (__pthread_hurd_cond_timedwait_np, pthread_hurd_cond_timedwait_np);
+
+int
+__pthread_hurd_cond_timedwait_internal (pthread_cond_t *cond,
+					pthread_mutex_t *mutex,
+					const struct timespec *abstime)
+{
+  struct hurd_sigstate *ss = _hurd_self_sigstate ();
+  struct __pthread *self = _pthread_self ();
+  error_t err = 0;
+  int cancel, drain;
+  clockid_t clock_id = __pthread_default_condattr.__clock;
+
+  /* This function will be called by hurd_thread_cancel while we are blocked
+     We wake up our thread if it's still blocking or about to block, so it will
+     progress and notice the cancellation flag.  */
+  void cancel_me (void)
+    {
+      int unblock;
+
+      __pthread_spin_lock (&cond->__lock);
+      /* The thread only needs to be awaken if it's blocking or about to block.
+	 If it was already unblocked, it's not queued any more.  */
+      unblock = self->prevp != NULL;
+      if (unblock)
+	__pthread_dequeue (self);
+      __pthread_spin_unlock (&cond->__lock);
+
+      if (unblock)
+	__pthread_wakeup (self);
+    }
+
+  assert (ss->intr_port == MACH_PORT_NULL); /* Sanity check for signal bugs. */
+
+  if (abstime && (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000))
+    return EINVAL;
+
+  /* Atomically enqueue our thread on the condition variable's queue of
+     waiters, and mark our sigstate to indicate that `cancel_me' must be
+     called to wake us up.  We must hold the sigstate lock while acquiring
+     the condition variable's lock and tweaking it, so that
+     hurd_thread_cancel can never suspend us and then deadlock waiting for
+     the condition variable's lock.  */
+
+  __spin_lock (&ss->lock);
+  __pthread_spin_lock (&cond->__lock);
+  cancel = ss->cancel;
+  if (cancel)
+    /* We were cancelled before doing anything.  Don't block at all.  */
+    ss->cancel = 0;
+  else
+    {
+      /* Put us on the queue so that pthread_cond_broadcast will know to wake
+         us up.  */
+      __pthread_enqueue (&cond->__queue, self);
+      if (cond->__attr)
+	clock_id = cond->__attr->__clock;
+      /* Tell hurd_thread_cancel how to unblock us.  */
+      ss->cancel_hook = &cancel_me;
+    }
+  __pthread_spin_unlock (&cond->__lock);
+  __spin_unlock (&ss->lock);
+
+  if (cancel)
+    {
+      /* Cancelled on entry.  Just leave the mutex locked.  */
+      mutex = NULL;
+
+      __spin_lock (&ss->lock);
+    }
+  else
+    {
+      /* Release MUTEX before blocking.  */
+      __pthread_mutex_unlock (mutex);
+
+      /* Block the thread.  */
+      if (abstime)
+	err = __pthread_timedblock (self, abstime, clock_id);
+      else
+	{
+	  err = 0;
+	  __pthread_block (self);
+	}
+
+      /* As it was done when enqueueing, prevent hurd_thread_cancel from
+	 suspending us while the condition lock is held.  */
+      __spin_lock (&ss->lock);
+      __pthread_spin_lock (&cond->__lock);
+      if (! self->prevp)
+	/* Another thread removed us from the list of waiters, which means
+	   a wakeup message has been sent.  It was either consumed while
+	   we were blocking, or queued after we timed out and before we
+	   acquired the condition lock, in which case the message queue
+	   must be drained.  */
+	drain = err ? 1 : 0;
+      else
+	{
+	  /* We're still in the list of waiters.  Noone attempted to wake us
+	     up, i.e. we timed out.  */
+	  __pthread_dequeue (self);
+	  drain = 0;
+	}
+      __pthread_spin_unlock (&cond->__lock);
+
+      if (drain)
+	__pthread_block (self);
+    }
+
+  /* Clear the hook, now that we are done blocking.  */
+  ss->cancel_hook = NULL;
+  /* Check the cancellation flag; we might have unblocked due to
+     cancellation rather than a normal pthread_cond_signal or
+     pthread_cond_broadcast (or we might have just happened to get cancelled
+     right after waking up).  */
+  cancel |= ss->cancel;
+  ss->cancel = 0;
+  __spin_unlock (&ss->lock);
+
+  if (mutex)
+    /* Reacquire the mutex and return.  */
+    __pthread_mutex_lock (mutex);
+
+  if (cancel)
+    return EINTR;
+  else if (err)
+    {
+      assert (err == ETIMEDOUT);
+      return err;
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-hurd-cond-wait.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-hurd-cond-wait.c
@@ -0,0 +1,41 @@
+/* pthread_hurd_cond_wait.  Hurd-specific wait on a condition.
+   Copyright (C) 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+#include <hurd/signal.h>
+
+#include <pt-internal.h>
+
+/* Implemented in pt-hurd-cond-timedwait.c.  */
+extern int __pthread_hurd_cond_timedwait_internal (pthread_cond_t *cond,
+						   pthread_mutex_t *mutex,
+						   const struct timespec *abstime);
+
+int
+__pthread_hurd_cond_wait_np (pthread_cond_t *cond,
+			     pthread_mutex_t *mutex)
+{
+  error_t err;
+
+  err = __pthread_hurd_cond_timedwait_internal (cond, mutex, NULL);
+  return (err == EINTR);
+}
+
+strong_alias (__pthread_hurd_cond_wait_np, pthread_hurd_cond_wait_np);
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sigstate.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sigstate.c
@@ -0,0 +1,69 @@
+/* Set a thread's signal state.  Hurd on Mach version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <assert.h>
+#include <signal.h>
+#include <hurd/signal.h>
+
+#include <pt-internal.h>
+
+error_t
+__pthread_sigstate (struct __pthread *thread, int how,
+		    const sigset_t *set, sigset_t *oset,
+		    int clear_pending)
+{
+  error_t err = 0;
+  struct hurd_sigstate *ss;
+
+  ss = _hurd_thread_sigstate (thread->kernel_thread);
+  assert (ss);
+
+  __pthread_spin_lock (&ss->lock);
+
+  if (oset)
+    *oset = ss->blocked;
+
+  if (set)
+    switch (how)
+      {
+      case SIG_BLOCK:
+	ss->blocked |= *set;
+	break;
+
+      case SIG_SETMASK:
+	ss->blocked = *set;
+	break;
+
+      case SIG_UNBLOCK:
+	ss->blocked &= ~*set;
+	break;
+
+      default:
+	err = EINVAL;
+	break;
+      }
+
+  if (! err && clear_pending)
+    __sigemptyset (&ss->pending);
+
+  __pthread_spin_unlock (&ss->lock);
+
+  return err;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sigstate-destroy.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sigstate-destroy.c
@@ -0,0 +1,28 @@
+/* Destroy the signal state.  Hurd on Mach version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+
+#include <pt-internal.h>
+
+void
+__pthread_sigstate_destroy (struct __pthread *thread)
+{
+  _hurd_sigstate_delete (thread->kernel_thread);
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sigstate-init.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sigstate-init.c
@@ -0,0 +1,44 @@
+/* Initialize the signal state.  Hurd on Mach version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <pt-internal.h>
+
+error_t
+__pthread_sigstate_init (struct __pthread *thread)
+{
+  static int do_init_global;
+
+  /* Mark the thread as a global signal receiver so as to conform with
+     the pthread semantics.  However, we must be careful.  The first
+     pthread created is the main thread, during libpthread initialization.
+     We must not mark it, otherwise the sigprocmask call in
+     __pthread_create would try to access _hurd_global_sigstate,
+     which is not initialized yet.  When glibc runs _hurdsig_init later
+     on, the message thread is created, which must not be marked either.  */
+  if (do_init_global)
+    {
+      struct hurd_sigstate *ss = _hurd_thread_sigstate (thread->kernel_thread);
+      _hurd_sigstate_set_global_rcv (ss);
+    }
+  else if (__pthread_num_threads >= 2)
+    do_init_global = 1;
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sysdep.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sysdep.c
@@ -0,0 +1,98 @@
+/* System dependent pthreads code.  Hurd version.
+   Copyright (C) 2000, 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <stddef.h>
+#include <stdint.h>
+
+#include <mach.h>
+#include <mach/mig_support.h>
+
+#include <pt-internal.h>
+
+__thread struct __pthread *___pthread_self;
+
+/* Forward.  */
+static void *init_routine (void);
+
+/* OK, the name of this variable isn't really appropriate, but I don't
+   want to change it yet.  */
+void *(*_cthread_init_routine)(void) = &init_routine;
+
+/* This function is called from the Hurd-specific startup code.  It
+   should return a new stack pointer for the main thread.  The caller
+   will switch to this new stack before doing anything serious.  */
+static void *
+_init_routine (void *stack)
+{
+  struct __pthread *thread;
+  int err;
+  pthread_attr_t attr, *attrp = 0;
+
+  if (__pthread_threads)
+    /* Already initialized */
+    return 0;
+
+  /* Initialize the library.  */
+  ___pthread_init ();
+
+  if (stack)
+    {
+      /* We are getting initialized due to dlopening a library using libpthread
+	 while the main program was not linked against libpthread.  */
+      /* Avoid allocating another stack */
+      attrp = &attr;
+      pthread_attr_init(attrp);
+      pthread_attr_setstack(attrp, stack, __vm_page_size);
+    }
+
+  /* Create the pthread structure for the main thread (i.e. us).  */
+  err = __pthread_create_internal (&thread, attrp, 0, 0);
+  assert_perror (err);
+
+  /* XXX The caller copies the command line arguments and the environment
+     to the new stack.  Pretend it wasn't allocated so that it remains
+     valid if the main thread terminates.  */
+  thread->stack = 0;
+
+  ___pthread_self = thread;
+
+  /* Decrease the number of threads, to take into account that the
+     signal thread (which will be created by the glibc startup code
+     when we return from here) shouldn't be seen as a user thread.  */
+  __pthread_total--;
+
+  /* Make MiG code thread aware.  */
+  __mig_init (thread->stackaddr);
+
+  return thread->mcontext.sp;
+}
+
+static void *
+init_routine (void)
+{
+  return _init_routine (0);
+}
+
+#ifdef SHARED
+__attribute__ ((constructor)) static void dynamic_init_routine(void)
+{
+  _init_routine (__libc_stack_end);
+}
+#endif
Index: glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sysdep.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/hurd/pt-sysdep.h
@@ -0,0 +1,67 @@
+/* Internal defenitions for pthreads library.
+   Copyright (C) 2000, 2002, 2007, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef _PT_SYSDEP_H
+#define _PT_SYSDEP_H	1
+
+#include <mach.h>
+
+/* XXX */
+#define _POSIX_THREAD_THREADS_MAX	64
+
+/* The default stack size.  */
+#define PTHREAD_STACK_DEFAULT	(2 * 1024 * 1024)
+
+#define PTHREAD_SYSDEP_MEMBERS \
+  thread_t kernel_thread;      \
+  mach_msg_header_t wakeupmsg;
+
+extern __thread struct __pthread *___pthread_self;
+#define _pthread_self()                                            \
+	({                                                         \
+	  struct __pthread *thread;                                \
+	                                                           \
+	  assert (__pthread_threads);                              \
+	  thread = ___pthread_self;                                \
+	                                                           \
+	  assert (thread);                                         \
+	  assert (({ mach_port_t ktid = __mach_thread_self ();     \
+                     int ok = thread->kernel_thread == ktid;       \
+                     __mach_port_deallocate (__mach_task_self (), ktid);\
+                     ok; }));                                      \
+          thread;                                                  \
+         })
+
+extern inline void
+__attribute__((__always_inline__))
+__pthread_stack_dealloc (void *stackaddr, size_t stacksize)
+{
+  __vm_deallocate (__mach_task_self (), (vm_offset_t) stackaddr, stacksize);
+}
+
+/* Change thread THREAD's program counter to PC if SET_PC is true,
+   its stack pointer to SP if SET_IP is true, and its thread pointer
+   to TP if SET_TP is true.  */
+extern int __thread_set_pcsptp (thread_t thread,
+			      int set_pc, void *pc,
+			      int set_sp, void *sp,
+			      int set_tp, void *tp);
+
+
+#endif /* pt-sysdep.h */
Index: glibc-2.21/libpthread/sysdeps/mach/pt-block.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-block.c
@@ -0,0 +1,39 @@
+/* Block a thread.  Mach version.
+   Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <mach.h>
+#include <mach/message.h>
+
+#include <pt-internal.h>
+
+/* Block THREAD.  */
+void
+__pthread_block (struct __pthread *thread)
+{
+  mach_msg_header_t msg;
+  error_t err;
+
+  err = __mach_msg (&msg, MACH_RCV_MSG, 0, sizeof msg,
+		    thread->wakeupmsg.msgh_remote_port,
+		    MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
+  assert_perror (err);
+}
Index: glibc-2.21/libpthread/sysdeps/mach/pt-spin.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-spin.c
@@ -0,0 +1,36 @@
+/* Spin locks.  Mach version.
+   Copyright (C) 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <machine-lock.h>
+
+/* In glibc.  */
+extern void __spin_lock_solid (__pthread_spinlock_t *lock);
+
+/* Lock the spin lock object LOCK.  If the lock is held by another
+   thread spin until it becomes available.  */
+int
+_pthread_spin_lock (__pthread_spinlock_t *lock)
+{
+  __spin_lock_solid (lock);
+  return 0;
+}
+
+weak_alias (_pthread_spin_lock, pthread_spin_lock);
+weak_alias (_pthread_spin_lock, __pthread_spin_lock);
Index: glibc-2.21/libpthread/sysdeps/mach/pt-stack-alloc.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-stack-alloc.c
@@ -0,0 +1,69 @@
+/* Allocate a new stack.  Mach version.
+   Copyright (C) 2000,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+
+#include <mach.h>
+#include <mach/machine/vm_param.h>
+
+#include <pt-internal.h>
+
+/* The next address to use for stack allocation.  */
+static vm_address_t next_stack_base = VM_MIN_ADDRESS;
+
+
+/* Allocate a new stack of size STACKSIZE.  If successful, store the
+   address of the newly allocated stack in *STACKADDR and return 0.
+   Otherwise return an error code (EINVAL for an invalid stack size,
+   EAGAIN if the system lacked the necessary resources to allocate a
+   new stack).  */
+int
+__pthread_stack_alloc (void **stackaddr, size_t stacksize)
+{
+  vm_offset_t base;
+  int i = 0;
+
+ get_stack:
+  i ++;
+  for (base = next_stack_base;
+       base < VM_MAX_ADDRESS
+	 && __vm_allocate (__mach_task_self (), &base,
+			   stacksize, FALSE) != KERN_SUCCESS;
+       base += stacksize)
+    ;
+
+  if (base >= VM_MAX_ADDRESS)
+    {
+      if (i == 1)
+	{
+	  next_stack_base = VM_MIN_ADDRESS;
+	  goto get_stack;
+	}
+      else
+	return EAGAIN;
+    }
+
+  if (base >= VM_MAX_ADDRESS)
+    return EAGAIN;
+
+  next_stack_base = base + stacksize;
+
+  (*stackaddr) = (void *) base;
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/pt-thread-alloc.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-thread-alloc.c
@@ -0,0 +1,95 @@
+/* Start thread.  Mach version.
+   Copyright (C) 2000, 2002, 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <string.h>
+
+#include <mach.h>
+
+#include <pt-internal.h>
+
+/* Prepare a wakeup message.  */
+static error_t
+create_wakeupmsg (struct __pthread *thread)
+{
+  kern_return_t err;
+
+  /* Build wakeup message.  */
+  thread->wakeupmsg.msgh_bits = MACH_MSGH_BITS (MACH_MSG_TYPE_COPY_SEND, 0);
+  thread->wakeupmsg.msgh_size = 0;
+
+  err = __mach_port_allocate (__mach_task_self (), MACH_PORT_RIGHT_RECEIVE,
+			      &thread->wakeupmsg.msgh_remote_port);
+  if (err)
+    return EAGAIN;
+
+  thread->wakeupmsg.msgh_local_port = MACH_PORT_NULL;
+  thread->wakeupmsg.msgh_seqno = 0;
+  thread->wakeupmsg.msgh_id = 0;
+
+  err = __mach_port_insert_right (__mach_task_self (),
+				  thread->wakeupmsg.msgh_remote_port,
+				  thread->wakeupmsg.msgh_remote_port,
+				  MACH_MSG_TYPE_MAKE_SEND);
+  if (err)
+    {
+      __mach_port_destroy (__mach_task_self (),
+			   thread->wakeupmsg.msgh_remote_port);
+      return EAGAIN;
+    }
+
+  /* No need to queue more than one wakeup message on this port.  */
+  mach_port_set_qlimit (__mach_task_self (),
+			thread->wakeupmsg.msgh_remote_port, 1);
+
+  return 0;
+}
+
+/* Allocate any resouces for THREAD.  The new kernel thread should not
+   be eligible to be scheduled.  */
+int
+__pthread_thread_alloc (struct __pthread *thread)
+{
+  static int do_create;
+  error_t err;
+
+  err = create_wakeupmsg (thread);
+  if (err)
+    return err;
+
+  if (! do_create)
+    {
+      assert (__pthread_total == 0);
+      thread->kernel_thread = __mach_thread_self ();
+      do_create = 1;
+    }
+  else
+    {
+      err = __thread_create (__mach_task_self (), &thread->kernel_thread);
+      if (err)
+	{
+	  __mach_port_destroy (__mach_task_self (),
+			       thread->wakeupmsg.msgh_remote_port);
+	  return EAGAIN;
+	}
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/pt-thread-start.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-thread-start.c
@@ -0,0 +1,51 @@
+/* Start thread.  Mach version.
+   Copyright (C) 2000,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <mach.h>
+
+#include <pt-internal.h>
+
+/* Start THREAD.  Get the kernel thread scheduled and running.  */
+int
+__pthread_thread_start (struct __pthread *thread)
+{
+  static int do_start;
+  error_t err;
+
+  if (! do_start)
+    {
+      /* The main thread is already running: do nothing.  */
+      assert (__pthread_total == 1);
+      assert (({ mach_port_t ktid = __mach_thread_self ();
+                 int ok = thread->kernel_thread == ktid;
+                 __mach_port_deallocate (__mach_task_self (),
+					 thread->kernel_thread);
+		 ok; }));
+      do_start = 1;
+    }
+  else
+    {
+      err = __thread_resume (thread->kernel_thread);
+      assert_perror (err);
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/pt-thread-terminate.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-thread-terminate.c
@@ -0,0 +1,85 @@
+/* Deallocate the kernel thread resources.  Mach version.
+   Copyright (C) 2000, 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <mach.h>
+
+#include <mach/mig_support.h>
+
+#include <pt-internal.h>
+
+/* Terminate the kernel thread associated with THREAD, and deallocate its
+   right reference and its stack.  The function also drops a reference
+   on THREAD.  */
+void
+__pthread_thread_terminate (struct __pthread *thread)
+{
+  thread_t kernel_thread, self_ktid;
+  mach_port_t wakeup_port, reply_port;
+  void *stackaddr;
+  size_t stacksize;
+  error_t err;
+
+  kernel_thread = thread->kernel_thread;
+
+  if (thread->stack)
+    {
+      stackaddr = thread->stackaddr;
+      stacksize = ((thread->guardsize + __vm_page_size-1)
+		  / __vm_page_size) * __vm_page_size
+		  + thread->stacksize;
+    }
+  else
+    {
+      stackaddr = NULL;
+      stacksize = 0;
+    }
+
+  wakeup_port = thread->wakeupmsg.msgh_remote_port;
+
+  /* Each thread has its own reply port, allocated from MiG stub code calling
+     __mig_get_reply_port.  Destroying it is a bit tricky because the calls
+     involved are also RPCs, causing the creation of a new reply port if
+     currently null. The __thread_terminate_release call is actually a one way
+     simple routine designed not to require a reply port.  */
+  self_ktid = __mach_thread_self ();
+  reply_port = (self_ktid == kernel_thread)
+	       ? __mig_get_reply_port ()
+	       : MACH_PORT_NULL;
+  __mach_port_deallocate (__mach_task_self (), self_ktid);
+
+  /* Finally done with the thread structure.  */
+  __pthread_dealloc (thread);
+
+  /* The wake up port is now no longer needed.  */
+  __mach_port_destroy (__mach_task_self (), wakeup_port);
+
+  /* Terminate and release all that's left.  */
+  err = __thread_terminate_release (kernel_thread, mach_task_self (),
+				    kernel_thread, reply_port,
+				    stackaddr, stacksize);
+
+  /* The kernel does not support it yet.  Leak but at least terminate
+     correctly.  */
+  err = __thread_terminate (kernel_thread);
+
+  /* We are out of luck.  */
+  assert_perror (err);
+}
Index: glibc-2.21/libpthread/sysdeps/mach/pt-timedblock.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-timedblock.c
@@ -0,0 +1,68 @@
+/* Block a thread with a timeout.  Mach version.
+   Copyright (C) 2000, 2002, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <time.h>
+#include <sys/time.h>
+
+#include <mach.h>
+#include <mach/message.h>
+
+#include <pt-internal.h>
+
+/* Block THREAD.  */
+error_t
+__pthread_timedblock (struct __pthread *thread,
+		      const struct timespec *abstime,
+		      clockid_t clock_id)
+{
+  error_t err;
+  mach_msg_header_t msg;
+  mach_msg_timeout_t timeout;
+  struct timespec now;
+
+  /* We have an absolute time and now we have to convert it to a
+     relative time.  Arg.  */
+
+  err = clock_gettime (clock_id, &now);
+  assert (! err);
+
+  if (now.tv_sec > abstime->tv_sec
+      || (now.tv_sec == abstime->tv_sec
+	  && now.tv_nsec > abstime->tv_nsec))
+    return ETIMEDOUT;
+
+  timeout = (abstime->tv_sec - now.tv_sec) * 1000;
+
+  if (abstime->tv_nsec >= now.tv_nsec)
+    timeout += (abstime->tv_nsec - now.tv_nsec + 999999) / 1000000;
+  else
+    /* Need to do a carry.  */
+    timeout -= (now.tv_nsec - abstime->tv_nsec + 999999) / 1000000;
+
+  err = __mach_msg (&msg, MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0,
+		    sizeof msg, thread->wakeupmsg.msgh_remote_port,
+		    timeout, MACH_PORT_NULL);
+  if (err == EMACH_RCV_TIMED_OUT)
+    return ETIMEDOUT;
+
+  assert_perror (err);
+  return 0;
+}
Index: glibc-2.21/libpthread/sysdeps/mach/pt-wakeup.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/mach/pt-wakeup.c
@@ -0,0 +1,38 @@
+/* Wakeup a thread.  Mach version.
+   Copyright (C) 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <mach.h>
+#include <mach/message.h>
+
+#include <pt-internal.h>
+
+/* Wakeup THREAD.  */
+void
+__pthread_wakeup (struct __pthread *thread)
+{
+  error_t err;
+  
+  err = __mach_msg (&thread->wakeupmsg, MACH_SEND_MSG | MACH_SEND_TIMEOUT,
+		    sizeof (thread->wakeupmsg), 0, MACH_PORT_NULL,
+		    0 , MACH_PORT_NULL);
+  assert_perror (err);
+}
Index: glibc-2.21/libpthread/sysdeps/posix/pt-spin.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/posix/pt-spin.c
@@ -0,0 +1,54 @@
+/* Spin locks.
+   Copyright (C) 2000, 2004, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <sched.h>
+
+/* The default for single processor machines; don't spin, it's
+   pointless.  */
+#ifndef __PTHREAD_SPIN_COUNT
+# define __PTHREAD_SPIN_COUNT 1
+#endif
+
+/* The number of times to spin while trying to lock a spin lock object
+   before yielding the processor. */
+int __pthread_spin_count = __PTHREAD_SPIN_COUNT;
+
+
+/* Lock the spin lock object LOCK.  If the lock is held by another
+   thread spin until it becomes available.  */
+int
+_pthread_spin_lock (__pthread_spinlock_t *lock)
+{
+  int i;
+
+  while (1)
+    {
+      for (i = 0; i < __pthread_spin_count; i++)
+	{
+	  if (__pthread_spin_trylock (lock) == 0)
+	    return 0;
+	}
+
+      __sched_yield ();
+    }
+}
+
+weak_alias (_pthread_spin_lock, pthread_spin_lock);
+weak_alias (_pthread_spin_lock, __pthread_spin_lock);
Index: glibc-2.21/libpthread/sysdeps/pthread/Makefile
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/Makefile
@@ -0,0 +1,4 @@
+ifeq ($(subdir),posix)
+  # FIXME: this is not getting $(pthread-version) from libpthread/Makefile!
+CFLAGS-confstr.c += -DLIBPTHREAD_VERSION='"libpthread $(pthread-version)"'
+endif
Index: glibc-2.21/libpthread/tests/.cvsignore
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/.cvsignore
@@ -0,0 +1 @@
+Makefile.in
Index: glibc-2.21/libpthread/tests/Makefile
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/Makefile
@@ -0,0 +1,40 @@
+ifdef INSTALL_ROOT
+INSTALL_ROOT_CPPFLAGS = -isystem $(INSTALL_ROOT)/include
+INSTALL_ROOT_LDFLAGS = -L$(INSTALL_ROOT)/lib -Wl,-rpath,$(INSTALL_ROOT)/lib
+endif
+
+CFLAGS=-Wall -g
+
+LDLIBS = -lpthread
+
+CHECK_SRC := test-1.c test-2.c test-3.c test-6.c test-7.c test-8.c	\
+	test-9.c test-10.c test-11.c test-12.c test-13.c test-14.c	\
+	test-15.c test-16.c test-17.c test-__pthread_destroy_specific-skip.c
+
+CHECK_OBJS := $(addsuffix .o,$(basename $(notdir $(CHECK_SRC))))
+CHECK_PROGS := $(basename $(notdir $(CHECK_SRC))) \
+	$(addsuffix -static, $(basename $(CHECK_SRC)))
+
+%.o: %.c
+	$(CC) $(INSTALL_ROOT_CPPFLAGS) $(CPPFLAGS) $(CFLAGS) $< -c -o $@
+
+%: %.o
+	$(CC) $(INSTALL_ROOT_LDFLAGS) $(LDFLAGS) $< -o $@ $(LDLIBS)
+
+%-static: %.o
+	$(CC) -static $(INSTALL_ROOT_LDFLAGS) $(LDFLAGS) $< -o $@ $(LDLIBS)
+
+check: $(CHECK_OBJS) $(CHECK_PROGS)
+	for i in $(CHECK_PROGS); do		\
+	  echo -n Running $$i...\ ;		\
+	  if ./$$i 2>&1 > $$i.out;		\
+	  then					\
+	    echo Success.;			\
+	  else					\
+	    echo Failure.;			\
+	  fi					\
+	done
+
+clean:
+	rm -f $(CHECK_OBJS) $(CHECK_PROGS) \
+	  $(addsuffix .out,$(basename $(notdir $(CHECK_PROGS))))
\ No newline at end of file
Index: glibc-2.21/libpthread/tests/README
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/README
@@ -0,0 +1,6 @@
+Testing of installed package:
+
+    $ [libpthread]/configure --prefix=[install_root]
+    $ make
+    $ make install
+    $ make -C [libpthread]/tests/ INSTALL_ROOT=[install_root] clean check
Index: glibc-2.21/libpthread/tests/test-10.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-10.c
@@ -0,0 +1,46 @@
+/* Test error checking mutexes.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  pthread_mutexattr_t mattr;
+  pthread_mutex_t mutex;
+
+  err = pthread_mutexattr_init (&mattr);
+  if (err)
+    error (1, err, "pthread_mutexattr_init");
+
+  err = pthread_mutexattr_settype (&mattr, PTHREAD_MUTEX_ERRORCHECK);
+  if (err)
+    error (1, err, "pthread_mutexattr_settype");
+
+  err = pthread_mutex_init (&mutex, &mattr);
+  if (err)
+    error (1, err, "pthread_mutex_init");
+
+  err = pthread_mutexattr_destroy (&mattr);
+  if (err)
+    error (1, err, "pthread_mutexattr_destroy");
+
+  err = pthread_mutex_lock (&mutex);
+  assert (err == 0);
+
+  err = pthread_mutex_lock (&mutex);
+  assert (err == EDEADLK);
+
+  err = pthread_mutex_unlock (&mutex);
+  assert (err == 0);
+
+  err = pthread_mutex_unlock (&mutex);
+  assert (err == EPERM);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-11.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-11.c
@@ -0,0 +1,143 @@
+/* Test rwlocks.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+
+#define THREADS 1
+
+int a;
+int b;
+
+/* Get a read lock and assert that a == b.  */
+void *
+test1 (void *arg)
+{
+  error_t err;
+  pthread_rwlock_t *lock = arg;
+  int i;
+
+  for (i = 0; i < 200; i ++)
+    {
+      err = pthread_rwlock_rdlock (lock);
+      assert (err == 0);
+
+      assert (a == b);
+
+      sched_yield ();
+
+      assert (a == b);
+
+      err = pthread_rwlock_unlock (lock);
+      assert (err == 0);
+    }
+
+  return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  pthread_rwlockattr_t attr;
+  pthread_rwlock_t lock;
+  int pshared;
+
+  int i;
+  pthread_t tid[THREADS];
+  void *ret;
+
+  err = pthread_rwlockattr_init (&attr);
+  if (err)
+    error (1, err, "pthread_rwlockattr_init");
+
+  err = pthread_rwlockattr_getpshared (&attr, &pshared);
+  if (err)
+    error (1, err, "pthread_rwlockattr_getpshared");
+
+  /* Assert the default state as mandated by POSIX.  */
+  assert (pshared == PTHREAD_PROCESS_PRIVATE);
+
+  err = pthread_rwlockattr_setpshared (&attr, pshared);
+  if (err)
+    error (1, err, "pthread_rwlockattr_setpshared");
+
+  err = pthread_rwlock_init (&lock, &attr);
+  if (err)
+    error (1, err, "pthread_rwlock_init");
+
+  err = pthread_rwlockattr_destroy (&attr);
+  if (err)
+    error (1, err, "pthread_rwlockattr_destroy");
+
+  /* Now test the lock.  */
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      err = pthread_create (&tid[i], 0, test1, &lock);
+      if (err)
+	error (1, err, "pthread_create");
+    }
+
+  for (i = 0; i < 10; i ++)
+    {
+      sched_yield ();
+
+      /* Get a write lock.  */
+      pthread_rwlock_wrlock (&lock);
+      /* Increment a and b giving other threads a chance to run in
+	 between.  */
+      sched_yield ();
+      a ++;
+      sched_yield ();
+      b ++;
+      sched_yield ();
+      /* Unlock.  */
+      pthread_rwlock_unlock (&lock);
+    }
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      err = pthread_join (tid[i], &ret);
+      if (err)
+	error (1, err, "pthread_join");
+    }
+
+  /* Read lock it.  */
+  err = pthread_rwlock_tryrdlock (&lock);
+  assert (err == 0);
+  
+  /* Try to write lock it.  It should fail with EBUSY.  */
+  err = pthread_rwlock_trywrlock (&lock);
+  assert (err == EBUSY);
+  
+  /* Drop the read lock.  */
+  err = pthread_rwlock_unlock (&lock);
+  assert (err == 0);
+
+  /* Get a write lock.  */
+  err = pthread_rwlock_trywrlock (&lock);
+  assert (err == 0);
+
+  /* Fail trying to acquire another write lock.  */
+  err = pthread_rwlock_trywrlock (&lock);
+  assert (err == EBUSY);
+
+  /* Try to get a read lock which should also fail.  */
+  err = pthread_rwlock_tryrdlock (&lock);
+  assert (err == EBUSY);
+
+  /* Unlock it.  */
+  err = pthread_rwlock_unlock (&lock);
+  assert (err == 0);
+
+
+  err = pthread_rwlock_destroy (&lock);
+  if (err)
+    error (1, err, "pthread_rwlock_destroy");
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-12.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-12.c
@@ -0,0 +1,29 @@
+/* Test concurrency level.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+
+int
+main (int argc, char **argv)
+{
+  int i;
+  int err;
+
+  i = pthread_getconcurrency ();
+  assert (i == 0);
+
+  err = pthread_setconcurrency (-1);
+  assert (err == EINVAL);
+
+  err = pthread_setconcurrency (4);
+  assert (err == 0);
+
+  i = pthread_getconcurrency ();
+  assert (i == 4);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-13.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-13.c
@@ -0,0 +1,66 @@
+/* Test condition attributes and pthread_cond_timedwait.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <stdio.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+#include <sys/time.h>
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  int i;
+  pthread_condattr_t attr;
+  pthread_cond_t cond;
+  struct timespec ts;
+  pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
+  struct timeval before, after;
+  int diff;
+
+  err = pthread_condattr_init (&attr);
+  if (err)
+    error (1, err, "pthread_condattr_init");
+
+  err = pthread_condattr_getpshared (&attr, &i);
+  if (err)
+    error (1, err, "pthread_condattr_getpshared");
+  assert (i == PTHREAD_PROCESS_PRIVATE);
+
+  err = pthread_condattr_setpshared (&attr, PTHREAD_PROCESS_PRIVATE);
+  assert (err == 0);
+
+  err = pthread_cond_init (&cond, &attr);
+  if (err)
+    error (1, err, "pthread_cond_init");
+
+  err = pthread_condattr_destroy (&attr);
+  if (err)
+    error (1, err, "pthread_condattr_destroy");
+
+  gettimeofday (&before, 0);
+  ts.tv_sec = before.tv_sec + 1;
+  ts.tv_nsec = before.tv_usec * 1000;
+
+  printf ("Starting wait @ %d\n", (int) before.tv_sec);
+
+  pthread_mutex_lock (&m);
+  err = pthread_cond_timedwait (&cond, &m, &ts);
+
+  gettimeofday (&after, 0);
+
+  printf ("End wait @ %d (err = %d)\n", (int) after.tv_sec, err);
+
+  assert (err == ETIMEDOUT);
+
+  diff = after.tv_sec * 1000000 + after.tv_usec
+    - before.tv_sec * 1000000 - before.tv_usec;
+
+  if (diff < 900000 || diff > 1100000)
+    error (1, EGRATUITOUS, "pthread_cond_timedwait waited %d us", diff);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-14.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-14.c
@@ -0,0 +1,44 @@
+/* Test pthread_mutex_timedlock.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <stdio.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+#include <sys/time.h>
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  struct timespec ts;
+  pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;
+  struct timeval before, after;
+  int diff;
+
+  gettimeofday (&before, 0);
+  ts.tv_sec = before.tv_sec + 1;
+  ts.tv_nsec = before.tv_usec * 1000;
+
+  printf ("Starting wait @ %d\n", (int) before.tv_sec);
+
+  pthread_mutex_lock (&m);
+  /* A default mutex shall dead lock if locked twice.  As such we do
+     not need spawn a second thread.  */
+  err = pthread_mutex_timedlock (&m, &ts);
+  assert (err == ETIMEDOUT);
+
+  gettimeofday (&after, 0);
+
+  printf ("End wait @ %d\n", (int) after.tv_sec);
+
+  diff = after.tv_sec * 1000000 + after.tv_usec
+    - before.tv_sec * 1000000 - before.tv_usec;
+
+  if (diff < 900000 || diff > 1100000)
+    error (1, EGRATUITOUS, "pthread_mutex_timedlock waited %d us", diff);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-15.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-15.c
@@ -0,0 +1,87 @@
+/* Test pthread_rwlock_timedrdlock and pthread_rwlock_timedwrlock.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <stdio.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+#include <sys/time.h>
+
+#define THREADS 10
+
+pthread_rwlock_t rwlock;
+
+void *
+test (void *arg)
+{
+  error_t err;
+  int foo = (int) arg;
+  struct timespec ts;
+  struct timeval before, after;
+  int diff;
+
+  gettimeofday (&before, 0);
+  ts.tv_sec = before.tv_sec + 1;
+  ts.tv_nsec = before.tv_usec * 1000;
+
+  printf ("Thread %d starting wait @ %d\n", pthread_self (),
+	  (int) before.tv_sec);
+
+  if (foo % 2 == 0)
+    err = pthread_rwlock_timedrdlock (&rwlock, &ts);
+  else
+    err = pthread_rwlock_timedwrlock (&rwlock, &ts);
+
+  assert (err == ETIMEDOUT);
+
+  gettimeofday (&after, 0);
+
+  printf ("Thread %d ending wait @ %d\n", pthread_self (),
+	  (int) after.tv_sec);
+
+  diff = after.tv_sec * 1000000 + after.tv_usec
+    - before.tv_sec * 1000000 - before.tv_usec;
+
+  if (diff < 900000 || diff > 1100000)
+    error (1, EGRATUITOUS, "pthread_mutex_timedlock waited %d us", diff);
+
+  return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  int i;
+  pthread_t tid[THREADS];
+
+  err = pthread_rwlock_init (&rwlock, 0);
+  if (err)
+    error (1, err, "pthread_rwlock_init");
+
+  /* Lock it so all the threads will block.  */
+  err = pthread_rwlock_wrlock (&rwlock);
+  assert (err == 0);
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      err = pthread_create (&tid[i], 0, test, (void *) i);
+      if (err)
+	error (1, err, "pthread_create");
+    }
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      void *ret;
+
+      err = pthread_join (tid[i], &ret);
+      if (err)
+	error (1, err, "pthread_join");
+
+      assert (ret == 0);
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-16.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-16.c
@@ -0,0 +1,71 @@
+/* Test pthread_kill.c.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <signal.h>
+#include <stdio.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+#include <hurd/signal.h>
+
+pthread_t testthread;
+
+int i;
+
+void *
+test (void *arg)
+{
+  error_t err;
+
+  printf ("test: %d\n", pthread_self ());
+
+  err = pthread_kill (pthread_self (), SIGINFO);
+  if (err)
+    error (1, err, "pthread_kill");
+
+  /* To avoid using condition variables in a signal handler.  */
+  while (i == 0)
+    sched_yield ();
+
+  return 0;
+}
+
+static void
+handler (int sig)
+{
+  assert (pthread_equal (pthread_self (), testthread));
+  printf ("handler: %d\n", pthread_self ());
+  i = 1;
+}
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  struct sigaction sa;
+  void *ret;
+
+  printf ("main: %d\n", pthread_self ());
+
+  sa.sa_handler = handler;
+  sa.sa_mask = 0;
+  sa.sa_flags = 0;
+
+  err = sigaction (SIGINFO, &sa, 0);
+  if (err)
+    error (1, err, "sigaction");
+
+  err = pthread_create (&testthread, 0, test, 0);
+  if (err)
+    error (1, err, "pthread_create");
+
+  err = pthread_join (testthread, &ret);
+  if (err)
+    error (1, err, "pthread_join");
+
+  assert (ret == 0);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-17.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-17.c
@@ -0,0 +1,57 @@
+/* Test that the key reuse inside libpthread does not cause thread
+   specific values to persist. */
+
+#define _GNU_SOURCE 1
+
+#include <pthread.h>
+#include <stdio.h>
+#include <assert.h>
+#include <errno.h>
+
+void
+work (int iter)
+{
+  error_t err;
+  pthread_key_t key1;
+  pthread_key_t key2;
+  void *value1;
+  void *value2;
+
+  printf ("work/%d: start\n", iter);
+  err = pthread_key_create (&key1, NULL);
+  assert (err == 0);
+  err = pthread_key_create (&key2, NULL);
+  assert (err == 0);
+
+  value1 = pthread_getspecific (key1);
+  value2 = pthread_getspecific (key2);
+  printf ("work/%d: pre-setspecific: %p,%p\n", iter, value1, value2);
+  assert (value1 == NULL);
+  assert (value2 == NULL);
+  err = pthread_setspecific (key1, (void *)(0x100 + iter));
+  assert (err == 0);
+  err = pthread_setspecific (key2, (void *)(0x200 + iter));
+  assert (err == 0);
+
+  value1 = pthread_getspecific (key1);
+  value2 = pthread_getspecific (key2);
+  printf ("work/%d: post-setspecific: %p,%p\n", iter, value1, value2);
+  assert (value1 == (void *)(0x100 + iter));
+  assert (value2 == (void *)(0x200 + iter));
+
+  err = pthread_key_delete (key1);
+  assert (err == 0);
+  err = pthread_key_delete (key2);
+  assert (err == 0);
+}
+
+int
+main (int argc, char *argv[])
+{
+  int i;
+
+  for (i = 0; i < 8; ++i)
+    work (i + 1);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-1.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-1.c
@@ -0,0 +1,50 @@
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <unistd.h>
+#include <error.h>
+#include <errno.h>
+#include <stdio.h>
+
+#define THREADS 500
+
+void *
+foo (void *arg)
+{
+  pthread_mutex_t *mutex = arg;
+  pthread_mutex_lock (mutex);
+  pthread_mutex_unlock (mutex);
+  return mutex;
+}
+
+int
+main (int argc, char **argv)
+{
+  int i;
+  error_t err;
+  pthread_t tid[THREADS];
+  pthread_mutex_t mutex[THREADS];
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      pthread_mutex_init (&mutex[i], 0);
+      pthread_mutex_lock (&mutex[i]);
+      err = pthread_create (&tid[i], 0, foo, &mutex[i]);
+      if (err)
+	error (1, err, "pthread_create");
+      sched_yield ();
+    }
+
+  for (i = THREADS - 1; i >= 0; i --)
+    {
+      void *ret;
+      pthread_mutex_unlock (&mutex[i]);
+      err = pthread_join (tid[i], &ret);
+      if (err)
+	error (1, err, "pthread_join");
+      assert (ret == &mutex[i]);
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-2.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-2.c
@@ -0,0 +1,39 @@
+/* Test detachability.  */
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+#include <unistd.h>
+
+void *
+thread (void *arg)
+{
+  while (1)
+    sched_yield ();
+}
+
+int
+main (int argc, char **argv)
+{
+  int err;
+  pthread_t tid;
+  void *ret;
+
+  err = pthread_create (&tid, 0, thread, 0);
+  if (err)
+    error (1, err, "pthread_create");
+
+  err = pthread_detach (tid);
+  if (err)
+    error (1, err, "pthread_detach");
+
+  err = pthread_detach (tid);
+  assert (err == EINVAL);
+
+  err = pthread_join (tid, &ret);
+  assert (err == EINVAL);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-3.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-3.c
@@ -0,0 +1,55 @@
+/* Test the thread attribute get and set methods.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <sched.h>
+#include <assert.h>
+#include <errno.h>
+
+int
+main (int argc, char *argv[])
+{
+  error_t err;
+  pthread_attr_t attr;
+
+  int i;
+  struct sched_param sp;
+  void *p;
+  size_t sz;
+
+  err = pthread_attr_init (&attr);
+  assert_perror (err);
+
+  err = pthread_attr_destroy (&attr);
+  assert_perror (err);
+
+  err = pthread_attr_init (&attr);
+  assert_perror (err);
+
+#define TEST1(foo, rv, v) \
+	err = pthread_attr_get##foo (&attr, rv); \
+	assert_perror (err); \
+	\
+	err = pthread_attr_set##foo (&attr, v); \
+	assert_perror (err);
+
+#define TEST(foo, rv, v) TEST1(foo, rv, v)
+
+  TEST(inheritsched, &i, i);
+  TEST(schedparam, &sp, &sp);
+  TEST(schedpolicy, &i, i);
+  TEST(scope, &i, i);
+  TEST(stackaddr, &p, p);
+  TEST(detachstate, &i, i);
+  TEST(guardsize, &sz, sz);
+  TEST(stacksize, &sz, sz);
+
+  err = pthread_attr_getstack (&attr, &p, &sz);
+  assert_perror (err);
+
+  err = pthread_attr_setstack (&attr, p, sz);
+  assert_perror (err);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-4.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-4.c
@@ -0,0 +1,86 @@
+/* Test the stack guard.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <stdio.h>
+
+size_t stacksize;
+
+void *
+thr (void *arg)
+{
+  int i;
+  char *foo;
+
+  foo = alloca (3 * stacksize / 4);
+  for (i = 0; i < sizeof foo; i ++)
+    foo[i] = -1;
+
+  return (void *) 1;
+}
+
+int
+main (int argc, char *argv[])
+{
+  error_t err;
+  pid_t child;
+
+  child = fork ();
+  switch (child)
+    {
+    case -1:
+      error (1, errno, "fork");
+      break;
+
+    case 0:
+      {
+	pthread_attr_t attr;
+	pthread_t tid;
+	void *ret;
+
+	err = pthread_attr_init (&attr);
+	assert_perror (err);
+
+	err = pthread_attr_getstacksize (&attr, &stacksize);
+	assert_perror (err);
+
+	err = pthread_attr_setguardsize (&attr, stacksize / 2);
+	if (err == ENOTSUP)
+	  {
+	    printf ("Stack guard attribute not supported.\n");
+	    return 1;
+	  }
+	assert_perror (err);
+
+	err = pthread_create (&tid, &attr, thr, 0);
+	assert_perror (err);
+
+	err = pthread_attr_destroy (&attr);
+	assert_perror (err);
+
+	err = pthread_join (tid, &ret);
+	/* Should never be successful.  */
+	printf ("Thread did not segfault!?!\n");
+	assert_perror (err);
+	return 0;
+      }
+
+    default:
+      {
+	pid_t pid;
+	int status;
+
+	pid = waitpid (child, &status, 0);
+	printf ("pid = %d; child = %d; status = %d\n", pid, child, status);
+	assert (pid == child);
+	assert (status != 0);
+      }
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-5.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-5.c
@@ -0,0 +1,75 @@
+/* Test signals.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <errno.h>
+#include <error.h>
+#include <assert.h>
+#include <sys/resource.h>
+#include <sys/wait.h>
+
+void *
+thr (void *arg)
+{
+  * (int *)0 = 0;
+  return 0;
+}
+
+int foobar;
+
+int
+main (int argc, char *argv[])
+{
+  error_t err;
+  pid_t child;
+
+  struct rlimit limit;
+
+  limit.rlim_cur = 0;
+  limit.rlim_max = 0;
+
+  err = setrlimit (RLIMIT_CORE, &limit);
+  if (err)
+    error (1, err, "setrlimit");
+
+  child = fork ();
+  switch (child)
+    {
+    case -1:
+      error (1, errno, "fork");
+      break;
+
+    case 0:
+      {
+	pthread_t tid;
+	void *ret;
+
+	err = pthread_create (&tid, 0, thr, 0);
+	if (err)
+	  error (1, err, "pthread_create");
+
+	err = pthread_join (tid, &ret);
+	assert_perror (err);
+
+	/* Should have never returned.  Our parent expects us to fail
+	   thus we succeed and indicate the error.  */
+	return 0;
+      }
+
+    default:
+      {
+	pid_t pid;
+	int status;
+
+	pid = waitpid (child, &status, 0);
+	printf ("pid = %d; child = %d; status = %d\n", pid, child, status);
+	assert (pid == child);
+	assert (status != 0);
+      }
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-6.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-6.c
@@ -0,0 +1,96 @@
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <stdio.h>
+#include <error.h>
+#include <assert.h>
+#include <errno.h>
+
+#define THREADS 500
+#define WAITS 3
+
+void *
+dowait (void *arg)
+{
+  pthread_barrier_t *barrier = arg;
+  int ret;
+
+  ret = pthread_barrier_wait (barrier);
+  printf ("%d ", pthread_self ());
+  return (void *) ret;
+}
+
+int
+main (int argc, char **argv)
+{
+  pthread_barrierattr_t attr;
+  pthread_barrier_t barrier;
+
+  int i, j;
+  error_t err;
+  pthread_t tid[THREADS];
+
+  int havesyncs;
+
+  err = pthread_barrierattr_init (&attr);
+  if (err)
+    error (1, err, "pthread_barrierattr_init");
+
+  err = pthread_barrierattr_getpshared (&attr, &i);
+  if (err)
+    error (1, err, "pthread_barrierattr_getpshared");
+  assert (i == PTHREAD_PROCESS_PRIVATE || i == PTHREAD_PROCESS_SHARED);
+
+  err = pthread_barrierattr_setpshared (&attr, PTHREAD_PROCESS_PRIVATE);
+  if (err)
+    error (1, err, "pthread_barrierattr_setpshared");
+
+  err = pthread_barrier_init (&barrier, &attr, THREADS + 1);
+  if (err)
+    error (1, err, "pthread_barrier_init");
+
+  for (j = 0; j < WAITS; j ++)
+    {    
+
+      for (i = 0; i < THREADS; i ++)
+	{
+	  err = pthread_create (&tid[i], 0, dowait, &barrier);
+	  if (err)
+	    error (1, err, "pthread_create (%d)", i);
+	}
+
+      printf ("Manager will now call pthread_barrier_wait.\n");
+
+      havesyncs
+	= pthread_barrier_wait (&barrier) == PTHREAD_BARRIER_SERIAL_THREAD
+	? 1 : 0;
+
+      for (i = THREADS - 1; i >= 0; i --)
+	{
+	  void *ret;
+	  err = pthread_join (tid[i], &ret);
+	  if (err)
+	    error (1, err, "pthread_join");
+
+	  switch ((int) ret)
+	    {
+	    case 0:
+	      break;
+
+	    case PTHREAD_BARRIER_SERIAL_THREAD:
+	      havesyncs ++;
+	      break;
+
+	    default:
+	      assert (! "Unknown value returned from pthread_barrier_wait.");
+	      break;
+	    }
+	}
+
+      printf ("\n");
+
+      assert (havesyncs == 1);
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-7.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-7.c
@@ -0,0 +1,70 @@
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <stdio.h>
+#include <error.h>
+#include <errno.h>
+
+#define THREADS 10
+#define KEYS 400
+
+pthread_key_t key[KEYS];
+
+void *
+thr (void *arg)
+{
+  error_t err;
+  int i;
+
+  for (i = 0; i < KEYS; i ++)
+    {
+      printf ("pthread_getspecific(%d).\n", key[i]);
+      assert (pthread_getspecific (key[i]) == NULL);
+      printf ("pthread_setspecific(%d, %d).\n", key[i], pthread_self ());
+      err = pthread_setspecific (key[i], (void *) pthread_self ());
+      printf ("pthread_setspecific(%d, %d) => %d.\n", key[i], pthread_self (), err);      
+      assert_perror (err);
+    }
+
+  return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  int i;
+  pthread_t tid[THREADS];
+
+  void des (void *val)
+    {
+      assert ((pthread_t) val == pthread_self ());
+    }
+
+  assert (pthread_getspecific ((pthread_key_t) 0) == NULL);
+  assert (pthread_setspecific ((pthread_key_t) 0, (void *) 0x1) == EINVAL);
+
+  for (i = 0; i < KEYS; i ++)
+    err = pthread_key_create (&key[i], des);
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      err = pthread_create (&tid[i], 0, thr, 0);
+      if (err)
+	error (1, err, "pthread_create (%d)", i);
+    }
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      void *ret;
+
+      err = pthread_join (tid[i], &ret);
+      if (err)
+	error (1, err, "pthread_join");
+
+      assert (ret == 0);
+    }
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-8.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-8.c
@@ -0,0 +1,60 @@
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+
+#define THREADS 10
+
+pthread_once_t inc_var_once = PTHREAD_ONCE_INIT;
+int var;
+
+void
+inc_var (void)
+{
+  var ++;
+}
+
+void *
+thr (void *arg)
+{
+  int i;
+
+  for (i = 0; i < 500; i ++)
+    pthread_once (&inc_var_once, inc_var);
+
+  return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  int i;
+  pthread_t tid[THREADS];
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      err = pthread_create (&tid[i], 0, thr, 0);
+      if (err)
+	error (1, err, "pthread_create (%d)", i);
+    }
+
+  assert (thr (0) == 0);
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      void *ret;
+
+      err = pthread_join (tid[i], &ret);
+      if (err)
+	error (1, err, "pthread_join");
+
+      assert (ret == 0);
+    }
+
+  assert (var == 1);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-9.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-9.c
@@ -0,0 +1,88 @@
+/* Test recursive mutexes.  */
+
+#define _GNU_SOURCE
+
+#include <pthread.h>
+#include <assert.h>
+#include <error.h>
+#include <errno.h>
+
+#define THREADS 10
+
+int foo;
+
+void *
+thr (void *arg)
+{
+  int i;
+
+  pthread_mutex_lock (arg);
+
+  foo = pthread_self ();
+
+  for (i = 0; i < 500; i ++)
+    pthread_mutex_lock (arg);
+  for (i = 0; i < 500; i ++)
+    pthread_mutex_unlock (arg);
+
+  assert (foo == pthread_self ());
+
+  pthread_mutex_unlock (arg);
+
+  return 0;
+}
+
+int
+main (int argc, char **argv)
+{
+  error_t err;
+  int i;
+  pthread_t tid[THREADS];
+  pthread_mutexattr_t mattr;
+  pthread_mutex_t mutex;
+
+  err = pthread_mutexattr_init (&mattr);
+  if (err)
+    error (1, err, "pthread_mutexattr_init");
+
+  err = pthread_mutexattr_settype (&mattr, PTHREAD_MUTEX_RECURSIVE);
+  if (err)
+    error (1, err, "pthread_mutexattr_settype");
+
+  err = pthread_mutex_init (&mutex, &mattr);
+  if (err)
+    error (1, err, "pthread_mutex_init");
+
+  err = pthread_mutexattr_destroy (&mattr);
+  if (err)
+    error (1, err, "pthread_mutexattr_destroy");
+
+  pthread_mutex_lock (&mutex);
+  pthread_mutex_lock (&mutex);
+  pthread_mutex_unlock (&mutex);
+  pthread_mutex_unlock (&mutex);
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      err = pthread_create (&tid[i], 0, thr, &mutex);
+      if (err)
+	error (1, err, "pthread_create (%d)", i);
+    }
+
+  for (i = 0; i < THREADS; i ++)
+    {
+      void *ret;
+
+      err = pthread_join (tid[i], &ret);
+      if (err)
+	error (1, err, "pthread_join");
+
+      assert (ret == 0);
+    }
+
+  err = pthread_mutex_destroy (&mutex);
+  if (err)
+    error (1, err, "pthread_mutex_destroy");
+
+  return 0;
+}
Index: glibc-2.21/libpthread/tests/test-__pthread_destroy_specific-skip.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/tests/test-__pthread_destroy_specific-skip.c
@@ -0,0 +1,83 @@
+/* Check that __pthread_destroy_specific works correctly if it has to skip
+   unused slots.  */
+
+#define _GNU_SOURCE
+
+#include <error.h>
+#include <pthread.h>
+#include <stdio.h>
+
+
+#define N_k 42
+
+static volatile int v;
+
+static void
+d (void *x)
+{
+  int *i = (int *) x;
+
+  if (v != *i)
+    error (1, 0, "FAILED %d %d", v, *i);
+  v += 2;
+
+  printf ("%s %d\n", __FUNCTION__, *i);
+  fflush (stdout);
+}
+
+static void *
+test (void *x)
+{
+  pthread_key_t k[N_k];
+  static int k_v[N_k];
+
+  int err, i;
+
+  for (i = 0; i < N_k; i += 1)
+    {
+      err = pthread_key_create (&k[i], &d);
+      if (err != 0)
+        error (1, err, "pthread_key_create %d", i);
+    }
+
+  for (i = 0; i < N_k; i += 1)
+    {
+      k_v[i] = i;
+      err = pthread_setspecific (k[i], &k_v[i]);
+      if (err != 0)
+        error (1, err, "pthread_setspecific %d", i);
+    }
+
+  /* Delete every even key.  */
+  for (i = 0; i < N_k; i += 2)
+    {
+      err = pthread_key_delete (k[i]);
+      if (err != 0)
+        error (1, err, "pthread_key_delete %d", i);
+    }
+
+  v = 1;
+  pthread_exit (NULL);
+
+  return NULL;
+}
+
+
+int main(void)
+{
+  pthread_t tid;
+  int err;
+
+  err = pthread_create (&tid, 0, test, NULL);
+  if (err != 0)
+    error (1, err, "pthread_create");
+
+  err = pthread_join(tid, NULL);
+  if (err)
+    error (1, err, "pthread_join");
+
+  if (v != N_k + 1)
+    error (1, 0, "FAILED END %d %d", v, N_k + 1);
+
+  return 0;
+}
Index: glibc-2.21/libpthread/TODO
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/TODO
@@ -0,0 +1,131 @@
+-*- Mode: outline -*-
+
+* Interfaces
+** All interfaces specified by IEEE Std 1003.1-2001 are present, however,
+   pthread_kill and pthread_sigmask are defined in <pthread.h> and not
+   <signal.h> as they should be.  Once we are compiled with glibc,
+   this should be eaiser.
+
+* Test cases.  Can never have enough.
+
+* Ports
+  Port to other kernels (e.g. Linux and FreeBSD) and test on other
+  platforms.
+
+* Implementation details
+** pthread_atfork
+   This cannot be implemented without either changing glibc to export
+   some hooks (c.f. libc/sysdeps/mach/hurd/fork.c) or by providing a
+   custom fork implementation that wraps the origial using dlopen et
+   al.
+
+** Scheduling and priorities
+
+   We do not support scheduling right now in any way what so ever.
+
+   This affects:
+     pthread_attr_getinheritsched
+     pthread_attr_setinheritsched
+     pthread_attr_getschedparam
+     pthread_attr_setschedparam
+     pthread_attr_getschedpolicy
+     pthread_attr_setschedpolicy
+     pthread_attr_getscope
+     pthread_attr_setscope
+
+     pthread_mutexattr_getprioceiling
+     pthread_mutexattr_setprioceiling
+     pthread_mutexattr_getprotocol
+     pthread_mutexattr_setprotocol
+     pthread_mutex_getprioceiling
+     pthread_mutex_setprioceiling
+
+     pthread_setschedprio
+     pthread_getschedparam
+     pthread_setschedparam
+
+** Cancelation
+*** Cancelation points
+    The only cancelation points are pthread_join, pthread_cond_wait,
+    pthead_cond_timedwait and pthread_testcancel.  Need to explore if
+    the hurd_sigstate->cancel_hook (c.f. <hurd/signal.h>) provides the
+    desired semantics.  If not, must either wrap the some functions
+    using dlsym or wait until integration with glibc.
+*** Async cancelation
+    We inject a new IP into the cancelled (running) thread and then
+    run the cancelation handlers
+    (c.f. sysdeps/mach/hurd/pt-docancel.c).  The handlers need to have
+    access to the stack as they may use local variables.  I think that
+    this method may leave the frame pointer in a corrupted state if
+    the thread was in, for instance, the middle of a function call.
+    The robustness needs to be confirmed.
+
+** Process Shared Attribute
+
+   Currently, there is no real support for the process shared
+   attribute.  spinlocks work because we just use a test and set loop,
+   however, barriers, conditions mutexes and rwlocks, however, signal
+   wakeups via ports of which the names are process local.
+
+   We could have some process local data that is hashed to via the
+   address of the data structure.  Then the first thread that blocks
+   per process would spin on the shared memory area and all others
+   would then block as normal.  When the resource became available,
+   the first thread would signal the other local threads as necessary.
+   Alternatively, there could be some server, however, this opens a
+   new question: what can we use as an authentication agent.
+
+** Locking algorithm
+
+   When a thread blocks, it puts itself on a queue and then waits for
+   a message on a thread local port.  The thread which eventually does
+   the wakeup sends a message to the waiter thereby waking it up.  If
+   the wakeup is a broadcast wakeup (e.g. pthread_cond_broadcast,
+   pthread_barrier_wait and pthread_rdlock_unlock), the thread must
+   send O(N) messages where N is the number of waiting threads.  If
+   all the threads instead received on a lock local (rather than
+   thread local) port then the thread which eventually does the wake
+   need just do one operation, mach_port_destroy and all of the
+   waiting threads would wakeup and get MACH_RCV_PORT_DIED back from
+   mach_msg.  Note that the trade off is that the port must be
+   recreated.  This needs to be benchmarked.
+
+   A possible problem with this is scheduling priorities.  There may
+   be a preference for certain threads to wakeup before others
+   (especially if we are not doing a broadcast, for instance,
+   pthread_mutex_unlock and pthread_cond_signal).  If we take this
+   approach, the kernel chooses which threads are awakened.  If we
+   find that the kernel makes the wrong choices, we can still overcome
+   this by merging the two algorithms: have a list of ports sorted in
+   priority order and the waker does a mach_port_destroy on each as
+   appropriate.
+
+** Barriers
+
+   Barriers can be very slow and the contention can be very high.  The
+   above algorithm is very appealing, however, this may be augmented
+   with an initial number of spins and yields.  It is expected that
+   all of the threads reach the barrier within close succession, thus
+   queuing a message may be more expensive.  This needs to be
+   benchmarked.
+
+** Clocks
+*** pthread_condattr_setclock allows a process to specify a clock for
+    use with pthread_cond_timedwaits.  What is the correct default for
+    this, right now, we use CLOCK_REALTIME, however, we are really
+    using the system clock which, if I understand correctly, is
+    completely different.
+*** Could we even use other clocks? mach_msg uses a relative time against
+    the system clock.
+*** pthread_getcpuclockid just returns CLOCK_THREAD_CPUTIME_ID if defined.
+    Is this the correct behavior?
+
+** Timed Blocking
+*** pthread_cond_timedwait, pthead_mutex_timedlock, pthread_rwlock_timedrdlock
+    and pthread_rwlock_timedwrlock all take absolute times.  We need
+    to convert them to relative times for mach_msg.  Is there a way
+    around this?  How will clock skew affect us?
+
+** weak aliases
+   Use them consistently and correctly and start by reading
+   http://sources.redhat.com/ml/libc-alpha/2002-08/msg00278.html.
Index: glibc-2.21/libpthread/Versions
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/Versions
@@ -0,0 +1,142 @@
+libc {
+  GLIBC_2.13 {
+    pthread_attr_destroy; pthread_attr_getdetachstate;
+    pthread_attr_getinheritsched; pthread_attr_getschedparam;
+    pthread_attr_getschedpolicy; pthread_attr_getscope; pthread_attr_init;
+    pthread_attr_setdetachstate; pthread_attr_setinheritsched;
+    pthread_attr_setschedparam; pthread_attr_setschedpolicy;
+    pthread_attr_setscope;
+    pthread_condattr_destroy; pthread_condattr_init;
+    pthread_cond_broadcast; pthread_cond_destroy;
+    pthread_cond_init; pthread_cond_signal; pthread_cond_wait;
+    pthread_cond_timedwait;
+    pthread_equal;
+    pthread_exit; pthread_getschedparam; pthread_setschedparam;
+    pthread_mutex_destroy; pthread_mutex_init;
+    pthread_mutex_lock; pthread_mutex_trylock; pthread_mutex_unlock;
+    pthread_self; pthread_setcancelstate; pthread_setcanceltype;
+    __pthread_get_cleanup_stack;
+  GLIBC_PRIVATE {
+    __libc_pthread_init;
+    __register_atfork;
+  }
+}
+
+libpthread {
+  GLIBC_2.2.6 {
+    _IO_flockfile; _IO_ftrylockfile; _IO_funlockfile;
+  }
+  GLIBC_2.12 {
+    __pthread_errorcheck_mutexattr; __pthread_recursive_mutexattr;
+
+    __pthread_get_cleanup_stack;
+
+    __pthread_mutex_transfer_np;
+
+    _pthread_mutex_destroy; _pthread_mutex_init;
+    _pthread_mutex_lock; _pthread_mutex_trylock; _pthread_mutex_unlock;
+    _pthread_rwlock_destroy; _pthread_rwlock_init;
+
+    _cthread_init_routine;
+
+    cthread_detach;
+    cthread_fork;
+    cthread_keycreate;
+    cthread_getspecific;
+    __libc_getspecific;
+    cthread_setspecific;
+    __mutex_lock_solid;
+    __mutex_unlock_solid;
+    _cthreads_flockfile;
+    _cthreads_ftrylockfile;
+    _cthreads_funlockfile;
+
+    flockfile; ftrylockfile; funlockfile;
+
+    pthread_atfork;
+
+    pthread_attr_destroy; pthread_attr_getdetachstate;
+    pthread_attr_getguardsize; pthread_attr_getinheritsched;
+    pthread_attr_getschedparam; pthread_attr_getschedpolicy;
+    pthread_attr_getscope; pthread_attr_getstack; pthread_attr_getstackaddr;
+    pthread_attr_getstacksize; pthread_attr_init; pthread_attr_setdetachstate;
+    pthread_attr_setguardsize; pthread_attr_setinheritsched;
+    pthread_attr_setschedparam; pthread_attr_setschedpolicy;
+    pthread_attr_setscope; pthread_attr_setstack; pthread_attr_setstackaddr;
+    pthread_attr_setstacksize;
+
+    pthread_barrier_destroy; pthread_barrier_init; pthread_barrier_wait;
+    pthread_barrierattr_destroy; pthread_barrierattr_getpshared;
+    pthread_barrierattr_init; pthread_barrierattr_setpshared;
+
+    pthread_cancel;
+
+    pthread_cond_broadcast; pthread_cond_destroy; pthread_cond_init;
+    pthread_cond_signal; pthread_cond_timedwait; pthread_cond_wait;
+
+    pthread_condattr_destroy; pthread_condattr_getclock;
+    pthread_condattr_getpshared; pthread_condattr_init;
+    pthread_condattr_setclock; pthread_condattr_setpshared;
+
+    pthread_create; pthread_detach; pthread_equal; pthread_exit;
+
+    pthread_getattr_np;
+
+    pthread_getconcurrency; pthread_getcpuclockid;
+    pthread_getschedparam; pthread_getspecific;
+
+    pthread_join;
+
+    pthread_key_create; pthread_key_delete;
+    __pthread_key_create;
+
+    pthread_kill;
+
+    pthread_mutex_destroy; pthread_mutex_getprioceiling;
+    pthread_mutex_init; pthread_mutex_lock; pthread_mutex_setprioceiling;
+    pthread_mutex_timedlock; pthread_mutex_transfer_np;
+    pthread_mutex_trylock; pthread_mutex_unlock;
+
+    pthread_mutexattr_destroy; pthread_mutexattr_getprioceiling;
+    pthread_mutexattr_getprotocol; pthread_mutexattr_getpshared;
+    pthread_mutexattr_gettype; pthread_mutexattr_init;
+    pthread_mutexattr_setprioceiling; pthread_mutexattr_setprotocol;
+    pthread_mutexattr_setpshared; pthread_mutexattr_settype;
+
+    pthread_once;
+
+    pthread_rwlock_destroy; pthread_rwlock_init; pthread_rwlock_rdlock;
+    pthread_rwlock_timedrdlock; pthread_rwlock_timedwrlock;
+    pthread_rwlock_tryrdlock; pthread_rwlock_trywrlock;
+    pthread_rwlock_unlock; pthread_rwlock_wrlock;
+
+    pthread_rwlockattr_destroy; pthread_rwlockattr_getpshared;
+    pthread_rwlockattr_init; pthread_rwlockattr_setpshared;
+
+    pthread_self;
+
+    pthread_setcancelstate; pthread_setcanceltype;
+    pthread_setconcurrency; pthread_setschedparam;
+    pthread_setschedprio; pthread_setspecific;
+
+    pthread_sigmask;
+    pthread_testcancel;
+    pthread_yield;
+
+    sem_close; sem_destroy; sem_getvalue; sem_init; sem_open; sem_post;
+    sem_timedwait; sem_trywait; sem_unlink; sem_wait;
+
+    pthread_spin_destroy; pthread_spin_init; pthread_spin_lock;
+    pthread_spin_trylock; pthread_spin_unlock;
+    __pthread_spin_destroy; __pthread_spin_init;
+    __pthread_spin_lock; __pthread_spin_trylock; __pthread_spin_unlock;
+    _pthread_spin_lock;
+  }
+  GLIBC_2.17 {
+    pthread_hurd_cond_wait_np;
+    pthread_hurd_cond_timedwait_np;
+  }
+  GLIBC_PRIVATE {
+    __shm_directory;
+  }
+}
Index: glibc-2.21/libpthread/sysdeps/pthread/flockfile.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/flockfile.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdio.h>
+#include <libio.h>
+#include <bits/libc-lock.h>
+
+
+void
+__flockfile (stream)
+     FILE *stream;
+{
+#ifdef SHARED
+  __libc_ptf_call (_IO_flockfile, (stream), 0);
+#endif
+}
+weak_alias (__flockfile, _IO_flockfile)
+weak_alias (__flockfile, flockfile)
Index: glibc-2.21/libpthread/sysdeps/pthread/ftrylockfile.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/ftrylockfile.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <bits/stdio-lock.h>
+
+
+int
+__ftrylockfile (stream)
+     FILE *stream;
+{
+#ifdef SHARED
+  return __libc_ptf_call (_IO_ftrylockfile, (stream), 0);
+#else
+  return 0;
+#endif
+}
+weak_alias (__ftrylockfile, _IO_ftrylockfile)
+weak_alias (__ftrylockfile, ftrylockfile)
Index: glibc-2.21/libpthread/sysdeps/pthread/funlockfile.c
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/funlockfile.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <pthread.h>
+#include <stdio.h>
+#include <libio.h>
+#include <bits/stdio-lock.h>
+
+
+void
+__funlockfile (stream)
+     FILE *stream;
+{
+#ifdef SHARED
+  __libc_ptf_call (_IO_funlockfile, (stream), 0);
+#endif
+}
+weak_alias (__funlockfile, _IO_funlockfile)
+weak_alias (__funlockfile, funlockfile)
Index: glibc-2.21/libpthread/sysdeps/pthread/bits/libc-lockP.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/bits/libc-lockP.h
@@ -0,0 +1,158 @@
+/* Private libc-internal interface for mutex locks.
+   Copyright (C) 2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_LIBC_LOCKP_H
+#define _BITS_LIBC_LOCKP_H 1
+
+#include <pthread.h>
+#include <pthread-functions.h>
+
+/* If we check for a weakly referenced symbol and then perform a
+   normal jump to it te code generated for some platforms in case of
+   PIC is unnecessarily slow.  What would happen is that the function
+   is first referenced as data and then it is called indirectly
+   through the PLT.  We can make this a direct jump.  */
+#ifdef __PIC__
+# define __libc_maybe_call(FUNC, ARGS, ELSE) \
+  (__extension__ ({ __typeof (FUNC) *_fn = (FUNC); \
+		    _fn != NULL ? (*_fn) ARGS : ELSE; }))
+#else
+# define __libc_maybe_call(FUNC, ARGS, ELSE) \
+  (FUNC != NULL ? FUNC ARGS : ELSE)
+#endif
+
+/* Call thread functions through the function pointer table.  */
+#if defined SHARED && !defined NOT_IN_libc
+# define PTFAVAIL(NAME) __libc_pthread_functions_init
+# define __libc_ptf_call(FUNC, ARGS, ELSE) \
+  (__libc_pthread_functions_init ? PTHFCT_CALL (ptr_##FUNC, ARGS) : ELSE)
+# define __libc_ptf_call_always(FUNC, ARGS) \
+  PTHFCT_CALL (ptr_##FUNC, ARGS)
+#else
+# define PTFAVAIL(NAME) (NAME != NULL)
+# define __libc_ptf_call(FUNC, ARGS, ELSE) \
+  __libc_maybe_call (FUNC, ARGS, ELSE)
+# define __libc_ptf_call_always(FUNC, ARGS) \
+  FUNC ARGS
+#endif
+
+/* Functions that are used by this file and are internal to the GNU C
+   library.  */
+
+extern int __pthread_mutex_init (pthread_mutex_t *__mutex,
+				 const pthread_mutexattr_t *__mutex_attr);
+
+extern int __pthread_mutex_destroy (pthread_mutex_t *__mutex);
+
+extern int __pthread_mutex_trylock (pthread_mutex_t *__mutex);
+
+extern int __pthread_mutex_lock (pthread_mutex_t *__mutex);
+
+extern int __pthread_mutex_unlock (pthread_mutex_t *__mutex);
+
+extern int __pthread_mutexattr_init (pthread_mutexattr_t *__attr);
+
+extern int __pthread_mutexattr_destroy (pthread_mutexattr_t *__attr);
+
+extern int __pthread_mutexattr_settype (pthread_mutexattr_t *__attr,
+					int __kind);
+
+extern int __pthread_rwlock_init (pthread_rwlock_t *__rwlock,
+				  const pthread_rwlockattr_t *__attr);
+
+extern int __pthread_rwlock_destroy (pthread_rwlock_t *__rwlock);
+
+extern int __pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock);
+
+extern int __pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock);
+
+extern int __pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock);
+
+extern int __pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock);
+
+extern int __pthread_rwlock_unlock (pthread_rwlock_t *__rwlock);
+
+extern int __pthread_key_create (pthread_key_t *__key,
+				 void (*__destr_function) (void *));
+
+extern int __pthread_setspecific (pthread_key_t __key,
+				  const void *__pointer);
+
+extern void *__pthread_getspecific (pthread_key_t __key);
+
+extern int __pthread_once (pthread_once_t *__once_control,
+			   void (*__init_routine) (void));
+
+extern int __pthread_atfork (void (*__prepare) (void),
+			     void (*__parent) (void),
+			     void (*__child) (void));
+
+
+
+/* Make the pthread functions weak so that we can elide them from
+   single-threaded processes.  */
+#ifndef __NO_WEAK_PTHREAD_ALIASES
+# ifdef weak_extern
+weak_extern (__pthread_mutex_init)
+weak_extern (__pthread_mutex_destroy)
+weak_extern (__pthread_mutex_lock)
+weak_extern (__pthread_mutex_trylock)
+weak_extern (__pthread_mutex_unlock)
+weak_extern (__pthread_mutexattr_init)
+weak_extern (__pthread_mutexattr_destroy)
+weak_extern (__pthread_mutexattr_settype)
+weak_extern (__pthread_rwlock_init)
+weak_extern (__pthread_rwlock_destroy)
+weak_extern (__pthread_rwlock_rdlock)
+weak_extern (__pthread_rwlock_tryrdlock)
+weak_extern (__pthread_rwlock_wrlock)
+weak_extern (__pthread_rwlock_trywrlock)
+weak_extern (__pthread_rwlock_unlock)
+weak_extern (__pthread_key_create)
+weak_extern (__pthread_setspecific)
+weak_extern (__pthread_getspecific)
+weak_extern (__pthread_once)
+weak_extern (__pthread_initialize)
+weak_extern (__pthread_atfork)
+weak_extern (pthread_setcancelstate)
+# else
+#  pragma weak __pthread_mutex_init
+#  pragma weak __pthread_mutex_destroy
+#  pragma weak __pthread_mutex_lock
+#  pragma weak __pthread_mutex_trylock
+#  pragma weak __pthread_mutex_unlock
+#  pragma weak __pthread_mutexattr_init
+#  pragma weak __pthread_mutexattr_destroy
+#  pragma weak __pthread_mutexattr_settype
+#  pragma weak __pthread_rwlock_destroy
+#  pragma weak __pthread_rwlock_rdlock
+#  pragma weak __pthread_rwlock_tryrdlock
+#  pragma weak __pthread_rwlock_wrlock
+#  pragma weak __pthread_rwlock_trywrlock
+#  pragma weak __pthread_rwlock_unlock
+#  pragma weak __pthread_key_create
+#  pragma weak __pthread_setspecific
+#  pragma weak __pthread_getspecific
+#  pragma weak __pthread_once
+#  pragma weak __pthread_initialize
+#  pragma weak __pthread_atfork
+#  pragma weak pthread_setcancelstate
+# endif
+#endif
+
+#endif	/* bits/libc-lockP.h */
Index: glibc-2.21/libpthread/sysdeps/pthread/pthread-functions.h
===================================================================
--- /dev/null
+++ glibc-2.21/libpthread/sysdeps/pthread/pthread-functions.h
@@ -0,0 +1,141 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _PTHREAD_FUNCTIONS_H
+#define _PTHREAD_FUNCTIONS_H	1
+
+#include <pthread.h>
+
+int __pthread_attr_destroy (pthread_attr_t *);
+int __pthread_attr_init (pthread_attr_t *);
+int __pthread_attr_getdetachstate (const pthread_attr_t *, int *);
+int __pthread_attr_setdetachstate (pthread_attr_t *, int);
+int __pthread_attr_getinheritsched (const pthread_attr_t *, int *);
+int __pthread_attr_setinheritsched (pthread_attr_t *, int);
+int __pthread_attr_getschedparam (const pthread_attr_t *,
+    				 struct sched_param *);
+int __pthread_attr_setschedparam (pthread_attr_t *,
+    				 const struct sched_param *);
+int __pthread_attr_getschedpolicy (const pthread_attr_t *, int *);
+int __pthread_attr_setschedpolicy (pthread_attr_t *, int);
+int __pthread_attr_getscope (const pthread_attr_t *, int *);
+int __pthread_attr_setscope (pthread_attr_t *, int);
+int __pthread_condattr_destroy (pthread_condattr_t *);
+int __pthread_condattr_init (pthread_condattr_t *);
+int __pthread_cond_broadcast (pthread_cond_t *);
+int __pthread_cond_destroy (pthread_cond_t *);
+int __pthread_cond_init (pthread_cond_t *,
+    		       const pthread_condattr_t *);
+int __pthread_cond_signal (pthread_cond_t *);
+int __pthread_cond_wait (pthread_cond_t *, pthread_mutex_t *);
+int __pthread_cond_timedwait (pthread_cond_t *, pthread_mutex_t *,
+    			     const struct timespec *);
+int __pthread_equal (pthread_t, pthread_t);
+void __pthread_exit (void *);
+int __pthread_getschedparam (pthread_t, int *, struct sched_param *);
+int __pthread_setschedparam (pthread_t, int,
+    			    const struct sched_param *);
+int _pthread_mutex_destroy (pthread_mutex_t *);
+int _pthread_mutex_init (pthread_mutex_t *,
+    			 const pthread_mutexattr_t *);
+int __pthread_mutex_lock (pthread_mutex_t *);
+int __pthread_mutex_trylock (pthread_mutex_t *);
+int __pthread_mutex_unlock (pthread_mutex_t *);
+pthread_t __pthread_self (void);
+int __pthread_setcancelstate (int, int *);
+int __pthread_setcanceltype (int, int *);
+struct __pthread_cancelation_handler **__pthread_get_cleanup_stack (void);
+int __pthread_once (pthread_once_t *, void (*) (void));
+int __pthread_rwlock_rdlock (pthread_rwlock_t *);
+int __pthread_rwlock_wrlock (pthread_rwlock_t *);
+int __pthread_rwlock_unlock (pthread_rwlock_t *);
+int __pthread_key_create (pthread_key_t *, void (*) (void *));
+void *__pthread_getspecific (pthread_key_t);
+int __pthread_setspecific (pthread_key_t, const void *);
+
+void _cthreads_flockfile (FILE *);
+void _cthreads_funlockfile (FILE *);
+int _cthreads_ftrylockfile (FILE *);
+
+/* Data type shared with libc.  The libc uses it to pass on calls to
+   the thread functions.  Wine pokes directly into this structure,
+   so if possible avoid breaking it and append new hooks to the end.  */
+struct pthread_functions
+{
+  int (*ptr_pthread_attr_destroy) (pthread_attr_t *);
+  int (*ptr_pthread_attr_init) (pthread_attr_t *);
+  int (*ptr_pthread_attr_getdetachstate) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setdetachstate) (pthread_attr_t *, int);
+  int (*ptr_pthread_attr_getinheritsched) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setinheritsched) (pthread_attr_t *, int);
+  int (*ptr_pthread_attr_getschedparam) (const pthread_attr_t *,
+					 struct sched_param *);
+  int (*ptr_pthread_attr_setschedparam) (pthread_attr_t *,
+					 const struct sched_param *);
+  int (*ptr_pthread_attr_getschedpolicy) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setschedpolicy) (pthread_attr_t *, int);
+  int (*ptr_pthread_attr_getscope) (const pthread_attr_t *, int *);
+  int (*ptr_pthread_attr_setscope) (pthread_attr_t *, int);
+  int (*ptr_pthread_condattr_destroy) (pthread_condattr_t *);
+  int (*ptr_pthread_condattr_init) (pthread_condattr_t *);
+  int (*ptr_pthread_cond_broadcast) (pthread_cond_t *);
+  int (*ptr_pthread_cond_destroy) (pthread_cond_t *);
+  int (*ptr_pthread_cond_init) (pthread_cond_t *,
+			       const pthread_condattr_t *);
+  int (*ptr_pthread_cond_signal) (pthread_cond_t *);
+  int (*ptr_pthread_cond_wait) (pthread_cond_t *, pthread_mutex_t *);
+  int (*ptr_pthread_cond_timedwait) (pthread_cond_t *, pthread_mutex_t *,
+				     const struct timespec *);
+  int (*ptr_pthread_equal) (pthread_t, pthread_t);
+  void (*ptr___pthread_exit) (void *);
+  int (*ptr_pthread_getschedparam) (pthread_t, int *, struct sched_param *);
+  int (*ptr_pthread_setschedparam) (pthread_t, int,
+				    const struct sched_param *);
+  int (*ptr_pthread_mutex_destroy) (pthread_mutex_t *);
+  int (*ptr_pthread_mutex_init) (pthread_mutex_t *,
+				 const pthread_mutexattr_t *);
+  int (*ptr_pthread_mutex_lock) (pthread_mutex_t *);
+  int (*ptr_pthread_mutex_trylock) (pthread_mutex_t *);
+  int (*ptr_pthread_mutex_unlock) (pthread_mutex_t *);
+  pthread_t (*ptr_pthread_self) (void);
+  int (*ptr_pthread_setcancelstate) (int, int *);
+  int (*ptr_pthread_setcanceltype) (int, int *);
+  struct __pthread_cancelation_handler **(*ptr___pthread_get_cleanup_stack) (void);
+  int (*ptr_pthread_once) (pthread_once_t *, void (*) (void));
+  int (*ptr_pthread_rwlock_rdlock) (pthread_rwlock_t *);
+  int (*ptr_pthread_rwlock_wrlock) (pthread_rwlock_t *);
+  int (*ptr_pthread_rwlock_unlock) (pthread_rwlock_t *);
+  int (*ptr_pthread_key_create) (pthread_key_t *, void (*) (void *));
+  void *(*ptr_pthread_getspecific) (pthread_key_t);
+  int (*ptr_pthread_setspecific) (pthread_key_t, const void *);
+  void (*ptr__IO_flockfile) (FILE *);
+  void (*ptr__IO_funlockfile) (FILE *);
+  int (*ptr__IO_ftrylockfile) (FILE *);
+};
+
+/* Variable in libc.so.  */
+extern struct pthread_functions __libc_pthread_functions attribute_hidden;
+extern int __libc_pthread_functions_init attribute_hidden;
+
+void __libc_pthread_init (const struct pthread_functions *functions);
+
+# define PTHFCT_CALL(fct, params) \
+    __libc_pthread_functions.fct params
+
+#endif	/* pthread-functions.h */
