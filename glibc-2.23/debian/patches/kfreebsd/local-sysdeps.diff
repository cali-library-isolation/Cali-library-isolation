--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/Dist
@@ -0,0 +1,29 @@
+bits/mcontext.h
+bits/stat16.h
+fpu.h
+machine/pal.h
+net/ethernet.h
+net/if_arp.h
+net/if_ether.h
+net/if_dl.h
+net/route.h
+nfs/nfs.h
+regdef.h
+sa_len.c
+stat16conv.c
+statfsconv.c
+sys/acl.h
+sys/extattr.h
+sys/io.h
+sys/jail.h
+sys/linker.h
+sys/mount.h
+sys/perm.h
+sys/rfork.h
+sys/rtprio.h
+sys/syslimits.h
+sys/timex.h
+sys/vm86.h
+sys_lseek.S
+sysarch.h
+ucontext_i.h
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/Implies
@@ -0,0 +1,11 @@
+# The kernel include files come from the 'kernel-include' add-on.
+# This is actually added by configure.in.
+#/usr/src/sys/
+
+# One of two possible utmp file formats.
+# This is actually added by configure.in.
+#unix/bsd/bsd4.4/kfreebsd/utmp-xyz
+
+# The gnu subdirectory exists for things common to Linux-based, Hurd-based
+# and kFreeBSD-based GNU systems.
+gnu
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/Makefile
@@ -0,0 +1,138 @@
+# Use bash, not /bin/sh, for executing scripts, because the native
+# FreeBSD /bin/sh does not interpret the  IFS="<tab>" read ...  command
+# in localedata/tst-fmon.sh correctly.
+SHELL = bash
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ kenv.h \
+ bits/os-unistd.h \
+ sys/mount.h \
+ sys/kd.h \
+ sys/rfork.h
+endif
+
+ifeq ($(subdir),stdlib)
+sysdep_headers += \
+ bits/mcontext.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),csu)
+# For <errno.h>.
+sysdep_routines += errno-loc
+endif
+
+ifeq ($(subdir),assert)
+CFLAGS-assert.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
+CFLAGS-assert-perr.c += -DFATAL_PREPARE_INCLUDE='<fatal-prepare.h>'
+endif
+
+ifeq ($(subdir),io)
+# For <unistd.h>.
+sysdep_routines += sys_access sys_faccessat sys_getcwd
+# For <fcntl.h>.
+sysdep_routines += sys_open sys_openat open_2
+# For <sys/stat.h>.
+sysdep_routines += sys_fstat sys_fstatat sys_lstat sys_mkfifoat sys_mknod sys_mknodat sys_nfstat sys_nlstat sys_nstat sys_stat lchflags
+# For <sys/statfs.h>.
+sysdep_routines += fstatfs64 statfs64 sys_fstatfs sys_statfs
+# For <sys/times.h>.
+sysdep_routines += sys_futimesat
+# Other.
+sysdep_routines += lchmod
+endif
+
+ifeq ($(subdir),dirent)
+# For <dirent.h>.
+sysdep_routines += sys_getdents sys_getdirentries getdirentries getdirentries64
+endif
+
+ifeq ($(subdir),misc)
+# For <kenv.h>.
+sysdep_routines += kenv
+# For <sched.h>.
+sysdep_routines += clone start_thread
+# For <unistd.h>.
+sysdep_routines += getosreldate
+# For <sys/acl.h>.
+sysdep_routines += acl_aclcheck_fd acl_aclcheck_file acl_delete_fd acl_delete_file acl_get_fd acl_get_file acl_set_fd acl_set_file
+# For <sys/extattr.h>.
+sysdep_routines += extattrctl extattr_delete_file extattr_get_file extattr_set_file
+# For <sys/jail.h>.
+sysdep_routines += jail jail_attach jail_remove jail_get jail_set
+# For <sys/ktrace.h>.
+sysdep_routines += ktrace utrace
+# For <sys/linker.h>.
+sysdep_routines += kldfind kldfirstmod kldload kldnext kldstat kldsym kldunload kldunloadf
+# For <sys/mman.h>.
+sysdep_routines += minherit sys_mmap sys_munmap
+# For <sys/mount.h>.
+sysdep_routines += fhopen sys_fhstat sys_fhstatfs fhstat fhstat64 fhstatfs fhstatfs64 getfh getfsstat getfsstat64 sys_getfsstat getmntinfo getmntinfo64 mount nmount unmount
+# For <sys/rfork.h>.
+sysdep_routines += rfork
+# For <sys/rtprio.h>.
+sysdep_routines += rtprio
+# For <sys/socket.h>.
+sysdep_routines += bsd_sendfile
+# For <sys/stat.h>.
+sysdep_routines += devname
+# For <sys/sysctl.h>.
+sysdep_routines += sysctl sysctlbyname sysctlnametomib
+# For <sys/uio.h>.
+sysdep_routines += sys_readv sys_writev
+# Other.
+sysdep_routines += swapon swapoff sys_aio_cancel sys_aio_error sys_aio_read sys_aio_return sys_aio_suspend sys_aio_waitcomplete sys_aio_write sys_lio_listio issetugid modfind modfnext modnext modstat obreak quotactl rfork sysarch undelete yield
+# for INLINE_SYSCALL
+sysdep_routines += sys_fork sys_sigaction sys_close sys_fcntl
+sysdep_routines += sys_clock_getres sys_clock_gettime sys_clock_settime
+sysdep_routines += sys_ktimer_create sys_ktimer_gettime sys_ktimer_settime sys_ktimer_getoverrun sys_ktimer_delete
+sysdep_routines += sys_semctl sys_shmctl sys_msgctl
+endif
+
+ifeq ($(subdir),posix)
+# For <unistd.h>.
+sysdep_routines += sys_getlogin sys_setlogin sys_read sys_write
+# for <sched.h>
+sysdep_routines += sys_cpuset_getaffinity sys_cpuset_setaffinity
+endif
+
+ifeq ($(subdir),inet)
+sysdep_headers += net/ethernet.h net/if_ether.h
+endif
+
+ifeq ($(subdir),time)
+# For <sys/timex.h>.
+sysdep_routines += ntp_adjtime ntp_gettime
+endif
+
+ifeq ($(subdir),socket)
+sysdep_routines += sa_len sys_bind sys_connect sys_sendto
+endif
+
+# Linuxthreads dependencies.
+
+ifeq ($(subdir),posix)
+sysdep_headers += bits/initspin.h
+endif
+
+# Don't compile the ctype glue code, since we have a much better <ctype.h>
+# than the old non-GNU C library.
+inhibit-glue = yes
+
+# Special ELF hacks.
+ifeq ($(subdir),elf)
+sysdep-rtld-routines += dl-brk dl-sbrk dl-getcwd dl-openat64
+sysdep_routines += sys_umtx
+endif
+
+ifeq ($(subdir),sunrpc)
+sysdep_headers += nfs/nfs.h
+endif
+
+ifeq ($(subdir),rt)
+librt-routines += sys_shm_open
+endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/Versions
@@ -0,0 +1,129 @@
+libc {
+  # The comment lines with "#errlist-compat" are magic; see errlist-compat.awk.
+  # When you get an error from errlist-compat.awk, you need to add a new
+  # version here.  Don't do this blindly, since this means changing the ABI
+  # for all GNU/kFreeBSD configurations.
+
+  GLIBC_2.2.6 {
+    # c*
+    clone;
+
+    # e*
+    extattrctl; extattr_delete_file; extattr_get_file; extattr_set_file;
+
+    # f*
+    fhopen; fhstat; fhstatfs; futimes;
+
+    # g*
+    getdents; getfh; getfsstat; getfsstat64; getmntinfo; getmntinfo64;
+    getresgid; getresuid;
+
+    # i*
+    issetugid;
+
+    # j*
+    jail;
+
+    # k*
+    kldfind; kldfirstmod; kldload; kldnext; kldstat; kldsym; kldunload; kldunloadf;
+    ktrace;
+
+    # l*
+    lchmod; lutimes;
+
+    # m*
+    minherit; modfind; modfnext; modnext; modstat; mount;
+
+    # n*
+    nmount; ntp_adjtime; ntp_gettime;
+
+    # q*
+    quotactl;
+
+    # r*
+    rfork; rtprio;
+
+    # s*
+    sendfile; setresgid; setresuid; swapoff; swapon; sysarch; sysctl; sysctlbyname;
+
+    # u*
+    undelete; unmount; utrace;
+
+    # see <sys/acl.h>.
+    __acl_aclcheck_fd; __acl_aclcheck_file; __acl_delete_fd; __acl_delete_file;
+    __acl_get_fd; __acl_get_file; __acl_set_fd; __acl_set_file;
+
+    # see <errno.h>.
+    __errno_location;
+
+    # see <sys/sysctl.h>.
+    __sysctl;
+
+    # Questionable system calls. These functions may be removed at any moment.
+    __syscall_aio_cancel; __syscall_aio_error; __syscall_aio_read;
+    __syscall_aio_return; __syscall_aio_suspend; __syscall_aio_waitcomplete;
+    __syscall_aio_write; __syscall_lio_listio;
+    __syscall_obreak;
+    __syscall_yield;
+  }
+  GLIBC_2.3 {
+    #errlist-compat     87
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.3.4 {
+    # f*
+    fhstat64; fhstatfs64;
+    kqueue; kevent;
+
+    #errlist-compat     93
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+
+    # functions used in inline functions or macros
+    __libc_sa_len;
+  }
+  GLIBC_2.10 {
+    devname;
+    devname_r;
+    kenv;
+    sysctlnametomib;
+  }
+  GLIBC_2.11 {
+    lchflags;
+    #errlist-compat 94
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.13 {
+    jail_attach;
+    jail_remove;
+    jail_get;
+    jail_set;
+  }
+  GLIBC_2.18 {
+    msgctl;
+    semctl;
+    shmctl;
+    waitid;
+    #errlist-compat 97
+    _sys_errlist; sys_errlist; _sys_nerr; sys_nerr;
+  }
+  GLIBC_2.21 {
+    __statfs;
+  }
+  GLIBC_PRIVATE {
+    # needed by libpthread.
+    __clone; __libc_fork; __libc_sigaction; __kernel_getosreldate;
+    # needed by libpthread as INLINE_SYSCALL:
+    __syscall_fork;
+    __syscall_open; __syscall_close;
+    __syscall_read; __syscall_write;
+    __syscall_wait4; __syscall_fcntl;
+    # needed by librt as INLINE_SYSCALL:
+    __syscall_clock_getres; __syscall_clock_gettime; __syscall_clock_settime;
+    __syscall_ktimer_create; __syscall_ktimer_gettime; __syscall_ktimer_settime; __syscall_ktimer_getoverrun; __syscall_ktimer_delete;
+    # misc fixes for FreeBSD:
+    __syscall_connect; __syscall_sendto;
+    __syscall_cpuset_getaffinity ; __syscall_cpuset_setaffinity;
+     # global variable used in brk()
+    _end;
+  }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/_exit.S
@@ -0,0 +1,26 @@
+/* Copyright (C) 1991,92,97,99,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+PSEUDO (_exit, exit, 1)
+	/* Shouldn't get here.  */
+PSEUDO_END(_exit)
+libc_hidden_def (_exit)
+rtld_hidden_def (_exit)
+weak_alias (_exit, _Exit)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/a.out.h
@@ -0,0 +1,140 @@
+#ifndef __A_OUT_GNU_H__
+#define __A_OUT_GNU_H__
+
+#define __GNU_EXEC_MACROS__
+
+struct exec
+{
+  unsigned long a_info;	/* Use macros N_MAGIC, etc for access.  */
+  unsigned int a_text;	/* Length of text, in bytes.  */
+  unsigned int a_data;	/* Length of data, in bytes.  */
+  unsigned int a_bss;	/* Length of uninitialized data area for file, in bytes.  */
+  unsigned int a_syms;	/* Length of symbol table data in file, in bytes.  */
+  unsigned int a_entry;	/* Start address.  */
+  unsigned int a_trsize;/* Length of relocation info for text, in bytes.  */
+  unsigned int a_drsize;/* Length of relocation info for data, in bytes.  */
+};
+
+enum machine_type
+{
+  M_OLDSUN2 = 0,
+  M_68010 = 1,
+  M_68020 = 2,
+  M_SPARC = 3,
+  M_386 = 100,
+  M_MIPS1 = 151,
+  M_MIPS2 = 152
+};
+
+#define N_MAGIC(exec)	((exec).a_info & 0xffff)
+#define N_MACHTYPE(exec) ((enum machine_type)(((exec).a_info >> 16) & 0xff))
+#define N_FLAGS(exec)	(((exec).a_info >> 24) & 0xff)
+#define N_SET_INFO(exec, magic, type, flags) \
+  ((exec).a_info = ((magic) & 0xffff)					\
+   | (((int)(type) & 0xff) << 16)					\
+   | (((flags) & 0xff) << 24))
+#define N_SET_MAGIC(exec, magic) \
+  ((exec).a_info = ((exec).a_info & 0xffff0000) | ((magic) & 0xffff))
+#define N_SET_MACHTYPE(exec, machtype) \
+  ((exec).a_info =							\
+   ((exec).a_info&0xff00ffff) | ((((int)(machtype))&0xff) << 16))
+#define N_SET_FLAGS(exec, flags) \
+  ((exec).a_info =							\
+   ((exec).a_info&0x00ffffff) | (((flags) & 0xff) << 24))
+
+/* Code indicating object file or impure executable.  */
+#define OMAGIC 0407
+/* Code indicating pure executable.  */
+#define NMAGIC 0410
+/* Code indicating demand-paged executable.  */
+#define ZMAGIC 0413
+/* This indicates a demand-paged executable with the header in the text. 
+   The first page is unmapped to help trap NULL pointer references.  */
+#define QMAGIC 0314
+/* Code indicating core file.  */
+#define CMAGIC 0421
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+#define N_BADMAG(x) \
+  (N_MAGIC(x) != OMAGIC	&& N_MAGIC(x) != NMAGIC				\
+   && N_MAGIC(x) != ZMAGIC && N_MAGIC(x) != QMAGIC)
+#define _N_HDROFF(x)	(1024 - sizeof (struct exec))
+#define N_TXTOFF(x) \
+  (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) :	\
+   (N_MAGIC(x) == QMAGIC ? 0 : sizeof (struct exec)))
+#define N_DATOFF(x)	(N_TXTOFF(x) + (x).a_text)
+#define N_TRELOFF(x)	(N_DATOFF(x) + (x).a_data)
+#define N_DRELOFF(x)	(N_TRELOFF(x) + N_TRSIZE(x))
+#define N_SYMOFF(x)	(N_DRELOFF(x) + N_DRSIZE(x))
+#define N_STROFF(x)	(N_SYMOFF(x) + N_SYMSIZE(x))
+
+/* Address of text segment in memory after it is loaded.  */
+#define N_TXTADDR(x)	(N_MAGIC(x) == QMAGIC ? 4096 : 0)
+
+/* Address of data segment in memory after it is loaded.  */
+#define SEGMENT_SIZE	1024
+
+#define _N_SEGMENT_ROUND(x) (((x) + SEGMENT_SIZE - 1) & ~(SEGMENT_SIZE - 1))
+#define _N_TXTENDADDR(x) (N_TXTADDR(x)+(x).a_text)
+
+#define N_DATADDR(x) \
+  (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x))				\
+   : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x))))
+#define N_BSSADDR(x) (N_DATADDR(x) + (x).a_data)
+
+#if !defined (N_NLIST_DECLARED)
+struct nlist
+{
+  union 
+  {
+  char *n_name;
+  union
+    {
+      char *n_name;
+      struct nlist *n_next;
+      long n_strx;
+    } n_un;
+  } __attribute__ ((__transparent_union__)); 
+  unsigned char n_type;
+  char n_other;
+  short n_desc;
+  unsigned long n_value;
+};
+#endif /* no N_NLIST_DECLARED.  */
+
+#define N_UNDF	0
+#define N_ABS	2
+#define N_TEXT	4
+#define N_DATA	6
+#define N_BSS	8
+#define N_FN	15
+#define N_EXT	1
+#define N_TYPE	036
+#define N_STAB	0340
+#define N_INDR	0xa
+#define	N_SETA	0x14	/* Absolute set element symbol.  */
+#define	N_SETT	0x16	/* Text set element symbol.  */
+#define	N_SETD	0x18	/* Data set element symbol.  */
+#define	N_SETB	0x1A	/* Bss set element symbol.  */
+#define N_SETV	0x1C	/* Pointer to set vector in data area.  */
+
+#if !defined (N_RELOCATION_INFO_DECLARED)
+/* This structure describes a single relocation to be performed.
+   The text-relocation section of the file is a vector of these structures,
+   all of which apply to the text section.
+   Likewise, the data-relocation section applies to the data section.  */
+
+struct relocation_info
+{
+  int r_address;
+  unsigned int r_symbolnum:24;
+  unsigned int r_pcrel:1;
+  unsigned int r_length:2;
+  unsigned int r_extern:1;
+  unsigned int r_pad:4;
+};
+#endif /* no N_RELOCATION_INFO_DECLARED.  */
+
+#endif /* __A_OUT_GNU_H__ */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/access.c
@@ -0,0 +1,67 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <sysdep.h>
+
+/*
+   The FreeBSD kernel do not test file access correctly when the 
+   process' real user ID is superuser. In particular, they always return
+   zero when testing execute permissions without regard to whether the 
+   file is executable.
+
+   While this behaviour conforms to POSIX.1-2008, it is explicitely 
+   discouraged. This wrapper implements the recommended behaviour.
+ */
+
+extern int __syscall_access (const char *path, int mode);
+libc_hidden_proto (__syscall_access)
+
+int
+__access (const char *path, int mode)
+{
+  struct stat64 stats;
+
+  if ((__getuid() != 0) || !(mode & X_OK))
+    return __syscall_access (path, mode);
+
+  /* Althought the super-user can read and write any file, 
+     the file-system might be i.e. read-only. Do the check. */
+     
+  if (__syscall_access (path, mode))
+    return -1;
+    
+  if (stat64 (path, &stats))
+    return -1;
+
+  /* The super-user can execute any file that anyone can execute. */
+  if (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))
+    return 0;
+
+  __set_errno (EACCES);
+  return -1;
+}
+
+weak_alias (__access, access)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/aio_sigqueue.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <aio.h>
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <aio_misc.h>
+
+int
+internal_function
+__aio_sigqueue (int sig, const union sigval val, pid_t caller_pid)
+{
+#if !IS_IN (libc)
+    return sigqueue(caller_pid, sig, val);
+#else
+    return __sigqueue(caller_pid, sig, val);
+#endif    
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bind.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour. */
+
+extern int __libc_sa_len (sa_family_t __af);
+libc_hidden_proto (__libc_sa_len)
+
+extern int __syscall_bind (int fd, __CONST_SOCKADDR_ARG addr,
+			   socklen_t addrlen) __THROW;
+libc_hidden_proto (__syscall_bind)
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.  */
+
+int
+__bind (int fd, __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if ((new_addrlen != 0) && (new_addrlen < addrlen))
+    addrlen = new_addrlen;
+
+  /* We pass 3 arguments.  */
+  return INLINE_SYSCALL (bind, 3, fd, addr.__sockaddr__, addrlen);
+}
+
+weak_alias (__bind, bind)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/auxv.h
@@ -0,0 +1,44 @@
+/* Copyright (C) 1995-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Legal values for a_type (entry type).  */
+
+#define	AT_NULL		0	/* End of vector */
+#define	AT_IGNORE	1	/* Entry should be ignored */
+#define	AT_EXECFD	2	/* File descriptor of program */
+#define	AT_PHDR		3	/* Program headers for program */
+#define	AT_PHENT	4	/* Size of program header entry */
+#define	AT_PHNUM	5	/* Number of program headers */
+#define	AT_PAGESZ	6	/* System page size */
+#define	AT_BASE		7	/* Base address of interpreter */
+#define	AT_FLAGS	8	/* Flags */
+#define	AT_ENTRY	9	/* Entry point of program */
+#define	AT_NOTELF	10	/* Program is not ELF */
+#define	AT_UID		11	/* Real uid */
+#define	AT_EUID		12	/* Effective uid */
+#define	AT_GID		13	/* Real gid */
+#define	AT_EGID		14	/* Effective gid */
+#define	AT_EXECPATH	15	/* Path to the executable. */
+#define	AT_CANARY	16	/* Canary for SSP. */
+#define	AT_CANARYLEN	17	/* Length of the canary. */
+#define	AT_OSRELDATE	18	/* OSRELDATE. */
+#define	AT_NCPUS	19	/* Number of CPUs. */
+#define	AT_PAGESIZES	20	/* Pagesizes. */
+#define	AT_PAGESIZESLEN	21	/* Number of pagesizes. */
+#define	AT_TIMEKEEP	22	/* Pointer to timehands. */
+#define	AT_STACKPROT	23	/* Initial stack protection. */
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/dirent.h
@@ -0,0 +1,55 @@
+/* Directory entry structure `struct dirent'.  FreeBSD version.
+   Copyright (C) 1996-1998,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _DIRENT_H
+# error "Never use <bits/dirent.h> directly; include <dirent.h> instead."
+#endif
+
+struct dirent
+  {
+    unsigned int d_ino;		/* File serial number.  */
+    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
+    unsigned char d_type;	/* File type, possibly unknown.  */
+    unsigned char d_namlen;	/* Length of the file name.  */
+
+    /* Only this member is in the POSIX standard.  */
+    char d_name[256];		/* File name (actually longer).  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct dirent64
+  {
+    unsigned int d_ino;		/* File serial number.  */
+    unsigned short int d_reclen; /* Length of the whole `struct dirent'.  */
+    unsigned char d_type;	/* File type, possibly unknown.  */
+    unsigned char d_namlen;	/* Length of the file name.  */
+
+    /* Only this member is in the POSIX standard.  */
+    char d_name[256];		/* File name (actually longer).  */
+  };
+#endif
+
+#define d_fileno        d_ino   /* Backwards compatibility.  */
+
+#define _DIRENT_HAVE_D_RECLEN 1
+#define _DIRENT_HAVE_D_NAMLEN 1
+#define _DIRENT_HAVE_D_TYPE 1
+
+/* Inform libc code that these two types are effectively identical.  */
+# define _DIRENT_MATCHES_DIRENT64       1
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/errno.h
@@ -0,0 +1,195 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)errno.h	8.5 (Berkeley) 1/21/94
+ * $FreeBSD$
+ */
+
+#ifdef _ERRNO_H
+
+# undef EDOM
+# undef EILSEQ
+# undef ERANGE
+
+#define	EPERM		1		/* Operation not permitted */
+#define	ENOENT		2		/* No such file or directory */
+#define	ESRCH		3		/* No such process */
+#define	EINTR		4		/* Interrupted system call */
+#define	EIO		5		/* Input/output error */
+#define	ENXIO		6		/* Device not configured */
+#define	E2BIG		7		/* Argument list too long */
+#define	ENOEXEC		8		/* Exec format error */
+#define	EBADF		9		/* Bad file descriptor */
+#define	ECHILD		10		/* No child processes */
+#define	EDEADLK		11		/* Resource deadlock avoided */
+					/* 11 was EAGAIN */
+#define	ENOMEM		12		/* Cannot allocate memory */
+#define	EACCES		13		/* Permission denied */
+#define	EFAULT		14		/* Bad address */
+#define	ENOTBLK		15		/* Block device required */
+#define	EBUSY		16		/* Device busy */
+#define	EEXIST		17		/* File exists */
+#define	EXDEV		18		/* Cross-device link */
+#define	ENODEV		19		/* Operation not supported by device */
+#define	ENOTDIR		20		/* Not a directory */
+#define	EISDIR		21		/* Is a directory */
+#define	EINVAL		22		/* Invalid argument */
+#define	ENFILE		23		/* Too many open files in system */
+#define	EMFILE		24		/* Too many open files */
+#define	ENOTTY		25		/* Inappropriate ioctl for device */
+#define	ETXTBSY		26		/* Text file busy */
+#define	EFBIG		27		/* File too large */
+#define	ENOSPC		28		/* No space left on device */
+#define	ESPIPE		29		/* Illegal seek */
+#define	EROFS		30		/* Read-only filesystem */
+#define	EMLINK		31		/* Too many links */
+#define	EPIPE		32		/* Broken pipe */
+
+/* math software */
+#define	EDOM		33		/* Numerical argument out of domain */
+#define	ERANGE		34		/* Result too large */
+
+/* non-blocking and interrupt i/o */
+#define	EAGAIN		35		/* Resource temporarily unavailable */
+#define	EWOULDBLOCK	EAGAIN		/* Operation would block */
+#define	EINPROGRESS	36		/* Operation now in progress */
+#define	EALREADY	37		/* Operation already in progress */
+
+/* ipc/network software -- argument errors */
+#define	ENOTSOCK	38		/* Socket operation on non-socket */
+#define	EDESTADDRREQ	39		/* Destination address required */
+#define	EMSGSIZE	40		/* Message too long */
+#define	EPROTOTYPE	41		/* Protocol wrong type for socket */
+#define	ENOPROTOOPT	42		/* Protocol not available */
+#define	EPROTONOSUPPORT	43		/* Protocol not supported */
+#define	ESOCKTNOSUPPORT	44		/* Socket type not supported */
+#define	EOPNOTSUPP	45		/* Operation not supported */
+#define	ENOTSUP		EOPNOTSUPP	/* Operation not supported */
+#define	EPFNOSUPPORT	46		/* Protocol family not supported */
+#define	EAFNOSUPPORT	47		/* Address family not supported by protocol family */
+#define	EADDRINUSE	48		/* Address already in use */
+#define	EADDRNOTAVAIL	49		/* Can't assign requested address */
+
+/* ipc/network software -- operational errors */
+#define	ENETDOWN	50		/* Network is down */
+#define	ENETUNREACH	51		/* Network is unreachable */
+#define	ENETRESET	52		/* Network dropped connection on reset */
+#define	ECONNABORTED	53		/* Software caused connection abort */
+#define	ECONNRESET	54		/* Connection reset by peer */
+#define	ENOBUFS		55		/* No buffer space available */
+#define	EISCONN		56		/* Socket is already connected */
+#define	ENOTCONN	57		/* Socket is not connected */
+#define	ESHUTDOWN	58		/* Can't send after socket shutdown */
+#define	ETOOMANYREFS	59		/* Too many references: can't splice */
+#define	ETIMEDOUT	60		/* Operation timed out */
+#define	ECONNREFUSED	61		/* Connection refused */
+
+#define	ELOOP		62		/* Too many levels of symbolic links */
+#define	ENAMETOOLONG	63		/* File name too long */
+
+/* should be rearranged */
+#define	EHOSTDOWN	64		/* Host is down */
+#define	EHOSTUNREACH	65		/* No route to host */
+#define	ENOTEMPTY	66		/* Directory not empty */
+
+/* quotas & mush */
+#define	EPROCLIM	67		/* Too many processes */
+#define	EUSERS		68		/* Too many users */
+#define	EDQUOT		69		/* Disc quota exceeded */
+
+/* Network File System */
+#define	ESTALE		70		/* Stale NFS file handle */
+#define	EREMOTE		71		/* Too many levels of remote in path */
+#define	EBADRPC		72		/* RPC struct is bad */
+#define	ERPCMISMATCH	73		/* RPC version wrong */
+#define	EPROGUNAVAIL	74		/* RPC prog. not avail */
+#define	EPROGMISMATCH	75		/* Program version wrong */
+#define	EPROCUNAVAIL	76		/* Bad procedure for program */
+
+#define	ENOLCK		77		/* No locks available */
+#define	ENOSYS		78		/* Function not implemented */
+
+#define	EFTYPE		79		/* Inappropriate file type or format */
+#define	EAUTH		80		/* Authentication error */
+#define	ENEEDAUTH	81		/* Need authenticator */
+#define	EIDRM		82		/* Identifier removed */
+#define	ENOMSG		83		/* No message of desired type */
+#define	EOVERFLOW	84		/* Value too large to be stored in data type */
+#define	ECANCELED	85		/* Operation canceled */
+#define	EILSEQ		86		/* Illegal byte sequence */
+#define	ENOATTR		87		/* Attribute not found */
+
+#define	EDOOFUS		88		/* Programming error */
+
+#define	EBADMSG		89		/* Bad message */
+#define	EMULTIHOP	90		/* Multihop attempted */
+#define	ENOLINK		91		/* Link has been severed */
+#define	EPROTO		92		/* Protocol error */
+
+#define	ENOTCAPABLE	93		/* Capabilities insufficient */
+#define	ECAPMODE	94		/* Not permitted in capability mode */
+#define	ENOTRECOVERABLE	95		/* State not recoverable */
+#define	EOWNERDEAD	96		/* Previous owner died */
+
+#define	ELAST		96		/* Must be equal largest errno */
+
+#ifdef _KERNEL
+/* pseudo-errors returned inside kernel to modify return to process */
+#define	ERESTART	(-1)		/* restart syscall */
+#define	EJUSTRETURN	(-2)		/* don't modify regs, just return */
+#define	ENOIOCTL	(-3)		/* ioctl not handled by this layer */
+#define	EDIRIOCTL	(-4)		/* do direct ioctl in GEOM */
+#endif
+
+# ifndef __ASSEMBLER__
+/* Function to get address of global `errno' variable.  */
+extern int *__errno_location (void) __THROW __attribute__ ((__const__));
+
+#  if !defined _LIBC || defined _LIBC_REENTRANT
+/* When using threads, errno is a per-thread value.  */
+#   define errno (*__errno_location ())
+#  endif
+# endif /* !__ASSEMBLER__ */
+#endif /* _ERRNO_H */
+
+#if !defined _ERRNO_H && defined __need_Emath
+/* This is ugly but the kernel header is not clean enough.  We must
+   define only the values EDOM, EILSEQ and ERANGE in case __need_Emath is
+   defined.  */
+
+#define	EDOM		33		/* Numerical argument out of domain */
+#define	ERANGE		34		/* Result too large */
+#define	EILSEQ		86		/* Illegal byte sequence */
+
+#endif /* !_ERRNO_H && __need_Emath */
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/fcntl.h
@@ -0,0 +1,233 @@
+/* O_*, F_*, FD_* bit values for FreeBSD.
+   Copyright (C) 1991-1992, 1997-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+#include <sys/types.h>
+#include <bits/wordsize.h>
+#ifdef __USE_GNU
+# include <bits/uio.h>
+#endif
+
+/*
+ * File status flags: these are used by open(2), fcntl(2).
+ * They are also used (indirectly) in the kernel file structure f_flags,
+ * which is a superset of the open/fcntl flags.  Open flags and f_flags
+ * are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
+ * Open/fcntl flags begin with O_; kernel-internal flags begin with F.
+ */
+/* open-only flags */
+#define	O_RDONLY	0x0000		/* open for reading only */
+#define	O_WRONLY	0x0001		/* open for writing only */
+#define	O_RDWR		0x0002		/* open for reading and writing */
+#define	O_ACCMODE	0x0003		/* mask for above modes */
+
+/*
+ * Kernel encoding of open mode; separate read and write bits that are
+ * independently testable: 1 greater than the above.
+ */
+ 
+#define	O_NONBLOCK	0x0004		/* no delay */
+#define	O_NDELAY	O_NONBLOCK	/* compat */
+#define	O_APPEND	0x0008		/* set append mode */
+
+#if defined __USE_MISC
+#define	O_SHLOCK	0x0010		/* open with shared file lock */
+#define	O_EXLOCK	0x0020		/* open with exclusive file lock */
+#endif
+
+#define	O_ASYNC		0x0040		/* signal pgrp when data ready */
+#define	O_FSYNC		0x0080		/* synchronous writes */
+#define	O_SYNC		O_FSYNC		/* POSIX synonym for O_FSYNC */
+
+#if defined (__USE_XOPEN2K8) || defined (__USE_MISC)
+#define	O_NOFOLLOW	0x0100		/* don't follow symlinks */
+#endif
+
+#define	O_CREAT		0x0200		/* create if nonexistent */
+#define	O_TRUNC		0x0400		/* truncate to zero length */
+#define	O_EXCL		0x0800		/* error if already exists */
+/* Defined by POSIX 1003.1; BSD default, but must be distinct from O_RDONLY. */
+#define	O_NOCTTY	0x8000		/* don't assign controlling terminal */
+
+#if defined __USE_MISC
+/* Attempt to bypass buffer cache */
+#define	O_DIRECT	0x00010000
+enum { O_NOATIME = 0};          /* Do not set atime.  */
+#endif
+
+/* Defined by POSIX Extended API Set Part 2 */
+#if defined (__USE_XOPEN2K8) || defined (__USE_MISC)
+#define	O_DIRECTORY	0x00020000	/* Fail if not directory */
+#define	O_EXEC		0x00040000	/* Open for execute only */
+#endif
+
+#if defined (__USE_XOPEN2K8) || defined (__USE_MISC)
+/* Defined by POSIX 1003.1-2008; BSD default, but reserve for future use. */
+#define	O_TTY_INIT	0x00080000	/* Restore default termios attributes */
+#define	O_CLOEXEC	0x00100000
+#endif
+
+/* For now FreeBSD has synchronisity options for data and read operations.
+   We define the symbols here but let them do the same as O_SYNC since
+   this is a superset.	*/
+#if defined __USE_POSIX199309 || defined __USE_UNIX98
+# define O_DSYNC	O_SYNC	/* Synchronize data.  */
+# define O_RSYNC	O_SYNC	/* Synchronize read operations.	 */
+#endif
+
+/* Since 'off_t' is 64-bit, O_LARGEFILE is a no-op.  */
+#define O_LARGEFILE	0
+
+#ifdef __USE_MISC
+/* Bits in the file status flags returned by F_GETFL.
+   These are all the O_* flags, plus FREAD and FWRITE, which are
+   independent bits set by which of O_RDONLY, O_WRONLY, and O_RDWR, was
+   given to `open'.  */
+#define FREAD		1
+#define	FWRITE		2
+#endif
+
+#ifdef __USE_ATFILE
+# define AT_FDCWD		-100	/* Special value used to indicate
+					   the *at functions should use the
+					   current working directory. */
+# define AT_EACCESS		0x100	/* Test access permitted for
+					   effective IDs, not real IDs.  */
+# define AT_SYMLINK_NOFOLLOW	0x200	/* Do not follow symbolic links.  */
+# define AT_SYMLINK_FOLLOW	0x400	/* Follow symbolic links.  */
+# define AT_REMOVEDIR		0x800	/* Remove directory instead of
+					   unlinking file.  */
+#endif
+
+/*
+ * We are out of bits in f_flag (which is a short).  However,
+ * the flag bits not set in FMASK are only meaningful in the
+ * initial open syscall.  Those bits can thus be given a
+ * different meaning for fcntl(2).
+ */
+#ifdef __USE_MISC
+/*
+ * Set by shm_open(3) to get automatic MAP_ASYNC behavior
+ * for POSIX shared memory objects (which are otherwise
+ * implemented as plain files).
+ */
+#define FRDAHEAD        O_CREAT
+#define FPOSIXSHM	O_NOFOLLOW
+#endif
+
+/* Values for the second argument to `fcntl'.  */
+#define F_DUPFD		0	/* Duplicate file descriptor.  */
+#define F_GETFD		1	/* Get file descriptor flags.  */
+#define F_SETFD		2	/* Set file descriptor flags.  */
+#define F_GETFL		3	/* Get file status flags.  */
+#define F_SETFL		4	/* Set file status flags.  */
+#define F_GETLK		11	/* Get record locking info.  */
+#define F_SETLK		12	/* Set record locking info (non-blocking).  */
+#define F_SETLKW	13	/* Set record locking info (blocking).	*/
+/* Not necessary, we always have 64-bit offsets.  */
+#define F_GETLK64	11	/* Get record locking info.  */
+#define F_SETLK64	12	/* Set record locking info (non-blocking).  */
+#define F_SETLKW64	13	/* Set record locking info (blocking).	*/
+
+#ifdef __USE_XOPEN2K8
+#define	F_DUPFD_CLOEXEC	17	/* Like F_DUPFD, but FD_CLOEXEC is set */
+#endif
+#if defined __USE_MISC
+#define F_DUP2FD_CLOEXEC 18	/* Like F_DUP2FD, but FD_CLOEXEC is set */
+#endif
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K8
+# define F_GETOWN	5	/* Get owner of socket (receiver of SIGIO).  */
+# define F_SETOWN	6	/* Set owner of socket (receiver of SIGIO).  */
+#endif
+
+/* For F_[GET|SET]FD.  */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* record locking flags (F_GETLK, F_SETLK, F_SETLKW) */
+#define	F_RDLCK		1		/* shared or read lock */
+#define	F_UNLCK		2		/* unlock */
+#define	F_WRLCK		3		/* exclusive or write lock */
+#if defined __USE_MISC
+#define	F_UNLCKSYS	4		/* purge locks for a given system ID */ 
+#define	F_CANCEL	5		/* cancel an async lock request */
+#endif
+
+#ifdef __USE_MISC
+/* Operations for bsd flock(), also used by the kernel implementation.	*/
+# define LOCK_SH	1	/* shared lock */
+# define LOCK_EX	2	/* exclusive lock */
+# define LOCK_NB	4	/* or'd with one of the above to prevent
+				   blocking */
+# define LOCK_UN	8	/* remove lock */
+#endif
+
+struct flock
+  {
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    int	__l_sysid;	/* remote system id or zero for local */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    int	__l_sysid;	/* remote system id or zero for local */
+  };
+#endif
+
+/* Define some more compatibility macros to be backward compatible with
+   BSD systems which did not managed to hide these kernel macros.  */
+#ifdef	__USE_MISC
+# define FAPPEND	O_APPEND
+# define FFSYNC		O_FSYNC
+# define FASYNC		O_ASYNC
+# define FNONBLOCK	O_NONBLOCK
+# define FNDELAY	O_NDELAY
+
+#define FCREAT		O_CREAT
+#define FEXCL		O_EXCL
+#define FTRUNC		O_TRUNC
+#define FNOCTTY		O_NOCTTY
+#define FSYNC		O_SYNC
+#endif /* Use BSD.  */
+
+
+#ifdef __USE_XOPEN2K
+/*
+ * Advice to posix_fadvise
+ */
+#define	POSIX_FADV_NORMAL	0	/* no special treatment */
+#define	POSIX_FADV_RANDOM	1	/* expect random page references */
+#define	POSIX_FADV_SEQUENTIAL	2	/* expect sequential page references */
+#define	POSIX_FADV_WILLNEED	3	/* will need these pages */
+#define	POSIX_FADV_DONTNEED	4	/* dont need these pages */
+#define	POSIX_FADV_NOREUSE	5	/* access data only once */
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/in.h
@@ -0,0 +1,308 @@
+/* Copyright (C) 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* FreeBSD version.  */
+
+#ifndef _NETINET_IN_H
+# error "Never use <bits/in.h> directly; include <netinet/in.h> instead."
+#endif
+
+
+/* Link numbers.  */
+#define	IMPLINK_IP		155
+#define	IMPLINK_LOWEXPER	156
+#define	IMPLINK_HIGHEXPER	158
+
+#define IPPROTO_DIVERT          258             /* divert pseudo-protocol */
+
+/* To select the IP level.  */
+#define SOL_IP	0
+
+/*
+ * Options for use with [gs]etsockopt at the IP level.
+ * First word of comment is data type; bool is stored in int.
+ */
+#define	IP_OPTIONS		1    /* buf/ip_opts; set/get IP options */
+#define	IP_HDRINCL		2    /* int; header is included with data */
+#define	IP_TOS			3    /* int; IP type of service and preced. */
+#define	IP_TTL			4    /* int; IP time to live */
+#define	IP_RECVOPTS		5    /* bool; receive all IP opts w/dgram */
+#define	IP_RECVRETOPTS		6    /* bool; receive IP opts for response */
+#define	IP_RECVDSTADDR		7    /* bool; receive IP dst addr w/dgram */
+#define	IP_SENDSRCADDR		IP_RECVDSTADDR /* cmsg_type to set src addr */
+#define	IP_RETOPTS		8    /* ip_opts; set/get IP options */
+#define	IP_MULTICAST_IF		9    /* struct in_addr *or* struct ip_mreqn;
+				      * set/get IP multicast i/f  */
+#define	IP_MULTICAST_TTL	10   /* u_char; set/get IP multicast ttl */
+#define	IP_MULTICAST_LOOP	11   /* u_char; set/get IP multicast loopback */
+#define	IP_ADD_MEMBERSHIP	12   /* ip_mreq; add an IP group membership */
+#define	IP_DROP_MEMBERSHIP	13   /* ip_mreq; drop an IP group membership */
+#define	IP_MULTICAST_VIF	14   /* set/get IP mcast virt. iface */
+#define	IP_RSVP_ON		15   /* enable RSVP in kernel */
+#define	IP_RSVP_OFF		16   /* disable RSVP in kernel */
+#define	IP_RSVP_VIF_ON		17   /* set RSVP per-vif socket */
+#define	IP_RSVP_VIF_OFF		18   /* unset RSVP per-vif socket */
+#define	IP_PORTRANGE		19   /* int; range to choose for unspec port */
+#define	IP_RECVIF		20   /* bool; receive reception if w/dgram */
+/* for IPSEC */
+#define	IP_IPSEC_POLICY		21   /* int; set/get security policy */
+#define	IP_FAITH		22   /* bool; accept FAITH'ed connections */
+
+#define	IP_ONESBCAST		23   /* bool: send all-ones broadcast */
+#define	IP_NONLOCALOK		24   /* bool: allow bind to spoof non-local addresses;
+					requires kernel compile option IP_NONLOCALBIND */
+
+#define	IP_FW_TABLE_ADD		40   /* add entry */
+#define	IP_FW_TABLE_DEL		41   /* delete entry */
+#define	IP_FW_TABLE_FLUSH	42   /* flush table */
+#define	IP_FW_TABLE_GETSIZE	43   /* get table size */
+#define	IP_FW_TABLE_LIST	44   /* list table contents */
+
+#define	IP_FW_ADD		50   /* add a firewall rule to chain */
+#define	IP_FW_DEL		51   /* delete a firewall rule from chain */
+#define	IP_FW_FLUSH		52   /* flush firewall rule chain */
+#define	IP_FW_ZERO		53   /* clear single/all firewall counter(s) */
+#define	IP_FW_GET		54   /* get entire firewall rule chain */
+#define	IP_FW_RESETLOG		55   /* reset logging counters */
+
+#define IP_FW_NAT_CFG           56   /* add/config a nat rule */
+#define IP_FW_NAT_DEL           57   /* delete a nat rule */
+#define IP_FW_NAT_GET_CONFIG    58   /* get configuration of a nat rule */
+#define IP_FW_NAT_GET_LOG       59   /* get log of a nat rule */
+
+#define	IP_DUMMYNET_CONFIGURE	60   /* add/configure a dummynet pipe */
+#define	IP_DUMMYNET_DEL		61   /* delete a dummynet pipe from chain */
+#define	IP_DUMMYNET_FLUSH	62   /* flush dummynet */
+#define	IP_DUMMYNET_GET		64   /* get entire dummynet pipes */
+
+#define	IP_RECVTTL		65   /* bool; receive IP TTL w/dgram */
+#define	IP_MINTTL		66   /* minimum TTL for packet or drop */
+#define	IP_DONTFRAG		67   /* don't fragment packet */
+
+/* IPv4 Source Filter Multicast API [RFC3678] */
+#define	IP_ADD_SOURCE_MEMBERSHIP	70   /* join a source-specific group */
+#define	IP_DROP_SOURCE_MEMBERSHIP	71   /* drop a single source */
+#define	IP_BLOCK_SOURCE			72   /* block a source */
+#define	IP_UNBLOCK_SOURCE		73   /* unblock a source */
+
+/* The following option is private; do not use it from user applications. */
+#define	IP_MSFILTER			74   /* set/get filter list */
+
+/* Protocol Independent Multicast API [RFC3678] */
+#define	MCAST_JOIN_GROUP		80   /* join an any-source group */
+#define	MCAST_LEAVE_GROUP		81   /* leave all sources for group */
+#define	MCAST_JOIN_SOURCE_GROUP		82   /* join a source-specific group */
+#define	MCAST_LEAVE_SOURCE_GROUP	83   /* leave a single source */
+#define	MCAST_BLOCK_SOURCE		84   /* block a source */
+#define	MCAST_UNBLOCK_SOURCE		85   /* unblock a source */
+
+/*
+ * Defaults and limits for options
+ */
+#define	IP_DEFAULT_MULTICAST_TTL  1	/* normally limit m'casts to 1 hop  */
+#define	IP_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
+
+/*
+ * The imo_membership vector for each socket is now dynamically allocated at
+ * run-time, bounded by USHRT_MAX, and is reallocated when needed, sized
+ * according to a power-of-two increment.
+ */
+#define	IP_MIN_MEMBERSHIPS	31
+#define	IP_MAX_MEMBERSHIPS	4095
+#define	IP_MAX_SOURCE_FILTER	1024	/* # of filters per socket, per group */
+
+/*
+ * Filter modes; also used to represent per-socket filter mode internally.
+ */
+ 
+#define MCAST_UNDEFINED 0       /* fmode: not yet defined */
+#define	MCAST_INCLUDE	1	/* fmode: include these source(s) */
+#define	MCAST_EXCLUDE	2	/* fmode: exclude these source(s) */
+
+/*
+ * Argument for IP_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define	IP_PORTRANGE_DEFAULT	0	/* default range */
+#define	IP_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
+#define	IP_PORTRANGE_LOW	2	/* "low" - vouchsafe security */
+
+/*
+ * Names for IP sysctl objects
+ */
+#define	IPCTL_FORWARDING	1	/* act as router */
+#define	IPCTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
+#define	IPCTL_DEFTTL		3	/* default TTL */
+#ifdef notyet
+#define	IPCTL_DEFMTU		4	/* default MTU */
+#endif
+#define IPCTL_RTEXPIRE		5	/* cloned route expiration time */
+#define IPCTL_RTMINEXPIRE	6	/* min value for expiration time */
+#define IPCTL_RTMAXCACHE	7	/* trigger level for dynamic expire */
+#define	IPCTL_SOURCEROUTE	8	/* may perform source routes */
+#define	IPCTL_DIRECTEDBROADCAST	9	/* may re-broadcast received packets */
+#define IPCTL_INTRQMAXLEN	10	/* max length of netisr queue */
+#define	IPCTL_INTRQDROPS	11	/* number of netisr q drops */
+#define	IPCTL_STATS		12	/* ipstat structure */
+#define	IPCTL_ACCEPTSOURCEROUTE	13	/* may accept source routed packets */
+#define	IPCTL_FASTFORWARDING	14	/* use fast IP forwarding code */
+#define	IPCTL_KEEPFAITH		15	/* FAITH IPv4->IPv6 translater ctl */
+#define	IPCTL_GIF_TTL		16	/* default TTL for gif encap packet */
+#define	IPCTL_MAXID		17
+
+/* Structure used to describe IP options for IP_OPTIONS and IP_RETOPTS.
+   The `ip_dst' field is used for the first-hop gateway when using a
+   source route (this gets put into the header proper).  */
+struct ip_opts
+  {
+    struct in_addr ip_dst;	/* First hop; zero without source route.  */
+    char ip_opts[40];		/* Actually variable in size.  */
+  };
+
+/* Options for use with `getsockopt' and `setsockopt' at the IPv6 level.
+   The first word in the comment at the right is the data type used;
+   "bool" means a boolean value stored in an `int'.  */
+#define IPV6_SOCKOPT_RESERVED1	3  /* reserved for future use */
+#define IPV6_UNICAST_HOPS	4  /* int; IP6 hops */
+#define IPV6_MULTICAST_IF	9  /* u_int; set/get IP6 multicast i/f  */
+#define IPV6_MULTICAST_HOPS	10 /* int; set/get IP6 multicast hops */
+#define IPV6_MULTICAST_LOOP	11 /* u_int; set/get IP6 multicast loopback */
+#define IPV6_JOIN_GROUP		12 /* ip6_mreq; join a group membership */
+#define IPV6_LEAVE_GROUP	13 /* ip6_mreq; leave a group membership */
+#define IPV6_PORTRANGE		14 /* int; range to choose for unspec port */
+#define ICMP6_FILTER		18 /* icmp6_filter; icmp6 filter */
+
+#define IPV6_CHECKSUM		26 /* int; checksum offset for raw socket */
+#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */
+
+#define IPV6_IPSEC_POLICY	28 /* struct; get/set security policy */
+#define IPV6_FAITH		29 /* bool; accept FAITH'ed connections */
+
+#define IPV6_FW_ADD		30 /* add a firewall rule to chain */
+#define IPV6_FW_DEL		31 /* delete a firewall rule from chain */
+#define IPV6_FW_FLUSH		32 /* flush firewall rule chain */
+#define IPV6_FW_ZERO		33 /* clear single/all firewall counter(s) */
+#define IPV6_FW_GET		34 /* get entire firewall rule chain */
+#define IPV6_RTHDRDSTOPTS	35 /* ip6_dest; send dst option before rthdr */
+
+#define IPV6_RECVPKTINFO	36 /* bool; recv if, dst addr */
+#define IPV6_RECVHOPLIMIT	37 /* bool; recv hop limit */
+#define IPV6_RECVRTHDR		38 /* bool; recv routing header */
+#define IPV6_RECVHOPOPTS	39 /* bool; recv hop-by-hop option */
+#define IPV6_RECVDSTOPTS	40 /* bool; recv dst option after rthdr */
+
+#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */
+#define IPV6_RECVPATHMTU	43 /* bool; notify an according MTU */
+#define IPV6_PATHMTU		44 /* mtuinfo; get the current path MTU (sopt),
+				      4 bytes int; MTU notification (cmsg) */
+
+#define IPV6_PKTINFO		46 /* in6_pktinfo; send if, src addr */
+#define IPV6_HOPLIMIT		47 /* int; send hop limit */
+#define IPV6_NEXTHOP		48 /* sockaddr; next hop addr */
+#define IPV6_HOPOPTS		49 /* ip6_hbh; send hop-by-hop option */
+#define IPV6_DSTOPTS		50 /* ip6_dest; send dst option befor rthdr */
+#define IPV6_RTHDR		51 /* ip6_rthdr; send routing header */
+
+#define IPV6_RECVTCLASS		57 /* bool; recv traffic class values */
+
+#define IPV6_AUTOFLOWLABEL	59 /* bool; attach flowlabel automagically */
+
+#define IPV6_TCLASS		61 /* int; send traffic class value */
+#define IPV6_DONTFRAG		62 /* bool; disable IPv6 fragmentation */
+
+#define IPV6_PREFER_TEMPADDR	63 /* int; prefer temporary addresses as
+                                    * the source address.
+				    */
+
+/* Obsolete synonyms for the above.  */
+#define IPV6_ADD_MEMBERSHIP	IPV6_JOIN_GROUP
+#define IPV6_DROP_MEMBERSHIP	IPV6_LEAVE_GROUP
+#define IPV6_RXHOPOPTS		IPV6_HOPOPTS
+#define IPV6_RXDSTOPTS		IPV6_DSTOPTS
+
+/* Socket level values for IPv6.  */
+#define SOL_IPV6	41
+#define SOL_ICMPV6	58
+
+/*
+ * Defaults and limits for options
+ */
+#define IPV6_DEFAULT_MULTICAST_HOPS 1   /* normally limit m'casts to 1 hop */
+#define IPV6_DEFAULT_MULTICAST_LOOP 1   /* normally hear sends if a member */
+
+/*
+ * Argument for IPV6_PORTRANGE:
+ * - which range to search when port is unspecified at bind() or connect()
+ */
+#define IPV6_PORTRANGE_DEFAULT  0       /* default range */
+#define IPV6_PORTRANGE_HIGH     1       /* "high" - request firewall bypass */
+#define IPV6_PORTRANGE_LOW      2       /* "low" - vouchsafe security */
+
+/* Routing header options for IPv6.  */
+#define IPV6_RTHDR_LOOSE	0	/* Hop doesn't need to be neighbour. */
+#define IPV6_RTHDR_STRICT	1	/* Hop must be a neighbour.  */
+
+#define IPV6_RTHDR_TYPE_0	0	/* IPv6 Routing header type 0.  */
+
+/*
+ * Names for IP sysctl objects
+ */
+#define IPV6CTL_FORWARDING	1	/* act as router */
+#define IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding*/
+#define IPV6CTL_DEFHLIM		3	/* default Hop-Limit */
+#define IPV6CTL_FORWSRCRT	5	/* forward source-routed dgrams */
+#define IPV6CTL_STATS		6	/* stats */
+#define IPV6CTL_MRTSTATS	7	/* multicast forwarding stats */
+#define IPV6CTL_MRTPROTO	8	/* multicast routing protocol */
+#define IPV6CTL_MAXFRAGPACKETS	9	/* max packets reassembly queue */
+#define IPV6CTL_SOURCECHECK	10	/* verify source route and intf */
+#define IPV6CTL_SOURCECHECK_LOGINT 11	/* minimume logging interval */
+#define IPV6CTL_ACCEPT_RTADV	12
+#define IPV6CTL_KEEPFAITH	13
+#define IPV6CTL_LOG_INTERVAL	14
+#define IPV6CTL_HDRNESTLIMIT	15
+#define IPV6CTL_DAD_COUNT	16
+#define IPV6CTL_AUTO_FLOWLABEL	17
+#define IPV6CTL_DEFMCASTHLIM	18
+#define IPV6CTL_GIF_HLIM	19	/* default HLIM for gif encap packet */
+#define IPV6CTL_KAME_VERSION	20
+#define IPV6CTL_USE_DEPRECATED	21	/* use deprecated addr (RFC2462 5.5.4) */
+#define IPV6CTL_RR_PRUNE	22	/* walk timer for router renumbering */
+#define IPV6CTL_V6ONLY		24
+#define IPV6CTL_RTEXPIRE	25	/* cloned route expiration time */
+#define IPV6CTL_RTMINEXPIRE	26	/* min value for expiration time */
+#define IPV6CTL_RTMAXCACHE	27	/* trigger level for dynamic expire */
+
+#define IPV6CTL_USETEMPADDR	32	/* use temporary addresses (RFC3041) */
+#define IPV6CTL_TEMPPLTIME	33	/* preferred lifetime for tmpaddrs */
+#define IPV6CTL_TEMPVLTIME	34	/* valid lifetime for tmpaddrs */
+#define IPV6CTL_AUTO_LINKLOCAL	35	/* automatic link-local addr assign */
+#define IPV6CTL_RIP6STATS	36	/* raw_ip6 stats */
+#define IPV6CTL_PREFER_TEMPADDR	37	/* prefer temporary addr as src */
+#define IPV6CTL_ADDRCTLPOLICY	38	/* get/set address selection policy */
+#define IPV6CTL_USE_DEFAULTZONE	39	/* use default scope zone */
+
+#define IPV6CTL_MAXFRAGS	41	/* max fragments */
+#define IPV6CTL_MCAST_PMTU	44	/* enable pMTU discovery for multicast? */
+
+/* New entries should be added here from current IPV6CTL_MAXID value. */
+/* to define items, should talk with KAME guys first, for *BSD compatibility */
+/* 42-44 is already used in KAME */
+#define IPV6CTL_STEALTH		45
+#define	ICMPV6CTL_ND6_ONLINKNSRFC4861	47
+#define IPV6CTL_MAXID		48
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctl-types.h
@@ -0,0 +1,37 @@
+/* Structure types for pre-termios terminal ioctls.  FreeBSD version.
+   Copyright (C) 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IOCTL_H
+# error "Never use <bits/ioctl-types.h> directly; include <sys/ioctl.h> instead."
+#endif
+
+/* Many systems that have TIOCGWINSZ define TIOCGSIZE for source
+   compatibility with Sun; they define `struct ttysize' to have identical
+   layout as `struct winsize' and #define TIOCGSIZE to be TIOCGWINSZ
+   (likewise TIOCSSIZE and TIOCSWINSZ).  */
+/* struct ttysize is in FreeBSD originally defined in <sys/ioctl.h>,
+   which is replaced by GLIBC version -> define here */
+struct ttysize
+{
+  unsigned short int ts_lines;
+  unsigned short int ts_cols;
+  unsigned short int ts_xxx;
+  unsigned short int ts_yyy;
+};
+#define	_IOT_ttysize	_IOT_winsize
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ioctls.h
@@ -0,0 +1,50 @@
+/*-
+ * Copyright (c) 1982, 1986, 1990 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
+ */
+
+#ifndef	_IOCTLS_H_
+#define	_IOCTLS_H_
+
+#include <sys/ioccom.h>
+
+#include <sys/ttycom.h>
+
+/*
+ *	@(#)ioctl.h	8.6 (Berkeley) 3/28/94
+ */
+
+#define	TIOCGSIZE	TIOCGWINSZ
+#define	TIOCSSIZE	TIOCSWINSZ
+
+#include <sys/filio.h>
+
+#include <sys/sockio.h>
+
+#endif /* !_IOCTLS_H_ */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/ipc.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 1995-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_IPC_H
+# error "Never use <bits/ipc.h> directly; include <sys/ipc.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Mode bits for `msgget', `semget', and `shmget'.  */
+#define IPC_CREAT	01000		/* create key if key does not exist */
+#define IPC_EXCL	02000		/* fail if key exists */
+#define IPC_NOWAIT	04000		/* return error on wait */
+
+/* Control commands for `msgctl', `semctl', and `shmctl'.  */
+#define IPC_RMID	0		/* remove identifier */
+#define IPC_SET		1		/* set `ipc_perm' options */
+#define IPC_STAT	2		/* get `ipc_perm' options */
+
+/* Special key values.  */
+#define IPC_PRIVATE	((__key_t) 0)	/* private key */
+
+#ifdef __USE_MISC
+/* Common mode bits.  */
+# define IPC_R		0400		/* read permission, same as S_IRUSR */
+# define IPC_W		0200		/* write permission, same as S_IWUSR */
+# define IPC_M		0x1000		/* control permission */
+#endif
+
+
+/* Data structure used to pass permission information to IPC operations.  */
+struct ipc_perm
+{
+    __uid_t		cuid;	/* creator user id */
+    __gid_t		cgid;	/* creator group id */
+    __uid_t		uid;	/* user id */
+    __gid_t		gid;	/* group id */
+    __mode_t		mode;	/* r/w permission */
+    __uint16_t		__seq;	/* sequence # (to generate unique ipcid) */
+    __key_t		__key;	/* user specified msg/sem/shm key */
+};
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/local_lim.h
@@ -0,0 +1,25 @@
+/* Minimum guaranteed maximum values for system limits.  kFreeBSD version.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/param.h>
+
+/* BSD userland provides MAXHOSTNAMELEN via <sys/param.h>.  GNU
+   userland provides HOST_NAME_MAX via <limits.h>.  This makes
+   both worlds happy.  */
+#define HOST_NAME_MAX MAXHOSTNAMELEN
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/mman.h
@@ -0,0 +1,130 @@
+/* Definitions for POSIX memory map interface.  FreeBSD version.
+   Copyright (C) 1994-1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+#include <features.h>
+#include <stddef.h>
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define	PROT_NONE	 0x00	/* No access.  */
+#define	PROT_READ	 0x01	/* Pages can be read.  */
+#define	PROT_WRITE	 0x02	/* Pages can be written.  */
+#define	PROT_EXEC	 0x04	/* Pages can be executed.  */
+
+/* Flags contain mapping type, sharing type and options.  */
+
+/* Mapping type (must choose one and only one of these).  */
+#ifdef __USE_MISC
+# define MAP_FILE	 0x0000	/* Mapped from a file or device.  */
+# define MAP_ANON	 0x1000	/* Allocated from anonymous virtual memory.  */
+# define MAP_TYPE	 0x1000	/* Mask for type field.  */
+# ifdef __USE_MISC
+#  define MAP_ANONYMOUS  MAP_ANON /* Linux name. */
+# endif
+#endif
+
+/* Sharing types (must choose one and only one of these).  */
+#define	MAP_SHARED	 0x0001	/* Share changes.  */
+#define	MAP_PRIVATE	 0x0002	/* Changes private; copy pages on write.  */
+#ifdef __USE_MISC
+# define MAP_COPY MAP_PRIVATE	/* Virtual copy of region at mapping time.  */
+#endif
+
+/* Other flags.  */
+#define	MAP_FIXED	 0x0010	/* Map address must be exactly as requested. */
+#ifdef __USE_MISC
+#define MAP_RENAME	 0x0020 /* Sun: rename private pages to file */
+#define MAP_NORESERVE	 0x0040 /* Sun: don't reserve needed swap area */
+#define MAP_RESERVED0080 0x0080	/* previously misimplemented MAP_INHERIT */
+#define MAP_RESERVED0100 0x0100	/* previously unimplemented MAP_NOEXTEND */
+# define MAP_HASSEMPHORE 0x0200	/* Region may contain semaphores.  */
+# define MAP_STACK	 0x0400	/* Region grows down, like a stack.  */
+# define MAP_NOSYNC	 0x0800	/* Try to avoid flushing to the disk.  */
+# define MAP_NOCORE	0x20000	/* Don't include these pages in a core dump.  */
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_MISC
+# define MADV_NORMAL	 0	/* No further special treatment.  */
+# define MADV_RANDOM	 1	/* Expect random page references.  */
+# define MADV_SEQUENTIAL 2	/* Expect sequential page references.  */
+# define MADV_WILLNEED	 3	/* Will need these pages.  */
+# define MADV_DONTNEED	 4	/* Don't need these pages.  */
+# define MADV_FREE	 5	/* Don't need these pages, they contain junk. */
+# define MADV_NOSYNC	 6	/* Try to avoid flushing to the disk.  */
+# define MADV_AUTOSYNC	 7	/* Use the default flushing strategy.  */
+# define MADV_NOCORE	 8	/* Don't include these pages in a core dump.  */
+# define MADV_CORE	 9	/* Include pages in a core dump (default).  */
+# define MADV_PROTECT	10	/* protect process from pageout kill */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL	0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM	1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL	2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED	3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED	4 /* Don't need these pages.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC	1		/* Sync memory asynchronously.  */
+#define MS_SYNC		0		/* Synchronous memory sync.  */
+#define MS_INVALIDATE	2		/* Invalidate the caches.  */
+
+/* Flags for `mlockall' (can be OR'd together).  */
+#define MCL_CURRENT	1		/* Lock all currently mapped pages.  */
+#define MCL_FUTURE	2		/* Lock all additions to address
+					   space.  */
+
+/* Flags for 'minherit'.  */
+#ifdef __USE_MISC
+# define INHERIT_SHARE	0
+# define INHERIT_COPY	1
+# define INHERIT_NONE	2
+#endif
+
+
+/*
+ * Return bits from mincore
+ */
+#ifdef __USE_MISC
+#define	MINCORE_INCORE	 	 0x1 /* Page is incore */
+#define	MINCORE_REFERENCED	 0x2 /* Page has been referenced by us */
+#define	MINCORE_MODIFIED	 0x4 /* Page has been modified by us */
+#define	MINCORE_REFERENCED_OTHER 0x8 /* Page has been referenced */
+#define	MINCORE_MODIFIED_OTHER	0x10 /* Page has been modified */
+#endif /* Use MISC */
+
+#ifdef __USE_MISC
+
+__BEGIN_DECLS
+
+extern int minherit (void *__addr, size_t __len, int __inherit);
+
+__END_DECLS
+
+#endif /* Use BSD */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/msq.h
@@ -0,0 +1,65 @@
+/* Copyright (C) 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MSG_H
+#error "Never use <bits/msq.h> directly; include <sys/msg.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Define options for message queue functions.  */
+#define MSG_NOERROR	010000	/* no error if message is too big */
+
+/* Types used in the structure definition.  */
+typedef unsigned long int msgqnum_t;
+typedef unsigned long int msglen_t;
+
+
+/* Structure of record for one message inside the kernel.
+   The type `struct __msg' is opaque.  */
+struct msqid_ds
+{
+	struct	ipc_perm msg_perm;	/* msg queue permission bits */
+	void *__msg_first;		/* first message in the queue */
+	void *__msg_last;		/* last message in the queue */
+	msglen_t __msg_cbytes;	/* number of bytes in use on the queue */
+	msgqnum_t msg_qnum;	/* number of msgs in the queue */
+	msglen_t msg_qbytes;	/* max # of bytes on the queue */
+	__pid_t	msg_lspid;	/* pid of last msgsnd() */
+	__pid_t	msg_lrpid;	/* pid of last msgrcv() */
+	__time_t msg_stime;	/* time of last msgsnd() */
+	__time_t msg_rtime;	/* time of last msgrcv() */
+	__time_t msg_ctime;	/* time of last msgctl() */
+};
+
+#ifdef __USE_MISC
+
+# define msg_cbytes	__msg_cbytes
+
+/* buffer for msgctl calls IPC_INFO, MSG_INFO */
+struct msginfo
+  {
+    int msgmax;
+    int msgmni;
+    int msgmnb;
+    int msgtql;
+    int msgssz;
+    int msgseg;
+  };
+
+#endif /* __USE_MISC */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/os-unistd.h
@@ -0,0 +1,8 @@
+
+__BEGIN_DECLS
+
+/* whether is current process tainted by uid or gid changes */
+extern int issetugid(void) __THROW;
+
+__END_DECLS
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/param.h
@@ -0,0 +1,189 @@
+/* Copyright (C) 1995,1996,1997,2000,2001,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PARAM_H
+# error "Never use <bits/param.h> directly; include <sys/param.h> instead."
+#endif
+
+#include <limits.h>
+#include <sys/syslimits.h>
+
+/*
+ * __FreeBSD_version numbers are documented in the Porter's Handbook.
+ * If you bump the version for any reason, you should update the documentation
+ * there.
+ * Currently this lives here:
+ *
+ *      doc/en_US.ISO8859-1/books/porters-handbook/book.sgml
+ *
+ * scheme is:  <major><two digit minor><0 if release branch, otherwise 1>xx
+ */
+#include <osreldate.h>
+
+/* Some inet code expects that this file defines the 'u_int32_t' type.  */
+#include <stdint.h>
+
+/* FreeBSD code expects that this file implicitly defines SIG* macros.  */
+#include <signal.h>
+
+/*
+ * Machine-independent constants (some used in following include files).
+ * Redefined constants are from POSIX 1003.1 limits file.
+ *
+ * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
+ * MAXLOGNAME should be == UT_NAMESIZE+1 (see <utmp.h>)
+ */
+
+#define MAXCOMLEN       19              /* max command name remembered */
+#define MAXINTERP       32              /* max interpreter file name length */
+#define MAXLOGNAME      33              /* max login name length (incl. NUL) */
+#define MAXUPRC         CHILD_MAX       /* max simultaneous processes */
+#define NGROUPS         (NGROUPS_MAX+1) /* max number groups */
+#define MAXHOSTNAMELEN  256             /* max hostname size */
+#define SPECNAMELEN     63              /* max length of devicename */
+#define TTY_NAME_MAX	SPECNAMELEN
+
+/* BSD names for some <limits.h> values.  */
+
+#define	MAXSYMLINKS	32
+#define	CANBSIZ		MAX_CANON
+
+/* Machine type dependent parameters. */
+#include <machine/param.h>
+
+#ifndef BLKDEV_IOSIZE
+#define BLKDEV_IOSIZE	PAGE_SIZE        /* default block device I/O size */
+#endif
+#ifndef DFLTPHYS
+#define DFLTPHYS	(64 * 1024)     /* default max raw I/O transfer size */
+#endif
+#ifndef MAXPHYS
+#define MAXPHYS		(128 * 1024)    /* max raw I/O transfer size */
+#endif
+#ifndef MAXDUMPPGS
+#define MAXDUMPPGS	(DFLTPHYS/PAGE_SIZE)
+#endif
+
+/*
+ * Constants related to network buffer management.
+ * MCLBYTES must be no larger than PAGE_SIZE.
+ */
+#ifndef	MSIZE
+#define MSIZE		256		/* size of an mbuf */
+#endif	/* MSIZE */
+
+#ifndef	MCLSHIFT
+#define MCLSHIFT	11		/* convert bytes to mbuf clusters */
+#endif	/* MCLSHIFT */
+
+#define MCLBYTES	(1 << MCLSHIFT)	/* size of an mbuf cluster */
+
+/*
+ * Some macros for units conversion
+ */
+
+/* clicks to bytes */
+#ifndef ctob
+#define ctob(x)	((x)<<PAGE_SHIFT)
+#endif
+
+/* bytes to clicks */
+#ifndef btoc
+#define btoc(x)	(((vm_offset_t)(x)+PAGE_MASK)>>PAGE_SHIFT)
+#endif
+
+/*
+ * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
+ * want to shift an unsigned type to avoid sign extension and we don't
+ * want to widen `bytes' unnecessarily.  Assume that the result fits in
+ * a daddr_t.
+ */
+#ifndef btodb
+#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
+	(sizeof (bytes) > sizeof(long) \
+	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
+	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
+#endif
+
+#ifndef dbtob
+#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
+	((off_t)(db) << DEV_BSHIFT)
+#endif
+
+#define	PRIMASK	0x0ff
+#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
+#define	PDROP	0x200	/* OR'd with pri to stop re-entry of interlock mutex */
+
+#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */
+
+#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */
+
+#define	NODEV	(dev_t)(-1)	/* non-existent device */
+
+#define	CBLOCK	128		/* Clist block size, must be a power of 2. */
+#define CBQSIZE	(CBLOCK/NBBY)	/* Quote bytes/cblock - can do better. */
+				/* Data chars/clist. */
+#define	CBSIZE	(CBLOCK - sizeof(struct cblock *) - CBQSIZE)
+#define	CROUND	(CBLOCK - 1)	/* Clist rounding. */
+
+/*
+ * File system parameters and macros.
+ *
+ * MAXBSIZE -	Filesystems are made out of blocks of at most MAXBSIZE bytes
+ *		per block.  MAXBSIZE may be made larger without effecting
+ *		any existing filesystems as long as it does not exceed MAXPHYS,
+ *		and may be made smaller at the risk of not being able to use
+ *		filesystems which require a block size exceeding MAXBSIZE.
+ *
+ * BKVASIZE -	Nominal buffer space per buffer, in bytes.  BKVASIZE is the
+ *		minimum KVM memory reservation the kernel is willing to make.
+ *		Filesystems can of course request smaller chunks.  Actual
+ *		backing memory uses a chunk size of a page (PAGE_SIZE).
+ *
+ *		If you make BKVASIZE too small you risk seriously fragmenting
+ *		the buffer KVM map which may slow things down a bit.  If you
+ *		make it too big the kernel will not be able to optimally use
+ *		the KVM memory reserved for the buffer cache and will wind
+ *		up with too-few buffers.
+ *
+ *		The default is 16384, roughly 2x the block size used by a
+ *		normal UFS filesystem.
+ */
+#define MAXBSIZE	65536	/* must be power of 2 */
+#define BKVASIZE	16384	/* must be power of 2 */
+#define BKVAMASK	(BKVASIZE-1)
+
+/*
+ * Scale factor for scaled integers used to count %cpu time and load avgs.
+ *
+ * The number of CPU `tick's that map to a unique `%age' can be expressed
+ * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
+ * can be calculated (assuming 32 bits) can be closely approximated using
+ * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
+ *
+ * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
+ * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
+ */
+#define	FSHIFT	11		/* bits to right of fixed binary point */
+#define FSCALE	(1<<FSHIFT)
+
+#define dbtoc(db)			/* calculates devblks to pages */ \
+	((db + (ctodb(1) - 1)) >> (PAGE_SHIFT - DEV_BSHIFT))
+
+#define ctodb(db)			/* calculates pages to devblks */ \
+	((db) << (PAGE_SHIFT - DEV_BSHIFT))
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/poll.h
@@ -0,0 +1,62 @@
+/* Copyright (C) 1997, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_POLL_H
+# error "Never use <bits/poll.h> directly; include <sys/poll.h> instead."
+#endif
+
+/* Event types that can be polled for.  These bits may be set in `events'
+   to indicate the interesting event types; they will appear in `revents'
+   to indicate the status of the file descriptor.  */
+#define POLLIN		0x0001		/* There is data to read.  */
+#define POLLPRI		0x0002		/* There is urgent data to read.  */
+#define POLLOUT		0x0004		/* Writing now will not block.  */
+
+#if defined __USE_XOPEN || defined __USE_XOPEN2K8
+/* These values are defined in XPG4.2.  */
+# define POLLRDNORM	0x0040		/* Normal data may be read.  */
+# define POLLRDBAND	0x0080		/* Priority data may be read.  */
+# define POLLWRNORM	POLLOUT		/* Writing now will not block.  */
+# define POLLWRBAND	0x0100		/* Priority data may be written.  */
+#endif
+
+#ifdef __USE_MISC
+/* General FreeBSD extension (currently only supported for sockets): */
+# define POLLINIGNEOF	0x2000		/* like POLLIN, except ignore EOF */
+#endif
+
+/* Event types always implicitly polled for.  These bits need not be set in
+   `events', but they will appear in `revents' to indicate the status of
+   the file descriptor.  */
+#define POLLERR		0x0008		/* Error condition.  */
+#define POLLHUP		0x0010		/* Hung up.  */
+#define POLLNVAL	0x0020		/* Invalid polling request.  */
+
+#ifdef __USE_MISC
+
+# define POLLSTANDARD	(POLLIN|POLLPRI|POLLOUT|POLLRDNORM|POLLRDBAND|\
+			POLLWRBAND|POLLERR|POLLHUP|POLLNVAL)
+
+/*
+ * Request that poll() wait forever.
+ * XXX in SYSV, this is defined in stropts.h, which is not included
+ * by poll.h.
+ */
+#define INFTIM		(-1)
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/posix_opt.h
@@ -0,0 +1,92 @@
+/* Define POSIX options for FreeBSD.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <unistd.h> instead.
+ */
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+#include <bits/os-unistd.h> 
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	1
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	1
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	1
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	1
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	1
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	1
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	1
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* X/Open realtime support is available.  */
+#define _XOPEN_REALTIME	1
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	((unsigned char)'\377')
+
+/* The LFS interface is available, except for the asynchronous I/O.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX timers are available.  */
+#define _POSIX_TIMERS 1
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200912L
+
+#endif /* bits/posix_opt.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/resource.h
@@ -0,0 +1,220 @@
+/* Bit values & structures for resource limits.  FreeBSD version.
+   Copyright (C) 1994, 1996-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_RESOURCE_H
+# error "Never use <bits/resource.h> directly; include <sys/resource.h> instead."
+#endif
+
+#include <bits/types.h>
+#include <sys/_types.h>
+
+/* Transmute defines to enumerations.  The macro re-definitions are
+   necessary because some programs want to test for operating system
+   features with #ifdef RUSAGE_SELF.  In ISO C the reflexive
+   definition is a no-op.
+
+   These are the values for FreeBSD.  Earlier BSD systems have a subset of
+   these kinds of resource limit.  */
+
+/* Kinds of resource limit.  */
+enum __rlimit_resource
+{
+  /* Per-process CPU limit, in seconds.  */
+  RLIMIT_CPU = 0,
+#define	RLIMIT_CPU RLIMIT_CPU
+
+  /* Largest file that can be created, in bytes.  */
+  RLIMIT_FSIZE = 1,
+#define	RLIMIT_FSIZE RLIMIT_FSIZE
+
+  /* Maximum size of data segment, in bytes.  */
+  RLIMIT_DATA = 2,
+#define	RLIMIT_DATA RLIMIT_DATA
+
+  /* Maximum size of stack segment, in bytes.  */
+  RLIMIT_STACK = 3,
+#define	RLIMIT_STACK RLIMIT_STACK
+
+  /* Largest core file that can be created, in bytes.  */
+  RLIMIT_CORE = 4,
+#define	RLIMIT_CORE RLIMIT_CORE
+
+  /* Largest resident set size, in bytes.
+     This affects swapping; processes that are exceeding their
+     resident set size will be more likely to have physical memory
+     taken from them.  */
+  __RLIMIT_RSS = 5,
+#define	RLIMIT_RSS __RLIMIT_RSS
+
+  /* Locked-in-memory address space.  */
+  __RLIMIT_MEMLOCK = 6,
+#define	RLIMIT_MEMLOCK __RLIMIT_MEMLOCK
+
+  /* Number of processes.  */
+  __RLIMIT_NPROC = 7,
+#define	RLIMIT_NPROC __RLIMIT_NPROC
+
+  /* Number of open files.  */
+  RLIMIT_NOFILE = 8,
+#define	RLIMIT_NOFILE RLIMIT_NOFILE
+
+  /* Maximum size of all socket buffers.  */
+  __RLIMIT_SBSIZE = 9,
+#define RLIMIT_SBSIZE __RLIMIT_SBSIZE
+
+  /* Address space limit.  */
+  RLIMIT_AS = 10,
+#define RLIMIT_AS RLIMIT_AS
+  RLIMIT_VMEM = RLIMIT_AS,
+
+  /* Pseudo-terminals.  */
+  RLIMIT_NPTS = 11,
+#define RLIMIT_NPTS RLIMIT_NPTS
+
+  /* Swap used.  */
+  RLIMIT_SWAP = 12,
+#define RLIMIT_SWAP RLIMIT_SWAP
+
+  __RLIMIT_NLIMITS = 13,
+  __RLIM_NLIMITS = __RLIMIT_NLIMITS
+#define RLIMIT_NLIMITS __RLIMIT_NLIMITS
+#define RLIM_NLIMITS __RLIM_NLIMITS
+};
+
+/* Value to indicate that there is no limit.  */
+#define RLIM_INFINITY 0x7fffffffffffffffLL
+#ifdef __USE_LARGEFILE64
+# define RLIM64_INFINITY 0x7fffffffffffffffLL
+#endif
+
+
+/* Type for resource quantity measurement.  */
+typedef __rlim_t rlim_t;
+#ifdef __USE_LARGEFILE64
+typedef __rlim64_t rlim64_t;
+#endif
+
+struct rlimit
+  {
+    /* The current (soft) limit.  */
+    rlim_t rlim_cur;
+    /* The hard limit.  */
+    rlim_t rlim_max;
+  };
+
+#ifdef __USE_LARGEFILE64
+struct rlimit64
+  {
+    /* The current (soft) limit.  */
+    rlim64_t rlim_cur;
+    /* The hard limit.  */
+    rlim64_t rlim_max;
+ };
+#endif
+
+struct orlimit {
+	__int32_t	rlim_cur;	/* current (soft) limit */
+	__int32_t	rlim_max;	/* maximum value for rlim_cur */
+};
+
+struct loadavg {
+	__fixpt_t	ldavg[3];
+	long		fscale;
+};
+
+#define	CP_USER		0
+#define	CP_NICE		1
+#define	CP_SYS		2
+#define	CP_INTR		3
+#define	CP_IDLE		4
+#define	CPUSTATES	5
+
+/* Whose usage statistics do you want?  */
+enum __rusage_who
+{
+  /* The calling process.  */
+  RUSAGE_SELF = 0,
+#define RUSAGE_SELF RUSAGE_SELF
+
+  /* All of its terminated child processes.  */
+  RUSAGE_CHILDREN = -1
+#define RUSAGE_CHILDREN RUSAGE_CHILDREN
+};
+
+#define __need_timeval
+#include <bits/time.h>		/* For `struct timeval'.  */
+
+/* Structure which says how much of each resource has been used.  */
+struct rusage
+  {
+    /* Total amount of user time used.  */
+    struct timeval ru_utime;
+    /* Total amount of system time used.  */
+    struct timeval ru_stime;
+    /* Maximum resident set size (in kilobytes).  */
+    long int ru_maxrss;
+    /* Amount of sharing of text segment memory
+       with other processes (kilobyte-seconds).  */
+    long int ru_ixrss;
+    /* Amount of data segment memory used (kilobyte-seconds).  */
+    long int ru_idrss;
+    /* Amount of stack memory used (kilobyte-seconds).  */
+    long int ru_isrss;
+    /* Number of soft page faults (i.e. those serviced by reclaiming
+       a page from the list of pages awaiting reallocation.  */
+    long int ru_minflt;
+    /* Number of hard page faults (i.e. those that required I/O).  */
+    long int ru_majflt;
+    /* Number of times a process was swapped out of physical memory.  */
+    long int ru_nswap;
+    /* Number of input operations via the file system.  Note: This
+       and `ru_oublock' do not include operations with the cache.  */
+    long int ru_inblock;
+    /* Number of output operations via the file system.  */
+    long int ru_oublock;
+    /* Number of IPC messages sent.  */
+    long int ru_msgsnd;
+    /* Number of IPC messages received.  */
+    long int ru_msgrcv;
+    /* Number of signals delivered.  */
+    long int ru_nsignals;
+    /* Number of voluntary context switches, i.e. because the process
+       gave up the process before it had to (usually to wait for some
+       resource to be available).  */
+    long int ru_nvcsw;
+    /* Number of involuntary context switches, i.e. a higher priority process
+       became runnable or the current process used up its time slice.  */
+    long int ru_nivcsw;
+  };
+
+/* Priority limits.  */
+#define PRIO_MIN	-20	/* Minimum priority a process can have.  */
+#define PRIO_MAX	20	/* Maximum priority a process can have.  */
+
+/* The type of the WHICH argument to `getpriority' and `setpriority',
+   indicating what flavor of entity the WHO argument specifies.  */
+enum __priority_which
+{
+  PRIO_PROCESS = 0,		/* WHO is a process ID.  */
+#define PRIO_PROCESS PRIO_PROCESS
+  PRIO_PGRP = 1,		/* WHO is a process group ID.  */
+#define PRIO_PGRP PRIO_PGRP
+  PRIO_USER = 2			/* WHO is a user ID.  */
+#define PRIO_USER PRIO_USER
+};
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sched.h
@@ -0,0 +1,183 @@
+/* Definitions of constants and data structure for POSIX 1003.1b-1993
+   scheduling interface.
+   Copyright (C) 1996-1999,2001-2003,2005,2006,2007,2008
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __need_schedparam
+
+#ifndef _SCHED_H
+# error "Never include <bits/sched.h> directly; use <sched.h> instead."
+#endif
+
+
+/* Scheduling algorithms.  */
+#define SCHED_OTHER	2
+#define SCHED_FIFO	1
+#define SCHED_RR	3
+
+
+#ifdef __USE_MISC
+/* Cloning flags.  */
+# define CSIGNAL       0x000000ff /* Signal mask to be sent at exit.  */
+# define CLONE_VM      0x00000100 /* Set if VM shared between processes.  */
+# define CLONE_FS      0x00000200 /* Set if fs info shared between processes.  */
+# define CLONE_FILES   0x00000400 /* Set if open files shared between processes.  */
+# define CLONE_SIGHAND 0x00000800 /* Set if signal handlers shared.  */
+# define CLONE_PTRACE  0x00002000 /* Set if tracing continues on the child.  */
+# define CLONE_VFORK   0x00004000 /* Set if the parent wants the child to
+				     wake it up on mm_release.  */
+# define CLONE_SYSVSEM 0x00040000 /* share system V SEM_UNDO semantics */
+#endif
+
+/* The official definition.  */
+struct sched_param
+  {
+    int __sched_priority;
+  };
+
+__BEGIN_DECLS
+
+#ifdef __USE_MISC
+/* Clone current process.  */
+extern int clone (int (*__fn) (void *__arg), void *__child_stack,
+		  int __flags, void *__arg) __THROW;
+
+/* Unshare the specified resources.  */
+extern int unshare (int __flags) __THROW;
+
+/* Get index of currently used CPU.  */
+extern int sched_getcpu (void) __THROW;
+#endif
+
+__END_DECLS
+
+#endif	/* need schedparam */
+
+#if !defined __defined_schedparam \
+    && (defined __need_schedparam || defined _SCHED_H)
+# define __defined_schedparam	1
+/* Data structure to describe a process' schedulability.  */
+struct __sched_param
+  {
+    int __sched_priority;
+  };
+# undef __need_schedparam
+#endif
+
+
+#if defined _SCHED_H && !defined __cpu_set_t_defined
+# define __cpu_set_t_defined
+/* Size definition for CPU sets.  */
+# define __CPU_SETSIZE	128
+# define __NCPUBITS	(8 * sizeof (__cpu_mask))
+
+/* Type for array elements in 'cpu_set_t'.  */
+typedef unsigned long int __cpu_mask;
+
+/* Basic access functions.  */
+# define __CPUELT(cpu)	((cpu) / __NCPUBITS)
+# define __CPUMASK(cpu)	((__cpu_mask) 1 << ((cpu) % __NCPUBITS))
+
+/* Data structure to describe CPU mask.  */
+typedef struct
+{
+  __cpu_mask __bits[__CPU_SETSIZE / __NCPUBITS];
+} cpu_set_t;
+
+/* Access functions for CPU masks.  */
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do __builtin_memset (cpusetp, '\0', setsize); while (0)
+# else
+#  define __CPU_ZERO_S(setsize, cpusetp) \
+  do {									      \
+    size_t __i;								      \
+    size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+    __cpu_mask *__bits = (cpusetp)->__bits;				      \
+    for (__i = 0; __i < __imax; ++__i)					      \
+      __bits[__i] = 0;							      \
+  } while (0)
+# endif
+# define __CPU_SET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
+	 |= __CPUMASK (__cpu))						      \
+      : 0; }))
+# define __CPU_CLR_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? (((__cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]		      \
+	 &= ~__CPUMASK (__cpu))						      \
+      : 0; }))
+# define __CPU_ISSET_S(cpu, setsize, cpusetp) \
+  (__extension__							      \
+   ({ size_t __cpu = (cpu);						      \
+      __cpu < 8 * (setsize)						      \
+      ? ((((__const __cpu_mask *) ((cpusetp)->__bits))[__CPUELT (__cpu)]	      \
+	  & __CPUMASK (__cpu))) != 0					      \
+      : 0; }))
+
+# define __CPU_COUNT_S(setsize, cpusetp) \
+  __sched_cpucount (setsize, cpusetp)
+
+# if __GNUC_PREREQ (2, 91)
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__builtin_memcmp (cpusetp1, cpusetp2, setsize) == 0)
+# else
+#  define __CPU_EQUAL_S(setsize, cpusetp1, cpusetp2) \
+  (__extension__							      \
+   ({ __const __cpu_mask *__arr1 = (cpusetp1)->__bits;				      \
+      __const __cpu_mask *__arr2 = (cpusetp2)->__bits;				      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	if (__bits[__i] != __bits[__i])					      \
+	  break;							      \
+      __i == __imax; }))
+# endif
+
+# define __CPU_OP_S(setsize, destset, srcset1, srcset2, op) \
+  (__extension__							      \
+   ({ cpu_set_t *__dest = (destset);					      \
+      __const __cpu_mask *__arr1 = (srcset1)->__bits;				      \
+      __const __cpu_mask *__arr2 = (srcset2)->__bits;				      \
+      size_t __imax = (setsize) / sizeof (__cpu_mask);			      \
+      size_t __i;							      \
+      for (__i = 0; __i < __imax; ++__i)				      \
+	((__cpu_mask *) __dest->__bits)[__i] = __arr1[__i] op __arr2[__i];    \
+      __dest; }))
+
+# define __CPU_ALLOC_SIZE(count) \
+  ((((count) + __NCPUBITS - 1) / __NCPUBITS) * sizeof (__cpu_mask))
+# define __CPU_ALLOC(count) __sched_cpualloc (count)
+# define __CPU_FREE(cpuset) __sched_cpufree (cpuset)
+
+__BEGIN_DECLS
+
+extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
+  __THROW;
+extern cpu_set_t *__sched_cpualloc (size_t __count) __THROW __wur;
+extern void __sched_cpufree (cpu_set_t *__set) __THROW;
+
+__END_DECLS
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sem.h
@@ -0,0 +1,93 @@
+/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SEM_H
+# error "Never include <bits/sem.h> directly; use <sys/sem.h> instead."
+#endif
+
+#include <sys/types.h>
+
+/* Flags for `semop'.  */
+#define SEM_UNDO	0x1000		/* undo the operation on exit */
+
+/* Commands for `semctl'.  */
+#define GETPID		4		/* get sempid */
+#define GETVAL		5		/* get semval */
+#define GETALL		6		/* get all semval's */
+#define GETNCNT		3		/* get semncnt */
+#define GETZCNT		7		/* get semzcnt */
+#define SETVAL		8		/* set semval */
+#define SETALL		9		/* set all semval's */
+
+#ifdef __USE_MISC
+# define SEM_R		IPC_R		/* read permission for user */
+# define SEM_A		IPC_W		/* alter permission for user */
+#endif
+
+
+/* Data structure describing a set of semaphores.  */
+struct semid_ds 
+{
+    struct ipc_perm	sem_perm;	/* operation permission struct */
+    void		*__sem_base;	/* pointer to first semaphore in set */
+    unsigned short	sem_nsems;	/* number of sems in set */
+    __time_t		sem_otime;	/* last operation time */
+    __time_t		sem_ctime;	/* last change time */
+    					/* Times measured in secs since */
+    					/* 00:00:00 GMT, Jan. 1, 1970 */
+};
+/* The user should define a union like the following to use it for arguments
+   for `semctl'.
+
+   union semun
+   {
+     int val;				<= value for SETVAL
+     struct semid_ds *buf;		<= buffer for IPC_STAT & IPC_SET
+     unsigned short int *array;		<= array for GETALL & SETALL
+     struct seminfo *__buf;		<= buffer for IPC_INFO
+   };
+
+   Previous versions of this file used to define this union but this is
+   incorrect.  One can test the macro _SEM_SEMUN_UNDEFINED to see whether
+   one must define the union or not.  */
+#define _SEM_SEMUN_UNDEFINED	1
+
+#ifdef __USE_MISC
+
+/* ipcs ctl cmds */
+# define SEM_STAT 10
+# define SEM_INFO 11
+
+/*
+ * semaphore info struct
+ */
+struct seminfo {
+        int     semmap,         /* # of entries in semaphore map */
+                semmni,         /* # of semaphore identifiers */
+                semmns,         /* # of semaphores in system */
+                semmnu,         /* # of undo structures in system */
+                semmsl,         /* max # of semaphores per id */
+                semopm,         /* max # of operations per semop call */
+                semume,         /* max # of undo entries per process */
+                semusz,         /* size in bytes of undo structure */
+                semvmx,         /* semaphore maximum value */
+                semaem;         /* adjust on exit max value */
+};
+
+#endif
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/shm.h
@@ -0,0 +1,89 @@
+/* Copyright (C) 1995-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SHM_H
+# error "Never include <bits/shm.h> directly; use <sys/shm.h> instead."
+#endif
+
+#include <bits/types.h>
+
+/* Permission flag for shmget.  */
+#ifdef __USE_MISC
+# define SHM_R		IPC_R		/* read permission for user */
+# define SHM_W		IPC_W		/* write permission for user */
+#endif
+
+/* Flags for `shmat'.  */
+#define SHM_RDONLY	010000		/* attach read-only else read-write */
+#define SHM_RND		020000		/* round attach address to SHMLBA */
+
+/* Commands for `shmctl'.  */
+#define SHM_LOCK	11		/* lock segment (root only) */
+#define SHM_UNLOCK	12		/* unlock segment (root only) */
+
+__BEGIN_DECLS
+
+/* Segment low boundary address multiple.  */
+#define SHMLBA		(__getpagesize ())
+extern int __getpagesize (void) __THROW __attribute__ ((__const__));
+
+
+/* Type to count number of attaches.  */
+typedef int shmatt_t;
+
+/* Data structure describing a set of semaphores.  */
+struct shmid_ds
+  {
+    struct ipc_perm shm_perm;		/* operation permission struct */
+    size_t shm_segsz;			/* size of segment in bytes */
+    __pid_t shm_lpid;			/* pid of last shmop */
+    __pid_t shm_cpid;			/* pid of creator */
+    shmatt_t shm_nattch;		/* number of current attaches */
+    __time_t shm_atime;			/* time of last shmat() */
+    __time_t shm_dtime;			/* time of last shmdt() */
+    __time_t shm_ctime;			/* time of last change by shmctl() */
+  };
+
+#ifdef __USE_MISC
+
+/* ipcs ctl commands */
+# define SHM_STAT 	13
+# define SHM_INFO 	14
+
+struct shminfo
+  {
+        int     shmmax,         /* max shared memory segment size (bytes) */
+                shmmin,         /* min shared memory segment size (bytes) */
+                shmmni,         /* max number of shared memory identifiers */
+                shmseg,         /* max shared memory segments per process */
+                shmall;         /* max amount of shared memory (pages) */
+  };
+
+struct shm_info
+  {
+    int used_ids;
+    unsigned long int shm_tot;	/* total allocated shm */
+    unsigned long int shm_rss;	/* total resident shm */
+    unsigned long int shm_swp;	/* total swapped shm */
+    unsigned long int swap_attempts;
+    unsigned long int swap_successes;
+  };
+
+#endif /* __USE_MISC */
+
+__END_DECLS
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigaction.h
@@ -0,0 +1,76 @@
+/* Copyright (C) 1991-1992,1996-1998,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SIGNAL_H
+# error "Never include <bits/sigaction.h> directly; use <signal.h> instead."
+#endif
+
+/* These definitions match those used by the FreeBSD kernel.  */
+
+/* Structure describing the action to be taken when a signal arrives.  */
+struct sigaction
+  {
+    /* Signal handler.  */
+#ifdef __USE_POSIX199309
+    union
+      {
+	/* Used if SA_SIGINFO is not set.  */
+	__sighandler_t sa_handler;
+	/* Used if SA_SIGINFO is set.  */
+	void (*sa_sigaction) (int, siginfo_t *, void *);
+      }
+    __sigaction_handler;
+# define sa_handler	__sigaction_handler.sa_handler
+# define sa_sigaction	__sigaction_handler.sa_sigaction
+#else
+    __sighandler_t sa_handler;
+#endif
+
+    /* Special flags.  */
+    int sa_flags;
+
+    /* Additional set of signals to be blocked.  */
+    __sigset_t sa_mask;
+  };
+
+/* Bits in `sa_flags'.  */
+#if defined __USE_UNIX98 || defined __USE_MISC
+# define SA_ONSTACK	0x0001	/* Take signal on signal stack.  */
+# define SA_RESTART	0x0002	/* Restart syscall on signal return.  */
+# define SA_RESETHAND	0x0004	/* Reset to SIG_DFL on entry to handler.  */
+# define SA_NODEFER	0x0010	/* Don't automatically block the signal when
+				    its handler is being executed.  */
+# define SA_NOCLDWAIT	0x0020	/* Don't save zombie processes.  */
+# define SA_SIGINFO	0x0040	/* Provide additional info to the handler.  */
+#endif
+#define	SA_NOCLDSTOP	0x0008	/* Don't send SIGCHLD when children stop.  */
+
+#ifdef __USE_MISC
+# define SA_INTERRUPT	0	/* Historical no-op ("not SA_RESTART").  */
+
+/* Some aliases for the SA_ constants.  */
+# define SA_NOMASK    SA_NODEFER
+# define SA_ONESHOT   SA_RESETHAND
+# define SA_STACK     SA_ONSTACK
+#endif
+
+
+/* Values for the HOW argument to `sigprocmask'.  */
+#define	SIG_BLOCK	1	/* Block signals.  */
+#define	SIG_UNBLOCK	2	/* Unblock signals.  */
+#define	SIG_SETMASK	3	/* Set the set of blocked signals.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/siginfo.h
@@ -0,0 +1,276 @@
+/* siginfo_t, sigevent and constants.  FreeBSD version.
+   Copyright (C) 1997-1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t 1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+#include <bits/types.h>		/* __pid_t, __uid_t */
+
+typedef struct siginfo
+  {
+    int si_signo;		/* Signal number.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+    __pid_t si_pid;		/* Sending process ID.  */
+    __uid_t si_uid;		/* Real user ID of sending process.  */
+    int si_status;		/* Exit value or signal.  */
+    void *si_addr;		/* Address of faulting instruction.  */
+    union sigval si_value;	/* Signal value.  */
+    union
+      {
+	struct
+	  {
+	    int     _trapno;	/* machine specific trap code */
+	   } _fault;
+
+	/* POSIX.1b timers.  */
+	struct
+	  {
+	    int     _timerid;
+	    int     _overrun;
+	  } _timer;
+
+	struct
+	  {
+	    int     _mqd;
+	  } _mesgq;
+
+	/* SIGPOLL.  */
+	struct
+	  {
+	    long    _band;	/* band event for SIGPOLL.  */
+	  } _poll;
+
+	struct
+	  {
+	    long    __spare1__;
+	    int     __spare2__[7];
+	  } __spare__;
+	} _reason;
+  } siginfo_t;
+
+
+/* X/Open requires some more fields with fixed names.  */
+# define si_int		si_value.sival_int
+# define si_ptr		si_value.sival_ptr
+# define si_trapno	_reason._fault._trapno
+# define si_timerid	_reason._timer._timerid
+# define si_overrun	_reason._timer._overrun
+# define si_mqd		_reason._mesgq._mqd
+# define si_band	_reason._poll._band
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCIO = 0x10004,		/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_MESGQ = 0x10005,		/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER = 0x10003,		/* Sent by timer expiration.  */
+# define SI_TIMER	SI_TIMER
+  SI_QUEUE = 0x10002,		/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER = 0x10001,		/* Sent by kill, sigsend, raise.  */
+# define SI_USER	SI_USER
+  SI_KERNEL = 0x10006,
+# define SI_KERNEL	SI_KERNEL
+  SI_LWP = 0x10007,		/* Sent by thr_kill.  */
+# define SI_LWP		SI_LWP
+  SI_UNDEFINED = 0
+# define SI_UNDEFINED	SI_UNDEFINED
+};
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTOVF = 1,		/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_INTDIV,			/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+/* XXX These are only used by the waitid() function, not by the kernel.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+#include <sys/_types.h>		/* __lwpid_t */
+
+/* Structure to transport application-defined values with signals.  */
+
+typedef struct sigevent
+  {
+    int sigev_notify;
+    int sigev_signo;
+    sigval_t sigev_value;
+    union
+    {
+      __lwpid_t threadid;
+      struct
+      {
+	void (*function) (sigval_t);	/* Function to start.  */
+	void *attributes;		/* Really pthread_attr_t.  */
+      } thread;
+    } un;
+  } sigevent_t;
+
+#define sigev_notify_kqueue	sigev_signo
+#define sigev_notify_function	un.thread.function
+#define sigev_notify_attributes	un.thread.attributes
+#define sigev_notify_thread_id	un.threadid
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 1,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE = 0,		/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  /* Not yet supported by the kernel.  */
+  SIGEV_THREAD = 2,		/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+  SIGEV_KEVENT = 3,
+# define SIGEV_KEVENT	SIGEV_KEVENT
+  SIGEV_THREAD_ID = 4,
+# define SIGEV_THREAD_ID	SIGEV_THREAD_ID
+};
+
+#endif	/* have _SIGNAL_H.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/signum.h
@@ -0,0 +1,84 @@
+/* Signal number definitions.  FreeBSD version.
+   Copyright (C) 1991-1993, 1996, 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifdef	_SIGNAL_H
+
+/* This file defines the fake signal functions and signal
+   number constants for 4.2 or 4.3 BSD-derived Unix system.  */
+
+/* Fake signal functions.  */
+#define	SIG_ERR	((__sighandler_t) -1) /* Error return.  */
+#define	SIG_DFL	((__sighandler_t) 0) /* Default action.  */
+#define	SIG_IGN	((__sighandler_t) 1) /* Ignore signal.  */
+
+#define	SIG_CATCH ((__sighandler_t) 2) /* FreeBSD specific ? */
+#define	SIG_HOLD  ((__sighandler_t) 3) /* Add signal to hold mask.  */
+
+/* Signals.  */
+#define	SIGHUP		1	/* Hangup (POSIX).  */
+#define	SIGINT		2	/* Interrupt (ANSI).  */
+#define	SIGQUIT		3	/* Quit (POSIX).  */
+#define	SIGILL		4	/* Illegal instruction (ANSI).  */
+#define	SIGABRT		SIGIOT	/* Abort (ANSI).  */
+#define	SIGTRAP		5	/* Trace trap (POSIX).  */
+#define	SIGIOT		6	/* IOT trap (4.2 BSD).  */
+#define	SIGEMT		7	/* EMT trap (4.2 BSD).  */
+#define	SIGFPE		8	/* Floating-point exception (ANSI).  */
+#define	SIGKILL		9	/* Kill, unblockable (POSIX).  */
+#define	SIGBUS		10	/* Bus error (4.2 BSD).  */
+#define	SIGSEGV		11	/* Segmentation violation (ANSI).  */
+#define	SIGSYS		12	/* Bad argument to system call (4.2 BSD).  */
+#define	SIGPIPE		13	/* Broken pipe (POSIX).  */
+#define	SIGALRM		14	/* Alarm clock (POSIX).  */
+#define	SIGTERM		15	/* Termination (ANSI).  */
+#define	SIGURG		16	/* Urgent condition on socket (4.2 BSD).  */
+#define	SIGSTOP		17	/* Stop, unblockable (POSIX).  */
+#define	SIGTSTP		18	/* Keyboard stop (POSIX).  */
+#define	SIGCONT		19	/* Continue (POSIX).  */
+#define	SIGCHLD		20	/* Child status has changed (POSIX).  */
+#define	SIGCLD		SIGCHLD	/* Same as SIGCHLD (System V).  */
+#define	SIGTTIN		21	/* Background read from tty (POSIX).  */
+#define	SIGTTOU		22	/* Background write to tty (POSIX).  */
+#define	SIGIO		23	/* I/O now possible (4.2 BSD).  */
+#define	SIGPOLL		SIGIO	/* Pollable event occurred (System V).  */
+#define	SIGXCPU		24	/* CPU limit exceeded (4.2 BSD).  */
+#define	SIGXFSZ		25	/* File size limit exceeded (4.2 BSD).  */
+#define	SIGVTALRM	26	/* Virtual alarm clock (4.2 BSD).  */
+#define	SIGPROF		27	/* Profiling alarm clock (4.2 BSD).  */
+#define	SIGWINCH	28	/* Window size change (4.3 BSD, Sun).  */
+#define SIGINFO		29	/* Information request (4.4 BSD).  */
+#define	SIGUSR1		30	/* User-defined signal 1 (POSIX).  */
+#define	SIGUSR2		31	/* User-defined signal 2 (POSIX).  */
+/* Signals 32 and 33 are reserved for system libraries. */
+
+/* Signal 34 is used (but not reserved) by thread library.
+   See PTHREAD_SIGBASE in kernel-features.h.  */
+
+#define	_NSIG		129	/* Biggest signal number + 1
+				   (including real-time signals).  */
+
+#define SIGRTMIN	(__libc_current_sigrtmin ())
+#define SIGRTMAX	(__libc_current_sigrtmax ())
+
+/* These are the hard limits of the kernel.  These values should not be
+   used directly at user level.  */
+#define __SIGRTMIN	65	/* be in sync with FreeBSD kernel */
+#define __SIGRTMAX	126	/* be in sync with FreeBSD kernel */
+
+#endif	/* <signal.h> included.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sigset.h
@@ -0,0 +1,140 @@
+/* __sig_atomic_t, __sigset_t, and related definitions.  FreeBSD version.
+   Copyright (C) 1994-1996, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SIGSET_H_types
+# define _SIGSET_H_types	1
+
+typedef int __sig_atomic_t;
+
+/* A `sigset_t' has a bit for each signal.  */
+__extension__ typedef struct
+  {
+    __extension__ union
+      {
+        unsigned int __sigbits[4];
+        unsigned int __bits[4];
+      };
+  } __sigset_t;
+
+#endif
+
+
+/* We only want to define these functions if <signal.h> was actually
+   included; otherwise we were included just to define the types.  Since we
+   are namespace-clean, it wouldn't hurt to define extra macros.  But
+   trouble can be caused by functions being defined (e.g., any global
+   register vars declared later will cause compilation errors).  */
+
+#if !defined _SIGSET_H_fns && defined _SIGNAL_H
+# define _SIGSET_H_fns 1
+
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+
+/* Return a mask that includes the bit for SIG only.  */
+# define __sigmask(sig)	((unsigned int) 1 << ((sig) - 1) % 32)
+
+/* Return the word index for SIG.  */
+# define __sigword(sig)	(((sig) - 1) >> 5)
+
+# if defined __GNUC__ && __GNUC__ >= 2
+#  define __sigemptyset(set) \
+  (__extension__ ({ sigset_t *__set = (set);				      \
+		    __set->__sigbits[0] = 0; __set->__sigbits[1] = 0;	      \
+		    __set->__sigbits[2] = 0; __set->__sigbits[3] = 0;	      \
+		    0; }))
+#  define __sigfillset(set) \
+  (__extension__ ({ sigset_t *__set = (set);				      \
+		    __set->__sigbits[0] = ~0; __set->__sigbits[1] = ~0;	      \
+		    __set->__sigbits[2] = ~0; __set->__sigbits[3] = ~0;	      \
+		    0; }))
+
+#  ifdef __USE_GNU
+/* The POSIX does not specify for handling the whole signal set in one
+   command.  This is often wanted and so we define three more functions
+   here.  */
+#   define __sigisemptyset(set) \
+  (__extension__ ({ const sigset_t *__set = (set);			      \
+		    __set->__sigbits[0] == 0				      \
+		    && __set->__sigbits[1] == 0				      \
+		    && __set->__sigbits[2] == 0				      \
+		    && __set->__sigbits[3] == 0; }))
+#   define __sigandset(dest, left, right) \
+  (__extension__ ({ sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    __dest->__sigbits[0] =				      \
+		      __left->__sigbits[0] & __right->__sigbits[0];	      \
+		    __dest->__sigbits[1] =				      \
+		      __left->__sigbits[1] & __right->__sigbits[1];	      \
+		    __dest->__sigbits[2] =				      \
+		      __left->__sigbits[2] & __right->__sigbits[2];	      \
+		    __dest->__sigbits[3] =				      \
+		      __left->__sigbits[3] & __right->__sigbits[3];	      \
+		    0; }))
+#   define __sigorset(dest, left, right) \
+  (__extension__ ({ sigset_t *__dest = (dest);				      \
+		    const sigset_t *__left = (left);			      \
+		    const sigset_t *__right = (right);			      \
+		    __dest->__sigbits[0] =				      \
+		      __left->__sigbits[0] | __right->__sigbits[0];	      \
+		    __dest->__sigbits[1] =				      \
+		      __left->__sigbits[1] | __right->__sigbits[1];	      \
+		    __dest->__sigbits[2] =				      \
+		      __left->__sigbits[2] | __right->__sigbits[2];	      \
+		    __dest->__sigbits[3] =				      \
+		      __left->__sigbits[3] | __right->__sigbits[3];	      \
+		    0; }))
+#  endif
+# endif
+
+/* These functions needn't check for a bogus signal number -- error
+   checking is done in the non __ versions.  */
+
+extern int __sigismember (__const __sigset_t *, int);
+extern int __sigaddset (__sigset_t *, int);
+extern int __sigdelset (__sigset_t *, int);
+
+# ifdef __USE_EXTERN_INLINES
+
+_EXTERN_INLINE int
+__sigismember (__const __sigset_t *__set, int __sig)
+{
+  return (__set->__sigbits[__sigword (__sig)] & __sigmask (__sig) ? 1 : 0);
+}
+
+_EXTERN_INLINE int
+__sigaddset (__sigset_t *__set, int __sig)
+{
+  __set->__sigbits[__sigword (__sig)] |= __sigmask (__sig);
+  return 0;
+}
+
+_EXTERN_INLINE int
+__sigdelset (__sigset_t *__set, int __sig)
+{
+  __set->__sigbits[__sigword (__sig)] &= ~__sigmask (__sig);
+  return 0;
+}
+
+# endif
+
+
+#endif /* ! _SIGSET_H_fns.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/socket.h
@@ -0,0 +1,431 @@
+/* System-specific socket constants and types.  FreeBSD version.
+   Copyright (C) 1991-1992,1994-1999,2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H	1
+
+#if !defined _SYS_SOCKET_H && !defined _NETINET_IN_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#include <limits.h>		/* XXX Is this allowed?  */
+#include <bits/types.h>
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+
+/* Types of sockets.  */
+enum __socket_type
+{
+  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
+				   byte streams.  */
+#define SOCK_STREAM SOCK_STREAM
+  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
+				   of fixed maximum length.  */
+#define SOCK_DGRAM SOCK_DGRAM
+  SOCK_RAW = 3,			/* Raw protocol interface.  */
+#define SOCK_RAW SOCK_RAW
+  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
+#define SOCK_RDM SOCK_RDM
+  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
+				   datagrams of fixed maximum length.  */
+#define SOCK_SEQPACKET SOCK_SEQPACKET
+
+  /* Flags to be ORed into the type parameter of socket and socketpair and
+     used for the flags parameter of paccept.  */
+
+  SOCK_CLOEXEC = 0x10000000,	/* Atomically set close-on-exec flag for the
+				new descriptor(s).  */
+#define SOCK_CLOEXEC SOCK_CLOEXEC
+  SOCK_NONBLOCK = 0x20000000	/* Atomically mark descriptor(s) as
+				non-blocking.  */
+#define SOCK_NONBLOCK SOCK_NONBLOCK
+};
+
+/*
+ * Structure used by kernel to pass protocol
+ * information in raw sockets.
+ */
+struct sockproto {
+	unsigned short	sp_family;		/* address family */
+	unsigned short	sp_protocol;		/* protocol */
+};
+
+/* Protocol families.  */
+#define	PF_UNSPEC	0	/* Unspecified.  */
+#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
+#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* POSIX name for PF_LOCAL.  */
+#define	PF_INET		2	/* IP protocol family.  */
+#define	PF_IMPLINK	3	/* ARPAnet IMP protocol.  */
+#define	PF_PUP		4	/* PUP protocols.  */
+#define	PF_CHAOS	5	/* MIT Chaos protocols.  */
+#define	PF_NETBIOS	6	/* SMB protocols.  */
+#define	PF_ISO		7	/* ISO protocols.  */
+#define	PF_OSI		PF_ISO
+#define	PF_ECMA		8	/* ECMA protocols.  */
+#define	PF_DATAKIT	9	/* AT&T Datakit protocols.  */
+#define	PF_CCITT	10	/* CCITT protocols (X.25 et al).  */
+#define	PF_SNA		11	/* IBM SNA protocol.  */
+#define	PF_DECnet	12	/* DECnet protocols.  */
+#define	PF_DLI		13	/* Direct data link interface.  */
+#define	PF_LAT		14	/* DEC Local Area Transport protocol.  */
+#define	PF_HYLINK	15	/* NSC Hyperchannel protocol.  */
+#define	PF_APPLETALK	16	/* Don't use this.  */
+#define	PF_ROUTE	17	/* Internal Routing Protocol.  */
+#define	PF_LINK		18	/* Link layer interface.  */
+#define	PF_XTP		19	/* eXpress Transfer Protocol (no AF).  */
+#define	PF_COIP		20	/* Connection-oriented IP, aka ST II.  */
+#define	PF_CNT		21	/* Computer Network Technology.  */
+#define PF_RTIP		22	/* Help Identify RTIP packets.  **/
+#define	PF_IPX		23	/* Novell Internet Protocol.  */
+#define	PF_SIP		24	/* Simple Internet Protocol.  */
+#define PF_PIP		25	/* Help Identify PIP packets.  */
+#define PF_ISDN		26	/* Integrated Services Digital Network.  */
+#define PF_KEY		27	/* Internal key-management function.  */
+#define PF_INET6	28	/* IP version 6.  */
+#define PF_NATM		29	/* Native ATM access.  */
+#define PF_ATM		30	/* ATM.  */
+#define PF_HDRCMPLT	31	/* Used by BPF to not rewrite headers in
+				   interface output routine.  */
+#define PF_NETGRAPH	32	/* Netgraph sockets.  */
+#define	PF_MAX		33
+
+/* Address families.  */
+#define	AF_UNSPEC	PF_UNSPEC
+#define	AF_LOCAL	PF_LOCAL
+#define	AF_UNIX		PF_UNIX
+#define	AF_FILE		PF_FILE
+#define	AF_INET		PF_INET
+#define	AF_IMPLINK	PF_IMPLINK
+#define	AF_PUP		PF_PUP
+#define	AF_CHAOS	PF_CHAOS
+#define	AF_NETBIOS	PF_NETBIOS
+#define	AF_ISO		PF_ISO
+#define	AF_OSI		PF_OSI
+#define	AF_ECMA		PF_ECMA
+#define	AF_DATAKIT	PF_DATAKIT
+#define	AF_CCITT	PF_CCITT
+#define	AF_SNA		PF_SNA
+#define	AF_DECnet	PF_DECnet
+#define	AF_DLI		PF_DLI
+#define	AF_LAT		PF_LAT
+#define	AF_HYLINK	PF_HYLINK
+#define	AF_APPLETALK	PF_APPLETALK
+#define	AF_ROUTE	PF_ROUTE
+#define	AF_LINK		PF_LINK
+#define	pseudo_AF_XTP	PF_XTP
+#define	AF_COIP		PF_COIP
+#define	AF_CNT		PF_CNT
+#define pseudo_AF_RTIP	PF_RTIP
+#define	AF_IPX		PF_IPX
+#define	AF_SIP		PF_SIP
+#define pseudo_AF_PIP	PF_PIP
+#define AF_ISDN		PF_ISDN
+#define AF_E164		AF_ISDN		/* CCITT E.164 recommendation.  */
+#define pseudo_AF_KEY	PF_KEY
+#define AF_INET6	PF_INET6
+#define AF_NATM		PF_NATM
+#define AF_ATM		PF_ATM
+#define pseudo_AF_HDRCMPLT PF_HDRCMPLT
+#define AF_NETGRAPH	PF_NETGRAPH
+#define	AF_MAX		PF_MAX
+
+/* Maximum queue length specifiable by listen.  */
+#define SOMAXCONN	128	/* 5 on the original 4.4 BSD.  */
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+/* Structure describing a generic socket address.  */
+struct sockaddr
+  {
+    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
+    char sa_data[14];		/* Address data.  */
+  };
+
+
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  We reserve 128 bytes.  */
+#if ULONG_MAX > 0xffffffff
+# define __ss_aligntype	__uint64_t
+#else
+# define __ss_aligntype	__uint32_t
+#endif
+#define _SS_SIZE	128
+#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
+
+struct sockaddr_storage
+  {
+    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+    char __ss_padding[_SS_PADSIZE];
+  };
+
+
+/* Bits in the FLAGS argument to `send', `recv', et al.  */
+enum
+  {
+    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
+#define MSG_OOB MSG_OOB
+    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
+#define MSG_PEEK MSG_PEEK
+    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
+#define MSG_DONTROUTE MSG_DONTROUTE
+    MSG_EOR		= 0x08,	/* Data completes record.  */
+#define MSG_EOR MSG_EOR
+    MSG_TRUNC		= 0x10,	/* Data discarded before delivery.  */
+#define MSG_TRUNC MSG_TRUNC
+    MSG_CTRUNC		= 0x20,	/* Control data lost before delivery.  */
+#define MSG_CTRUNC MSG_CTRUNC
+    MSG_WAITALL		= 0x40,	/* Wait for full request or error.  */
+#define MSG_WAITALL MSG_WAITALL
+    MSG_DONTWAIT	= 0x80,	/* This message should be nonblocking.  */
+#define MSG_DONTWAIT MSG_DONTWAIT
+    MSG_EOF		= 0x100, /* Data completes connection.  */
+#define MSG_EOF MSG_EOF
+    MSG_NOTIFICATION	= 0x2000,/* SCTP notification */
+#define MSG_NOTIFICATION MSG_NOTIFICATION
+    MSG_NBIO		= 0x4000,/*FIONBIO mode, used by fifofs */
+#define MSG_NBIO MSG_NBIO
+    MSG_COMPAT		= 0x8000,/* Used in sendit().  */
+#define MSG_COMPAT MSG_COMPAT
+    MSG_NOSIGNAL	= 0x20000 /* do not generate SIGPIPE on EOF */
+#define MSG_NOSIGNAL MSG_NOSIGNAL
+  };
+
+
+/* Structure describing messages sent by
+   `sendmsg' and received by `recvmsg'.  */
+struct msghdr
+  {
+    void *msg_name;		/* Address to send to/receive from.  */
+    socklen_t msg_namelen;	/* Length of address data.  */
+
+    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
+    int msg_iovlen;		/* Number of elements in the vector.  */
+
+    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
+    socklen_t msg_controllen;	/* Ancillary data buffer length.  */
+
+    int msg_flags;		/* Flags in received message.  */
+  };
+
+/* Structure used for storage of ancillary data object information.  */
+struct cmsghdr
+  {
+    socklen_t cmsg_len;		/* Length of data in cmsg_data plus length
+				   of cmsghdr structure.  */
+    int cmsg_level;		/* Originating protocol.  */
+    int cmsg_type;		/* Protocol specific type.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+    __extension__ unsigned char __cmsg_data  __flexarr __attribute__ ((aligned (__alignof__(size_t)))); /* Ancillary data.  */
+#endif
+  };
+
+#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
+
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			   & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+/* Ancillary data object manipulation macros.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
+#else
+# define CMSG_DATA(cmsg) ((unsigned char *) (cmsg) + CMSG_ALIGN(sizeof (struct cmsghdr)))
+#endif
+
+extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
+				      struct cmsghdr *__cmsg) __THROW;
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+_EXTERN_INLINE struct cmsghdr *
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
+{
+  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
+    /* The kernel header does this so there may be a reason.  */
+    return 0;
+
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
+					+ __mhdr->msg_controllen)
+      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
+	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
+    /* No more entries.  */
+    return 0;
+  return __cmsg;
+}
+#endif	/* Use `extern inline'.  */
+
+/* Socket level message types.  */
+enum
+  {
+    SCM_RIGHTS = 0x01,		/* Access rights (array of int).  */
+#define SCM_RIGHTS SCM_RIGHTS
+    SCM_TIMESTAMP = 0x02,	/* Timestamp (struct timeval).  */
+#define SCM_TIMESTAMP SCM_TIMESTAMP
+    SCM_CREDS = 0x03		/* Process creds (struct cmsgcred).  */
+#define SCM_CREDS SCM_CREDS
+  };
+
+/* Unfortunately, BSD practice dictates this structure be of fixed size.
+   If there are more than CMGROUP_MAX groups, the list is truncated.
+   (On GNU systems, the `cmcred_euid' field is just the first in the
+   list of effective UIDs.)  */
+#define CMGROUP_MAX	16
+
+/* Structure delivered by SCM_CREDS.  This describes the identity of the
+   sender of the data simultaneously received on the socket.  By BSD
+   convention, this is included only when a sender on a AF_LOCAL socket
+   sends cmsg data of this type and size; the sender's structure is
+   ignored, and the system fills in the various IDs of the sender process.  */
+struct cmsgcred
+  {
+    __pid_t cmcred_pid;
+    __uid_t cmcred_uid;
+    __uid_t cmcred_euid;
+    __gid_t cmcred_gid;
+    short cmcred_ngroups;
+    __gid_t cmcred_groups[CMGROUP_MAX];
+  };
+
+/* Protocol number used to manipulate socket-level options
+   with `getsockopt' and `setsockopt'.  */
+#define	SOL_SOCKET	0xffff
+
+/* Socket-level options for `getsockopt' and `setsockopt'.  */
+enum
+  {
+    SO_DEBUG = 0x0001,		/* Record debugging information.  */
+#define SO_DEBUG SO_DEBUG
+    SO_ACCEPTCONN = 0x0002,	/* Accept connections on socket.  */
+#define SO_ACCEPTCONN SO_ACCEPTCONN
+    SO_REUSEADDR = 0x0004,	/* Allow reuse of local addresses.  */
+#define SO_REUSEADDR SO_REUSEADDR
+    SO_KEEPALIVE = 0x0008,	/* Keep connections alive and send
+				   SIGPIPE when they die.  */
+#define SO_KEEPALIVE SO_KEEPALIVE
+    SO_DONTROUTE = 0x0010,	/* Don't do local routing.  */
+#define SO_DONTROUTE SO_DONTROUTE
+    SO_BROADCAST = 0x0020,	/* Allow transmission of
+				   broadcast messages.  */
+#define SO_BROADCAST SO_BROADCAST
+    SO_USELOOPBACK = 0x0040,	/* Use the software loopback to avoid
+				   hardware use when possible.  */
+#define SO_USELOOPBACK SO_USELOOPBACK
+    SO_LINGER = 0x0080,		/* Block on close of a reliable
+				   socket to transmit pending data.  */
+#define SO_LINGER SO_LINGER
+    SO_OOBINLINE = 0x0100,	/* Receive out-of-band data in-band.  */
+#define SO_OOBINLINE SO_OOBINLINE
+    SO_REUSEPORT = 0x0200,	/* Allow local address and port reuse.  */
+#define SO_REUSEPORT SO_REUSEPORT
+    SO_TIMESTAMP = 0x0400,	/* Timestamp received dgram traffic.  */
+#define SO_TIMESTAMP SO_TIMESTAMP
+    SO_SNDBUF = 0x1001,		/* Send buffer size.  */
+#define SO_SNDBUF SO_SNDBUF
+    SO_RCVBUF = 0x1002,		/* Receive buffer.  */
+#define SO_RCVBUF SO_RCVBUF
+    SO_SNDLOWAT = 0x1003,	/* Send low-water mark.  */
+#define SO_SNDLOWAT SO_SNDLOWAT
+    SO_RCVLOWAT = 0x1004,	/* Receive low-water mark.  */
+#define SO_RCVLOWAT SO_RCVLOWAT
+    SO_SNDTIMEO = 0x1005,	/* Send timeout.  */
+#define SO_SNDTIMEO SO_SNDTIMEO
+    SO_RCVTIMEO = 0x1006,	/* Receive timeout.  */
+#define SO_RCVTIMEO SO_RCVTIMEO
+    SO_ERROR = 0x1007,		/* Get and clear error status.  */
+#define SO_ERROR SO_ERROR
+    SO_STYLE = 0x1008,		/* Get socket connection style.  */
+#define SO_STYLE SO_STYLE
+    SO_TYPE = SO_STYLE,		/* Compatible name for SO_STYLE.  */
+#define SO_TYPE SO_TYPE
+    SO_LABEL = 0x1009,
+#define SO_LABEL SO_LABEL
+    SO_PEERLABEL = 0x1010,
+#define SO_PEERLABEL SO_PEERLABEL
+    SO_LISTENQLIMIT = 0x1011,
+#define SO_LISTENQLIMIT SO_LISTENQLIMIT
+    SO_LISTENQLEN = 0x1012,
+#define SO_LISTENQLEN SO_LISTENQLEN
+    SO_LISTENINCQLEN = 0x1013,
+#define SO_LISTENINCQLEN SO_LISTENINCQLEN
+    SO_SETFIB = 0x1014,
+#define SO_SETFIB SO_SETFIB
+    SO_USER_COOKIE = 0x1015,
+#define SO_USER_COOKIE SO_USER_COOKIE
+    SO_PROTOCOL = 0x1016,
+#define SO_PROTOCOL SO_PROTOCOL
+    SO_PROTOTYPE = SO_PROTOCOL
+#define SO_PROTOTYPE SO_PROTOTYPE
+  };
+
+/* Socket options. */
+#define LOCAL_PEERCRED          0x001   /* retrieve peer credentials */
+#define LOCAL_CREDS             0x002   /* pass credentials to receiver */
+#define LOCAL_CONNWAIT          0x004   /* connects block until accepted */
+
+/* Structure used to manipulate the SO_LINGER option.  */
+struct linger
+  {
+    int l_onoff;		/* Nonzero to linger on close.  */
+    int l_linger;		/* Time to linger.  */
+  };
+
+/* Magic IPv4 addresses defined in FreeBSD version of <netinet/in.h>, but not
+   included in Glibc version of the same header. */
+#define	INADDR_ALLRPTS_GROUP	(u_int32_t)0xe0000016	/* 224.0.0.22, IGMPv3 */
+#define	INADDR_CARP_GROUP	(u_int32_t)0xe0000012	/* 224.0.0.18 */
+#define	INADDR_PFSYNC_GROUP	(u_int32_t)0xe00000f0	/* 224.0.0.240 */
+#define	INADDR_ALLMDNS_GROUP	(u_int32_t)0xe00000fb	/* 224.0.0.251 */
+
+#ifdef __USE_MISC
+
+struct sf_hdtr;
+
+__BEGIN_DECLS
+
+extern int bsd_sendfile (int __in_fd, int __out_sock,
+			 __off_t __in_offset, size_t __nbytes,
+			 struct sf_hdtr *__hdtr, __off_t *__sockbytes,
+			 int __flags) __THROW;
+
+__END_DECLS
+
+#endif /* Use BSD */
+
+#endif	/* bits/socket.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat.h
@@ -0,0 +1,219 @@
+/* Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_STAT_H && !defined _FCNTL_H
+# error "Never include <bits/stat.h> directly; use <sys/stat.h> instead."
+#endif
+
+#ifndef _BITS_STAT_H
+#define _BITS_STAT_H   1
+
+/* This structure needs to be defined in accordance with the
+   implementation of __stat, __fstat, and __lstat.  */
+
+#include <bits/types.h>
+
+/* Versions of the 'struct stat' data structure.  */
+#define _STAT_VER_ostat	0	/* 'struct ostat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_stat	1	/* 'struct stat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_nstat	2	/* 'struct nstat' in /usr/src/sys/sys/stat.h */
+#define _STAT_VER_gstat 3	/* glibc's 'struct stat' without LFS */
+/* By default we use _STAT_VER_gstat, but we support also _STAT_VER_stat */
+#define _STAT_VER	_STAT_VER_gstat
+
+/* Structure describing file characteristics.  */
+struct stat
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+#ifndef __USE_FILE_OFFSET64
+    __ino_t st_ino;		/* File serial number.  */
+#else
+    __ino64_t st_ino;		/* File serial number.	*/
+#endif
+
+    __mode_t st_mode;		/* File mode.  */
+    __mode_t __pad_mode;	/* __mode_t is 16 bit, fill to 32 bit to retain previous ABI */
+    __nlink_t st_nlink;		/* Link count.  */
+    __nlink_t __pad_nlink;	/* __nlink_t is 16 bit, fill to 32 bit to retain previous ABI */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+#endif
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+#define _STATBUF_ST_BLKSIZE	/* Tell code we have this member.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __quad_t __unused1[2];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct stat64
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino64_t st_ino;		/* File serial number.	*/
+
+    __mode_t st_mode;		/* File mode.  */
+    __mode_t __pad_mode;	/* __mode_t is 16 bit, fill to 32 bit to retain previous ABI */
+    __nlink_t st_nlink;		/* Link count.  */
+    __nlink_t __pad_nlink;	/* __nlink_t is 16 bit, fill to 32 bit to retain previous ABI */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+#if defined __USE_MISC || defined __USE_XOPEN2K8
+    /* Nanosecond resolution timestamps are stored in a format
+       equivalent to 'struct timespec'.  This is the type used
+       whenever possible but the Unix namespace rules do not allow the
+       identifier 'timespec' to appear in the <sys/stat.h> header.
+       Therefore we have to handle the use of this header in strictly
+       standard-compliant sources special.  */
+    struct timespec st_atim;		/* Time of last access.  */
+    struct timespec st_mtim;		/* Time of last modification.  */
+    struct timespec st_ctim;		/* Time of last status change.  */
+# define st_atime st_atim.tv_sec	/* Backward compatibility.  */
+# define st_mtime st_mtim.tv_sec
+# define st_ctime st_ctim.tv_sec
+#else
+    __time_t st_atime;		/* Time of last access.  */
+    long int st_atimensec;	/* Nanoseconds of last access.  */
+    __time_t st_mtime;		/* Time of last modification.  */
+    long int st_mtimensec;	/* Nanoseconds of last modification.  */
+    __time_t st_ctime;		/* Time of last status change.  */
+    long int st_ctimensec;	/* Nanoseconds of last status change.  */
+#endif
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __quad_t __unused1[2];
+  };
+#endif
+
+/* Encoding of the file mode.  These are the standard Unix values,
+   but POSIX.1 does not specify what values should be used.  */
+
+#define __S_IFMT	0170000	/* These bits determine file type.  */
+
+/* File types.  */
+#define __S_IFDIR	0040000	/* Directory.  */
+#define __S_IFCHR	0020000	/* Character device.  */
+#define __S_IFBLK	0060000	/* Block device.  */
+#define __S_IFREG	0100000	/* Regular file.  */
+#define __S_IFLNK	0120000	/* Symbolic link.  */
+#define __S_IFSOCK	0140000	/* Socket.  */
+#define __S_IFWHT	0160000	/* Whiteout.  */
+#define __S_IFIFO	0010000	/* FIFO.  */
+
+/* POSIX.1b objects.  */
+#define __S_TYPEISMQ(buf) 0
+#define __S_TYPEISSEM(buf) 0
+#define __S_TYPEISSHM(buf) 0
+
+/* Protection bits.  */
+
+#define __S_ISUID	04000	/* Set user ID on execution.  */
+#define __S_ISGID	02000	/* Set group ID on execution.  */
+#define __S_ISVTX	01000	/* Save swapped text after use (sticky).  */
+#define __S_IREAD	0400	/* Read by owner.  */
+#define __S_IWRITE	0200	/* Write by owner.  */
+#define __S_IEXEC	0100	/* Execute by owner.  */
+
+#ifdef __USE_MISC
+
+/* Definitions of flags stored in file flags word.  */
+
+/* Super-user and owner changeable flags.  */
+# define UF_SETTABLE	0x0000ffff	/* mask of owner changeable flags */
+# define UF_NODUMP	0x00000001	/* do not dump file */
+# define UF_IMMUTABLE	0x00000002	/* file may not be changed */
+# define UF_APPEND	0x00000004	/* writes to file may only append */
+# define UF_OPAQUE	0x00000008	/* directory is opaque wrt. union */
+# define UF_NOUNLINK	0x00000010	/* file may not be removed or renamed */
+
+/* Super-user changeable flags.  */
+# define SF_SETTABLE	0xffff0000	/* mask of superuser changeable flags */
+# define SF_ARCHIVED	0x00010000	/* file is archived */
+# define SF_IMMUTABLE	0x00020000	/* file may not be changed */
+# define SF_APPEND	0x00040000	/* writes to file may only append */
+# define SF_NOUNLINK	0x00100000	/* file may not be removed or renamed */
+# define SF_SNAPSHOT	0x00200000	/* snapshot inode */
+
+__BEGIN_DECLS
+
+/* Set file flags for FILE to FLAGS.  */
+extern int chflags (__const char *__file, unsigned long int __flags) __THROW;
+
+/* Set file flags of the file referred to by FD to FLAGS.  */
+extern int fchflags (int __fd, unsigned long int __flags) __THROW;
+
+/* Set file flags for FILE to FLAGS without following symlinks.  */
+extern int lchflags(__const char *__file, int __flags);
+
+/* Get device name in /dev with a device number of dev and a file type
+   matching the one encoded in type.  */
+extern char *devname(__dev_t dev, __mode_t type) __THROW;
+
+/* Store at most BUFLEN characters of the device name in /dev with a 
+   device number of dev and a file type matching the one encoded in type.  */
+extern char *devname_r(__dev_t dev, __mode_t type, char *buf, int buflen) __THROW;
+
+__END_DECLS
+
+#endif /* __USE_MISC */
+
+#endif /* bits/stat.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/stat16.h
@@ -0,0 +1,56 @@
+/* Copyright (C) 2002, 2006, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This structure corresponds to the standard FreeBSD 'struct stat'
+   (i.e. _STAT_VER_stat), and is used by the stat() system call family. */
+
+struct stat16
+  {
+    __dev_t st_dev;		/* Device containing the file.  */
+    __ino_t st_ino;		/* File serial number.  */
+
+    __uint16_t st_mode;		/* File mode.  */
+    __uint16_t st_nlink;	/* Link count.  */
+
+    __uid_t st_uid;		/* User ID of the file's owner.  */
+    __gid_t st_gid;		/* Group ID of the file's group.  */
+
+    __dev_t st_rdev;		/* Device number, if device.  */
+
+    struct  timespec st_atimespec;  /* time of last access */
+    struct  timespec st_mtimespec;  /* time of last data modification */
+    struct  timespec st_ctimespec;  /* time of last file status change */
+
+    __off_t st_size;		/* Size of file, in bytes.  */
+
+    __blkcnt_t st_blocks;	/* Number of 512-byte blocks allocated.  */
+
+    __blksize_t st_blksize;	/* Optimal block size for I/O.  */
+
+    __uint32_t st_flags;	/* User defined flags.  */
+
+    __uint32_t st_gen;		/* Generation number.  */
+
+    __uint32_t __unused1;
+
+    __time_t st_birthtime;	/* Time of file creation.  */
+    long int st_birthtimensec;	/* Nanoseconds of file creation.  */
+
+#define _BIRTH_PADSIZE     (16 - sizeof(__time_t) - sizeof (long int))
+    char __birth_padding[_BIRTH_PADSIZE];
+  };
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statfs.h
@@ -0,0 +1,91 @@
+/* Definition of `struct statfs', information about a filesystem.
+   Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_STATFS_H
+#define _BITS_STATFS_H	1
+
+#if !defined _SYS_STATFS_H && !defined _SYS_MOUNT_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+struct statfs
+  {
+    unsigned long f_version;
+    unsigned long f_bsize;
+    unsigned long f_iosize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+#endif
+    __fsid_t f_fsid;
+    __uid_t f_owner;
+    int f_type;
+    int f_flags;
+    unsigned long int f_syncwrites;
+    unsigned long int f_asyncwrites;
+    char f_fstypename[16];
+    char f_mntonname[80];
+    unsigned long int f_syncreads;
+    unsigned long int f_asyncreads;
+    unsigned short f_namemax;
+    char f_mntfromname[80];
+    short __unused3;
+    long __unused4[2];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    unsigned long f_version;
+    unsigned long f_bsize;
+    unsigned long f_iosize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    __uid_t f_owner;
+    int f_type;
+    int f_flags;
+    unsigned long int f_syncwrites;
+    unsigned long int f_asyncwrites;
+    char f_fstypename[16];
+    char f_mntonname[80];
+    unsigned long int f_syncreads;
+    unsigned long int f_asyncreads;
+    unsigned short f_namemax;
+    char f_mntfromname[80];
+    short __unused3;
+    long __unused4[2];
+  };
+#endif
+
+#endif /* _BITS_STATFS_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/statvfs.h
@@ -0,0 +1,97 @@
+/* Definition of `struct statvfs', information about a filesystem.
+   Copyright (C) 1998, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_STATVFS_H
+# error "Never include <bits/statvfs.h> directly; use <sys/statvfs.h> instead."
+#endif
+
+#include <bits/types.h>
+
+#if __WORDSIZE == 32
+#define _STATVFSBUF_F_UNUSED
+#endif
+
+struct statvfs
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+#ifndef __USE_FILE_OFFSET64
+    __fsblkcnt_t f_blocks;
+    __fsblkcnt_t f_bfree;
+    __fsblkcnt_t f_bavail;
+    __fsfilcnt_t f_files;
+    __fsfilcnt_t f_ffree;
+    __fsfilcnt_t f_favail;
+#else
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+#endif
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    unsigned int f_spare[6];
+  };
+
+#ifdef __USE_LARGEFILE64
+struct statvfs64
+  {
+    unsigned long int f_bsize;
+    unsigned long int f_frsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsfilcnt64_t f_favail;
+    unsigned long int f_fsid;
+#ifdef _STATVFSBUF_F_UNUSED
+    int __f_unused;
+#endif
+    unsigned long int f_flag;
+    unsigned long int f_namemax;
+    unsigned int f_spare[6];
+  };
+#endif
+
+/* Definitions for the flag in `f_flag'.  */
+enum
+{
+  ST_RDONLY = 1,		/* Mount read-only.  */
+#define ST_RDONLY	ST_RDONLY
+  ST_NOSUID = 2			/* Ignore suid and sgid bits.  */
+#define ST_NOSUID	ST_NOSUID
+#ifdef __USE_GNU
+  ,
+  ST_NODEV = 4,			/* Disallow access to device special files.  */
+# define ST_NODEV	ST_NODEV
+  ST_NOEXEC = 8,		/* Disallow program execution.  */
+# define ST_NOEXEC	ST_NOEXEC
+  ST_SYNCHRONOUS = 16,		/* Writes are synced at once.  */
+# define ST_SYNCHRONOUS	ST_SYNCHRONOUS
+  ST_NOATIME = 0x10000000	/* Do not update access times.  */
+# define ST_NOATIME	ST_NOATIME
+#endif	/* Use GNU.  */
+};
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/sys_errlist.h
@@ -0,0 +1,33 @@
+/* Declare sys_errlist and sys_nerr, or don't.  Compatibility (do) version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _STDIO_H
+# error "Never include <bits/sys_errlist.h> directly; use <stdio.h> instead."
+#endif
+
+/* sys_errlist and sys_nerr are deprecated.  Use strerror instead.  */
+
+#ifdef  __USE_MISC
+extern int sys_nerr;
+extern __const char *__const sys_errlist[];
+#endif
+#ifdef  __USE_GNU
+extern int _sys_nerr;
+extern __const char *__const _sys_errlist[];
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/syslog-path.h
@@ -0,0 +1,31 @@
+/* <bits/syslog-path.h> -- _PATH_LOG definition
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSLOG_H
+# error "Never include this file directly.  Use <sys/syslog.h> instead"
+#endif
+
+#ifndef _BITS_SYSLOG_PATH_H
+#define _BITS_SYSLOG_PATH_H 1
+
+/* On kFreeBSD, named pipes are not allowed in /dev (devfs), so we pick this
+   alternate path. */
+#define _PATH_LOG	"/var/run/log"
+
+#endif /* bits/syslog-path.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/termios.h
@@ -0,0 +1,245 @@
+/* termios type and macro definitions.  FreeBSD version.
+   Copyright (C) 1993-1994,1996-1997,1999,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _TERMIOS_H
+# error "Never include <bits/termios.h> directly; use <termios.h> instead."
+#endif
+
+/* These macros are also defined in some <bits/ioctls.h> files (with
+   numerically identical values), but this serves to shut up cpp's
+   complaining. */
+#ifdef __USE_MISC
+
+# ifdef MDMBUF
+#  undef MDMBUF
+# endif
+# ifdef FLUSHO
+#  undef FLUSHO
+# endif
+# ifdef PENDIN
+#  undef PENDIN
+# endif
+
+#endif /* __USE_MISC */
+
+#ifdef ECHO
+# undef ECHO
+#endif
+#ifdef TOSTOP
+# undef TOSTOP
+#endif
+#ifdef NOFLSH
+# undef NOFLSH
+#endif
+
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 20
+struct termios
+  {
+    tcflag_t c_iflag;		/* input mode flags */
+    tcflag_t c_oflag;		/* output mode flags */
+    tcflag_t c_cflag;		/* control mode flags */
+    tcflag_t c_lflag;		/* local mode flags */
+    cc_t c_cc[NCCS];		/* control characters */
+    speed_t c_ispeed;		/* input speed */
+    speed_t c_ospeed;		/* output speed */
+#define __ispeed c_ispeed
+#define __ospeed c_ospeed
+#define _HAVE_STRUCT_TERMIOS_C_ISPEED 1
+#define _HAVE_STRUCT_TERMIOS_C_OSPEED 1
+  };
+
+/* c_cc characters */
+#define VEOF 0
+#define VEOL 1
+#define VEOL2 2
+#define VERASE 3
+#define VWERASE 4
+#define VKILL 5
+#define VREPRINT 6
+#ifdef __USE_MISC
+# define VERASE2 7
+#endif
+#define VINTR 8
+#define VQUIT 9
+#define VSUSP 10
+#ifdef __USE_MISC
+# define VDSUSP 11
+#endif
+#define VSTART 12
+#define VSTOP 13
+#define VLNEXT 14
+#define VDISCARD 15
+#define VMIN 16
+#define VTIME 17
+#ifdef __USE_MISC
+# define VSTATUS 18
+#endif
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IXON	0001000
+#define IXOFF	0002000
+#define IXANY	0004000
+#define IMAXBEL	0020000
+
+/* c_oflag bits */
+#define	OPOST	(1 << 0)	/* Perform output processing.  */
+#define	ONLCR	(1 << 1)	/* Map NL to CR-NL on output.  */
+#if defined __USE_MISC || defined __USE_XOPEN
+# define TAB0   (0 << 2)	/* no tab delay and expansion */
+# define TAB3   (1 << 2)	/* expand tabs to spaces */
+# define TABDLY	TAB3		/* tab delay mask */
+# define OXTABS	TAB3
+# define XTABS	TAB3
+#endif
+#ifdef	__USE_MISC
+# define ONOEOT	(1 << 3)	/* Discard EOT (^D) on output.  */
+#endif
+#define	OCRNL	(1 << 4)	/* map CR to NL on output */
+#define	ONOCR	(1 << 5)	/* no CR output at column 0 */
+#define	ONLRET	(1 << 6)	/* NL performs CR function */
+
+/* c_cflag bit meaning */
+#ifdef	__USE_MISC
+# define CIGNORE	(1 << 0)	/* Ignore these control flags.  */
+#endif
+#define	CSIZE	(CS5|CS6|CS7|CS8)	/* Number of bits per byte (mask).  */
+#define	CS5	(0 << 8)	/* 5 bits per byte.  */
+#define	CS6	(1 << 8)	/* 6 bits per byte.  */
+#define	CS7	(2 << 8)	/* 7 bits per byte.  */
+#define	CS8	(3 << 8)	/* 8 bits per byte.  */
+#define	CSTOPB	(1 << 10)	/* Two stop bits instead of one.  */
+#define	CREAD	(1 << 11)	/* Enable receiver.  */
+#define	PARENB	(1 << 12)	/* Parity enable.  */
+#define	PARODD	(1 << 13)	/* Odd parity instead of even.  */
+#define	HUPCL	(1 << 14)	/* Hang up on last close.  */
+#define	CLOCAL	(1 << 15)	/* Ignore modem status lines.  */
+#ifdef	__USE_MISC
+# define CCTS_OFLOW	(1 << 16)	/* CTS flow control of output.  */
+# define CRTS_IFLOW	(1 << 17)	/* RTS flow control of input.  */
+# define CRTSCTS	(CCTS_OFLOW|CRTS_IFLOW)	/* CTS/RTS flow control.  */
+# define CDTR_IFLOW	(1 << 18)	/* DTR flow control of input.  */
+# define CDSR_OFLOW	(1 << 19)	/* DSR flow control of output.  */
+# define CCAR_OFLOW	(1 << 20)	/* DCD flow control of output.  */
+# define MDMBUF		(1 << 20)	/* Carrier flow control of output.  */
+#endif
+
+/* c_lflag bits */
+#ifdef	__USE_MISC
+# define ECHOKE	(1 << 0)	/* Visual erase for KILL.  */
+#endif
+#define	ECHOE	(1 << 1)	/* Visual erase for ERASE.  */
+#define	ECHOK	(1 << 2)	/* Echo NL after KILL.  */
+#define	ECHO	(1 << 3)	/* Enable echo.  */
+#define	ECHONL	(1 << 4)	/* Echo NL even if ECHO is off.  */
+#ifdef	__USE_MISC
+# define ECHOPRT	(1 << 5)	/* Hardcopy visual erase.  */
+# define ECHOCTL	(1 << 6)	/* Echo control characters as ^X.  */
+#endif
+#define	ISIG	(1 << 7)	/* Enable signals.  */
+#define	ICANON	(1 << 8)	/* Do erase and kill processing.  */
+#ifdef	__USE_MISC
+# define ALTWERASE (1 << 9)	/* Alternate WERASE algorithm.  */
+#endif
+#define	IEXTEN	(1 << 10)	/* Enable DISCARD and LNEXT.  */
+#ifdef __USE_MISC
+# define EXTPROC (1 << 11)	/* External processing.  */
+#endif
+#define	TOSTOP	(1 << 22)	/* Send SIGTTOU for background output.  */
+#ifdef	__USE_MISC
+# define FLUSHO	(1 << 23)	/* Output being flushed (state).  */
+# define NOKERNINFO (1 << 25)	/* Disable VSTATUS.  */
+# define PENDIN	(1 << 29)	/* Retype pending input (state).  */
+#endif
+#define	NOFLSH	(1 << 31)	/* Disable flush after interrupt.  */
+
+  /* Input and output baud rates.  */
+#define	B0	0		/* Hang up.  */
+#define	B50	50		/* 50 baud.  */
+#define	B75	75		/* 75 baud.  */
+#define	B110	110		/* 110 baud.  */
+#define	B134	134		/* 134.5 baud.  */
+#define	B150	150		/* 150 baud.  */
+#define	B200	200		/* 200 baud.  */
+#define	B300	300		/* 300 baud.  */
+#define	B600	600		/* 600 baud.  */
+#define	B1200	1200		/* 1200 baud.  */
+#define	B1800	1800		/* 1800 baud.  */
+#define	B2400	2400		/* 2400 baud.  */
+#define	B4800	4800		/* 4800 baud.  */
+#define	B9600	9600		/* 9600 baud.  */
+#define	B19200	19200		/* 19200 baud.  */
+#define	B38400	38400		/* 38400 baud.  */
+#define B76800	76800
+#ifdef	__USE_MISC
+# define EXTA	19200
+# define EXTB	38400
+#endif
+#define B7200	7200
+#define B14400	14400
+#define B28800	28800
+#define	B57600	57600
+#define	B115200	115200
+#define	B230400	230400
+#define	B460800	460800
+#define	B500000	500000
+#define	B576000	576000
+#define	B921600	921600
+#define	B1000000 1000000
+#define	B1152000 1152000
+#define	B1500000 1500000
+#define	B2000000 2000000
+#define	B2500000 2500000
+#define	B3000000 3000000
+#define	B3500000 3500000
+#define	B4000000 4000000
+#define	__MAX_BAUD B4000000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		1
+#define	TCOON		2
+#define	TCIOFF		3
+#define	TCION		4
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	1
+#define	TCOFLUSH	2
+#define	TCIOFLUSH	3
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+#ifdef	__USE_MISC
+# define TCSASOFT	0x10	/* Flag: Don't alter hardware state.  */
+#endif
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/time.h
@@ -0,0 +1,103 @@
+/* System-dependent timing definitions.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <time.h> instead.
+ */
+
+#ifndef __need_timeval
+# ifndef _BITS_TIME_H
+#  define _BITS_TIME_H	1
+
+/* ISO/IEC 9899:1990 7.12.1: <time.h>
+   The macro `CLOCKS_PER_SEC' is the number per second of the value
+   returned by the `clock' function. */
+/* CAE XSH, Issue 4, Version 2: <time.h>
+   The value of CLOCKS_PER_SEC is required to be 1 million on all
+   XSI-conformant systems. */
+#  define CLOCKS_PER_SEC  ((clock_t) 1000000l)
+
+#  if (!defined __STRICT_ANSI__ || defined __USE_POSIX) \
+   && !defined __USE_XOPEN2K
+/* Even though CLOCKS_PER_SEC has such a strange value CLK_TCK
+   presents the real value for clock ticks per second for the system.  */
+#   define CLK_TCK 128
+#  endif
+
+#  ifdef __USE_POSIX199309
+/* Identifier for system-wide realtime clock.  */
+#   define CLOCK_REALTIME		0
+/* Monotonic system-wide clock.  */
+#   define CLOCK_MONOTONIC		4
+/* These are BSD specific clocks.  */
+#   ifdef __USE_MISC
+#    define CLOCK_VIRTUAL		1
+#    define CLOCK_PROF			2
+#    define CLOCK_UPTIME    5               /* FreeBSD-specific. */
+#    define CLOCK_UPTIME_PRECISE    7       /* FreeBSD-specific. */
+#    define CLOCK_UPTIME_FAST       8       /* FreeBSD-specific. */
+#    define CLOCK_REALTIME_PRECISE  9       /* FreeBSD-specific. */
+#    define CLOCK_REALTIME_FAST     10      /* FreeBSD-specific. */
+#    define CLOCK_MONOTONIC_PRECISE 11      /* FreeBSD-specific. */
+#    define CLOCK_MONOTONIC_FAST    12      /* FreeBSD-specific. */
+#    define CLOCK_SECOND    13              /* FreeBSD-specific. */
+#   endif
+/* Thread-specific CPU-time clock.  */
+#   define CLOCK_THREAD_CPUTIME_ID	14
+/* High-resolution timer from the CPU.  */
+#   define CLOCK_PROCESS_CPUTIME_ID	15
+#   ifdef __USE_MISC
+#     define CPUCLOCK_WHICH_PID 0
+#     define CPUCLOCK_WHICH_TID 1
+#   endif
+
+/* Flag to indicate time is absolute.  */
+#   define TIMER_RELTIME	0   /* relative timer */
+#   define TIMER_ABSTIME	1   /* absolute timer */
+#  endif
+
+
+/* Getkerninfo clock information structure */
+struct clockinfo
+  {
+    int hz;		/* clock frequency */
+    int tick;		/* micro-seconds per hz tick */
+    int spare;
+    int stathz;		/* statistics clock frequency */
+    int profhz;		/* profiling clock frequency */
+  };
+
+# endif	/* bits/time.h */
+#endif
+
+#ifdef __need_timeval
+# undef __need_timeval
+# ifndef _STRUCT_TIMEVAL
+#  define _STRUCT_TIMEVAL	1
+#  include <bits/types.h>
+
+/* A time value that is accurate to the nearest
+   microsecond but also has a range of years.  */
+struct timeval
+  {
+    __time_t tv_sec;		/* Seconds.  */
+    __suseconds_t tv_usec;	/* Microseconds.  */
+  };
+# endif	/* struct timeval */
+#endif	/* need timeval */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/typesizes.h
@@ -0,0 +1,91 @@
+/* bits/typesizes.h -- underlying types for *_t.  kFreeBSD version.
+   Copyright (C) 2002, 2003, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U16_TYPE
+#define __NLINK_T_TYPE		__U16_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__SQUAD_TYPE
+#define __RLIM64_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__S32_TYPE
+#define	__FSWORD_T_TYPE		__SWORD_TYPE
+
+/*
+ * This one is a bit tricky.  It needs to match the size
+ * in the sys/${arch}/include/_types.h typedefs.
+ *
+ * However, for i386 and amd64 we started with __SLONGWORD_TYPE
+ * and we need to maintain ABI.  Even if size is the same, using
+ * a different type may affect C++ ABI (this distinction is
+ * necessary to implement function overload), so it must stay
+ * with __SLONGWORD_TYPE.
+ */
+#if defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#else
+#define __TIME_T_TYPE		__S64_TYPE
+#endif
+
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__SQUAD_TYPE
+#define __SWBLK_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__SLONGWORD_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		union { int __val[2]; int val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
+
+/* Tell the libc code that off_t and off64_t are actually the same type
+   for all ABI purposes, even if possibly expressed as different base types
+   for C type-checking purposes.  */
+#define __OFF_T_MATCHES_OFF64_T 1
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/uio.h
@@ -0,0 +1,55 @@
+/* Copyright (C) 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UIO_H && !defined _FCNTL_H
+# error "Never include <bits/uio.h> directly; use <sys/uio.h> instead."
+#endif
+
+#ifndef _BITS_UIO_H
+#define _BITS_UIO_H     1
+
+#include <sys/types.h>
+
+
+/* `struct iovec' -- Structure describing a section of memory.  */
+
+struct iovec
+{
+  /* Starting address.  */
+  __ptr_t iov_base;
+  /* Length in bytes.  */
+  size_t iov_len;
+};
+
+/* Maximum number of 'struct iovec's that can be passed to a readv() or
+   writev() system call.  For larger arrays of 'struct iovec', the libc
+   uses a single read() or write() call to guarantee atomicity.  */
+#define UIO_MAXIOV	1024
+
+#ifdef __USE_MISC
+enum    uio_rw { UIO_READ, UIO_WRITE };
+
+/* Segment flag values. */
+enum uio_seg {
+        UIO_USERSPACE,          /* from user data space */
+        UIO_SYSSPACE,           /* from system space */
+        UIO_NOCOPY              /* don't copy, already in object */
+};
+#endif
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/utsname.h
@@ -0,0 +1,31 @@
+/* Copyright (C) 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_UTSNAME_H
+# error "Never include <bits/utsname.h> directly; use <sys/utsname.h> instead."
+#endif
+
+/* Length of the entries in 'struct utsname' is 32.  */
+#define _UTSNAME_LENGTH 32
+
+/* But the version entry is longer.  */
+#define _UTSNAME_VERSION_LENGTH 256
+
+/* If nonzero, the size of of the `domainname` field in `struct utsname'.
+   This is zero to indicate that there should be no such field at all.  */
+#define _UTSNAME_DOMAIN_LENGTH  0
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitflags.h
@@ -0,0 +1,82 @@
+/* Definitions of flag bits for `waitpid' et al.
+   Copyright (C) 1992, 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitflags.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* Bits in the third argument to `waitpid'.  */
+#define	WNOHANG		1	/* Don't block waiting.  */
+#define	WUNTRACED	2	/* Report status of stopped children.  */
+
+/* Bits in the fourth argument to `waitid'.  */
+#define	WSTOPPED	2	/* Report stopped child (same as WUNTRACED). */
+#define	WCONTINUED	4	/* Report continued child.  */
+#define	WNOWAIT		8	/* Poll only. Don't delete the proc entry. */
+#define WEXITED         16      /* Wait for exited processes. */
+#define WTRAPPED        32      /* Wait for a process to hit a trap or
+                                   a breakpoint. */
+                                   
+#define __WCLONE	0x80000000	/* Wait for cloned process.  */
+#ifdef __USE_MISC
+# define WLINUXCLONE	__WCLONE	/* FreeBSD name for __WCLONE.  */
+#endif
+
+
+/* The following values are used by the `waitid' function.  */
+#if defined __USE_MISC || defined __USE_XOPEN || defined __USE_XOPEN2K8
+# ifndef __ENUM_IDTYPE_T
+# define __ENUM_IDTYPE_T 1
+
+typedef enum
+{
+        /*
+         * These names were mostly lifted from Solaris source code and
+         * still use Solaris style naming to avoid breaking any
+         * OpenSolaris code which has been ported to FreeBSD.  There
+         * is no clear FreeBSD counterpart for all of the names, but
+         * some have a clear correspondence to FreeBSD entities.
+         *
+         * The numerical values are kept synchronized with the Solaris
+         * values.
+         */
+        P_PID,                  /* A process identifier. */
+        P_PPID,                 /* A parent process identifier. */
+        P_PGID,                 /* A process group identifier. */
+        P_SID,                  /* A session identifier. */
+        P_CID,                  /* A scheduling class identifier. */
+        P_UID,                  /* A user identifier. */
+        P_GID,                  /* A group identifier. */
+        P_ALL,                  /* All processes. */
+        P_LWPID,                /* An LWP identifier. */
+        P_TASKID,               /* A task identifier. */
+        P_PROJID,               /* A project identifier. */
+        P_POOLID,               /* A pool identifier. */
+        P_JAILID,               /* A zone identifier. */
+        P_CTID,                 /* A (process) contract identifier. */
+        P_CPUID,                /* CPU identifier. */
+        P_PSETID                /* Processor set identifier. */
+} idtype_t;                     /* The type of id_t we are using. */
+
+#  if defined __USE_MISC
+#  define P_ZONEID        P_JAILID
+#  endif
+# endif
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/bits/waitstatus.h
@@ -0,0 +1,102 @@
+/* Definitions of status bits for `wait' et al.
+   Copyright (C) 1992,1994,1996,1997,2000,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_WAIT_H && !defined _STDLIB_H
+# error "Never include <bits/waitstatus.h> directly; use <sys/wait.h> instead."
+#endif
+
+
+/* If WIFEXITED(STATUS), the low-order 8 bits of the status.  */
+#define	__WEXITSTATUS(status)	(((status) & 0xff00) >> 8)
+
+/* If WIFSIGNALED(STATUS), the terminating signal.  */
+#define	__WTERMSIG(status)	((status) & 0x7f)
+
+/* If WIFSTOPPED(STATUS), the signal that stopped the child.  */
+#define	__WSTOPSIG(status)	__WEXITSTATUS(status)
+
+/* Nonzero if STATUS indicates normal termination.  */
+#define	__WIFEXITED(status)	(__WTERMSIG(status) == 0)
+
+/* Nonzero if STATUS indicates the child is stopped.  */
+#define	__WIFSTOPPED(status)	(((status) & 0x7f) == 0x7f)
+
+/* Linux uses 0xffff, BSD uses SIGCONT */
+#define __W_CONTINUED		0x13
+#define	__WCOREFLAG		0x80
+/* Nonzero if STATUS indicates the child continued after a stop. */
+#define __WIFCONTINUED(status)	((status) == __W_CONTINUED)
+
+/* Nonzero if STATUS indicates the child dumped core.  */
+#define	__WCOREDUMP(status)	((status) & __WCOREFLAG)
+
+/* Nonzero if STATUS indicates termination by a signal.  */
+#define __WIFSIGNALED(status) \
+  (!__WIFSTOPPED(status) && !__WIFEXITED(status) && !__WIFCONTINUED(status))
+
+/* Macros for constructing status values.  */
+#define	__W_EXITCODE(ret, sig)	((ret) << 8 | (sig))
+#define	__W_STOPCODE(sig)	((sig) << 8 | 0x7f)
+
+
+
+#ifdef	__USE_MISC
+
+# include <endian.h>
+
+union wait
+  {
+    int w_status;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_termsig:7; /* Terminating signal.  */
+	unsigned int __w_coredump:1; /* Set if dumped core.  */
+	unsigned int __w_retcode:8; /* Return code if exited normally.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_retcode:8;
+	unsigned int __w_coredump:1;
+	unsigned int __w_termsig:7;
+# endif				/* Big endian.  */
+      } __wait_terminated;
+    struct
+      {
+# if	__BYTE_ORDER == __LITTLE_ENDIAN
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int:16;
+# endif				/* Little endian.  */
+# if	__BYTE_ORDER == __BIG_ENDIAN
+	unsigned int:16;
+	unsigned int __w_stopsig:8; /* Stopping signal.  */
+	unsigned int __w_stopval:8; /* W_STOPPED if stopped.  */
+# endif				/* Big endian.  */
+      } __wait_stopped;
+  };
+
+# define w_termsig	__wait_terminated.__w_termsig
+# define w_coredump	__wait_terminated.__w_coredump
+# define w_retcode	__wait_terminated.__w_retcode
+# define w_stopsig	__wait_stopped.__w_stopsig
+# define w_stopval	__wait_stopped.__w_stopval
+
+#endif	/* Use BSD.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/brk.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2004, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <unistd.h>
+#include <sysdep.h>
+
+extern int __syscall_obreak (void *addr);
+libc_hidden_proto (__syscall_obreak)
+
+extern char _end[];
+
+/* sbrk.c expects this.  */
+void *__curbrk = _end;
+
+/* Set the end of the process's data space to ADDR.
+   Return 0 if successful, -1 if not.  */
+int
+__brk (void *addr)
+{
+  if ((char*)addr < _end)
+    return 0;
+
+  if (INLINE_SYSCALL (obreak, 1, addr) == -1)
+    {
+      __set_errno (ENOMEM);
+      return -1;
+    }
+
+  __curbrk = addr;
+  return 0;
+}
+weak_alias (__brk, brk)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_fds.c
@@ -0,0 +1 @@
+void __libc_check_standard_fds (void) {;}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_native.c
@@ -0,0 +1,42 @@
+/* Determine whether interfaces use native transport.  Dummy version.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <ifaddrs.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <net/if_arp.h>
+#include <sys/ioctl.h>
+
+#include <not-cancel.h>
+
+
+void
+__check_native (uint32_t a1_index, int *a1_native,
+		uint32_t a2_index, int *a2_native)
+{
+
+#warning __check_native() not yet implemented
+  return;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/check_pf.c
@@ -0,0 +1 @@
+#include <inet/check_pf.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock.c
@@ -0,0 +1,44 @@
+/* Copyright (C) 1991, 1997, 1998, 1999 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/resource.h>
+#include <sys/time.h>
+#include <time.h>
+
+#ifdef	__GNUC__
+__inline
+#endif
+static clock_t
+timeval_to_clock_t (const struct timeval *tv)
+{
+  return (clock_t) ((tv->tv_sec * CLOCKS_PER_SEC) +
+		    (tv->tv_usec * CLOCKS_PER_SEC / 1000000));
+}
+
+/* Return the time used by the program so far (user time + system time).  */
+clock_t
+clock (void)
+{
+  struct rusage usage;
+
+  if (__getrusage (RUSAGE_SELF, &usage) < 0)
+    return (clock_t) -1;
+
+  return (timeval_to_clock_t (&usage.ru_stime) +
+	  timeval_to_clock_t (&usage.ru_utime));
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_getres.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+int __syscall_clock_getres(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_getres)
+
+# define SYSDEP_GETRES \
+	case CLOCK_REALTIME:		\
+	case CLOCK_VIRTUAL:		\
+	case CLOCK_PROF:		\
+	case CLOCK_MONOTONIC:		\
+	case CLOCK_UPTIME:		\
+	case CLOCK_UPTIME_PRECISE:	\
+	case CLOCK_UPTIME_FAST:		\
+	case CLOCK_REALTIME_PRECISE:	\
+	case CLOCK_REALTIME_FAST:	\
+	case CLOCK_MONOTONIC_PRECISE:	\
+	case CLOCK_MONOTONIC_FAST:	\
+	case CLOCK_SECOND:		\
+    retval = INLINE_SYSCALL (clock_getres, 2, clock_id, res);		      \
+    break
+
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+
+#include <sysdeps/posix/clock_getres.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_gettime.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "kernel-posix-cpu-timers.h"
+
+int __syscall_clock_gettime(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_gettime)
+
+# define SYSDEP_GETTIME \
+	case CLOCK_REALTIME:		\
+	case CLOCK_VIRTUAL:		\
+	case CLOCK_PROF:		\
+	case CLOCK_MONOTONIC:		\
+	case CLOCK_UPTIME:		\
+	case CLOCK_UPTIME_PRECISE:	\
+	case CLOCK_UPTIME_FAST:		\
+	case CLOCK_REALTIME_PRECISE:	\
+	case CLOCK_REALTIME_FAST:	\
+	case CLOCK_MONOTONIC_PRECISE:	\
+	case CLOCK_MONOTONIC_FAST:	\
+	case CLOCK_SECOND:		\
+    retval = INLINE_SYSCALL (clock_gettime, 2, clock_id, tp);		      \
+    break
+
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+#include <sysdeps/unix/clock_gettime.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/clock_settime.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include "kernel-posix-cpu-timers.h"
+
+int __syscall_clock_settime(clockid_t clock_id, const struct timespec *tp);
+libc_hidden_proto (__syscall_clock_settime)
+
+# define SYSDEP_SETTIME \
+  case CLOCK_REALTIME:							      \
+    retval = INLINE_SYSCALL (clock_settime, 2, clock_id, tp);		      \
+    break
+/* We handled the REALTIME clock here.  */
+# define HANDLED_REALTIME	1
+
+#include <sysdeps/unix/clock_settime.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/clone.c
@@ -0,0 +1,122 @@
+/* Create a thread.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __clone __no_broken_clone_decl
+#include <sched.h>
+#include <sys/rfork.h>
+#include <errno.h>
+#include <signal.h>
+#include <stddef.h>
+#include <getosreldate.h>
+#undef __clone
+
+/* __start_thread (flags, child_stack, fn, arg)
+   is roughly equivalent to
+
+     int retval = __rfork (flags);
+     if (retval == 0)
+       {
+         // Here we are in the child thread.
+         %stackpointer = child_stack;
+         _exit (fn (arg));
+       }
+     return retval;
+
+   but it cannot be done in portable C because it must access fn and arg
+   after having replaced the stack pointer.  */
+
+extern int __start_thread (int flags, void *child_stack,
+			   int (*fn) (void *), void *arg);
+
+int __clone (int (*fn) (void *), void *child_stack, int flags, void *arg)
+{
+  int rfork_flags = RFPROC;
+
+  if (fn == NULL || child_stack == NULL)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* This implementation of clone() does not support all Linux flags.  */
+  if (flags & ~(CSIGNAL | CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND
+		| CLONE_VFORK | CLONE_SYSVSEM))
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  if ((flags & CSIGNAL) != SIGCHLD)
+  {
+    if (__kernel_getosreldate() >= 802510)
+                /* we slightly cheat here, */
+                /* the 9.x snapshot prior to r223966 does not support it too */
+    {
+      if ((flags & CSIGNAL) & ~RFTSIGMASK)
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+        rfork_flags |= (RFTSIGZMB | RFTSIGFLAGS(flags & CSIGNAL));
+    }
+    else
+    {
+      if ((flags & CSIGNAL) & ~RFTHPNMASK)
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+      if ((flags & CSIGNAL) == 0)
+        rfork_flags |= (RFLINUXTHPN | ((SIGCHLD) <<  RFTHPNSHIFT));
+      else
+        rfork_flags |= (RFLINUXTHPN | ((flags & CSIGNAL) <<  RFTHPNSHIFT));
+    }
+  } 
+  if (flags & CLONE_VM)
+    rfork_flags |= RFMEM;
+
+  if (flags & CLONE_FS)
+    /* Sharing the filesystem related info (umask, cwd, root dir)
+       is not supported by rfork.  Ignore this; let's hope programs
+       will set their umask and cwd before spawning threads.  */
+    ;
+
+  if (flags & CLONE_SYSVSEM)
+    /* Ignore this; it has been introduced into linuxthreads in post 2.4 glibc */
+    ;
+
+  if (!(flags & CLONE_FILES))
+    rfork_flags |= RFFDG;
+
+  if (flags & CLONE_SIGHAND)
+    {
+      rfork_flags |= RFSIGSHARE;
+      /* Also set the undocumented flag RFTHREAD.  It has the effect that when
+	 the thread leader exits, all threads belonging to it are killed.  */
+      rfork_flags |= RFTHREAD;
+    }
+
+  if (flags & CLONE_VFORK)
+    rfork_flags |= RFPPWAIT;
+
+  return __start_thread (rfork_flags, child_stack, fn, arg);
+}
+
+weak_alias (__clone, clone)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/configure
@@ -0,0 +1,423 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+ # Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
+
+# The kFreeBSD headers can be found in
+#   /usr/src/sys/
+# Check whether this directory is available.
+if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
+   test -d /usr/src/sys/ ; then
+  sysheaders="/usr/src/sys/"
+  ccheaders=`$CC -print-file-name=include`
+      SYSINCLUDES="-I $sysheaders"
+fi
+
+# Don't bother trying to generate any glue code to be compatible with the
+# existing system library, because we are the only system library.
+inhibit_glue=yes
+
+if test -n "$sysheaders"; then
+  OLD_CPPFLAGS=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for grep that handles long lines and -e" >&5
+$as_echo_n "checking for grep that handles long lines and -e... " >&6; }
+if test "${ac_cv_path_GREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$GREP"; then
+  ac_path_GREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in grep ggrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_GREP" && $as_test_x "$ac_path_GREP"; } || continue
+# Check for GNU ac_path_GREP and select it if it is found.
+  # Check for GNU $ac_path_GREP
+case `"$ac_path_GREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'GREP' >> "conftest.nl"
+    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_GREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_GREP="$ac_path_GREP"
+      ac_path_GREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_GREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_GREP"; then
+    as_fn_error "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_GREP=$GREP
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_GREP" >&5
+$as_echo "$ac_cv_path_GREP" >&6; }
+ GREP="$ac_cv_path_GREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for egrep" >&5
+$as_echo_n "checking for egrep... " >&6; }
+if test "${ac_cv_path_EGREP+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
+   then ac_cv_path_EGREP="$GREP -E"
+   else
+     if test -z "$EGREP"; then
+  ac_path_EGREP_found=false
+  # Loop through the user's path and test for each of PROGNAME-LIST
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in egrep; do
+    for ac_exec_ext in '' $ac_executable_extensions; do
+      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
+      { test -f "$ac_path_EGREP" && $as_test_x "$ac_path_EGREP"; } || continue
+# Check for GNU ac_path_EGREP and select it if it is found.
+  # Check for GNU $ac_path_EGREP
+case `"$ac_path_EGREP" --version 2>&1` in
+*GNU*)
+  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
+*)
+  ac_count=0
+  $as_echo_n 0123456789 >"conftest.in"
+  while :
+  do
+    cat "conftest.in" "conftest.in" >"conftest.tmp"
+    mv "conftest.tmp" "conftest.in"
+    cp "conftest.in" "conftest.nl"
+    $as_echo 'EGREP' >> "conftest.nl"
+    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
+    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
+    as_fn_arith $ac_count + 1 && ac_count=$as_val
+    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
+      # Best one so far, save it but keep looking for a better one
+      ac_cv_path_EGREP="$ac_path_EGREP"
+      ac_path_EGREP_max=$ac_count
+    fi
+    # 10*(2^10) chars as input seems more than enough
+    test $ac_count -gt 10 && break
+  done
+  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
+esac
+
+      $ac_path_EGREP_found && break 3
+    done
+  done
+  done
+IFS=$as_save_IFS
+  if test -z "$ac_cv_path_EGREP"; then
+    as_fn_error "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
+  fi
+else
+  ac_cv_path_EGREP=$EGREP
+fi
+
+   fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_path_EGREP" >&5
+$as_echo "$ac_cv_path_EGREP" >&6; }
+ EGREP="$ac_cv_path_EGREP"
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking installed kFreeBSD kernel header files" >&5
+$as_echo_n "checking installed kFreeBSD kernel header files... " >&6; }
+if test "${libc_cv_kfreebsd830+set}" = set; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version <  (8 *100000+ 3 *1000+ 0) /* 8.3.0 */
+eat flaming death
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "eat flaming death" >/dev/null 2>&1; then :
+  libc_cv_kfreebsd830='TOO OLD!'
+else
+  libc_cv_kfreebsd830='8.3.0 or later'
+fi
+rm -f conftest*
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_cv_kfreebsd830" >&5
+$as_echo "$libc_cv_kfreebsd830" >&6; }
+if test "$libc_cv_kfreebsd830" != '8.3.0 or later'; then
+  as_fn_error "GNU libc requires kernel header files from
+kFreeBSD 8.3.0 or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD 8.3.0 or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers." "$LINENO" 5
+fi
+
+# Check whether --enable-compatible-utmp was given.
+if test "${enable_compatible_utmp+set}" = set; then :
+  enableval=$enable_compatible_utmp; enable_utmp_compat=$enableval
+else
+  enable_utmp_compat=no
+fi
+
+if test "$enable_utmp_compat" = no; then
+  utmp_subdir=utmp-utmpx
+else
+  utmp_subdir=utmp-compat
+fi
+sysnames="$sysnames sysdeps/unix/bsd/bsd4.4/kfreebsd/$utmp_subdir"
+
+# If the user gave a minimal version number test whether the available
+# kernel headers are young enough.  Additionally we have minimal
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
+case "$machine" in
+  i386*)
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=8.3.0
+    ;;
+  x86_64*)
+    arch_minimum_kernel=8.3.0
+    ;;
+  *)
+    arch_minimum_kernel=8.3.0
+    ;;
+esac
+if test -n "$minimum_kernel"; then
+
+  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+
+  if test $user_version -lt $arch_version; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&5
+$as_echo "$as_me: WARNING: minimum kernel version reset to $arch_minimum_kernel" >&2;}
+    minimum_kernel=$arch_minimum_kernel
+  fi
+else
+  if test $arch_minimum_kernel != '8.3.0'; then
+    minimum_kernel=$arch_minimum_kernel
+  fi
+fi
+
+if test -n "$minimum_kernel"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for kernel header at least $minimum_kernel" >&5
+$as_echo_n "checking for kernel header at least $minimum_kernel... " >&6; }
+  hdrnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 100000 + \2 * 1000 + \3)/'`;
+  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 65536 + \2 * 256 + \3)/'`;
+  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if __FreeBSD_kernel_version < $hdrnum
+eat flaming death
+#endif
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "eat flaming death" >/dev/null 2>&1; then :
+  libc_minimum_kernel='too old!'
+else
+  libc_minimum_kernel=ok
+fi
+rm -f conftest*
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $libc_minimum_kernel" >&5
+$as_echo "$libc_minimum_kernel" >&6; }
+  if test "$libc_minimum_kernel" = ok; then
+    cat >>confdefs.h <<_ACEOF
+#define __KFREEBSD_KERNEL_VERSION $decnum
+_ACEOF
+
+    cat >>confdefs.h <<_ACEOF
+#define __ABI_TAG_VERSION $abinum
+_ACEOF
+
+  else
+    as_fn_error "*** The available kernel headers are older than the requested
+*** compatible kernel version" "$LINENO" 5
+  fi
+fi
+
+if test -n "$sysheaders"; then
+  CPPFLAGS=$OLD_CPPFLAGS
+fi
+# The Linux filesystem standard prescribes where to place "essential"
+# files.  I.e., when the installation prefix is "/usr" we have to place
+# shared library objects and the configuration files on the root partition
+# in /lib and /etc.
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_complocaledir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_complocaledir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+  # Allow the user to override the path with --sysconfdir
+  if test $sysconfdir = '${prefix}/etc'; then
+    libc_cv_sysconfdir=/etc
+  else
+    libc_cv_sysconfdir=$sysconfdir
+   fi
+  libc_cv_rootsbindir="/sbin"
+  ;;
+esac
+
+
+# Put exception handling support into libc, so that not every shared
+# library needs to include it.
+# FIXME: Does not work yet.
+libc_cv_gcc_unwind_find_fde=no
+
+
+# Under kFreeBSD the FBTL add-on should be available.
+case $add_ons in
+  # It is available.  Good.
+  *fbtl*)
+    fbtl_missing=
+    ;;
+  *)
+    fbtl_missing=yes
+    ;;
+esac
+
+if test "$fbtl_missing"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
+*** \`fbtl' add-on.  Without that, the library will be
+*** incompatible with normal GNU/kFreeBSD systems.
+*** If you really mean to not use this add-on, run configure again
+*** using the extra parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Are you sure you do not want to use the \`fbtl'
+*** add-on?"
+  fi
+fi
+
+if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
+*** /usr/local since this might make your system totally unusable.
+*** We strongly advise to use a different prefix.  For details read the FAQ.
+*** If you really mean to do this, run configure again using the extra
+*** parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Do you really want to install the GNU C Library into /usr/local?
+*** This might make your system totally unusable, for details read the FAQ."
+  fi
+fi
+
+
+# One kFreeBSD we use ldconfig.
+use_ldconfig=yes
+
+# We need some extensions to the `ldd' script.
+
+case "$machine" in
+  x86_64*)
+    ldd_rewrite_script=$dir/x86_64/ldd-rewrite.sed
+    ;;
+  *)
+    ;;
+esac
+
+
+if test $host = $build; then
+  # If $prefix/include/{net,scsi} are symlinks, make install will
+  # clobber what they're linked to (probably a kernel tree).
+  # test -L ought to work on all Linux boxes.
+  if test "x$prefix" != xNONE; then
+    ac_prefix=$prefix
+  else
+    ac_prefix=$ac_default_prefix
+  fi
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for symlinks in ${ac_prefix}/include" >&5
+$as_echo_n "checking for symlinks in ${ac_prefix}/include... " >&6; }
+  ac_message=
+  if test -L ${ac_prefix}/include/net; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/net is a symlink"
+  fi
+  if test -L ${ac_prefix}/include/scsi; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/scsi is a symlink"
+  fi
+  if test -n "$ac_message"; then
+    as_fn_error "$ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way." "$LINENO" 5
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: ok" >&5
+$as_echo "ok" >&6; }
+  fi
+fi
+
+# We support internal syscalls.
+# It is advertised as inlined syscalls availability ...
+$as_echo "#define HAVE_INLINED_SYSCALLS 1" >>confdefs.h
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/configure.in
@@ -0,0 +1,258 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/bsd/bsd4.4/kfreebsd.
+
+# The kFreeBSD headers can be found in
+#   /usr/src/sys/
+# Check whether this directory is available.
+if test -z "$sysheaders" &&
+   test "x$cross_compiling" = xno &&
+   test -d /usr/src/sys/ ; then
+  sysheaders="/usr/src/sys/"
+  ccheaders=`$CC -print-file-name=include`
+  dnl We don't have to use -nostdinc.  We just want one more directory
+  dnl to be used.
+  SYSINCLUDES="-I $sysheaders"
+fi
+
+# Don't bother trying to generate any glue code to be compatible with the
+# existing system library, because we are the only system library.
+inhibit_glue=yes
+
+define([LIBC_KFREEBSD_VERSION],[8.3.0])dnl
+if test -n "$sysheaders"; then
+  OLD_CPPFLAGS=$CPPFLAGS
+  CPPFLAGS="$CPPFLAGS $SYSINCLUDES"
+fi
+define([libc_cv_kfreebsdVER], [libc_cv_kfreebsd]patsubst(LIBC_KFREEBSD_VERSION,[\.]))dnl
+AC_CACHE_CHECK(installed kFreeBSD kernel header files, libc_cv_kfreebsdVER, [dnl
+AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if !defined __FreeBSD_kernel_version || __FreeBSD_kernel_version < ]dnl
+patsubst(LIBC_KFREEBSD_VERSION,[^\([^.]*\)\.\([^.]*\)\.\([^.]*\)$],dnl
+[ (\1 *100000+ \2 *1000+ \3) /* \1.\2.\3 */])[
+eat flaming death
+#endif],
+	     libc_cv_kfreebsdVER='TOO OLD!',
+	     libc_cv_kfreebsdVER='LIBC_KFREEBSD_VERSION or later')])
+if test "$libc_cv_kfreebsdVER" != 'LIBC_KFREEBSD_VERSION or later'; then
+  AC_MSG_ERROR([GNU libc requires kernel header files from
+kFreeBSD LIBC_KFREEBSD_VERSION or later to be installed before configuring.
+The kernel header files are found usually in /usr/src/sys/; make sure
+these directories use files from kFreeBSD LIBC_KFREEBSD_VERSION or later.
+This check uses <osreldate.h>, so
+make sure that file was built correctly when installing the kernel header
+files.  To use kernel headers not from /usr/src/sys/, use the
+configure option --with-headers.])
+fi
+
+AC_ARG_ENABLE([compatible-utmp],
+	AC_HELP_STRING([--disable-compatible-utmp],
+		[use a struct utmp which is the same as struct utmpx, as on kFreeBSD, but incompatible with FreeBSD]),
+	[enable_utmp_compat=$enableval],
+	[enable_utmp_compat=no])
+if test "$enable_utmp_compat" = no; then
+  utmp_subdir=utmp-utmpx
+else
+  utmp_subdir=utmp-compat
+fi
+sysnames="$sysnames sysdeps/unix/bsd/bsd4.4/kfreebsd/$utmp_subdir"
+
+# If the user gave a minimal version number test whether the available
+# kernel headers are young enough.  Additionally we have minimal
+# kernel versions for some architectures.  If a previous configure fragment
+# set arch_minimum_kernel already, let that override our defaults here.
+# Note that we presume such a fragment has set libc_cv_gcc_unwind_find_fde
+# if appropriate too.
+test -n "$arch_minimum_kernel" ||
+case "$machine" in
+  i386*)
+    libc_cv_gcc_unwind_find_fde=yes
+    arch_minimum_kernel=8.3.0
+    ;;
+  x86_64*)
+    arch_minimum_kernel=8.3.0
+    ;;
+  *)
+    arch_minimum_kernel=8.3.0
+    ;;
+esac
+if test -n "$minimum_kernel"; then
+  changequote(,)
+  user_version=$((`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+  arch_version=$((`echo "$arch_minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1 \* 65536 + \2 \* 256 + \3/'`))
+  changequote([,])
+  if test $user_version -lt $arch_version; then
+    AC_MSG_WARN([minimum kernel version reset to $arch_minimum_kernel])
+    minimum_kernel=$arch_minimum_kernel
+  fi
+else
+  if test $arch_minimum_kernel != '8.3.0'; then
+    minimum_kernel=$arch_minimum_kernel
+  fi
+fi
+
+if test -n "$minimum_kernel"; then
+  AC_MSG_CHECKING(for kernel header at least $minimum_kernel)
+changequote(,)dnl
+  hdrnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 100000 + \2 * 1000 + \3)/'`;
+  decnum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/(\1 * 65536 + \2 * 256 + \3)/'`;
+  abinum=`echo "$minimum_kernel.0.0.0" | sed 's/\([0-9]*\)\.\([0-9]*\)\.\([0-9]*\).*/\1,\2,\3/'`;
+changequote([,])dnl
+  AC_EGREP_CPP([eat flaming death], [#include <osreldate.h>
+#if !defined(__FreeBSD_kernel_version) && defined(__FreeBSD_version)
+#define __FreeBSD_kernel_version __FreeBSD_version
+#endif
+#if __FreeBSD_kernel_version < $hdrnum
+eat flaming death
+#endif], libc_minimum_kernel='too old!', libc_minimum_kernel=ok)
+  AC_MSG_RESULT($libc_minimum_kernel)
+  if test "$libc_minimum_kernel" = ok; then
+    AC_DEFINE_UNQUOTED(__KFREEBSD_KERNEL_VERSION, $decnum)
+    AC_DEFINE_UNQUOTED(__ABI_TAG_VERSION, $abinum)
+  else
+    AC_MSG_ERROR([*** The available kernel headers are older than the requested
+*** compatible kernel version])
+  fi
+fi
+
+if test -n "$sysheaders"; then
+  CPPFLAGS=$OLD_CPPFLAGS
+fi
+# The Linux filesystem standard prescribes where to place "essential"
+# files.  I.e., when the installation prefix is "/usr" we have to place
+# shared library objects and the configuration files on the root partition
+# in /lib and /etc.
+case "$prefix" in
+/usr | /usr/)
+  # 64-bit libraries on bi-arch platforms go in /lib64 instead of /lib
+  case $machine in
+  sparc/sparc64 | x86_64 | powerpc/powerpc64 | s390/s390-64 | \
+  mips/mips64/n64/* )
+    libc_cv_slibdir="/lib64"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib64';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  mips/mips64/n32/* )
+    libc_cv_slibdir="/lib32"
+    if test "$libdir" = '${exec_prefix}/lib'; then
+      libdir='${exec_prefix}/lib32';
+      # Locale data can be shared between 32bit and 64bit libraries
+      libc_cv_localedir='${exec_prefix}/lib/locale'
+    fi
+    ;;
+  *)
+    libc_cv_slibdir="/lib"
+    ;;
+  esac
+  # Allow the user to override the path with --sysconfdir
+  if test $sysconfdir = '${prefix}/etc'; then
+    libc_cv_sysconfdir=/etc
+  else
+    libc_cv_sysconfdir=$sysconfdir
+   fi
+  libc_cv_rootsbindir="/sbin"
+  ;;
+esac
+
+
+# Put exception handling support into libc, so that not every shared
+# library needs to include it.
+# FIXME: Does not work yet.
+libc_cv_gcc_unwind_find_fde=no
+
+
+# Under kFreeBSD the FBTL add-on should be available.
+case $add_ons in
+  # It is available.  Good.
+  *fbtl*)
+    fbtl_missing=
+    ;;
+  *)
+    fbtl_missing=yes
+    ;;
+esac
+
+if test "$fbtl_missing"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems it is normal to compile GNU libc with the
+*** \`fbtl' add-on.  Without that, the library will be
+*** incompatible with normal GNU/kFreeBSD systems.
+*** If you really mean to not use this add-on, run configure again
+*** using the extra parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Are you sure you do not want to use the \`fbtl'
+*** add-on?"
+  fi
+fi
+
+if test "$prefix" = "/usr/local" -o "$prefix" = "/usr/local/" -o "$prefix" = "NONE"; then
+  if test $enable_sanity = yes; then
+    echo "\
+*** On GNU/kFreeBSD systems the GNU C Library should not be installed into
+*** /usr/local since this might make your system totally unusable.
+*** We strongly advise to use a different prefix.  For details read the FAQ.
+*** If you really mean to do this, run configure again using the extra
+*** parameter \`--disable-sanity-checks'."
+    exit 1
+  else
+    echo "\
+*** WARNING: Do you really want to install the GNU C Library into /usr/local?
+*** This might make your system totally unusable, for details read the FAQ."
+  fi
+fi
+
+
+# One kFreeBSD we use ldconfig.
+use_ldconfig=yes
+
+# We need some extensions to the `ldd' script.
+changequote(,)
+case "$machine" in
+  x86_64*)
+    ldd_rewrite_script=$dir/x86_64/ldd-rewrite.sed
+    ;;
+  *)
+    ;;
+esac
+changequote([,])
+
+if test $host = $build; then
+  # If $prefix/include/{net,scsi} are symlinks, make install will
+  # clobber what they're linked to (probably a kernel tree).
+  # test -L ought to work on all Linux boxes.
+  if test "x$prefix" != xNONE; then
+    ac_prefix=$prefix
+  else
+    ac_prefix=$ac_default_prefix
+  fi
+  AC_MSG_CHECKING([for symlinks in ${ac_prefix}/include])
+  ac_message=
+  if test -L ${ac_prefix}/include/net; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/net is a symlink"
+  fi
+  if test -L ${ac_prefix}/include/scsi; then
+    ac_message="$ac_message
+   ${ac_prefix}/include/scsi is a symlink"
+  fi
+  if test -n "$ac_message"; then
+    AC_MSG_ERROR([$ac_message
+\`make install' will destroy the target of the link(s).
+Delete the links and re-run configure, or better still, move the entire
+${ac_prefix}/include directory out of the way.])
+  else
+    AC_MSG_RESULT(ok)
+  fi
+fi
+
+# We support internal syscalls.
+# It is advertised as inlined syscalls availability ...
+AC_DEFINE(HAVE_INLINED_SYSCALLS)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/connect.c
@@ -0,0 +1,65 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour.  */
+
+extern int __libc_sa_len (sa_family_t __af);
+libc_hidden_proto (__libc_sa_len)
+
+extern int __syscall_connect (int fd, __CONST_SOCKADDR_ARG addr,
+			      socklen_t addrlen);
+libc_hidden_proto (__syscall_connect)
+
+/* Open a connection on socket FD to peer at ADDR (which LEN bytes long).
+   For connectionless socket types, just set the default address to send to
+   and the only address from which to accept transmissions.
+   Return 0 on success, -1 for errors.  */
+
+int
+__libc_connect (int fd, __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+  new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+
+  /* Only allow a smaller size, otherwise it could lead to
+    stack corruption */
+  if ((new_addrlen != 0) && (new_addrlen < addrlen))
+    addrlen = new_addrlen;
+
+  /* We pass 3 arguments.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (connect, 3, fd, addr.__sockaddr__, addrlen);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (connect, 3, fd, addr.__sockaddr__, addrlen);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+weak_alias (__libc_connect, __connect)
+weak_alias (__libc_connect, connect)
+libc_hidden_weak (__connect)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/cpuset-kern.h
@@ -0,0 +1,52 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* From <sys/cpuset.h> */
+
+
+/*
+ * Valid cpulevel_t values.
+ */
+#define	CPU_LEVEL_ROOT		1	/* All system cpus. */
+#define	CPU_LEVEL_CPUSET	2	/* Available cpus for which. */
+#define	CPU_LEVEL_WHICH		3	/* Actual mask/id for which. */
+
+/*
+ * Valid cpuwhich_t values.
+ */
+#define	CPU_WHICH_TID		1	/* Specifies a thread id. */
+#define	CPU_WHICH_PID		2	/* Specifies a process id. */
+#define	CPU_WHICH_CPUSET	3	/* Specifies a set id. */
+#define	CPU_WHICH_IRQ		4	/* Specifies an irq #. */
+#define	CPU_WHICH_JAIL		5	/* Specifies a jail id. */
+
+/*
+ * Reserved cpuset identifiers.
+ */
+#define	CPUSET_INVALID	-1
+#define	CPUSET_DEFAULT	0
+
+extern int __syscall_cpuset_getaffinity(int level, int which, int64_t id,
+					size_t setsize, cpu_set_t *mask);
+libc_hidden_proto(__syscall_cpuset_getaffinity)
+
+
+extern int __syscall_cpuset_setaffinity(int level, int which, int64_t id,
+					size_t setsize, const cpu_set_t *mask);
+libc_hidden_proto(__syscall_cpuset_setaffinity)
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/devname.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+
+#include <stdio.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+
+char *
+__devname_r(__dev_t dev, __mode_t type, char *buf, int len)
+{
+	int i;
+	size_t j;
+	const char *r;
+
+	if ((type & S_IFMT) == S_IFCHR) {
+		j = len;
+		i = __sysctlbyname("kern.devname", buf, &j, &dev, sizeof (dev));
+		if (i == 0)
+		    return (buf);
+	}
+
+	/* Finally just format it */
+	if (dev == NODEV)
+		r = "#NODEV";
+	else 
+		r = "#%c:%d:0x%x";
+	__snprintf(buf, len, r,
+	    (type & S_IFMT) == S_IFCHR ? 'C' : 'B', major(dev), minor(dev));
+	return (buf);
+}
+
+
+char *
+__devname(__dev_t dev, __mode_t type)
+{
+	static char buf[SPECNAMELEN + 1];
+
+	return(__devname_r(dev, type, buf, sizeof(buf)));
+}
+weak_alias (__devname_r, devname_r)
+weak_alias (__devname, devname)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-execstack.c
@@ -0,0 +1,58 @@
+/* Stack executability handling for GNU dynamic linker.  Linux version.
+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+#include <sys/mman.h>
+#include <errno.h>
+#include <libintl.h>
+#include <stdbool.h>
+#include <stackinfo.h>
+#include <caller.h>
+
+
+extern int __stack_prot attribute_relro attribute_hidden;
+
+
+int
+internal_function
+_dl_make_stack_executable (void **stack_endp)
+{
+  /* This gives us the highest/lowest page that needs to be changed.  */
+  uintptr_t page = ((uintptr_t) *stack_endp
+		    & -(intptr_t) GLRO(dl_pagesize));
+
+  /* Challenge the caller.  */
+  if (__builtin_expect (__check_caller (RETURN_ADDRESS (0),
+					allow_ldso|allow_libpthread) != 0, 0)
+      || __builtin_expect (*stack_endp != __libc_stack_end, 0))
+    return EPERM;
+
+  if (__builtin_expect (__mprotect ((void *) page, GLRO(dl_pagesize),
+				    __stack_prot) != 0, 0))
+    return errno;
+
+  /* Clear the address.  */
+  *stack_endp = NULL;
+
+  /* Remember that we changed the permission.  */
+  GL(dl_stack_flags) |= PF_X;
+
+  return 0;
+}
+rtld_hidden_def (_dl_make_stack_executable)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-getcwd.c
@@ -0,0 +1 @@
+#include "getcwd.c"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-openat64.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@gmain.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+extern int __syscall_openat (int fd, const char *path, int flag, mode_t mode);
+libc_hidden_proto (__syscall_openat)
+
+int
+openat64 (int dfd, const char *file, int oflag, ...)
+{
+  assert ((oflag & O_CREAT) == 0);
+
+  return INLINE_SYSCALL (openat, 4, dfd, file, oflag, 0);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-origin.c
@@ -0,0 +1,123 @@
+/* Find path of executable.
+   Copyright (C) 1998, 1999, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1998.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <ldsodefs.h>
+#include <sysdep.h>
+
+#include <dl-dst.h>
+
+const char *_self_program_name_from_auxv attribute_hidden;
+
+static int
+_dl_self_name(char *buf, int buflen)
+{
+  int len, wdlen;
+
+  /* try /proc/self/exe symlink. */  
+  len = __readlink("/proc/self/exe", buf, buflen);
+
+  if (len > 0 && buf[0] == '/')
+    return len;
+
+  if (!_self_program_name_from_auxv)
+    return -1;
+
+  len = strlen(_self_program_name_from_auxv);
+  if (len > 0 && _self_program_name_from_auxv[0] == '/')
+  {
+    /* absolute file name */
+    if (len < buflen)
+    {
+      strcpy(buf, _self_program_name_from_auxv);
+      return len;
+    }
+    memcpy(buf, _self_program_name_from_auxv, buflen);
+    buf[buflen - 1] = 0;
+    return buflen - 1;
+  };
+  
+  /* relative file name, do our best */
+  if (NULL == __getcwd(buf, buflen))
+    return -1;
+  
+  wdlen = strlen(buf);
+  buf[wdlen] = '/';
+  if ((wdlen + len + 1) < buflen)
+  {
+    strcpy(buf + wdlen + 1, _self_program_name_from_auxv);
+    return wdlen + len + 1;
+  }
+  memcpy(buf + wdlen + 1, _self_program_name_from_auxv, buflen - wdlen - 1);  
+  buf[buflen - 1] = 0;
+  return buflen - 1;  
+}
+
+
+
+const char *
+_dl_get_origin (void)
+{
+  char linkval[2*PATH_MAX];
+  char *result;
+  int len;
+
+  len = _dl_self_name(linkval, sizeof(linkval));
+
+  if (len > 0)
+    {
+      /* We can use this value.  */
+      while (len > 1 && linkval[len - 1] != '/')
+	--len;
+      result = (char *) malloc (len + 1);
+      if (result == NULL)
+	result = (char *) -1;
+      else if (len == 1)
+	memcpy (result, "/", 2);
+      else
+	*((char *) __mempcpy (result, linkval, len - 1)) = '\0';
+    }
+  else
+    {
+      result = (char *) -1;
+      /* We use the environment variable LD_ORIGIN_PATH.  If it is set make
+	 a copy and strip out trailing slashes.  */
+      if (GLRO(dl_origin_path) != NULL)
+	{
+	  size_t len = strlen (GLRO(dl_origin_path));
+	  result = (char *) malloc (len + 1);
+	  if (result == NULL)
+	    result = (char *) -1;
+	  else
+	    {
+	      char *cp = __mempcpy (result, GLRO(dl_origin_path), len);
+	      while (cp > result + 1 && cp[-1] == '/')
+		--cp;
+	      *cp = '\0';
+	    }
+	}
+    }
+
+  return result;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-osinfo.h
@@ -0,0 +1,94 @@
+/* Operating system specific code  for generic dynamic loader functions.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <kernel-features.h>
+#include <dl-sysdep.h>
+#include <endian.h>
+#include <fcntl.h>
+#include <stdint.h>
+#include <not-cancel.h>
+
+#ifndef MIN
+# define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
+#define DL_SYSDEP_OSCHECK(FATAL)					      \
+  do {									      \
+    /* Test whether the kernel is new enough.  This test is only performed    \
+       if the library is not compiled to run on all kernels.  */	      \
+									      \
+    int version = _dl_discover_osversion ();				      \
+    if (__builtin_expect (version >= 0, 1))				      \
+      {									      \
+	if (__builtin_expect (GLRO(dl_osversion) == 0, 1)		      \
+	    || GLRO(dl_osversion) > version)				      \
+	  GLRO(dl_osversion) = version;					      \
+									      \
+	/* Now we can test with the required version.  */		      \
+	if (__KFREEBSD_KERNEL_VERSION > 0 && 				      \
+	    version < __KFREEBSD_KERNEL_VERSION)   			      \
+	  /* Not sufficent.  */						      \
+	  FATAL ("FATAL: kernel too old\n");				      \
+      }									      \
+    else if (__KFREEBSD_KERNEL_VERSION > 0)				      \
+      FATAL ("FATAL: cannot determine kernel version\n");		      \
+  } while (0)
+
+static inline uintptr_t __attribute__ ((always_inline))
+_dl_setup_stack_chk_guard (void *dl_random)
+{
+  union
+  {
+    uintptr_t num;
+    unsigned char bytes[sizeof (uintptr_t)];
+  } ret;
+
+    {
+      const size_t filllen = sizeof (ret.bytes) - 1;
+      ret.num = 0;
+# ifdef ENABLE_STACKGUARD_RANDOMIZE
+      int fd = open_not_cancel_2 ("/dev/urandom", O_RDONLY);
+      if (fd >= 0)
+	{
+	  ssize_t reslen = read_not_cancel (fd, ret.bytes + 1, filllen);
+	  close_not_cancel_no_status (fd);
+	  if (reslen == (ssize_t) filllen)
+	    return ret.num;
+	}
+# endif
+      ret.bytes[filllen] = 255;
+      ret.bytes[filllen - 1] = '\n';
+    }
+  return ret.num;
+}
+
+static inline uintptr_t __attribute__ ((always_inline))
+_dl_setup_pointer_guard (void *dl_random, uintptr_t stack_chk_guard)
+{
+  uintptr_t ret;
+
+  ret = stack_chk_guard;
+# ifndef HP_TIMING_NONAVAIL
+  hp_timing_t now;
+  HP_TIMING_NOW (now);
+  ret ^= now;
+# endif
+  return ret;
+}
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-support.c
@@ -0,0 +1,46 @@
+/* Dynamic linker system dependencies for GNU/kFreeBSD.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ldsodefs.h>
+#ifdef HAVE_AUX_VECTOR
+#include <bits/auxv.h>
+int _dl_clktck;
+
+void
+internal_function
+_dl_aux_init (ElfW(auxv_t) *av)
+{
+  for (; av->a_type != AT_NULL; ++av)
+    switch (av->a_type)
+      {
+      case AT_PAGESZ:
+	GLRO(dl_pagesize) = av->a_un.a_val;
+	break;
+      case AT_PHDR:
+	GL(dl_phdr) = (void *) av->a_un.a_val;
+	break;
+      case AT_PHNUM:
+	GL(dl_phnum) = av->a_un.a_val;
+	break;
+      }
+}
+#undef HAVE_AUX_VECTOR
+#endif
+
+#include <elf/dl-support.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-sysdep.c
@@ -0,0 +1,316 @@
+/* Operating system support for run-time dynamic linker.  GNU/kFreeBSD version.
+   Copyright (C) 1995-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We conditionalize the whole of this file rather than simply eliding it
+   from the static build, because other sysdeps/ versions of this file
+   might define things needed by a static build.  */
+
+#include <stdlib.h>
+#include <sys/sysctl.h>
+
+#ifdef SHARED
+
+#include <assert.h>
+#include <elf.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <libintl.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+#include <ldsodefs.h>
+#include <_itoa.h>
+#include <fpu_control.h>
+
+#include <entry.h>
+#include <dl-machine.h>
+#include <dl-procinfo.h>
+#include <dl-osinfo.h>
+#include <hp-timing.h>
+#include <tls.h>
+
+extern char **_environ attribute_hidden;
+extern char _end[] attribute_hidden;
+
+/* Protect SUID program against misuse of file descriptors.  */
+extern void __libc_check_standard_fds (void);
+
+#ifdef NEED_DL_BASE_ADDR
+ElfW(Addr) _dl_base_addr;
+#endif
+int __libc_enable_secure attribute_relro = 0;
+rtld_hidden_data_def (__libc_enable_secure)
+int __libc_multiple_libcs = 0;	/* Defining this here avoids the inclusion
+				   of init-first.  */
+/* This variable contains the lowest stack address ever used.  */
+void *__libc_stack_end attribute_relro = NULL;
+rtld_hidden_data_def(__libc_stack_end)
+void *_dl_random attribute_relro = NULL;
+
+#ifndef DL_FIND_ARG_COMPONENTS
+# define DL_FIND_ARG_COMPONENTS(cookie, argc, argv, envp, auxp)	\
+  do {									      \
+    void **_tmp;							      \
+    (argc) = *(long int *) cookie;					      \
+    (argv) = (char **) ((long int *) cookie + 1);			      \
+    (envp) = (argv) + (argc) + 1;					      \
+    for (_tmp = (void **) (envp); *_tmp; ++_tmp)			      \
+      continue;								      \
+    (auxp) = (void *) ++_tmp;						      \
+  } while (0)
+#endif
+
+#ifndef DL_STACK_END
+# define DL_STACK_END(cookie) ((void *) (cookie))
+#endif
+
+
+extern const char *_self_program_name_from_auxv attribute_hidden;
+
+ElfW(Addr)
+_dl_sysdep_start (void **start_argptr,
+		  void (*dl_main) (const ElfW(Phdr) *phdr, ElfW(Word) phnum,
+				   ElfW(Addr) *user_entry, ElfW(auxv_t) *auxv))
+{
+  const ElfW(Phdr) *phdr = NULL;
+  ElfW(Word) phnum = 0;
+  ElfW(Addr) user_entry;
+  ElfW(auxv_t) *av;
+  uid_t uid = 0;
+  gid_t gid = 0;
+#ifdef NEED_DL_SYSINFO
+  uintptr_t new_sysinfo = 0;
+#endif
+
+  __libc_stack_end = DL_STACK_END (start_argptr);
+  DL_FIND_ARG_COMPONENTS (start_argptr, _dl_argc, _dl_argv, _environ,
+			  GLRO(dl_auxv));
+
+  user_entry = (ElfW(Addr)) ENTRY_POINT;
+  GLRO(dl_platform) = NULL; /* Default to nothing known about the platform.  */
+
+  for (av = GLRO(dl_auxv); av->a_type != AT_NULL; av++)
+    switch (av->a_type)
+      {
+      case AT_PHDR:
+	phdr = (void *) av->a_un.a_val;
+	break;
+      case AT_PHNUM:
+	phnum = av->a_un.a_val;
+	break;
+      case AT_PAGESZ:
+	GLRO(dl_pagesize) = av->a_un.a_val;
+	break;
+      case AT_ENTRY:
+	user_entry = av->a_un.a_val;
+	break;
+      case AT_EXECPATH:
+	_self_program_name_from_auxv = (char *) av->a_un.a_val;
+	break;
+#ifdef NEED_DL_BASE_ADDR
+      case AT_BASE:
+	_dl_base_addr = av->a_un.a_val;
+	break;
+#endif
+      }
+
+    {
+      /* Fill in the values we have not gotten from the kernel through the
+	 auxiliary vector.  */
+#  undef SEE
+#  define SEE(UID, var, uid) \
+   var ^= __get##uid ()
+      SEE (UID, uid, uid);
+      SEE (EUID, uid, euid);
+      SEE (GID, gid, gid);
+      SEE (EGID, gid, egid);
+
+      /* If one of the two pairs of IDs does not match this is a setuid
+	 or setgid run.  */
+      __libc_enable_secure = uid | gid;
+    }
+
+#ifndef HAVE_AUX_PAGESIZE
+  if (GLRO(dl_pagesize) == 0)
+    GLRO(dl_pagesize) = __getpagesize ();
+#endif
+
+#if defined NEED_DL_SYSINFO
+  /* Only set the sysinfo value if we also have the vsyscall DSO.  */
+  if (GLRO(dl_sysinfo_dso) != 0 && new_sysinfo)
+    GLRO(dl_sysinfo) = new_sysinfo;
+#endif
+
+#ifdef DL_SYSDEP_INIT
+  DL_SYSDEP_INIT;
+#endif
+
+#ifdef DL_PLATFORM_INIT
+  DL_PLATFORM_INIT;
+#endif
+
+  /* Determine the length of the platform name.  */
+  if (GLRO(dl_platform) != NULL)
+    GLRO(dl_platformlen) = strlen (GLRO(dl_platform));
+
+  if (__sbrk (0) == _end)
+    /* The dynamic linker was run as a program, and so the initial break
+       starts just after our bss, at &_end.  The malloc in dl-minimal.c
+       will consume the rest of this page, so tell the kernel to move the
+       break up that far.  When the user program examines its break, it
+       will see this new value and not clobber our data.  */
+    __sbrk (GLRO(dl_pagesize)
+	    - ((_end - (char *) 0) & (GLRO(dl_pagesize) - 1)));
+
+  /* If this is a SUID program we make sure that FDs 0, 1, and 2 are
+     allocated.  If necessary we are doing it ourself.  If it is not
+     possible we stop the program.  */
+  if (__builtin_expect (__libc_enable_secure, 0))
+    __libc_check_standard_fds ();
+
+  (*dl_main) (phdr, phnum, &user_entry, GLRO(dl_auxv));
+  return user_entry;
+}
+
+void
+internal_function
+_dl_show_auxv (void)
+{
+  char buf[64];
+  ElfW(auxv_t) *av;
+
+  /* Terminate string.  */
+  buf[63] = '\0';
+
+  /* The following code assumes that the AT_* values are encoded
+     starting from 0 with AT_NULL, 1 for AT_IGNORE, and all other values
+     close by (otherwise the array will be too large).  In case we have
+     to support a platform where these requirements are not fulfilled
+     some alternative implementation has to be used.  */
+  for (av = GLRO(dl_auxv); av->a_type != AT_NULL; ++av)
+    {
+      static const struct
+      {
+	const char label[17];
+	enum { unknown = 0, dec, hex, str, ignore } form : 8;
+      } auxvars[] =
+	{
+	  [AT_EXECFD - 2] =		{ "EXECFD:       ", dec },
+	  [AT_PHDR - 2] =		{ "PHDR:         0x", hex },
+	  [AT_PHENT - 2] =		{ "PHENT:        ", dec },
+	  [AT_PHNUM - 2] =		{ "PHNUM:        ", dec },
+	  [AT_PAGESZ - 2] =		{ "PAGESZ:       ", dec },
+	  [AT_BASE - 2] =		{ "BASE:         0x", hex },
+	  [AT_FLAGS - 2] =		{ "FLAGS:        0x", hex },
+	  [AT_ENTRY - 2] =		{ "ENTRY:        0x", hex },
+#ifndef __powerpc__
+	  /* For some odd reason these are not in sys/powerpc/include/elf.h.  */
+	  [AT_NOTELF - 2] =		{ "NOTELF:       ", hex },
+	  [AT_UID - 2] =		{ "UID:          ", dec },
+	  [AT_EUID - 2] =		{ "EUID:         ", dec },
+	  [AT_GID - 2] =		{ "GID:          ", dec },
+	  [AT_EGID - 2] =		{ "EGID:         ", dec },
+#endif
+	  [AT_EXECPATH - 2] =		{ "EXECPATH:     ", str },
+	  [AT_CANARY - 2] =		{ "CANARY:       0x", hex },
+	  [AT_CANARYLEN - 2] =		{ "CANARYLEN:    ", dec },
+	  [AT_OSRELDATE - 2] =		{ "OSRELDATE:    ", dec },
+	  [AT_NCPUS - 2] =		{ "NCPUS:        ", dec },
+	  [AT_PAGESIZES - 2] =		{ "PAGESIZES:    0x", hex },
+	  [AT_PAGESIZESLEN - 2] =	{ "PAGESIZESLEN: ", dec },
+	  [AT_TIMEKEEP - 2] =		{ "TIMEKEEP:     0x", hex },
+	  [AT_STACKPROT - 2] =		{ "STACKPROT:    0x", hex },
+	};
+      unsigned int idx = (unsigned int) (av->a_type - 2);
+
+      if ((unsigned int) av->a_type < 2u || auxvars[idx].form == ignore)
+	continue;
+
+      assert (AT_NULL == 0);
+      assert (AT_IGNORE == 1);
+
+      if (idx < sizeof (auxvars) / sizeof (auxvars[0])
+	  && auxvars[idx].form != unknown)
+	{
+	  const char *val = (char *) av->a_un.a_val;
+
+	  if (__builtin_expect (auxvars[idx].form, dec) == dec)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 10, 0);
+	  else if (__builtin_expect (auxvars[idx].form, hex) == hex)
+	    val = _itoa ((unsigned long int) av->a_un.a_val,
+			 buf + sizeof buf - 1, 16, 0);
+
+	  _dl_printf ("AT_%s%s\n", auxvars[idx].label, val);
+
+	  continue;
+	}
+
+      /* Unknown value: print a generic line.  */
+      char buf2[17];
+      buf2[sizeof (buf2) - 1] = '\0';
+      const char *val2 = _itoa ((unsigned long int) av->a_un.a_val,
+				buf2 + sizeof buf2 - 1, 16, 0);
+      const char *val =  _itoa ((unsigned long int) av->a_type,
+				buf + sizeof buf - 1, 16, 0);
+      _dl_printf ("AT_??? (0x%s): 0x%s\n", val, val2);
+    }
+}
+void
+internal_function
+_dl_sysdep_start_cleanup (void)
+{
+}
+
+
+#endif
+
+
+int
+attribute_hidden
+_dl_discover_osversion (void)
+{
+  int request[2] = { CTL_KERN, KERN_OSRELDATE };
+  size_t len;
+  int version;
+  int subrelease;
+
+  len = sizeof(version);
+  if (__sysctl (request, 2, &version, &len, NULL, 0) < 0)
+    return -1;
+    
+/*
+ * since 8.0 release
+ * scheme is:  <major><two digit minor>Rxx
+ *              'R' is in the range 0 to 4 if this is a release branch or
+ *              x.0-CURRENT before RELENG_*_0 is created, otherwise 'R' is
+ *              in the range 5 to 9.
+ */
+
+  /* Convert to the GLIBC versioning system */
+  subrelease = version % 1000;
+  if (subrelease >= 500)
+      subrelease -= 300;	/* hopefull 55 values suffice for stable update */
+  if (subrelease > 255)		/* it have to fit into byte */
+      subrelease = 255;
+  return ((version / 100000) << 16)		/* major */
+	 | (((version % 100000) / 1000) << 8)   /* minor 	0 -  99 */
+	 | subrelease;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-sysdep.h
@@ -0,0 +1,26 @@
+/* System-specific settings for dynamic linker code.  Linux version.
+   Copyright (C) 2005, 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include_next <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+/* Get version of the OS.  */
+extern int _dl_discover_osversion (void) attribute_hidden;
+# define HAVE_DL_DISCOVER_OSVERSION	1
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/dl-writev.h
@@ -0,0 +1,38 @@
+/* Message-writing for the dynamic linker.
+   Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sys/uio.h>
+#include <sysdep.h>
+
+/* This is used from only one place: dl-misc.c:_dl_debug_vdprintf.
+   Hence it's in a header with the expectation it will be inlined.
+
+   This is writev, but with a constraint added and others loosened:
+
+   1. Under RTLD_PRIVATE_ERRNO, it must not clobber the private errno
+      when another thread holds the dl_load_lock.
+   2. It is not obliged to detect and report errors at all.
+   3. It's not really obliged to deliver a single atomic write
+      (though it may be preferable).  */
+
+static inline void
+_dl_writev (int fd, const struct iovec *iov, size_t niov)
+{
+  INTERNAL_SYSCALL_DECL (err);
+  INTERNAL_SYSCALL (writev, err, 3, fd, iov, niov);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/faccessat.c
@@ -0,0 +1,64 @@
+/* Test for access to file, relative to open directory.  Linux version.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+#include <sysdep.h>
+
+extern int __syscall_faccessat (int fd, const char *path, int mode, int flag);
+libc_hidden_proto (__syscall_faccessat)
+
+/*
+   The FreeBSD kernel do not test file access correctly when the 
+   process' real user ID is superuser. In particular, they always return
+   zero when testing execute permissions without regard to whether the 
+   file is executable.
+
+   While this behaviour conforms to POSIX.1-2008, it is explicitely 
+   discouraged. This wrapper implements the recommended behaviour.
+ */
+
+int
+faccessat (int fd, const char *file, int mode, int flag)
+{
+        int result = INLINE_SYSCALL (faccessat, 4, fd, file, mode, flag);
+        if ((result == 0) && (mode & X_OK))
+        {
+          uid_t uid = (flag & AT_EACCESS) ? __geteuid () : __getuid ();
+          if (uid == 0)
+          {
+            struct stat64 stats;
+            if (fstatat64 (fd, file, &stats, flag & AT_SYMLINK_NOFOLLOW))
+              return -1;
+            if ((stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0)
+            {
+              __set_errno (EACCES);
+              return -1;
+	    }
+          }
+	}
+	return result;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/Implies
@@ -0,0 +1 @@
+pthread
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/Makefile
@@ -0,0 +1,62 @@
+# Copyright (C) 2002-2013 Free Software Foundation, Inc.
+# This file is part of the GNU C Library.
+# Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library; if not, see
+# <http://www.gnu.org/licenses/>.
+
+ifeq ($(subdir),fbtl)
+sysdep_routines += register-atfork unregister-atfork libc_pthread_init \
+		   libc_multiple_threads
+
+libpthread-sysdep_routines += pt-fork pthread_mutex_cond_lock
+
+gen-as-const-headers += lowlevelrwlock.sym \
+			unwindbuf.sym \
+ 			structsem.sym
+ 			
+#gen-as-const-headers += lowlevelcond.sym lowlevelrwlock.sym \
+#			lowlevelbarrier.sym unwindbuf.sym \
+#			lowlevelrobustlock.sym pthread-pi-defines.sym \
+#			structsem.sym
+endif
+
+ifeq ($(subdir),fbtl)
+routines += sys_thr_kill sys_thr_self
+routines += sys_sigwaitinfo sys_sigwait sys_sigtimedwait
+libpthread-routines += ptw-sys_sigwaitinfo ptw-sys_sigwait ptw-sys_sigtimedwait
+libpthread-routines += ptw-sys_sigprocmask ptw-sys_umtx
+libpthread-routines += ptw-sys_thr_kill
+libpthread-routines += ptw-sys_thr_kill2
+libpthread-routines += ptw-sys_thr_new
+libpthread-routines += ptw-sys_thr_self
+libpthread-routines += ptw-sys_thr_set_name
+libpthread-routines += ptw-sys_thr_exit
+libpthread-routines += ptw-sigprocmask
+libpthread-routines += ptw-ioctl
+libpthread-routines += ptw-sys_clock_getcpuclockid2
+endif
+
+ifeq ($(subdir),rt)
+sysdep_routines += sys_clock_getcpuclockid2
+endif
+
+ifeq ($(subdir),posix)
+CFLAGS-fork.c = $(libio-mtsafe)
+CFLAGS-getpid.o = -fomit-frame-pointer
+CFLAGS-getpid.os = -fomit-frame-pointer
+endif
+
+# Needed in both the signal and nptl subdir.
+CFLAGS-sigaction.c = -DWRAPPER_INCLUDE='<fbtl/sigaction.c>'
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/Versions
@@ -0,0 +1,18 @@
+libc {
+  GLIBC_2.3.2 {
+    __register_atfork;
+  }
+  GLIBC_PRIVATE {
+    __libc_pthread_init;
+    __libc_current_sigrtmin_private; __libc_current_sigrtmax_private;
+    __libc_allocate_rtsig_private;
+# needed by pthread library
+    __syscall_sigprocmask;
+    __syscall_sigwaitinfo;
+    __syscall_sigsuspend;
+    __syscall_sigaction;
+    __syscall__umtx_op;
+# needed by librt as INLINE_SYSCALL:
+    __syscall_clock_getcpuclockid2;
+  }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/aio_misc.h
@@ -0,0 +1,65 @@
+/* Copyright (C) 2004-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2004.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _AIO_MISC_H
+# include_next <aio_misc.h>
+# include <limits.h>
+# include <pthread.h>
+# include <signal.h>
+# include <sysdep.h>
+
+# define aio_start_notify_thread __aio_start_notify_thread
+# define aio_create_helper_thread __aio_create_helper_thread
+
+extern inline void
+__aio_start_notify_thread (void)
+{
+  sigset_t ss;
+  sigemptyset (&ss);
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &ss, NULL);
+}
+
+extern inline int
+__aio_create_helper_thread (pthread_t *threadp, void *(*tf) (void *),
+			    void *arg)
+{
+  pthread_attr_t attr;
+
+  /* Make sure the thread is created detached.  */
+  pthread_attr_init (&attr);
+  pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
+
+  /* The helper thread needs only very little resources.  */
+  (void) pthread_attr_setstacksize (&attr, __pthread_get_minstack (&attr));
+
+  /* Block all signals in the helper thread.  To do this thoroughly we
+     temporarily have to block all signals here.  */
+  sigset_t ss;
+  sigset_t oss;
+  sigfillset (&ss);
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &ss, &oss);
+
+  int ret = pthread_create (threadp, &attr, tf, arg);
+
+  /* Restore the signal mask.  */
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &oss, NULL);
+
+  (void) pthread_attr_destroy (&attr);
+  return ret;
+}
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/allocrtsig.c
@@ -0,0 +1,55 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <signal.h>
+
+
+static int current_rtmin = __SIGRTMIN + 2;
+static int current_rtmax = __SIGRTMAX;
+
+
+/* We reserve __SIGRTMIN for use as the cancelation signal.  This
+   signal is used internally.  */
+int
+__libc_current_sigrtmin (void)
+{
+  return current_rtmin;
+}
+libc_hidden_def (__libc_current_sigrtmin)
+strong_alias (__libc_current_sigrtmin, __libc_current_sigrtmin_private)
+
+
+int
+__libc_current_sigrtmax (void)
+{
+  return current_rtmax;
+}
+libc_hidden_def (__libc_current_sigrtmax)
+strong_alias (__libc_current_sigrtmax, __libc_current_sigrtmax_private)
+
+
+int
+__libc_allocate_rtsig (int high)
+{
+  if (current_rtmin == -1 || current_rtmin > current_rtmax)
+    /* We don't have anymore signal available.  */
+    return -1;
+
+  return high ? current_rtmin++ : current_rtmax--;
+}
+strong_alias (__libc_allocate_rtsig, __libc_allocate_rtsig_private)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/bits/initspin.h
@@ -0,0 +1 @@
+/* No thread support. */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/bits/local_lim.h
@@ -0,0 +1,51 @@
+/* Minimum guaranteed maximum values for system limits.  FreeBSD version.
+   Copyright (C) 1993-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/syslimits.h>
+
+/* The number of data keys per process.  */
+#define _POSIX_THREAD_KEYS_MAX	128
+/* This is the value this implementation supports.  */
+#define PTHREAD_KEYS_MAX	1024
+
+/* Controlling the iterations of destructors for thread-specific data.  */
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS	4
+/* Number of iterations this implementation does.  */
+#define PTHREAD_DESTRUCTOR_ITERATIONS	_POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/* The number of threads per process.  */
+#define _POSIX_THREAD_THREADS_MAX	64
+/* We have no predefined limit on the number of threads.  */
+#undef PTHREAD_THREADS_MAX
+
+/* Maximum amount by which a process can descrease its asynchronous I/O
+   priority level.  */
+#define AIO_PRIO_DELTA_MAX	20
+
+/* Minimum size for a thread.  We are free to choose a reasonable value.  */
+#define PTHREAD_STACK_MIN	16384
+
+/* Maximum number of POSIX timers available.  */
+#define TIMER_MAX	256
+
+/* Maximum number of timer expiration overruns.  */
+#define DELAYTIMER_MAX	2147483647
+
+/* Maximum value the semaphore can have.  */
+#define SEM_VALUE_MAX   (2147483647)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/bits/posix_opt.h
@@ -0,0 +1,203 @@
+/* Define POSIX options for FreeBSD.
+   Copyright (C) 1996-1997, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Never include this file directly; use <unistd.h> instead.
+ */
+
+#ifndef	_BITS_POSIX_OPT_H
+#define	_BITS_POSIX_OPT_H	1
+
+#include <bits/os-unistd.h>
+
+/* Job control is supported.  */
+#define	_POSIX_JOB_CONTROL	1
+
+/* Processes have a saved set-user-ID and a saved set-group-ID.  */
+#define	_POSIX_SAVED_IDS	1
+
+/* Priority scheduling is supported.  */
+#define	_POSIX_PRIORITY_SCHEDULING	200809L
+
+/* Synchronizing file data is supported.  */
+#define	_POSIX_SYNCHRONIZED_IO	200809L
+
+/* The fsync function is present.  */
+#define	_POSIX_FSYNC	200809L
+
+/* Mapping of files to memory is supported.  */
+#define	_POSIX_MAPPED_FILES	200809L
+
+/* Locking of all memory is supported.  */
+#define	_POSIX_MEMLOCK	200809L
+
+/* Locking of ranges of memory is supported.  */
+#define	_POSIX_MEMLOCK_RANGE	200809L
+
+/* Setting of memory protections is supported.  */
+#define	_POSIX_MEMORY_PROTECTION	200809L
+
+/* Only root can change owner of file.  */
+#define	_POSIX_CHOWN_RESTRICTED	1
+
+/* `c_cc' member of 'struct termios' structure can be disabled by
+   using the value _POSIX_VDISABLE.  */
+#define	_POSIX_VDISABLE	((unsigned char)'\377')
+
+/* Filenames are not silently truncated.  */
+#define	_POSIX_NO_TRUNC	1
+
+/* X/Open realtime support is only partially available.  */
+#define _XOPEN_REALTIME	-1
+
+/* X/Open realtime thread support is only partially available.  */
+#define _XOPEN_REALTIME_THREADS	-1
+
+/* Implementation supports `poll' function.  */
+#define	_POSIX_POLL	1
+
+/* Implementation supports `select' and `pselect' functions.  */
+#define	_POSIX_SELECT	1
+
+/* XPG4.2 shared memory is supported.  */
+#define	_XOPEN_SHM	1
+
+/* Tell we have POSIX threads.  */
+#define _POSIX_THREADS	200809L
+
+/* We have the reentrant functions described in POSIX.  */
+#define _POSIX_REENTRANT_FUNCTIONS	1
+#define _POSIX_THREAD_SAFE_FUNCTIONS	200809L
+
+/* We provide priority scheduling for threads.  */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
+
+/* We support user-defined stack sizes.  */
+#define _POSIX_THREAD_ATTR_STACKSIZE	200809L
+
+/* We support user-defined stacks.  */
+#define _POSIX_THREAD_ATTR_STACKADDR	200809L
+
+/* We do not support priority inheritence.  */
+#define _POSIX_THREAD_PRIO_INHERIT      -1
+
+/* We do not support priority protection */
+#define _POSIX_THREAD_PRIO_PROTECT      -1
+
+#ifdef __USE_XOPEN2K8
+/* We do not support priority inheritence for robust mutexes.  */
+# define _POSIX_THREAD_ROBUST_PRIO_INHERIT	-1
+
+/* We do not support priority protection for robust mutexes.  */
+# define _POSIX_THREAD_ROBUST_PRIO_PROTECT      -1
+#endif
+
+/* We support POSIX.1b semaphores.  */
+#define _POSIX_SEMAPHORES	200809L
+
+/* Real-time signals are available.  */
+#define _POSIX_REALTIME_SIGNALS	200809L
+
+/* We support asynchronous I/O.  */
+#define _POSIX_ASYNCHRONOUS_IO	200809L
+#define _POSIX_ASYNC_IO		1
+/* Alternative name for Unix98.  */
+#define _LFS_ASYNCHRONOUS_IO	1
+/* Support for prioritization is not available.  */
+#define _POSIX_PRIORITIZED_IO	-1
+
+/* The LFS support in asynchronous I/O is also available.  */
+#define _LFS64_ASYNCHRONOUS_IO	1
+
+/* The rest of the LFS is also available.  */
+#define _LFS_LARGEFILE		1
+#define _LFS64_LARGEFILE	1
+#define _LFS64_STDIO		1
+
+/* POSIX shared memory objects are implemented.  */
+#define _POSIX_SHARED_MEMORY_OBJECTS	200809L
+
+/* CPU-time clocks somewhere supported.  */
+#define _POSIX_CPUTIME	0
+
+/* We support somewhere the clock also in threads.  */
+#define _POSIX_THREAD_CPUTIME	0
+
+/* GNU libc provides regular expression handling.  */
+#define _POSIX_REGEXP	1
+
+/* Reader/Writer locks are available.  */
+#define _POSIX_READER_WRITER_LOCKS	200809L
+
+/* We have a POSIX shell.  */
+#define _POSIX_SHELL	1
+
+/* We support the Timeouts option.  */
+#define _POSIX_TIMEOUTS	200809L
+
+/* We support spinlocks.  */
+#define _POSIX_SPIN_LOCKS	200809L
+
+/* The `spawn' function family is supported.  */
+#define _POSIX_SPAWN	200809L
+
+/* We have POSIX timers.  */
+#define _POSIX_TIMERS	200809L
+
+/* The barrier functions are available.  */
+#define _POSIX_BARRIERS	200809L
+
+/* POSIX message queues are not available.  */
+#define _POSIX_MESSAGE_PASSING	-1
+
+/* Thread process-shared synchronization is supported.  */
+#define _POSIX_THREAD_PROCESS_SHARED	200809L
+
+/* The monotonic clock is available.  */
+#define _POSIX_MONOTONIC_CLOCK	200809L
+
+/* The clock selection interfaces are available.  */
+#define _POSIX_CLOCK_SELECTION	200809L
+
+/* Advisory information interfaces are available.  */
+#define _POSIX_ADVISORY_INFO	200809L
+
+/* IPv6 support is available.  */
+#define _POSIX_IPV6	200809L
+
+/* Raw socket support is available.  */
+#define _POSIX_RAW_SOCKETS	200809L
+
+/* We have at least one terminal.  */
+#define _POSIX2_CHAR_TERM	200809L
+
+/* Neither process nor thread sporadic server interfaces is available.  */
+#define _POSIX_SPORADIC_SERVER	-1
+#define _POSIX_THREAD_SPORADIC_SERVER	-1
+
+/* trace.h is not available.  */
+#define _POSIX_TRACE	-1
+#define _POSIX_TRACE_EVENT_FILTER	-1
+#define _POSIX_TRACE_INHERIT	-1
+#define _POSIX_TRACE_LOG	-1
+
+/* Typed memory objects are not available.  */
+#define _POSIX_TYPED_MEMORY_OBJECTS	-1
+
+#endif /* bits/posix_opt.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/bits/sigthread.h
@@ -0,0 +1,38 @@
+/* Signal handling function for threaded programs.
+   Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_SIGTHREAD_H
+#define _BITS_SIGTHREAD_H	1
+
+#if !defined _SIGNAL_H && !defined _PTHREAD_H
+# error "Never include this file directly.  Use <pthread.h> instead"
+#endif
+
+/* Functions for handling signals. */
+
+/* Modify the signal mask for the calling thread.  The arguments have
+   the same meaning as for sigprocmask(2). */
+extern int pthread_sigmask (int __how,
+			    __const __sigset_t *__restrict __newmask,
+			    __sigset_t *__restrict __oldmask) __THROW;
+
+/* Send signal SIGNO to the given thread. */
+extern int pthread_kill (pthread_t __threadid, int __signo) __THROW;
+
+#endif	/* bits/sigthread.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/bits/typesizes.h
@@ -0,0 +1,91 @@
+/* bits/typesizes.h -- underlying types for *_t.  kFreeBSD version.
+   Copyright (C) 2002, 2003, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_TYPES_H
+# error "Never include <bits/typesizes.h> directly; use <sys/types.h> instead."
+#endif
+
+#ifndef	_BITS_TYPESIZES_H
+#define	_BITS_TYPESIZES_H	1
+
+/* See <bits/types.h> for the meaning of these macros.  This file exists so
+   that <bits/types.h> need not vary across different GNU platforms.  */
+
+#define __DEV_T_TYPE		__U32_TYPE
+#define __UID_T_TYPE		__U32_TYPE
+#define __GID_T_TYPE		__U32_TYPE
+#define __INO_T_TYPE		__U32_TYPE
+#define __INO64_T_TYPE		__UQUAD_TYPE
+#define __MODE_T_TYPE		__U16_TYPE
+#define __NLINK_T_TYPE		__U16_TYPE
+#define __OFF_T_TYPE		__SQUAD_TYPE
+#define __OFF64_T_TYPE		__SQUAD_TYPE
+#define __PID_T_TYPE		__S32_TYPE
+#define __RLIM_T_TYPE		__SQUAD_TYPE
+#define __RLIM64_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT_T_TYPE		__SQUAD_TYPE
+#define	__BLKCNT64_T_TYPE	__SQUAD_TYPE
+#define	__FSBLKCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSBLKCNT64_T_TYPE	__UQUAD_TYPE
+#define	__FSFILCNT_T_TYPE	__ULONGWORD_TYPE
+#define	__FSFILCNT64_T_TYPE	__UQUAD_TYPE
+#define	__ID_T_TYPE		__U32_TYPE
+#define __CLOCK_T_TYPE		__S32_TYPE
+#define	__FSWORD_T_TYPE		__SWORD_TYPE
+
+/*
+ * This one is a bit tricky.  It needs to match the size
+ * in the sys/${arch}/include/_types.h typedefs.
+ *
+ * However, for i386 and amd64 we started with __SLONGWORD_TYPE
+ * and we need to maintain ABI.  Even if size is the same, using
+ * a different type may affect C++ ABI (this distinction is
+ * necessary to implement function overload), so it must stay
+ * with __SLONGWORD_TYPE.
+ */
+#if defined(__i386__) || defined(__amd64__) || defined(__powerpc__)
+#define __TIME_T_TYPE		__SLONGWORD_TYPE
+#else
+#define __TIME_T_TYPE		__S64_TYPE
+#endif
+
+#define __USECONDS_T_TYPE	__U32_TYPE
+#define __SUSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __DADDR_T_TYPE		__SQUAD_TYPE
+#define __SWBLK_T_TYPE		__S32_TYPE
+#define __KEY_T_TYPE		__SLONGWORD_TYPE
+#define __CLOCKID_T_TYPE	__S32_TYPE
+#define __TIMER_T_TYPE		__S32_TYPE
+#define __BLKSIZE_T_TYPE	__U32_TYPE
+#define __FSID_T_TYPE		union { int __val[2]; int val[2]; }
+#define __SSIZE_T_TYPE		__SWORD_TYPE
+#define __SNSECONDS_T_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_SLONG_TYPE	__SLONGWORD_TYPE
+#define __SYSCALL_ULONG_TYPE	__ULONGWORD_TYPE
+
+/* Tell the libc code that off_t and off64_t are actually the same type
+   for all ABI purposes, even if possibly expressed as different base types
+   for C type-checking purposes.  */
+#define __OFF_T_MATCHES_OFF64_T 1
+
+/* Number of descriptors that can fit in an `fd_set'.  */
+#define	__FD_SETSIZE		1024
+
+
+#endif /* bits/typesizes.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/clock_getcpuclockid.c
@@ -0,0 +1,28 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <time.h>
+#include <unistd.h>
+#include <kernel-features.h>
+
+int
+__clock_getcpuclockid (pid_t pid, clockid_t *clock_id)
+{
+   return INLINE_SYSCALL(clock_getcpuclockid2, 3, pid, CPUCLOCK_WHICH_PID, clock_id);
+}
+strong_alias (__clock_getcpuclockid, clock_getcpuclockid)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/clock_getres.c
@@ -0,0 +1,60 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stdint.h>
+#include <time.h>
+#include <sys/time.h>
+#include <libc-internal.h>
+#include <ldsodefs.h>
+#include <sysdep.h>
+
+int __syscall_clock_getres(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_getres)
+
+int __syscall_clock_gettime(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_gettime)
+
+/* Get resolution of clock.  */
+int
+__clock_getres (clockid_t clock_id, struct timespec *tp)
+{
+  /* we could try to provide fallback
+     via ??? for CLOCK_REALTIME
+     via HP_TIMING for CLOCK_PROCESS_CPUTIME_ID, 
+       CLOCK_THREAD_CPUTIME_ID and related timers
+
+     for now just pass it to kernel       
+   */
+  /* the negative clock_id means a CPU-timer, the resolution is same for all of them
+     the kernel returns resolution regardless whether the timer is accessible,
+     but POSIX/testsuite expects EINVAL
+   */
+   
+  if (clock_id < 0)
+  {
+    int rv;
+    /* we reuse user provided struct timespec */
+    rv = INLINE_SYSCALL (clock_gettime, 2, clock_id, tp);
+    if (rv != 0)
+      return rv;
+    /* valid, now really get the resolution  */
+  }
+
+  return INLINE_SYSCALL (clock_getres, 2, clock_id, tp);
+}
+strong_alias (__clock_getres, clock_getres)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/clock_gettime.c
@@ -0,0 +1,43 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stdint.h>
+#include <time.h>
+#include <sys/time.h>
+#include <libc-internal.h>
+#include <ldsodefs.h>
+#include <sysdep.h>
+
+int __syscall_clock_gettime(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_gettime)
+
+/* Get current value of CLOCK and store it in TP.  */
+int
+__clock_gettime (clockid_t clock_id, struct timespec *tp)
+{
+  /* we could try to provide fallback
+     via gettimeofday for  CLOCK_REALTIME
+     via HP_TIMING for CLOCK_PROCESS_CPUTIME_ID, 
+       CLOCK_THREAD_CPUTIME_ID and related timers
+
+     for now just pass it to kernel       
+   */    
+  return INLINE_SYSCALL (clock_gettime, 2, clock_id, tp);
+}
+weak_alias (__clock_gettime, clock_gettime)
+libc_hidden_def (__clock_gettime)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/clock_nanosleep.c
@@ -0,0 +1,99 @@
+/* High-resolution sleep with the specified clock.
+   Copyright (C) 2000-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <time.h>
+#include <hp-timing.h>
+#include <sysdep-cancel.h>
+
+
+int __syscall_clock_gettime(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_gettime)
+
+
+/* This implementation assumes that these is only a `nanosleep' system
+   call.  So we have to remap all other activities.  */
+int
+__clock_nanosleep (clockid_t clock_id, int flags, const struct timespec *req,
+		 struct timespec *rem)
+{
+  struct timespec now;
+
+  if (__builtin_expect (req->tv_nsec, 0) < 0
+      || __builtin_expect (req->tv_nsec, 0) >= 1000000000)
+    return EINVAL;
+
+  if (clock_id == CLOCK_THREAD_CPUTIME_ID)
+    return EINVAL;		/* POSIX specifies EINVAL for this case.  */
+
+  switch(clock_id)
+  {
+	case CLOCK_REALTIME:
+	case CLOCK_MONOTONIC:
+	case CLOCK_UPTIME:
+	case CLOCK_UPTIME_PRECISE:
+	case CLOCK_UPTIME_FAST:
+	case CLOCK_REALTIME_PRECISE:
+	case CLOCK_REALTIME_FAST:
+	case CLOCK_MONOTONIC_PRECISE:
+	case CLOCK_MONOTONIC_FAST:
+	case CLOCK_SECOND:
+	    /* almost realtime clocks */
+        break;
+        
+        default:
+            /* Not supported.  */
+            return ENOTSUP;
+  }         
+
+  /* If we got an absolute time, remap it.  */
+  if (flags == TIMER_ABSTIME)
+    {
+      long int nsec;
+      long int sec;
+
+      /* Make sure we use safe data types.  */
+      assert (sizeof (sec) >= sizeof (now.tv_sec));
+
+      /* Get the current time for this clock.  */
+      if (__builtin_expect (INLINE_SYSCALL (clock_gettime, 2, clock_id, &now), 0) != 0)
+	return errno;
+
+      /* Compute the difference.  */
+      nsec = req->tv_nsec - now.tv_nsec;
+      sec = req->tv_sec - now.tv_sec - (nsec < 0);
+      if (sec < 0)
+	/* The time has already elapsed.  */
+	return 0;
+
+      now.tv_sec = sec;
+      now.tv_nsec = nsec + (nsec < 0 ? 1000000000 : 0);
+
+      /* From now on this is our time.  */
+      req = &now;
+
+      /* Make sure we are not modifying the struct pointed to by REM.  */
+      rem = NULL;
+    }
+  else if (__builtin_expect (flags, 0) != 0)
+    return EINVAL;
+
+  return __builtin_expect (__nanosleep (req, rem), 0) ? errno : 0;
+}
+strong_alias (__clock_nanosleep, clock_nanosleep)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/clock_settime.c
@@ -0,0 +1,54 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stdint.h>
+#include <time.h>
+#include <sys/time.h>
+#include <libc-internal.h>
+#include <ldsodefs.h>
+#include <sysdep.h>
+
+int __syscall_clock_settime(clockid_t clock_id, const struct timespec *tp);
+libc_hidden_proto (__syscall_clock_settime)
+
+/* Set CLOCK to value TP.  */
+int
+__clock_settime (clockid_t clock_id, const struct timespec *tp)
+{
+  switch(clock_id)
+  {
+	case CLOCK_MONOTONIC:
+	case CLOCK_MONOTONIC_PRECISE:
+	case CLOCK_MONOTONIC_FAST:
+	    /* almost monotonic clocks */
+            __set_errno (EINVAL); /* per POSIX */
+	    return -1;
+        break;
+        default:;
+  };
+  /* we could try to provide fallback
+     via settimeofday for CLOCK_REALTIME
+     via HP_TIMING for CLOCK_PROCESS_CPUTIME_ID, 
+       CLOCK_THREAD_CPUTIME_ID and related timers
+
+     for now just pass it to kernel       
+   */    
+  
+  return INLINE_SYSCALL (clock_settime, 2, clock_id, tp);
+}
+strong_alias (__clock_settime, clock_settime)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/fatal-prepare.h
@@ -0,0 +1,24 @@
+/* Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <pthread.h>
+
+/* We have to completely disable cancellation.  assert() must not be a
+   cancellation point but the implementation uses write() etc.  */
+#define FATAL_PREPARE \
+  __libc_ptf_call (__pthread_setcancelstate, \
+		   (PTHREAD_CANCEL_DISABLE, NULL), 0)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/fork.c
@@ -0,0 +1,231 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sysdep.h>
+#include <libio/libioP.h>
+#include <tls.h>
+#include "fork.h"
+#include <hp-timing.h>
+#include <ldsodefs.h>
+#include <stdio-lock.h>
+#include <atomic.h>
+#include <pthreadP.h>
+
+
+unsigned long int *__fork_generation_pointer;
+
+
+
+/* The single linked list of all currently registered fork handlers.  */
+struct fork_handler *__fork_handlers;
+
+
+static void
+fresetlockfiles (void)
+{
+  _IO_ITER i;
+
+  for (i = _IO_iter_begin(); i != _IO_iter_end(); i = _IO_iter_next(i))
+    _IO_lock_init (*((_IO_lock_t *) _IO_iter_file(i)->_lock));
+}
+
+
+pid_t
+__libc_fork (void)
+{
+  pid_t pid;
+  struct used_handler
+  {
+    struct fork_handler *handler;
+    struct used_handler *next;
+  } *allp = NULL;
+
+  /* Run all the registered preparation handlers.  In reverse order.
+     While doing this we build up a list of all the entries.  */
+  struct fork_handler *runp;
+  while ((runp = __fork_handlers) != NULL)
+    {
+      /* Make sure we read from the current RUNP pointer.  */
+      atomic_full_barrier ();
+
+      unsigned int oldval = runp->refcntr;
+
+      if (oldval == 0)
+	/* This means some other thread removed the list just after
+	   the pointer has been loaded.  Try again.  Either the list
+	   is empty or we can retry it.  */
+	continue;
+
+      /* Bump the reference counter.  */
+      if (atomic_compare_and_exchange_bool_acq (&__fork_handlers->refcntr,
+						oldval + 1, oldval))
+	/* The value changed, try again.  */
+	continue;
+
+      /* We bumped the reference counter for the first entry in the
+	 list.  That means that none of the following entries will
+	 just go away.  The unloading code works in the order of the
+	 list.
+
+	 While executing the registered handlers we are building a
+	 list of all the entries so that we can go backward later on.  */
+      while (1)
+	{
+	  /* Execute the handler if there is one.  */
+	  if (runp->prepare_handler != NULL)
+	    runp->prepare_handler ();
+
+	  /* Create a new element for the list.  */
+	  struct used_handler *newp
+	    = (struct used_handler *) alloca (sizeof (*newp));
+	  newp->handler = runp;
+	  newp->next = allp;
+	  allp = newp;
+
+	  /* Advance to the next handler.  */
+	  runp = runp->next;
+	  if (runp == NULL)
+	    break;
+
+	  /* Bump the reference counter for the next entry.  */
+	  atomic_increment (&runp->refcntr);
+	}
+
+      /* We are done.  */
+      break;
+    }
+
+  _IO_list_lock ();
+
+#ifndef NDEBUG
+  pid_t ppid = THREAD_GETMEM (THREAD_SELF, tid);
+#endif
+
+  /* We need to prevent the getpid() code to update the PID field so
+     that, if a signal arrives in the child very early and the signal
+     handler uses getpid(), the value returned is correct.  */
+  pid_t parentpid = THREAD_GETMEM (THREAD_SELF, pid);
+  THREAD_SETMEM (THREAD_SELF, pid, -parentpid);
+
+#ifdef ARCH_FORK
+  pid = ARCH_FORK ();
+#else
+# warning "ARCH_FORK must be defined so that the CLONE_SETTID flag is used"
+  pid = INLINE_SYSCALL (fork, 0);
+#endif
+
+
+  if (pid == 0)
+    {
+      struct pthread *self = THREAD_SELF;
+
+#if 0
+      assert (THREAD_GETMEM (self, tid) != ppid);
+#else
+      { 
+         int val = __getpid();
+         INLINE_SYSCALL(thr_self, 1, &(self->ktid));
+         THREAD_SETMEM (self, pid, val);
+                 
+# warning fetch both getpid() and ktid via SYS_thr_self
+      }   
+#endif      
+
+      if (__fork_generation_pointer != NULL)
+	*__fork_generation_pointer += 4;
+
+      /* Adjust the PID field for the new process.  */
+#if 0      
+      THREAD_SETMEM (self, pid, THREAD_GETMEM (self, tid));
+#endif
+
+#if HP_TIMING_AVAIL
+      /* The CPU clock of the thread and process have to be set to zero.  */
+      hp_timing_t now;
+      HP_TIMING_NOW (now);
+      THREAD_SETMEM (self, cpuclock_offset, now);
+      GL(dl_cpuclock_offset) = now;
+#endif
+
+      /* Reset the file list.  These are recursive mutexes.  */
+      fresetlockfiles ();
+
+      /* Reset locks in the I/O code.  */
+      _IO_list_resetlock ();
+
+      /* Reset the lock the dynamic loader uses to protect its data.  */
+      __rtld_lock_initialize (GL(dl_load_lock));
+
+      /* Run the handlers registered for the child.  */
+      while (allp != NULL)
+	{
+	  if (allp->handler->child_handler != NULL)
+	    allp->handler->child_handler ();
+
+	  /* Note that we do not have to wake any possible waiter.
+	     This is the only thread in the new process.  The count
+	     may have been bumped up by other threads doing a fork.
+	     We reset it to 1, to avoid waiting for non-existing
+	     thread(s) to release the count.  */
+	  allp->handler->refcntr = 1;
+
+	  /* XXX We could at this point look through the object pool
+	     and mark all objects not on the __fork_handlers list as
+	     unused.  This is necessary in case the fork() happened
+	     while another thread called dlclose() and that call had
+	     to create a new list.  */
+
+	  allp = allp->next;
+	}
+
+      /* Initialize the fork lock.  */
+      __fork_lock = LLL_LOCK_INITIALIZER;
+    }
+  else
+    {
+      assert (THREAD_GETMEM (THREAD_SELF, tid) == ppid);
+
+      /* Restore the PID value.  */
+      THREAD_SETMEM (THREAD_SELF, pid, parentpid);
+
+      /* We execute this even if the 'fork' call failed.  */
+      _IO_list_unlock ();
+
+      /* Run the handlers registered for the parent.  */
+      while (allp != NULL)
+	{
+	  if (allp->handler->parent_handler != NULL)
+	    allp->handler->parent_handler ();
+
+	  if (atomic_decrement_and_test (&allp->handler->refcntr)
+	      && allp->handler->need_signal)
+	    lll_futex_wake (&allp->handler->refcntr, 1, LLL_PRIVATE);
+
+	  allp = allp->next;
+	}
+    }
+
+  return pid;
+}
+weak_alias (__libc_fork, __fork)
+libc_hidden_def (__fork)
+weak_alias (__libc_fork, fork)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/fork.h
@@ -0,0 +1,59 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <lowlevellock.h>
+
+/* The fork generation counter, defined in libpthread.  */
+extern unsigned long int __fork_generation attribute_hidden;
+
+/* Pointer to the fork generation counter in the thread library.  */
+extern unsigned long int *__fork_generation_pointer attribute_hidden;
+
+/* Lock to protect allocation and deallocation of fork handlers.  */
+extern int __fork_lock attribute_hidden;
+
+/* Elements of the fork handler lists.  */
+struct fork_handler
+{
+  struct fork_handler *next;
+  void (*prepare_handler) (void);
+  void (*parent_handler) (void);
+  void (*child_handler) (void);
+  void *dso_handle;
+  unsigned int refcntr;
+  int need_signal;
+};
+
+/* The single linked list of all currently registered for handlers.  */
+extern struct fork_handler *__fork_handlers attribute_hidden;
+
+
+/* Function to call to unregister fork handlers.  */
+extern void __unregister_atfork (void *dso_handle) attribute_hidden;
+#define UNREGISTER_ATFORK(dso_handle) __unregister_atfork (dso_handle)
+
+
+/* C library side function to register new fork handlers.  */
+extern int __register_atfork (void (*__prepare) (void),
+			      void (*__parent) (void),
+			      void (*__child) (void),
+			      void *dso_handle);
+libc_hidden_proto (__register_atfork)
+
+/* Add a new element to the fork list.  */
+extern void __linkin_atfork (struct fork_handler *newp) attribute_hidden;
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/gai_misc.h
@@ -0,0 +1,120 @@
+/* Copyright (C) 2006-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We define a special synchronization primitive for AIO.  POSIX
+   conditional variables would be ideal but the pthread_cond_*wait
+   operations do not return on EINTR.  This is a requirement for
+   correct aio_suspend and lio_listio implementations.  */
+
+#include <assert.h>
+#include <signal.h>
+#include <pthreadP.h>
+#include <lowlevellock.h>
+
+#define DONT_NEED_GAI_MISC_COND	1
+
+#define GAI_MISC_NOTIFY(waitlist) \
+  do {									      \
+    if (*waitlist->counterp > 0 && --*waitlist->counterp == 0)		      \
+      lll_futex_wake ((unsigned int *) waitlist->counterp, 1, LLL_PRIVATE);   \
+  } while (0)
+
+#warning have to check sign of return values from futex wait calls
+
+#define GAI_MISC_WAIT(result, futex, timeout, cancel) \
+  do {									      \
+    volatile int *futexaddr = &futex;					      \
+    int oldval = futex;							      \
+									      \
+    if (oldval != 0)							      \
+      {									      \
+	pthread_mutex_unlock (&__gai_requests_mutex);			      \
+									      \
+	int oldtype;							      \
+	if (cancel)							      \
+	  oldtype = LIBC_CANCEL_ASYNC ();				      \
+									      \
+	int status;							      \
+	do								      \
+	  {								      \
+	    status = lll_futex_timed_wait ((unsigned int *) futexaddr, oldval,\
+					   timeout, LLL_PRIVATE);	      \
+	    if (status != EWOULDBLOCK)					      \
+	      break;							      \
+									      \
+	    oldval = *futexaddr;					      \
+	  }								      \
+	while (oldval != 0);						      \
+									      \
+	if (cancel)							      \
+	  LIBC_CANCEL_RESET (oldtype);					      \
+									      \
+	if (status == EINTR)						      \
+	  result = EINTR;						      \
+	else if (status == ETIMEDOUT)					      \
+	  result = EAGAIN;						      \
+	else								      \
+	  assert (status == 0 || status == EWOULDBLOCK);		      \
+									      \
+	pthread_mutex_lock (&__gai_requests_mutex);			      \
+      }									      \
+  } while (0)
+
+
+#define gai_start_notify_thread __gai_start_notify_thread
+#define gai_create_helper_thread __gai_create_helper_thread
+
+extern inline void
+__gai_start_notify_thread (void)
+{
+  sigset_t ss;
+  sigemptyset (&ss);
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &ss, NULL);
+}
+
+extern inline int
+__gai_create_helper_thread (pthread_t *threadp, void *(*tf) (void *),
+			    void *arg)
+{
+  pthread_attr_t attr;
+
+  /* Make sure the thread is created detached.  */
+  pthread_attr_init (&attr);
+  pthread_attr_setdetachstate (&attr, PTHREAD_CREATE_DETACHED);
+
+  /* The helper thread needs only very little resources.  */
+  (void) pthread_attr_setstacksize (&attr,
+				    __pthread_get_minstack (&attr)
+				    + 4 * PTHREAD_STACK_MIN);
+
+  /* Block all signals in the helper thread.  To do this thoroughly we
+     temporarily have to block all signals here.  */
+  sigset_t ss;
+  sigset_t oss;
+  sigfillset (&ss);
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &ss, &oss);
+
+  int ret = pthread_create (threadp, &attr, tf, arg);
+
+  /* Restore the signal mask.  */
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &oss, NULL);
+
+  (void) pthread_attr_destroy (&attr);
+  return ret;
+}
+
+#include <resolv/gai_misc.h>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/internaltypes.h
@@ -0,0 +1,169 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _INTERNALTYPES_H
+#define _INTERNALTYPES_H	1
+
+#include <stdint.h>
+
+
+struct pthread_attr
+{
+  /* Scheduler parameters and priority.  */
+  struct sched_param schedparam;
+  int schedpolicy;
+  /* Various flags like detachstate, scope, etc.  */
+  int flags;
+  /* Size of guard area.  */
+  size_t guardsize;
+  /* Stack handling.  */
+  void *stackaddr;
+  size_t stacksize;
+  /* Affinity map.  */
+  cpu_set_t *cpuset;
+  size_t cpusetsize;
+};
+
+#define ATTR_FLAG_DETACHSTATE		0x0001
+#define ATTR_FLAG_NOTINHERITSCHED	0x0002
+#define ATTR_FLAG_SCOPEPROCESS		0x0004
+#define ATTR_FLAG_STACKADDR		0x0008
+#define ATTR_FLAG_OLDATTR		0x0010
+#define ATTR_FLAG_SCHED_SET		0x0020
+#define ATTR_FLAG_POLICY_SET		0x0040
+
+
+/* Mutex attribute data structure.  */
+struct pthread_mutexattr
+{
+  /* Identifier for the kind of mutex.
+
+     Bit 31 is set if the mutex is to be shared between processes.
+
+     Bit 0 to 30 contain one of the PTHREAD_MUTEX_ values to identify
+     the type of the mutex.  */
+  int mutexkind;
+};
+
+
+/* Conditional variable attribute data structure.  */
+struct pthread_condattr
+{
+  /* Combination of values:
+
+     Bit 0  : flag whether coditional variable will be shareable between
+	      processes.
+
+     Bit 1-7: clock ID.  */
+  int value;
+};
+
+
+/* The __NWAITERS field is used as a counter and to house the number
+   of bits for other purposes.  COND_CLOCK_BITS is the number
+   of bits needed to represent the ID of the clock.  COND_NWAITERS_SHIFT
+   is the number of bits reserved for other purposes like the clock.  */
+
+/* Under FreeBSD:
+        #define CLOCK_REALTIME  0
+        #define CLOCK_MONOTONIC 4   
+  
+  we therefore need at least 3 bits
+ */ 
+
+#define COND_CLOCK_BITS		4
+#define COND_NWAITERS_SHIFT	(COND_CLOCK_BITS)
+
+
+/* Read-write lock variable attribute data structure.  */
+struct pthread_rwlockattr
+{
+  int lockkind;
+  int pshared;
+};
+
+
+/* Barrier data structure.  */
+struct pthread_barrier
+{
+  unsigned int curr_event;
+  int lock;
+  unsigned int left;
+  unsigned int init_count;
+  int private;
+};
+
+
+/* Barrier variable attribute data structure.  */
+struct pthread_barrierattr
+{
+  int pshared;
+};
+
+
+/* Thread-local data handling.  */
+struct pthread_key_struct
+{
+  /* Sequence numbers.  Even numbers indicated vacant entries.  Note
+     that zero is even.  We use uintptr_t to not require padding on
+     32- and 64-bit machines.  On 64-bit machines it helps to avoid
+     wrapping, too.  */
+  uintptr_t seq;
+
+  /* Destructor for the data.  */
+  void (*destr) (void *);
+};
+
+/* Check whether an entry is unused.  */
+#define KEY_UNUSED(p) (((p) & 1) == 0)
+/* Check whether a key is usable.  We cannot reuse an allocated key if
+   the sequence counter would overflow after the next destroy call.
+   This would mean that we potentially free memory for a key with the
+   same sequence.  This is *very* unlikely to happen, A program would
+   have to create and destroy a key 2^31 times (on 32-bit platforms,
+   on 64-bit platforms that would be 2^63).  If it should happen we
+   simply don't use this specific key anymore.  */
+#define KEY_USABLE(p) (((uintptr_t) (p)) < ((uintptr_t) ((p) + 2)))
+
+
+/* Handling of read-write lock data.  */
+// XXX For now there is only one flag.  Maybe more in future.
+#define RWLOCK_RECURSIVE(rwlock) ((rwlock)->__data.__flags != 0)
+
+
+/* Semaphore variable structure.  */
+struct new_sem
+{
+  unsigned int value;
+  int private;
+  unsigned long int nwaiters;
+};
+
+struct old_sem
+{
+  unsigned int value;
+};
+
+
+/* Compatibility type for old conditional variable interfaces.  */
+typedef struct
+{
+  pthread_cond_t *cond;
+} pthread_cond_2_0_t;
+
+#endif	/* internaltypes.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/jmp-unwind.c
@@ -0,0 +1,38 @@
+/* Clean up stack frames unwound by longjmp.  Linux version.
+   Copyright (C) 1995-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <setjmp.h>
+#include <stddef.h>
+#include <pthreadP.h>
+
+extern void __pthread_cleanup_upto (__jmp_buf env, char *targetframe);
+#pragma weak __pthread_cleanup_upto
+
+
+void
+_longjmp_unwind (jmp_buf env, int val)
+{
+#ifdef SHARED
+  if (__libc_pthread_functions_init)
+    PTHFCT_CALL (ptr___pthread_cleanup_upto, (env->__jmpbuf,
+					      CURRENT_STACK_FRAME));
+#else
+  if (__pthread_cleanup_upto != NULL)
+    __pthread_cleanup_upto (env->__jmpbuf, CURRENT_STACK_FRAME);
+#endif
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/kernel-posix-timers.h
@@ -0,0 +1,138 @@
+/* Copyright (C) 2003, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <pthread.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <sys/types.h>
+
+
+/* Nonzero if the system calls are not available.  */
+extern int __no_posix_timers attribute_hidden;
+
+/* Callback to start helper thread.  */
+extern void __start_helper_thread (void) attribute_hidden;
+
+/* Control variable for helper thread creation.  */
+extern pthread_once_t __helper_once attribute_hidden;
+
+/* TID of the helper thread.  */
+extern pid_t __helper_tid attribute_hidden;
+
+/* List of active SIGEV_THREAD timers.  */
+extern struct timer *__active_timer_sigev_thread attribute_hidden;
+/* Lock for the __active_timer_sigev_thread.  */
+extern pthread_mutex_t __active_timer_sigev_thread_lock attribute_hidden;
+
+
+/* Type of timers in the kernel.  */
+typedef int kernel_timer_t;
+
+
+/* Internal representation of timer.  */
+struct timer
+{
+  /* Notification mechanism.  */
+  int sigev_notify;
+
+  /* Timer ID returned by the kernel.  */
+  kernel_timer_t ktimerid;
+
+  /* All new elements must be added after ktimerid.  And if the thrfunc
+     element is not the third element anymore the memory allocation in
+     timer_create needs to be changed.  */
+
+  /* Parameters for the thread to be started for SIGEV_THREAD.  */
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+  pthread_attr_t attr;
+
+  /* Next element in list of active SIGEV_THREAD timers.  */
+  struct timer *next;
+};
+
+extern struct timer *__all_timers[TIMER_MAX];
+
+static inline struct timer *
+__kfreebsd_timer_alloc (void)
+{
+  unsigned int i;
+  struct timer *timer = malloc (sizeof (struct timer));
+  
+  if (timer == NULL)
+      goto fail;
+
+  /* Find a free slot (and reserve it atomically).  */
+  for (i = 0; i < TIMER_MAX; i++)
+    if (atomic_compare_and_exchange_val_acq (&__all_timers[i],
+					     timer, NULL) == NULL)
+      return timer;
+      
+  free (timer);    
+
+fail:
+  errno = EAGAIN;
+  return NULL;
+}
+
+static inline struct timer *
+__kfreebsd_timer_id2ptr (timer_t id)
+{
+  void *ret = NULL;
+
+  if (id >= 0 && id < TIMER_MAX)
+    ret = __all_timers[id];
+
+  if (! ret)
+    errno = EINVAL;
+
+  return ret;
+}
+
+static inline timer_t
+__kfreebsd_timer_ptr2id (struct timer *ptr)
+{
+  unsigned int i;
+  for (i = 0; i < TIMER_MAX; i++)
+    if (__all_timers[i] == ptr)
+      return i;
+
+  return -1;
+}
+
+void static inline
+__kfreebsd_timer_free (struct timer *ptr)
+{
+  __all_timers[__kfreebsd_timer_ptr2id (ptr)] = NULL;
+  free (ptr);
+}
+
+/* used syscalls */
+
+int __syscall_ktimer_create (clockid_t clockid, struct sigevent *evp, kernel_timer_t *timerid);
+int __syscall_ktimer_delete (kernel_timer_t timerid);
+int __syscall_ktimer_getoverrun (kernel_timer_t timerid);
+int __syscall_ktimer_gettime (kernel_timer_t timerid, struct itimerspec *value);
+int __syscall_ktimer_settime (kernel_timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);
+
+libc_hidden_proto (__syscall_ktimer_create)
+libc_hidden_proto (__syscall_ktimer_delete)
+libc_hidden_proto (__syscall_ktimer_getoverrun)
+libc_hidden_proto (__syscall_ktimer_gettime)
+libc_hidden_proto (__syscall_ktimer_settime)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/libc-lowlevellock.c
@@ -0,0 +1,20 @@
+/* Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* No difference to lowlevellock.c, except we lose a couple of functions.  */
+#include <lowlevellock.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/libc_multiple_threads.c
@@ -0,0 +1,28 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <pthreadP.h>
+
+#if IS_IN (libc)
+# ifndef TLS_MULTIPLE_THREADS_IN_TCB
+/* Variable set to a nonzero value either if more than one thread runs or ran,
+   or if a single-threaded process is trying to cancel itself.  See
+   nptl/descr.h for more context on the single-threaded process case.  */
+int __libc_multiple_threads attribute_hidden;
+# endif
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/libc_pthread_init.c
@@ -0,0 +1,85 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <unistd.h>
+#include <list.h>
+#include <fork.h>
+#include <dl-sysdep.h>
+#include <tls.h>
+#include <string.h>
+#include <pthreadP.h>
+#include <libc-lock.h>
+#include <sysdep.h>
+#include <ldsodefs.h>
+
+
+#ifdef TLS_MULTIPLE_THREADS_IN_TCB
+void
+#else
+extern int __libc_multiple_threads attribute_hidden;
+
+int *
+#endif
+internal_function
+__libc_pthread_init (unsigned long int *ptr, void (*reclaim) (void),
+		     const struct pthread_functions *functions)
+{
+  /* Remember the pointer to the generation counter in libpthread.  */
+  __fork_generation_pointer = ptr;
+
+  /* Called by a child after fork.  */
+  __register_atfork (NULL, NULL, reclaim, NULL);
+
+#ifdef SHARED
+  /* Copy the function pointers into an array in libc.  This enables
+     access with just one memory reference but moreso, it prevents
+     hijacking the function pointers with just one pointer change.  We
+     "encrypt" the function pointers since we cannot write-protect the
+     array easily enough.  */
+  union ptrhack
+  {
+    struct pthread_functions pf;
+# define NPTRS (sizeof (struct pthread_functions) / sizeof (void *))
+    void *parr[NPTRS];
+  } __attribute__ ((may_alias)) const *src;
+  union ptrhack *dest;
+
+  src = (const void *) functions;
+  dest = (void *) &__libc_pthread_functions;
+
+  for (size_t cnt = 0; cnt < NPTRS; ++cnt)
+    {
+      void *p = src->parr[cnt];
+      PTR_MANGLE (p);
+      dest->parr[cnt] = p;
+    }
+  __libc_pthread_functions_init = 1;
+#endif
+
+#ifndef TLS_MULTIPLE_THREADS_IN_TCB
+  return &__libc_multiple_threads;
+#endif
+}
+
+#ifdef SHARED
+libc_freeres_fn (freeres_libptread)
+{
+  if (__libc_pthread_functions_init)
+    PTHFCT_CALL (ptr_freeres, ());
+}
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/lowlevellock.c
@@ -0,0 +1,129 @@
+/* low level locking for pthread library.  Generic futex-using version.
+   Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <lowlevellock.h>
+#include <sys/time.h>
+
+void
+__lll_lock_wait_private (int *futex)
+{
+  do
+    {
+      int oldval = atomic_compare_and_exchange_val_acq (futex, 2, 1);
+      if (oldval != 0)
+	lll_futex_wait (futex, 2, LLL_PRIVATE);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+}
+
+
+/* These functions don't get included in libc.so  */
+#if IS_IN (libpthread)
+void
+__lll_lock_wait_shared (int *futex)
+{
+  do
+    {
+      int oldval = atomic_compare_and_exchange_val_acq (futex, 2, 1);
+      if (oldval != 0)
+	lll_futex_wait (futex, 2, LLL_SHARED);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+}
+
+
+int
+__lll_timedlock_wait (int *futex, const struct timespec *abstime, int private)
+{
+  struct timespec rt;
+
+  /* Reject invalid timeouts.  */
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+    return EINVAL;
+
+  /* Upgrade the lock.  */
+  if (atomic_exchange_acq (futex, 2) == 0)
+    return 0;
+
+  do
+    {
+      struct timeval tv;
+
+      /* Get the current time.  */
+      (void) __gettimeofday (&tv, NULL);
+
+      /* Compute relative timeout.  */
+      rt.tv_sec = abstime->tv_sec - tv.tv_sec;
+      rt.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
+      if (rt.tv_nsec < 0)
+	{
+	  rt.tv_nsec += 1000000000;
+	  --rt.tv_sec;
+	}
+
+      /* Already timed out?  */
+      if (rt.tv_sec < 0)
+	return ETIMEDOUT;
+
+      // XYZ: Lost the lock to check whether it was private.
+      lll_futex_timed_wait (futex, 2, &rt, private);
+    }
+  while (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0);
+
+  return 0;
+}
+
+int
+__lll_timedwait_tid (long *tidp, const struct timespec *abstime)
+{
+  long tid;
+
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+    return EINVAL;
+
+  /* Repeat until thread terminated.  */
+  while ((tid = *tidp) != KTID_TERMINATED)
+    {
+      struct timeval tv;
+      struct timespec rt;
+
+      /* Get the current time.  */
+      (void) __gettimeofday (&tv, NULL);
+
+      /* Compute relative timeout.  */
+      rt.tv_sec = abstime->tv_sec - tv.tv_sec;
+      rt.tv_nsec = abstime->tv_nsec - tv.tv_usec * 1000;
+      if (rt.tv_nsec < 0)
+	{
+	  rt.tv_nsec += 1000000000;
+	  --rt.tv_sec;
+	}
+
+      /* Already timed out?  */
+      if (rt.tv_sec < 0)
+	return ETIMEDOUT;
+
+      /* Wait until thread terminates.  */
+      lll_umtx_long_wait_shared (tidp, tid, &rt);
+    }
+
+  return 0;
+}
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/lowlevellock.h
@@ -0,0 +1,167 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  
+   They are the same as linux one's
+ */  
+
+#define FUTEX_PRIVATE_FLAG 128
+
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+#define KTID_TERMINATED 1
+#include <stap-probe.h>
+
+#ifndef __ASSEMBLER__
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <kernel-features.h>
+#include <tcb-offsets.h>
+#include <atomic.h>
+#include <lowlevelumtx.h>
+
+/* Initializer for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+#define LLL_LOCK_INITIALIZER_WAITERS	(2)
+
+#define lll_futex_wait(futex, val, private) \
+  lll_futex_timed_wait(futex, val, NULL, private)
+
+#define lll_futex_timed_wait(futex, val, timeout, private) 		\
+  ({									\
+      int __status;							\
+      if ((private) == LLL_PRIVATE)					\
+          __status = lll_umtx_int_wait_private (futex, val, timeout);	\
+      else     								\
+          __status = lll_umtx_int_wait_shared (futex, val, timeout);	\
+    __status;								\
+  })
+
+#define lll_futex_wake(futex, nr, private) \
+  ({									\
+      int __status;							\
+      if ((private) == LLL_PRIVATE)					\
+          __status = lll_umtx_int_wake_private (futex, nr);		\
+      else     								\
+          __status = lll_umtx_int_wake_shared (futex, nr);		\
+    __status;								\
+  })
+
+#define lll_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 1, 0)
+
+#define lll_cond_trylock(lock)	\
+  atomic_compare_and_exchange_val_acq(&(lock), 2, 0)
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait_shared  (int *futex) attribute_hidden;
+
+#define __lll_lock_wait(futex, private)				\
+  ((void) ({								\
+	if ((private) == LLL_PRIVATE)	      				\
+	  __lll_lock_wait_private (futex);				\
+	else								\
+	  __lll_lock_wait_shared  (futex);				\
+  }))
+
+#define __lll_lock(futex, private)					\
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_compare_and_exchange_val_acq (__futex,       \
+								1, 0), 0))    \
+      {									      \
+	  __lll_lock_wait (__futex, private);				      \
+      }									      \
+  }))
+
+#define lll_lock(futex, private) __lll_lock (&(futex), private)
+
+
+#define __lll_cond_lock(futex, private)					      \
+  ((void) ({								      \
+    int *__futex = (futex);						      \
+    if (__builtin_expect (atomic_exchange_acq (__futex, 2), 0))		      \
+      __lll_lock_wait (__futex, private);				      \
+  }))
+  
+#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+
+#define __lll_timedlock(futex, abstime, private)			      \
+  ({									      \
+     int *__futex = (futex);						      \
+     int __val = 0;							      \
+									      \
+     if (__builtin_expect (atomic_exchange_acq (__futex, 1), 0))	      \
+       __val = __lll_timedlock_wait (__futex, abstime, private);	      \
+     __val;								      \
+  })
+  
+#define lll_timedlock(futex, abstime, private) \
+  __lll_timedlock (&(futex), abstime, private)
+
+
+#define __lll_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval > 1, 0))			\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+    
+#define lll_unlock(futex, private) __lll_unlock(&(futex), private)
+
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+
+/* The kernel notifies a process which uses CLONE_CHILD_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to one (not zero as on linux)
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {					\
+    __typeof (tid) __tid;		\
+    while ((__tid = (tid)) != KTID_TERMINATED)	\
+      lll_umtx_long_wait_shared (&(tid), __tid, NULL);\
+  } while (0)
+
+extern int __lll_timedwait_tid (long *, const struct timespec *)
+     attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != KTID_TERMINATED)			\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+  
+#endif  /* !__ASSEMBLER__ */
+
+#endif	/* lowlevellock.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/lowlevelrwlock.sym
@@ -0,0 +1,16 @@
+#include <stddef.h>
+#include <stdio.h>
+#include <bits/pthreadtypes.h>
+#include <bits/wordsize.h>
+
+--
+
+MUTEX		offsetof (pthread_rwlock_t, __data.__lock)
+NR_READERS	offsetof (pthread_rwlock_t, __data.__nr_readers)
+READERS_WAKEUP	offsetof (pthread_rwlock_t, __data.__readers_wakeup)
+WRITERS_WAKEUP	offsetof (pthread_rwlock_t, __data.__writer_wakeup)
+READERS_QUEUED	offsetof (pthread_rwlock_t, __data.__nr_readers_queued)
+WRITERS_QUEUED	offsetof (pthread_rwlock_t, __data.__nr_writers_queued)
+FLAGS		offsetof (pthread_rwlock_t, __data.__flags)
+WRITER		offsetof (pthread_rwlock_t, __data.__writer)
+PSHARED		offsetof (pthread_rwlock_t, __data.__shared)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pt-fork.c
@@ -0,0 +1,27 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <unistd.h>
+
+
+pid_t
+__fork (void)
+{
+  return __libc_fork ();
+}
+strong_alias (__fork, fork)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pt-raise.c
@@ -0,0 +1,54 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <tls.h>
+#include <kernel-features.h>
+
+
+int
+raise (int sig)
+{
+  /* raise is an async-safe function.  It could be called while the
+     fork function temporarily invalidated the PID field.  Adjust for
+     that.  */
+     
+#if 1
+#warning TODO recheck
+  long ktid;
+  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  if (__builtin_expect (pid < 0, 0))
+  {
+      /* This system call is not supposed to fail.  */
+      INLINE_SYSCALL(thr_self, 1, &ktid);
+  } 
+  else
+      ktid = THREAD_GETMEM (THREAD_SELF, tid);
+
+  return INLINE_SYSCALL(thr_kill, 2, ktid, sig);
+#else
+  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  if (__builtin_expect (pid < 0, 0))
+    pid = -pid;
+
+  return INLINE_SYSCALL (tgkill, 3, pid, THREAD_GETMEM (THREAD_SELF, tid),
+			 sig);
+#endif
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_attr_getaffinity.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <pthreadP.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/types.h>
+#include <shlib-compat.h>
+
+
+int
+__pthread_attr_getaffinity_new (const pthread_attr_t *attr, size_t cpusetsize,
+				cpu_set_t *cpuset)
+{
+  const struct pthread_attr *iattr;
+
+  assert (sizeof (*attr) >= sizeof (struct pthread_attr));
+  iattr = (const struct pthread_attr *) attr;
+
+  if (iattr->cpuset != NULL)
+    {
+      /* Check whether there are any bits set beyond the limits
+	 the user requested.  */
+      for (size_t cnt = cpusetsize; cnt < iattr->cpusetsize; ++cnt)
+	if (((char *) iattr->cpuset)[cnt] != 0)
+	  return EINVAL;
+
+      /* Copy over the cpuset from the thread attribute object.  Limit the copy
+	 to the minimum of the source and destination sizes to prevent a buffer
+	 overrun.  If the destination is larger, fill the remaining space with
+	 zeroes.  */
+      void *p = mempcpy (cpuset, iattr->cpuset,
+			 MIN (iattr->cpusetsize, cpusetsize));
+      if (cpusetsize > iattr->cpusetsize)
+	memset (p, '\0', cpusetsize - iattr->cpusetsize);
+    }
+  else
+    /* We have no information.  */
+    memset (cpuset, -1, cpusetsize);
+
+  return 0;
+}
+versioned_symbol (libpthread, __pthread_attr_getaffinity_new,
+		  pthread_attr_getaffinity_np, GLIBC_2_3_4);
+
+
+#if SHLIB_COMPAT (libpthread, GLIBC_2_3_3, GLIBC_2_3_4)
+/* The old interface have not been really exposed  */
+strong_alias (__pthread_attr_getaffinity_new, __pthread_attr_getaffinity_old)
+compat_symbol (libpthread, __pthread_attr_getaffinity_old,
+	       pthread_attr_getaffinity_np, GLIBC_2_3_3);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_attr_setaffinity.c
@@ -0,0 +1,76 @@
+/* Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthreadP.h>
+#include <shlib-compat.h>
+
+
+
+
+int
+__pthread_attr_setaffinity_new (pthread_attr_t *attr, size_t cpusetsize,
+				const cpu_set_t *cpuset)
+{
+  struct pthread_attr *iattr;
+
+  assert (sizeof (*attr) >= sizeof (struct pthread_attr));
+  iattr = (struct pthread_attr *) attr;
+
+  if (cpuset == NULL || cpusetsize == 0)
+    {
+      free (iattr->cpuset);
+      iattr->cpuset = NULL;
+      iattr->cpusetsize = 0;
+    }
+  else
+    {
+      int ret = check_cpuset_attr (cpuset, cpusetsize);
+
+      if (ret)
+        return ret;
+
+      if (iattr->cpusetsize != cpusetsize)
+	{
+	  void *newp = (cpu_set_t *) realloc (iattr->cpuset, cpusetsize);
+	  if (newp == NULL)
+	    return ENOMEM;
+
+	  iattr->cpuset = newp;
+	  iattr->cpusetsize = cpusetsize;
+	}
+
+      memcpy (iattr->cpuset, cpuset, cpusetsize);
+    }
+
+  return 0;
+}
+versioned_symbol (libpthread, __pthread_attr_setaffinity_new,
+		  pthread_attr_setaffinity_np, GLIBC_2_3_4);
+
+
+#if SHLIB_COMPAT (libpthread, GLIBC_2_3_3, GLIBC_2_3_4)
+/* The old interface have not been really exposed  */
+strong_alias (__pthread_attr_setaffinity_new, __pthread_attr_setaffinity_old)
+compat_symbol (libpthread, __pthread_attr_setaffinity_old,
+	       pthread_attr_setaffinity_np, GLIBC_2_3_3);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_getaffinity.c
@@ -0,0 +1,67 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <limits.h>
+#include <pthreadP.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/param.h>
+#include <sys/types.h>
+#include <shlib-compat.h>
+
+#include "../cpuset-kern.h"
+
+int
+__pthread_getaffinity_new (pthread_t th, size_t cpusetsize, cpu_set_t *cpuset)
+{
+  const struct pthread *pd = (const struct pthread *) th;
+  int64_t id = pd->tid;
+  int res;
+  
+  if (cpusetsize > sizeof(cpu_set_t))
+    {
+      /* Clean the rest of the memory the kernel won't do.  */
+      memset ((char *) cpuset + sizeof(cpu_set_t), '\0', cpusetsize - sizeof(cpu_set_t));
+
+      cpusetsize = sizeof(cpu_set_t);
+    }
+
+  res = INLINE_SYSCALL (cpuset_getaffinity, 5, CPU_LEVEL_WHICH,
+			CPU_WHICH_TID, id, cpusetsize, cpuset);
+
+  if (res == 0)
+      return 0;
+      
+  if (errno == ERANGE)
+    {
+      return EINVAL;
+    }
+  
+  return errno;
+}
+strong_alias (__pthread_getaffinity_new, __pthread_getaffinity_np)
+versioned_symbol (libpthread, __pthread_getaffinity_new,
+		  pthread_getaffinity_np, GLIBC_2_3_4);
+
+
+#if SHLIB_COMPAT (libpthread, GLIBC_2_3_3, GLIBC_2_3_4)
+/* The old interface have not been really exposed  */
+strong_alias (__pthread_getaffinity_new, __pthread_getaffinity_old)
+compat_symbol (libpthread, __pthread_getaffinity_old, pthread_getaffinity_np,
+	       GLIBC_2_3_3);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_getcpuclockid.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <time.h>
+#include <unistd.h>
+#include <kernel-features.h>
+#include <pthreadP.h>
+#include <tls.h>
+
+int
+pthread_getcpuclockid (pthread_t threadid, clockid_t *clockid)
+{
+  struct pthread *pd = (struct pthread *) threadid;
+
+  /* Make sure the descriptor is valid.  */
+  if (INVALID_TD_P (pd))
+    /* Not a valid thread handle.  */
+    return ESRCH;
+
+  return INLINE_SYSCALL(clock_getcpuclockid2, 3, pd->tid, CPUCLOCK_WHICH_TID, clockid);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_getname.c
@@ -0,0 +1,47 @@
+/* pthread_getname_np -- Get  thread name.
+   Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthreadP.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ptrace.h>
+
+int
+pthread_getname_np (pthread_t th, char *buf, size_t len)
+{
+  const struct pthread *pd = (const struct pthread *) th;
+  struct ptrace_lwpinfo ti;
+  int res;
+  
+  ti.pl_tdname[0] = 0;
+  res = ptrace(PT_LWPINFO, pd->tid, (caddr_t)&ti, sizeof(struct ptrace_lwpinfo));
+
+  if (res != 0)
+      return errno;
+
+  res = strlen(ti.pl_tdname);
+
+  if (len < (res+1))
+      return ERANGE;
+      
+  memcpy(buf, ti.pl_tdname, res+1);
+  return 0;    
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_getschedparam.c
@@ -0,0 +1,77 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <string.h>
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+
+int
+__pthread_getschedparam (pthread_t threadid, int *policy,
+			 struct sched_param *param)
+{
+  struct pthread *pd = (struct pthread *) threadid;
+
+  /* Make sure the descriptor is valid.  */
+  if (INVALID_TD_P (pd))
+    /* Not a valid thread handle.  */
+    return ESRCH;
+
+  int result = 0;
+#if 1
+#warning TODO scheduling 
+  *policy = SCHED_OTHER;
+  param->__sched_priority = 0;
+#else
+  
+  lll_lock (pd->lock, LLL_PRIVATE);
+
+  /* The library is responsible for maintaining the values at all
+     times.  If the user uses a interface other than
+     pthread_setschedparam to modify the scheduler setting it is not
+     the library's problem.  In case the descriptor's values have
+     not yet been retrieved do it now.  */
+  if ((pd->flags & ATTR_FLAG_SCHED_SET) == 0)
+    {
+      if (__sched_getparam (pd->tid, &pd->schedparam) != 0)
+	result = 1;
+      else
+	pd->flags |= ATTR_FLAG_SCHED_SET;
+    }
+
+  if ((pd->flags & ATTR_FLAG_POLICY_SET) == 0)
+    {
+      pd->schedpolicy = __sched_getscheduler (pd->tid);
+      if (pd->schedpolicy == -1)
+	result = 1;
+      else
+	pd->flags |= ATTR_FLAG_POLICY_SET;
+    }
+
+  if (result == 0)
+    {
+      *policy = pd->schedpolicy;
+      memcpy (param, &pd->schedparam, sizeof (struct sched_param));
+    }
+
+  lll_unlock (pd->lock, LLL_PRIVATE);
+#endif
+  return result;
+}
+strong_alias (__pthread_getschedparam, pthread_getschedparam)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_kill.c
@@ -0,0 +1,67 @@
+/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <pthreadP.h>
+#include <tls.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+
+int
+__pthread_kill (pthread_t threadid, int signo)
+{
+  struct pthread *pd = (struct pthread *) threadid;
+
+  /* Make sure the descriptor is valid.  */
+  if (DEBUGGING_P && INVALID_TD_P (pd))
+    /* Not a valid thread handle.  */
+    return ESRCH;
+
+  /* Force load of pd->tid into local variable or register.  Otherwise
+     if a thread exits between ESRCH test and tgkill, we might return
+     EINVAL, because pd->tid would be cleared by the kernel.  */
+  pid_t tid = atomic_forced_read (pd->tid);
+  if (__builtin_expect (tid <= KTID_TERMINATED, 0))
+    /* Not a valid thread handle.  */
+    return ESRCH;
+
+  /* Disallow sending the signal we use for cancellation, timers,
+     for the setxid implementation.  */
+  if (signo == SIGCANCEL || signo == SIGTIMER || signo == SIGSETXID)
+    return EINVAL;
+    
+  /* We have a special syscall to do the work.  */
+
+  /* One comment: The PID field in the TCB can temporarily be changed
+     (in fork).  But this must not affect this code here.  Since this
+     function would have to be called while the thread is executing
+     fork, it would have to happen in a signal handler.  But this is
+     no allowed, pthread_kill is not guaranteed to be async-safe.  */
+     
+  /* the KTID field in the TCB can be wrong under FreeBSD
+     a) before __pthread_initialize_minimal is finished (with libpthread)
+     b) in child just after fork
+     c) in single threaded program (no libpthread at all) 
+
+     In these situations no other thread can exist.
+   */
+  return INLINE_SYSCALL(thr_kill, 2, tid, signo);
+}
+strong_alias (__pthread_kill, pthread_kill)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_mutex_cond_lock.c
@@ -0,0 +1,14 @@
+#include <pthreadP.h>
+
+#define LLL_MUTEX_LOCK(mutex) \
+  lll_cond_lock ((mutex)->__data.__lock, PTHREAD_MUTEX_PSHARED (mutex))
+#define LLL_MUTEX_TRYLOCK(mutex) \
+  lll_cond_trylock ((mutex)->__data.__lock)
+#define LLL_ROBUST_MUTEX_LOCK(mutex, id) \
+  lll_robust_cond_lock ((mutex)->__data.__lock, id, \
+			PTHREAD_ROBUST_MUTEX_PSHARED (mutex))
+#define __pthread_mutex_lock internal_function __pthread_mutex_cond_lock
+#define __pthread_mutex_lock_full __pthread_mutex_cond_lock_full
+#define NO_INCR
+
+#include <fbtl/pthread_mutex_lock.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_once.c
@@ -0,0 +1,129 @@
+/* Copyright (C) 2003-2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "pthreadP.h"
+#include <lowlevellock.h>
+#include <atomic.h>
+
+
+unsigned long int __fork_generation attribute_hidden;
+
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  /* Reset to the uninitialized state here.  We don't need a stronger memory
+     order because we do not need to make any other of our writes visible to
+     other threads that see this value: This function will be called if we
+     get interrupted (see __pthread_once), so all we need to relay to other
+     threads is the state being reset again.  */
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+}
+
+
+/* This is similar to a lock implementation, but we distinguish between three
+   states: not yet initialized (0), initialization finished (2), and
+   initialization in progress (__fork_generation | 1).  If in the first state,
+   threads will try to run the initialization by moving to the second state;
+   the first thread to do so via a CAS on once_control runs init_routine,
+   other threads block.
+   When forking the process, some threads can be interrupted during the second
+   state; they won't be present in the forked child, so we need to restart
+   initialization in the child.  To distinguish an in-progress initialization
+   from an interrupted initialization (in which case we need to reclaim the
+   lock), we look at the fork generation that's part of the second state: We
+   can reclaim iff it differs from the current fork generation.
+   XXX: This algorithm has an ABA issue on the fork generation: If an
+   initialization is interrupted, we then fork 2^30 times (30 bits of
+   once_control are used for the fork generation), and try to initialize
+   again, we can deadlock because we can't distinguish the in-progress and
+   interrupted cases anymore.  */
+int
+__pthread_once (pthread_once_t *once_control, void (*init_routine) (void))
+{
+  while (1)
+    {
+      int oldval, val, newval;
+
+      /* We need acquire memory order for this load because if the value
+         signals that initialization has finished, we need to be see any
+         data modifications done during initialization.  */
+      val = *once_control;
+      atomic_read_barrier();
+      do
+	{
+	  /* Check if the initialization has already been done.  */
+	  if (__glibc_likely ((val & 2) != 0))
+	    return 0;
+
+	  oldval = val;
+	  /* We try to set the state to in-progress and having the current
+	     fork generation.  We don't need atomic accesses for the fork
+	     generation because it's immutable in a particular process, and
+	     forked child processes start with a single thread that modified
+	     the generation.  */
+	  newval = __fork_generation | 1;
+	  /* We need acquire memory order here for the same reason as for the
+	     load from once_control above.  */
+	  val = atomic_compare_and_exchange_val_acq (once_control, newval,
+						     oldval);
+	}
+      while (__glibc_unlikely (val != oldval));
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) != 0)
+	{
+	  /* Check whether the initializer execution was interrupted by a
+	     fork.  We know that for both values, bit 0 is set and bit 1 is
+	     not.  */
+	  if (oldval == newval)
+	    {
+	      /* Same generation, some other thread was faster. Wait.  */
+	      lll_futex_wait (once_control, newval, LLL_PRIVATE);
+	      continue;
+	    }
+	}
+
+      /* This thread is the first here.  Do the initialization.
+	 Register a cleanup handler so that in case the thread gets
+	 interrupted the initialization can be restarted.  */
+      pthread_cleanup_push (clear_once_control, once_control);
+
+      init_routine ();
+
+      pthread_cleanup_pop (0);
+
+
+      /* Mark *once_control as having finished the initialization.  We need
+         release memory order here because we need to synchronize with other
+         threads that want to use the initialized data.  */
+      atomic_write_barrier();
+      *once_control = 2;
+
+      /* Wake up all other threads.  */
+      lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+      break;
+    }
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+hidden_def (__pthread_once)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_setaffinity.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <alloca.h>
+#include <errno.h>
+#include <pthreadP.h>
+#include <sysdep.h>
+#include <sys/types.h>
+#include <shlib-compat.h>
+
+#include "../cpuset-kern.h"
+
+
+size_t __kernel_cpumask_size attribute_hidden;
+
+/* Determine the current affinity.  As a side affect we learn
+   about the size of the cpumask_t in the kernel.  */
+int
+__determine_cpumask_size (pid_t tid)
+{
+  /* not yet dynamical */
+  __kernel_cpumask_size = sizeof(cpu_set_t);
+  return 0;
+}
+
+int
+__pthread_setaffinity_new (pthread_t th, size_t cpusetsize,
+			   const cpu_set_t *cpuset)
+{
+  const struct pthread *pd = (const struct pthread *) th;
+  int64_t id = pd->tid;
+  int res;
+
+  res = INLINE_SYSCALL (cpuset_setaffinity, 5, CPU_LEVEL_WHICH,
+			CPU_WHICH_TID, id, cpusetsize, cpuset);
+
+  if (res == 0)
+      return 0;
+      
+  if ((errno == ERANGE) || (errno == EDEADLK))
+    {
+      return EINVAL;
+    }
+  
+  return errno;
+}
+versioned_symbol (libpthread, __pthread_setaffinity_new,
+		  pthread_setaffinity_np, GLIBC_2_3_4);
+
+
+#if SHLIB_COMPAT (libpthread, GLIBC_2_3_3, GLIBC_2_3_4)
+/* The old interface have not been really exposed  */
+strong_alias (__pthread_setaffinity_new, __pthread_setaffinity_old)
+compat_symbol (libpthread, __pthread_setaffinity_old, pthread_setaffinity_np,
+	       GLIBC_2_3_3);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_setname.c
@@ -0,0 +1,32 @@
+/* pthread_setname_np -- Set  thread name
+   Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthreadP.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+
+int
+pthread_setname_np (pthread_t th, const char *name)
+{
+  const struct pthread *pd = (const struct pthread *) th;
+
+  return INLINE_SYSCALL(thr_set_name, 2, pd->tid, name);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_setschedparam.c
@@ -0,0 +1,76 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+
+int
+__pthread_setschedparam (pthread_t threadid, int policy,
+			 const struct sched_param *param)
+{
+  struct pthread *pd = (struct pthread *) threadid;
+
+  /* Make sure the descriptor is valid.  */
+  if (INVALID_TD_P (pd))
+    /* Not a valid thread handle.  */
+    return ESRCH;
+
+#if 1
+#warning TODO scheduling
+  return ENOSYS;
+#else
+  int result = 0;
+
+  lll_lock (pd->lock, LLL_PRIVATE);
+
+  struct sched_param p;
+  const struct sched_param *orig_param = param;
+
+  /* If the thread should have higher priority because of some
+     PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority.  */
+  if (__builtin_expect (pd->tpp != NULL, 0)
+      && pd->tpp->priomax > param->sched_priority)
+    {
+      p = *param;
+      p.sched_priority = pd->tpp->priomax;
+      param = &p;
+    }
+
+  /* Try to set the scheduler information.  */
+  if (__builtin_expect (__sched_setscheduler (pd->tid, policy,
+					      param) == -1, 0))
+    result = errno;
+  else
+    {
+      /* We succeeded changing the kernel information.  Reflect this
+	 change in the thread descriptor.  */
+      pd->schedpolicy = policy;
+      memcpy (&pd->schedparam, orig_param, sizeof (struct sched_param));
+      pd->flags |= ATTR_FLAG_SCHED_SET | ATTR_FLAG_POLICY_SET;
+    }
+
+  lll_unlock (pd->lock, LLL_PRIVATE);
+
+  return result;
+#endif
+}
+strong_alias (__pthread_setschedparam, pthread_setschedparam)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_setschedprio.c
@@ -0,0 +1,68 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include <sched.h>
+#include "pthreadP.h"
+#include <lowlevellock.h>
+
+
+int
+pthread_setschedprio (pthread_t threadid, int prio)
+{
+  struct pthread *pd = (struct pthread *) threadid;
+
+  /* Make sure the descriptor is valid.  */
+  if (INVALID_TD_P (pd))
+    /* Not a valid thread handle.  */
+    return ESRCH;
+
+#if 1
+#warning TODO scheduling
+  return ENOSYS;
+#else
+  int result = 0;
+  struct sched_param param;
+  param.sched_priority = prio;
+
+  lll_lock (pd->lock, LLL_PRIVATE);
+
+  /* If the thread should have higher priority because of some
+     PTHREAD_PRIO_PROTECT mutexes it holds, adjust the priority.  */
+  if (__builtin_expect (pd->tpp != NULL, 0) && pd->tpp->priomax > prio)
+    param.sched_priority = pd->tpp->priomax;
+
+  /* Try to set the scheduler information.  */
+  if (__builtin_expect (sched_setparam (pd->tid, &param) == -1, 0))
+    result = errno;
+  else
+    {
+      /* We succeeded changing the kernel information.  Reflect this
+	 change in the thread descriptor.  */
+      param.sched_priority = prio;
+      memcpy (&pd->schedparam, &param, sizeof (struct sched_param));
+      pd->flags |= ATTR_FLAG_SCHED_SET;
+    }
+
+  lll_unlock (pd->lock, LLL_PRIVATE);
+
+  return result;
+#endif  
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_sigmask.c
@@ -0,0 +1,20 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define BUILD_AS_pthread_sigmask
+#include "sigprocmask.c"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/pthread_yield.c
@@ -0,0 +1,29 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <pthread.h>
+#include <sched.h>
+
+
+/* With the 1-on-1 model we implement this function is equivalent to
+   the 'sched_yield' function.  */
+int
+pthread_yield (void)
+{
+  return sched_yield ();
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/raise.c
@@ -0,0 +1,73 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <limits.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <fbtl/pthreadP.h>
+#include <kernel-features.h>
+
+
+int
+raise (int sig)
+{
+#if 1
+#warning TODO recheck
+  long ktid;
+  pid_t pid = THREAD_GETMEM (THREAD_SELF, pid);
+  if (__builtin_expect (pid <= 0, 0))	/* zero is before __pthread_initialize_minimal, i.e. also  no libpthread at all */
+  {
+      /* This system call is not supposed to fail.  */
+      INLINE_SYSCALL(thr_self, 1, &ktid);
+  } 
+  else
+      ktid = THREAD_GETMEM (THREAD_SELF, tid);
+
+  return INLINE_SYSCALL(thr_kill, 2, ktid, sig);
+#else
+  struct pthread *pd = THREAD_SELF;
+  pid_t pid = THREAD_GETMEM (pd, pid);
+  pid_t selftid = THREAD_GETMEM (pd, tid);
+  if (selftid == 0)
+    {
+      /* This system call is not supposed to fail.  */
+#ifdef INTERNAL_SYSCALL
+      INTERNAL_SYSCALL_DECL (err);
+      selftid = INTERNAL_SYSCALL (gettid, err, 0);
+#else
+      selftid = INLINE_SYSCALL (gettid, 0);
+#endif
+      THREAD_SETMEM (pd, tid, selftid);
+
+      /* We do not set the PID field in the TID here since we might be
+	 called from a signal handler while the thread executes fork.  */
+      pid = selftid;
+    }
+  else
+    /* raise is an async-safe function.  It could be called while the
+       fork/vfork function temporarily invalidated the PID field.  Adjust for
+       that.  */
+    if (__builtin_expect (pid <= 0, 0))
+      pid = (pid & INT_MAX) == 0 ? selftid : -pid;
+
+  return INLINE_SYSCALL (tgkill, 3, pid, selftid, sig);
+#endif  
+}
+libc_hidden_def (raise)
+weak_alias (raise, gsignal)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/register-atfork.c
@@ -0,0 +1,142 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fork.h>
+#include <atomic.h>
+
+
+/* Lock to protect allocation and deallocation of fork handlers.  */
+int __fork_lock = LLL_LOCK_INITIALIZER;
+
+
+/* Number of pre-allocated handler entries.  */
+#define NHANDLER 48
+
+/* Memory pool for fork handler structures.  */
+static struct fork_handler_pool
+{
+  struct fork_handler_pool *next;
+  struct fork_handler mem[NHANDLER];
+} fork_handler_pool;
+
+
+static struct fork_handler *
+fork_handler_alloc (void)
+{
+  struct fork_handler_pool *runp = &fork_handler_pool;
+  struct fork_handler *result = NULL;
+  unsigned int i;
+
+  do
+    {
+      /* Search for an empty entry.  */
+      for (i = 0; i < NHANDLER; ++i)
+	if (runp->mem[i].refcntr == 0)
+	  goto found;
+    }
+  while ((runp = runp->next) != NULL);
+
+  /* We have to allocate a new entry.  */
+  runp = (struct fork_handler_pool *) calloc (1, sizeof (*runp));
+  if (runp != NULL)
+    {
+      /* Enqueue the new memory pool into the list.  */
+      runp->next = fork_handler_pool.next;
+      fork_handler_pool.next = runp;
+
+      /* We use the last entry on the page.  This means when we start
+	 searching from the front the next time we will find the first
+	 entry unused.  */
+      i = NHANDLER - 1;
+
+    found:
+      result = &runp->mem[i];
+      result->refcntr = 1;
+      result->need_signal = 0;
+    }
+
+  return result;
+}
+
+
+int
+__register_atfork (void (*prepare) (void), void (*parent) (void),
+		   void (*child) (void), void *dso_handle)
+{
+  /* Get the lock to not conflict with other allocations.  */
+  lll_lock (__fork_lock, LLL_PRIVATE);
+
+  struct fork_handler *newp = fork_handler_alloc ();
+
+  if (newp != NULL)
+    {
+      /* Initialize the new record.  */
+      newp->prepare_handler = prepare;
+      newp->parent_handler = parent;
+      newp->child_handler = child;
+      newp->dso_handle = dso_handle;
+
+      __linkin_atfork (newp);
+    }
+
+  /* Release the lock.  */
+  lll_unlock (__fork_lock, LLL_PRIVATE);
+
+  return newp == NULL ? ENOMEM : 0;
+}
+libc_hidden_def (__register_atfork)
+
+
+void
+attribute_hidden
+__linkin_atfork (struct fork_handler *newp)
+{
+  do
+    newp->next = __fork_handlers;
+  while (catomic_compare_and_exchange_bool_acq (&__fork_handlers,
+						newp, newp->next) != 0);
+}
+
+
+libc_freeres_fn (free_mem)
+{
+  /* Get the lock to not conflict with running forks.  */
+  lll_lock (__fork_lock, LLL_PRIVATE);
+
+  /* No more fork handlers.  */
+  __fork_handlers = NULL;
+
+  /* Free eventually alloated memory blocks for the object pool.  */
+  struct fork_handler_pool *runp = fork_handler_pool.next;
+
+  memset (&fork_handler_pool, '\0', sizeof (fork_handler_pool));
+
+  /* Release the lock.  */
+  lll_unlock (__fork_lock, LLL_PRIVATE);
+
+  /* We can free the memory after releasing the lock.  */
+  while (runp != NULL)
+    {
+      struct fork_handler_pool *oldp = runp;
+      runp = runp->next;
+      free (oldp);
+    }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sem_post.c
@@ -0,0 +1,80 @@
+/* sem_post -- post to a POSIX semaphore.  Generic futex-using version.
+   Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <atomic.h>
+#include <errno.h>
+#include <sysdep.h>
+#include <lowlevellock.h>
+#include <internaltypes.h>
+#include <semaphore.h>
+
+#include <shlib-compat.h>
+
+int
+__new_sem_post (sem_t *sem)
+{
+  struct new_sem *isem = (struct new_sem *) sem;
+
+  __typeof (isem->value) cur;
+  do
+    {
+      cur = isem->value;
+      if (isem->value == SEM_VALUE_MAX)
+	{
+	  __set_errno (EOVERFLOW);
+	  return -1;
+	}
+    }
+  while (atomic_compare_and_exchange_bool_rel (&isem->value, cur + 1, cur));
+
+  atomic_full_barrier ();
+  if (isem->nwaiters > 0)
+    {
+      int err = lll_futex_wake (&isem->value, 1,
+				isem->private ^ FUTEX_PRIVATE_FLAG);
+      if (__builtin_expect (err, 0) != 0)
+	{
+	  __set_errno (err);
+	  return -1;
+	}
+    }
+  return 0;
+}
+versioned_symbol (libpthread, __new_sem_post, sem_post, GLIBC_2_1);
+
+
+#if SHLIB_COMPAT (libpthread, GLIBC_2_0, GLIBC_2_1)
+int
+attribute_compat_text_section
+__old_sem_post (sem_t *sem)
+{
+  int *futex = (int *) sem;
+
+  (void) atomic_increment_val (futex);
+  /* We always have to assume it is a shared semaphore.  */
+  int err = lll_futex_wake (futex, 1, LLL_SHARED);
+  if (__builtin_expect (err, 0) != 0)
+    {
+      __set_errno (err);
+      return -1;
+    }
+  return 0;
+}
+compat_symbol (libpthread, __old_sem_post, sem_post, GLIBC_2_0);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sem_timedwait.c
@@ -0,0 +1,116 @@
+/* sem_timedwait -- wait on a semaphore.  Generic futex-using version.
+   Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <lowlevellock.h>
+#include <internaltypes.h>
+#include <semaphore.h>
+
+#include <pthreadP.h>
+#include <shlib-compat.h>
+#include <sys/time.h>
+
+extern void __sem_wait_cleanup (void *arg) attribute_hidden;
+
+/* This is in a seperate function in order to make sure gcc
+   puts the call site into an exception region, and thus the
+   cleanups get properly run.  */
+static int
+__attribute__ ((noinline))
+do_futex_timed_wait (struct new_sem *isem, struct timespec *rt)
+{
+  int err, oldtype = __pthread_enable_asynccancel ();
+
+  err = lll_futex_timed_wait (&isem->value, 0, rt,
+			      isem->private ^ FUTEX_PRIVATE_FLAG);
+
+  __pthread_disable_asynccancel (oldtype);
+  return err;
+}
+
+int
+sem_timedwait (sem_t *sem, const struct timespec *abstime)
+{
+  struct new_sem *isem = (struct new_sem *) sem;
+  int err;
+
+  if (atomic_decrement_if_positive (&isem->value) > 0)
+    return 0;
+
+  if (abstime->tv_nsec < 0 || abstime->tv_nsec >= 1000000000)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  atomic_increment (&isem->nwaiters);
+
+  pthread_cleanup_push (__sem_wait_cleanup, isem);
+
+  while (1)
+    {
+      struct timeval tv;
+      struct timespec rt;
+      int sec, nsec;
+
+      /* Get the current time.  */
+      __gettimeofday (&tv, NULL);
+
+      /* Compute relative timeout.  */
+      sec = abstime->tv_sec - tv.tv_sec;
+      nsec = abstime->tv_nsec - tv.tv_usec * 1000;
+      if (nsec < 0)
+	{
+	  nsec += 1000000000;
+	  --sec;
+	}
+
+      /* Already timed out?  */
+      if (sec < 0)
+	{
+	  __set_errno (ETIMEDOUT);
+	  err = -1;
+	  break;
+	}
+
+      /* Do wait.  */
+      rt.tv_sec = sec;
+      rt.tv_nsec = nsec;
+      err = do_futex_timed_wait(isem, &rt);
+      if (err != 0 && err != EWOULDBLOCK)
+	{
+	  __set_errno (err);
+	  err = -1;
+	  break;
+	}
+
+      if (atomic_decrement_if_positive (&isem->value) > 0)
+	{
+	  err = 0;
+	  break;
+	}
+    }
+
+  pthread_cleanup_pop (0);
+
+  atomic_decrement (&isem->nwaiters);
+
+  return err;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sem_trywait.c
@@ -0,0 +1,49 @@
+/* sem_trywait -- wait on a semaphore.  Generic futex-using version.
+   Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <lowlevellock.h>
+#include <internaltypes.h>
+#include <semaphore.h>
+
+#include <shlib-compat.h>
+
+
+int
+__new_sem_trywait (sem_t *sem)
+{
+  int *futex = (int *) sem;
+  int val;
+
+  if (*futex > 0)
+    {
+      val = atomic_decrement_if_positive (futex);
+      if (val > 0)
+	return 0;
+    }
+
+  __set_errno (EAGAIN);
+  return -1;
+}
+versioned_symbol (libpthread, __new_sem_trywait, sem_trywait, GLIBC_2_1);
+#if SHLIB_COMPAT (libpthread, GLIBC_2_0, GLIBC_2_1)
+strong_alias (__new_sem_trywait, __old_sem_trywait)
+compat_symbol (libpthread, __old_sem_trywait, sem_trywait, GLIBC_2_0);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sem_wait.c
@@ -0,0 +1,122 @@
+/* sem_wait -- wait on a semaphore.  Generic futex-using version.
+   Copyright (C) 2003-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Paul Mackerras <paulus@au.ibm.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sysdep.h>
+#include <lowlevellock.h>
+#include <internaltypes.h>
+#include <semaphore.h>
+
+#include <pthreadP.h>
+#include <shlib-compat.h>
+
+
+void
+attribute_hidden
+__sem_wait_cleanup (void *arg)
+{
+  struct new_sem *isem = (struct new_sem *) arg;
+
+  atomic_decrement (&isem->nwaiters);
+}
+
+/* This is in a seperate function in order to make sure gcc
+   puts the call site into an exception region, and thus the
+   cleanups get properly run.  */
+static int
+__attribute__ ((noinline))
+do_futex_wait (struct new_sem *isem)
+{
+  int err, oldtype = __pthread_enable_asynccancel ();
+
+  err = lll_futex_wait (&isem->value, 0, isem->private ^ FUTEX_PRIVATE_FLAG);
+
+  __pthread_disable_asynccancel (oldtype);
+  return err;
+}
+
+int
+__new_sem_wait (sem_t *sem)
+{
+  struct new_sem *isem = (struct new_sem *) sem;
+  int err;
+
+  if (atomic_decrement_if_positive (&isem->value) > 0)
+    return 0;
+
+  atomic_increment (&isem->nwaiters);
+
+  pthread_cleanup_push (__sem_wait_cleanup, isem);
+
+  while (1)
+    {
+      err = do_futex_wait(isem);
+      if (err != 0 && err != EWOULDBLOCK)
+	{
+	  __set_errno (err);
+	  err = -1;
+	  break;
+	}
+
+      if (atomic_decrement_if_positive (&isem->value) > 0)
+	{
+	  err = 0;
+	  break;
+	}
+    }
+
+  pthread_cleanup_pop (0);
+
+  atomic_decrement (&isem->nwaiters);
+
+  return err;
+}
+versioned_symbol (libpthread, __new_sem_wait, sem_wait, GLIBC_2_1);
+
+
+#if SHLIB_COMPAT (libpthread, GLIBC_2_0, GLIBC_2_1)
+int
+attribute_compat_text_section
+__old_sem_wait (sem_t *sem)
+{
+  int *futex = (int *) sem;
+  int err;
+
+  do
+    {
+      if (atomic_decrement_if_positive (futex) > 0)
+	return 0;
+
+      /* Enable asynchronous cancellation.  Required by the standard.  */
+      int oldtype = __pthread_enable_asynccancel ();
+
+      /* Always assume the semaphore is shared.  */
+      err = lll_futex_wait (futex, 0, LLL_SHARED);
+
+      /* Disable asynchronous cancellation.  */
+      __pthread_disable_asynccancel (oldtype);
+    }
+  while (err == 0 || err == EWOULDBLOCK);
+
+  __set_errno (err);
+  return -1;
+}
+
+compat_symbol (libpthread, __old_sem_wait, sem_wait, GLIBC_2_0);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sigprocmask.c
@@ -0,0 +1,66 @@
+/* Copyright (C) 1997-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <kernel-features.h>
+
+#include <pthreadP.h>
+
+/* Get and/or change the set of blocked signals.  */
+int
+#ifdef BUILD_AS_pthread_sigmask
+pthread_sigmask(int how, const sigset_t *set, sigset_t *oset)
+#else
+__sigprocmask (int how, const sigset_t *set, sigset_t *oset)
+#endif
+{
+  sigset_t local_newmask;
+  int rv;
+
+  /* The only thing we have to make sure here is that SIGCANCEL and
+     SIGSETXID are not blocked.  */
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+	  ))
+    {
+      local_newmask = *set;
+      __sigdelset (&local_newmask, SIGCANCEL);
+      __sigdelset (&local_newmask, SIGSETXID);
+      set = &local_newmask;
+    }
+
+  rv = INLINE_SYSCALL (sigprocmask, 3, how, set, oset);
+#ifdef BUILD_AS_pthread_sigmask
+  return rv;
+}  
+#else
+  if (rv)
+  {
+      errno = rv;
+      return -1;
+  }
+  return 0;        
+}
+weak_alias (__sigprocmask, sigprocmask)
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sigtimedwait.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 1997-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#include <string.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <fbtl/pthreadP.h>
+
+static int
+do_sigtimedwait (const sigset_t *set, siginfo_t *info,
+		 const struct timespec *timeout)
+{
+#ifdef SIGCANCEL
+  sigset_t tmpset;
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+# ifdef SIGSETXID
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+# endif
+	  ))
+    {
+      /* Create a temporary mask without the bit for SIGCANCEL set.  */
+      tmpset = *set;
+      __sigdelset (&tmpset, SIGCANCEL);
+# ifdef SIGSETXID
+      __sigdelset (&tmpset, SIGSETXID);
+# endif
+      set = &tmpset;
+    }
+#endif
+
+  return INLINE_SYSCALL (sigtimedwait, 3, set, info, timeout);
+}
+
+
+/* Return any pending signal or wait for one for the given time.  */
+int
+__sigtimedwait (const sigset_t *set, siginfo_t *info,
+		const struct timespec *timeout)
+{
+  if (SINGLE_THREAD_P)
+    return do_sigtimedwait (set, info, timeout);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_sigtimedwait (set, info, timeout);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__sigtimedwait)
+weak_alias (__sigtimedwait, sigtimedwait)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sigwait.c
@@ -0,0 +1,76 @@
+/* Copyright (C) 1997-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#define __need_NULL
+#include <stddef.h>
+#include <string.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <fbtl/pthreadP.h>
+
+
+/* Return any pending signal or wait for one for the given time.  */
+static int
+do_sigwait (const sigset_t *set, int *sig)
+{
+  int ret;
+
+#ifdef SIGCANCEL
+  sigset_t tmpset;
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+# ifdef SIGSETXID
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+# endif
+	  ))
+    {
+      /* Create a temporary mask without the bit for SIGCANCEL set.  */
+      tmpset = *set;
+      __sigdelset (&tmpset, SIGCANCEL);
+# ifdef SIGSETXID
+      __sigdelset (&tmpset, SIGSETXID);
+# endif
+      set = &tmpset;
+    }
+#endif
+  do {
+      ret = INLINE_SYSCALL (sigwait, 2, set, sig);
+  } while (ret == EINTR);
+  
+  return ret;
+}
+
+int
+__sigwait (const sigset_t *set, int *sig)
+{
+  if (SINGLE_THREAD_P)
+    return do_sigwait (set, sig);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_sigwait (set, sig);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__sigwait)
+weak_alias (__sigwait, sigwait)
+strong_alias (__sigwait, __libc_sigwait)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sigwaitinfo.c
@@ -0,0 +1,72 @@
+/* Copyright (C) 1997-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <signal.h>
+#define __need_NULL
+#include <stddef.h>
+#include <string.h>
+
+#include <sysdep-cancel.h>
+#include <sys/syscall.h>
+#include <fbtl/pthreadP.h>
+
+
+static int
+do_sigwaitinfo (const sigset_t *set, siginfo_t *info)
+{
+#ifdef SIGCANCEL
+  sigset_t tmpset;
+  if (set != NULL
+      && (__builtin_expect (__sigismember (set, SIGCANCEL), 0)
+# ifdef SIGSETXID
+	  || __builtin_expect (__sigismember (set, SIGSETXID), 0)
+# endif
+	  ))
+    {
+      /* Create a temporary mask without the bit for SIGCANCEL set.  */
+      tmpset = *set;
+      __sigdelset (&tmpset, SIGCANCEL);
+# ifdef SIGSETXID
+      __sigdelset (&tmpset, SIGSETXID);
+# endif
+      set = &tmpset;
+    }
+#endif
+
+  return INLINE_SYSCALL (sigwaitinfo, 2, set, info);
+}
+
+
+/* Return any pending signal or wait for one for the given time.  */
+int
+__sigwaitinfo (const sigset_t *set, siginfo_t *info)
+{
+  if (SINGLE_THREAD_P)
+    return do_sigwaitinfo (set, info);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = do_sigwaitinfo (set, info);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__sigwaitinfo)
+weak_alias (__sigwaitinfo, sigwaitinfo)
+strong_alias (__sigwaitinfo, __libc_sigwaitinfo)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sleep.c
@@ -0,0 +1,2 @@
+#include <pthreadP.h>
+#include "../sleep.c"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/smp.h
@@ -0,0 +1,36 @@
+/* Determine whether the host has multiple processors.  FreeBSD version.
+   Copyright (C) 1996, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <sys/sysctl.h>
+
+/* Test whether the machine has more than one processor.  */
+static inline int
+is_smp_system (void)
+{
+  /* Fetch sysctl value of "hw.ncpu".  */
+  int request[] = { CTL_HW, HW_NCPU };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 0;
+
+  return (result > 1);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/structsem.sym
@@ -0,0 +1,12 @@
+#include <limits.h>
+#include <stddef.h>
+#include <sched.h>
+#include <bits/pthreadtypes.h>
+#include "internaltypes.h"
+
+--
+
+VALUE		offsetof (struct new_sem, value)
+PRIVATE		offsetof (struct new_sem, private)
+NWAITERS	offsetof (struct new_sem, nwaiters)
+SEM_VALUE_MAX	SEM_VALUE_MAX
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/sysconf.c
@@ -0,0 +1,70 @@
+/* Get file-specific information about a file.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sysdep.h>
+#include <time.h>
+#include <unistd.h>
+#include <hp-timing.h>
+#include <sys/sysctl.h>
+
+static long int posix_sysconf (int name);
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  int request[2];
+  int value;
+  size_t len = sizeof(value);
+
+  switch(name)
+    {
+      case _SC_CPUTIME:
+      case _SC_THREAD_CPUTIME:
+      {
+        clockid_t clock_id;
+        /* try whether we have a syscall available */ 
+        if ( ENOSYS != INLINE_SYSCALL(clock_getcpuclockid2, 3, 0, CPUCLOCK_WHICH_TID, &clock_id))
+	  return 200809L;
+	else
+	  return -1;
+      }  
+      case _SC_NGROUPS_MAX:
+	request[0] = CTL_KERN;
+	request[1] = KERN_NGROUPS;
+	if (__sysctl(request, 2, &value, &len, NULL, 0) == -1)
+	    return NGROUPS_MAX;
+	return (long)value;
+      case _SC_ARG_MAX:
+	request[0] = CTL_KERN;
+	request[1] = KERN_ARGMAX;
+	if (__sysctl(request, 2, &value, &len, NULL, 0) == -1)
+	    return ARG_MAX;
+	return (long)value;
+    }
+  return posix_sysconf (name);
+}
+
+/* Now the POSIX version.  */
+#undef __sysconf
+#define __sysconf static posix_sysconf
+#include <sysdeps/posix/sysconf.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/timer_create.c
@@ -0,0 +1,165 @@
+/* Copyright (C) 2003,2004, 2007, 2009, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include <internaltypes.h>
+#include <fbtl/pthreadP.h>
+#include "kernel-posix-timers.h"
+#include "kernel-posix-cpu-timers.h"
+
+
+int
+timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid)
+{
+    {
+      /* If the user wants notification via a thread we need to handle
+	 this special.  */
+      if (evp == NULL
+	  || __builtin_expect (evp->sigev_notify != SIGEV_THREAD, 1))
+	{
+	  struct sigevent local_evp;
+
+	  struct timer *newp = __kfreebsd_timer_alloc ();
+
+	  if (newp == NULL)
+	    /* No more memory.  */
+	    return -1;
+
+	  if (evp == NULL)
+	    {
+	      /* The kernel has to pass up the timer ID which is a
+		 userlevel object.  Therefore we cannot leave it up to
+		 the kernel to determine it.  */
+	      local_evp.sigev_notify = SIGEV_SIGNAL;
+	      local_evp.sigev_signo = SIGALRM;
+	      local_evp.sigev_value.sival_int = __kfreebsd_timer_ptr2id (newp);
+
+	      evp = &local_evp;
+	    }
+
+	  kernel_timer_t ktimerid;
+	  int retval = INLINE_SYSCALL (ktimer_create, 3, clock_id, evp,
+				       &ktimerid);
+
+	    {
+
+	      if (retval != -1)
+		{
+		  newp->sigev_notify = (evp != NULL
+					? evp->sigev_notify : SIGEV_SIGNAL);
+		  newp->ktimerid = ktimerid;
+
+		  *timerid = __kfreebsd_timer_ptr2id (newp);
+		}
+	      else
+		{
+		  /* Cannot allocate the timer, fail.  */
+		  __kfreebsd_timer_free (newp);
+		  retval = -1;
+		}
+
+	      return retval;
+	    }
+	}
+      else
+	{
+	    {
+	      /* Create the helper thread.  */
+	      pthread_once (&__helper_once, __start_helper_thread);
+	      if (__helper_tid == 0)
+		{
+		  /* No resources to start the helper thread.  */
+		  __set_errno (EAGAIN);
+		  return -1;
+		}
+
+	      struct timer *newp;
+	      newp = __kfreebsd_timer_alloc ();
+	      if (newp == NULL)
+		return -1;
+
+	      /* Copy the thread parameters the user provided.  */
+	      newp->sival = evp->sigev_value;
+	      newp->thrfunc = evp->sigev_notify_function;
+	      newp->sigev_notify = SIGEV_THREAD;
+
+	      /* We cannot simply copy the thread attributes since the
+		 implementation might keep internal information for
+		 each instance.  */
+	      (void) pthread_attr_init (&newp->attr);
+	      if (evp->sigev_notify_attributes != NULL)
+		{
+		  struct pthread_attr *nattr;
+		  struct pthread_attr *oattr;
+
+		  nattr = (struct pthread_attr *) &newp->attr;
+		  oattr = (struct pthread_attr *) evp->sigev_notify_attributes;
+
+		  nattr->schedparam = oattr->schedparam;
+		  nattr->schedpolicy = oattr->schedpolicy;
+		  nattr->flags = oattr->flags;
+		  nattr->guardsize = oattr->guardsize;
+		  nattr->stackaddr = oattr->stackaddr;
+		  nattr->stacksize = oattr->stacksize;
+		}
+
+	      /* In any case set the detach flag.  */
+	      (void) pthread_attr_setdetachstate (&newp->attr,
+						  PTHREAD_CREATE_DETACHED);
+
+	      /* Create the event structure for the kernel timer.  */
+	      struct sigevent sev =
+		{ .sigev_value.sival_ptr = newp,
+		  .sigev_signo = SIGTIMER,
+		  .sigev_notify = SIGEV_THREAD_ID,
+		  .sigev_notify_thread_id = __helper_tid,
+		};
+
+	      /* Create the timer.  */
+	      int res;
+	      res = INLINE_SYSCALL (ktimer_create, 3,
+				      clock_id, &sev, &newp->ktimerid);
+	      if (res != -1)
+		{
+		  /* Add to the queue of active timers with thread
+		     delivery.  */
+		  pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+		  newp->next = __active_timer_sigev_thread;
+		  __active_timer_sigev_thread = newp;
+		  pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+
+		  *timerid = __kfreebsd_timer_ptr2id (newp);
+		  return 0;
+		}
+
+	      /* Free the resources.  */
+	      __kfreebsd_timer_free (newp);
+
+	      return -1;
+	    }
+	}
+    }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/timer_delete.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 2003, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+int
+timer_delete (timer_t timerid)
+{
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      int res = INLINE_SYSCALL (ktimer_delete, 1, kt->ktimerid);
+
+      if (res == 0)
+	{
+	  if (kt->sigev_notify == SIGEV_THREAD)
+	    {
+	      /* Remove the timer from the list.  */
+	      pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+	      if (__active_timer_sigev_thread == kt)
+		__active_timer_sigev_thread = kt->next;
+	      else
+		{
+		  struct timer *prevp = __active_timer_sigev_thread;
+		  while (prevp->next != NULL)
+		    if (prevp->next == kt)
+		      {
+			prevp->next = kt->next;
+			break;
+		      }
+		    else
+		      prevp = prevp->next;
+		}
+	      pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+	    }
+
+	  /* Free the memory.  */
+	  (void) __kfreebsd_timer_free (kt);
+
+	  return 0;
+	}
+
+      /* The kernel timer is not known or something else bad happened.
+	 Return the error.  */
+	  return -1;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/timer_getoverr.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+int
+timer_getoverrun (timer_t timerid)
+{
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Get the information from the kernel.  */
+      return INLINE_SYSCALL (ktimer_getoverrun, 1, kt->ktimerid);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/timer_gettime.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+
+int
+timer_gettime (timer_t timerid, struct itimerspec *value)
+{
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Delete the kernel timer object.  */
+      return INLINE_SYSCALL (ktimer_gettime, 2, kt->ktimerid, value);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/timer_routines.c
@@ -0,0 +1,201 @@
+/* Copyright (C) 2003, 2004, 2005, 2006, 2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdbool.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include <fbtl/pthreadP.h>
+#include "kernel-posix-timers.h"
+
+/* NPTL/Linux simply casts "timer_t" to "struct timer *", but on
+   kFreeBSD timer_t may not be large enough to hold a pointer.
+   So we store the pointers here... (sigh) */
+struct timer *__all_timers[TIMER_MAX];
+
+/* List of active SIGEV_THREAD timers.  */
+struct timer *__active_timer_sigev_thread;
+/* Lock for the __active_timer_sigev_thread.  */
+pthread_mutex_t __active_timer_sigev_thread_lock = PTHREAD_MUTEX_INITIALIZER;
+
+
+struct thread_start_data
+{
+  void (*thrfunc) (sigval_t);
+  sigval_t sival;
+};
+
+
+/* Helper thread to call the user-provided function.  */
+static void *
+timer_sigev_thread (void *arg)
+{
+  /* The parent thread has all signals blocked.  This is a bit
+     surprising for user code, although valid.  We unblock all
+     signals.  */
+  sigset_t ss;
+  sigemptyset (&ss);
+
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &ss, NULL);
+
+  struct thread_start_data *td = (struct thread_start_data *) arg;
+
+  void (*thrfunc) (sigval_t) = td->thrfunc;
+  sigval_t sival = td->sival;
+
+  /* The TD object was allocated in timer_helper_thread.  */
+  free (td);
+
+  /* Call the user-provided function.  */
+  thrfunc (sival);
+
+  return NULL;
+}
+
+
+/* Helper function to support starting threads for SIGEV_THREAD.  */
+static void *
+timer_helper_thread (void *arg)
+{
+  /* Wait for the SIGTIMER signal, allowing the setXid signal, and
+     none else.  */
+  sigset_t ss;
+  sigemptyset (&ss);
+  __sigaddset (&ss, SIGTIMER);
+
+  /* Endless loop of waiting for signals.  The loop is only ended when
+     the thread is canceled.  */
+  while (1)
+    {
+      siginfo_t si;
+
+      /* sigwaitinfo cannot be used here, since it deletes
+	 SIGCANCEL == SIGTIMER from the set.  */
+      /* but direct interface to kernel does not do such things */
+
+      int oldtype = LIBC_CANCEL_ASYNC ();
+
+      int result = INLINE_SYSCALL (sigwaitinfo, 2, &ss, &si);
+
+      LIBC_CANCEL_RESET (oldtype);
+
+      if (result > 0)
+	{
+	  if (si.si_code == SI_TIMER)
+	    {
+	      struct timer *tk = (struct timer *) si.si_value.sival_ptr;
+
+	      /* Check the timer is still used and will not go away
+		 while we are reading the values here.  */
+	      pthread_mutex_lock (&__active_timer_sigev_thread_lock);
+
+	      struct timer *runp = __active_timer_sigev_thread;
+	      while (runp != NULL)
+		if (runp == tk)
+		  break;
+		else
+		  runp = runp->next;
+
+	      if (runp != NULL)
+		{
+		  struct thread_start_data *td = malloc (sizeof (*td));
+
+		  /* There is not much we can do if the allocation fails.  */
+		  if (td != NULL)
+		    {
+		      /* This is the signal we are waiting for.  */
+		      td->thrfunc = tk->thrfunc;
+		      td->sival = tk->sival;
+
+		      pthread_t th;
+		      (void) pthread_create (&th, &tk->attr,
+					     timer_sigev_thread, td);
+		    }
+		}
+
+	      pthread_mutex_unlock (&__active_timer_sigev_thread_lock);
+	    }
+	  else if (si.si_code == SI_LWP
+		   /* Backward compatibility (see rev 211732 in -CURRENT).  */
+		   || si.si_code == SI_USER)
+	    /* The thread is canceled.  */
+	    pthread_exit (NULL);
+	}
+    }
+}
+
+
+/* Control variable for helper thread creation.  */
+pthread_once_t __helper_once attribute_hidden;
+
+
+/* TID of the helper thread.  */
+pid_t __helper_tid attribute_hidden;
+
+
+/* Reset variables so that after a fork a new helper thread gets started.  */
+static void
+reset_helper_control (void)
+{
+  __helper_once = PTHREAD_ONCE_INIT;
+  __helper_tid = 0;
+}
+
+
+void
+attribute_hidden
+__start_helper_thread (void)
+{
+  /* The helper thread needs only very little resources
+     and should go away automatically when canceled.  */
+  pthread_attr_t attr;
+  (void) pthread_attr_init (&attr);
+  (void) pthread_attr_setstacksize (&attr, PTHREAD_STACK_MIN);
+
+  /* Block all signals in the helper thread but SIGSETXID.  To do this
+     thoroughly we temporarily have to block all signals here.  The
+     helper can lose wakeups if SIGCANCEL is not blocked throughout,
+     but sigfillset omits it SIGSETXID.  So, we add SIGCANCEL back
+     explicitly here.  */
+  sigset_t ss;
+  sigset_t oss;
+  sigfillset (&ss);
+  __sigaddset (&ss, SIGCANCEL);
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &ss, &oss);
+
+
+  /* Create the helper thread for this timer.  */
+  pthread_t th;
+  int res = pthread_create (&th, &attr, timer_helper_thread, NULL);
+  if (res == 0)
+    /* We managed to start the helper thread.  */
+    __helper_tid = ((struct pthread *) th)->tid;
+
+  /* Restore the signal mask.  */
+  INLINE_SYSCALL (sigprocmask, 3, SIG_SETMASK, &oss, NULL);
+
+  /* No need for the attribute anymore.  */
+  (void) pthread_attr_destroy (&attr);
+
+  /* We have to make sure that after fork()ing a new helper thread can
+     be created.  */
+  pthread_atfork (NULL, NULL, reset_helper_control);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/timer_settime.c
@@ -0,0 +1,39 @@
+/* Copyright (C) 2003, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; see the file COPYING.LIB.  If not,
+   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+#include "kernel-posix-timers.h"
+
+int
+timer_settime (timer_t timerid, int flags, const struct itimerspec *value,
+	       struct itimerspec *ovalue)
+{
+      struct timer *kt = __kfreebsd_timer_id2ptr (timerid);
+      if (! kt)
+	return -1;
+
+      /* Set the kernel timer object.  */
+      return INLINE_SYSCALL (ktimer_settime, 4, kt->ktimerid, flags,
+				value, ovalue);
+
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/unregister-atfork.c
@@ -0,0 +1,120 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <fork.h>
+#include <atomic.h>
+
+
+void
+__unregister_atfork (void *dso_handle)
+{
+  /* Check whether there is any entry in the list which we have to
+     remove.  It is likely that this is not the case so don't bother
+     getting the lock.
+
+     We do not worry about other threads adding entries for this DSO
+     right this moment.  If this happens this is a race and we can do
+     whatever we please.  The program will crash anyway seen.  */
+  struct fork_handler *runp = __fork_handlers;
+  struct fork_handler *lastp = NULL;
+
+  while (runp != NULL)
+    if (runp->dso_handle == dso_handle)
+      break;
+    else
+      {
+	lastp = runp;
+	runp = runp->next;
+      }
+
+  if (runp == NULL)
+    /* Nothing to do.  */
+    return;
+
+  /* Get the lock to not conflict with additions or deletions.  Note
+     that there couldn't have been another thread deleting something.
+     The __unregister_atfork function is only called from the
+     dlclose() code which itself serializes the operations.  */
+  lll_lock (__fork_lock, LLL_PRIVATE);
+
+  /* We have to create a new list with all the entries we don't remove.  */
+  struct deleted_handler
+  {
+    struct fork_handler *handler;
+    struct deleted_handler *next;
+  } *deleted = NULL;
+
+  /* Remove the entries for the DSO which is unloaded from the list.
+     It's a single linked list so readers are.  */
+  do
+    {
+    again:
+      if (runp->dso_handle == dso_handle)
+	{
+	  if (lastp == NULL)
+	    {
+	      /* We have to use an atomic operation here because
+		 __linkin_atfork also uses one.  */
+	      if (catomic_compare_and_exchange_bool_acq (&__fork_handlers,
+							 runp->next, runp)
+		  != 0)
+		{
+		  runp = __fork_handlers;
+		  goto again;
+		}
+	    }
+	  else
+	    lastp->next = runp->next;
+
+	  /* We cannot overwrite the ->next element now.  Put the deleted
+	     entries in a separate list.  */
+	  struct deleted_handler *newp = alloca (sizeof (*newp));
+	  newp->handler = runp;
+	  newp->next = deleted;
+	  deleted = newp;
+	}
+      else
+	lastp = runp;
+
+      runp = runp->next;
+    }
+  while (runp != NULL);
+
+  /* Release the lock.  */
+  lll_unlock (__fork_lock, LLL_PRIVATE);
+
+  /* Walk the list of all entries which have to be deleted.  */
+  while (deleted != NULL)
+    {
+      /* We need to be informed by possible current users.  */
+      deleted->handler->need_signal = 1;
+      /* Make sure this gets written out first.  */
+      atomic_write_barrier ();
+
+      /* Decrement the reference counter.  If it does not reach zero
+	 wait for the last user.  */
+      atomic_decrement (&deleted->handler->refcntr);
+      unsigned int val;
+      while ((val = deleted->handler->refcntr) != 0)
+	lll_futex_wait (&deleted->handler->refcntr, val, LLL_PRIVATE);
+
+      deleted = deleted->next;
+    }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fbtl/unwindbuf.sym
@@ -0,0 +1,7 @@
+#include <pthread.h>
+#include <stddef.h>
+
+--
+
+UNWINDBUFSIZE	sizeof (__pthread_unwind_buf_t)
+UWJMPBUF	offsetof (__pthread_unwind_buf_t, __cancel_jmp_buf)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fcntl.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2000, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <assert.h>
+#include <errno.h>
+#include <sysdep-cancel.h>	/* Must come before <fcntl.h>.  */
+#include <fcntl.h>
+#include <stdarg.h>
+
+#include <sys/syscall.h>
+
+
+#ifndef NO_CANCELLATION
+int
+__fcntl_nocancel (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+}
+#endif
+
+
+int
+__libc_fcntl (int fd, int cmd, ...)
+{
+  va_list ap;
+  void *arg;
+
+  va_start (ap, cmd);
+  arg = va_arg (ap, void *);
+  va_end (ap);
+
+  if (SINGLE_THREAD_P || cmd != F_SETLKW)
+    return INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (fcntl, 3, fd, cmd, arg);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+libc_hidden_def (__libc_fcntl)
+
+weak_alias (__libc_fcntl, __fcntl)
+libc_hidden_weak (__fcntl)
+weak_alias (__libc_fcntl, fcntl)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fdatasync.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <unistd.h>
+#include <sysdep-cancel.h>
+
+int __libc_fsync (int fd);
+libc_hidden_proto (__libc_fsync)
+
+/* Synchronize at least the data part of a file with the underlying
+   media.  */
+int
+fdatasync (int fildes)
+{
+  return __libc_fsync (fildes);
+}
+
+LIBC_CANCEL_HANDLED ();         /* fsync handles our cancellation.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+#include "stat16conv.c"
+
+int
+__fhstat (const fhandle_t *fhp, struct stat *buf)
+{
+  struct stat16 buf16;
+
+  if (__syscall_fhstat (fhp, &buf16) < 0)
+    return -1;
+
+  /* Convert a 'struct stat16' to 'struct stat'.  */
+  stat16_to_stat (&buf16, buf);
+
+  return 0;
+}
+
+weak_alias (__fhstat, fhstat)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstat64.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sysdep.h>
+
+#include "stat16conv.c"
+
+int
+fhstat64 (const fhandle_t *fhp, struct stat64 *buf)
+{
+  struct stat16 buf16;
+
+  if (__syscall_fhstat (fhp, &buf16) < 0)
+    return -1;
+
+  /* Convert a 'struct stat16' to 'struct stat64'.  */
+  stat16_to_stat64 (&buf16, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs.c
@@ -0,0 +1,35 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+
+#include "statfsconv.c"
+
+int
+fhstatfs (const fhandle_t *fhp, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fhstatfs (fhp, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fhstatfs64.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+
+#include "statfsconv.c"
+
+int
+fhstatfs64 (const fhandle_t *fhp, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fhstatfs (fhp, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statfs64'.  */
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs.c
@@ -0,0 +1,38 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs (int fd, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
+weak_alias (__fstatfs, fstatfs)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatfs64.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatfs64 (int fd, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statfs64'.  */
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__fstatfs64, fstatfs64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+fstatvfs (int fd, struct statvfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statvfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_def (fstatvfs)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fstatvfs64.c
@@ -0,0 +1,41 @@
+/* Return information about the filesystem on which FD resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FD resides.  */
+int
+__fstatvfs64 (int fd, struct statvfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_fstatfs (fd, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
+  statfs5_to_statvfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__fstatvfs64, fstatvfs64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ftruncate64.c
@@ -0,0 +1 @@
+/* 'ftruncate64' is the same as 'ftruncate', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/futimesat.c
@@ -0,0 +1,44 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/time.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_futimesat (int fd, const char *path,
+				const struct timeval *times);
+libc_hidden_proto (__syscall_futimesat)
+
+/* Change the access time of FILE relative to FD to TVP[0] and
+   the modification time of FILE to TVP[1].  */
+int
+futimesat (int fd, const char *file, const struct timeval tvp[2])
+{
+      if (file == NULL)
+	return __futimes (fd, tvp);
+
+      return INLINE_SYSCALL (futimesat, 3, fd, file, tvp);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat.c
@@ -0,0 +1,47 @@
+/* fxstat using FreeBSD fstat, nfstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include "stat16conv.c"
+
+int
+__fxstat (int vers, int fd, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_fstat (fd, &buf16);
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_fstat (fd, (struct stat16 *) buf);
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__fxstat)
+
+weak_alias (__fxstat, _fxstat)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstat64.c
@@ -0,0 +1,43 @@
+/* fxstat using FreeBSD fstat, nfstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include "stat16conv.c"
+
+int
+__fxstat64 (int vers, int fd, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_fstat (fd, &buf16);
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__fxstat64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstatat.c
@@ -0,0 +1,66 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+#include "stat16conv.c"
+
+extern int __syscall_fstatat (int fd, const char *path,
+			      struct stat16 *buf, int flag);
+libc_hidden_proto (__syscall_fstatat)
+
+/* Get information about the file NAME relative to FD in ST.  */
+int
+__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag)
+{
+      int result;
+
+      if (__builtin_expect (vers == _STAT_VER, 1))
+	{
+	  struct stat16 buf16;
+	  result =
+	    INLINE_SYSCALL (fstatat, 4, fd, file,
+			    &buf16, flag);
+	  if (result == 0)
+	    stat16_to_stat (&buf16, st);
+	}
+      else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+	{
+	  result =
+	    INLINE_SYSCALL (fstatat, 4, fd, file,
+			    (struct stat16 *) st, flag);
+	}
+      else
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+	return result;
+}
+
+libc_hidden_def (__fxstatat)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/fxstatat64.c
@@ -0,0 +1,60 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+#include "stat16conv.c"
+
+extern int __syscall_fstatat (int fd, const char *path,
+			      struct stat16 *buf, int flag);
+libc_hidden_proto (__syscall_fstatat)
+
+/* Get information about the file NAME relative to FD in ST.  */
+int
+__fxstatat64 (int vers, int fd, const char *file, struct stat64 *st, int flag)
+{
+      int result;
+
+      if (__builtin_expect (vers == _STAT_VER, 1))
+	{
+	  struct stat16 buf16;
+	  result =
+	    INLINE_SYSCALL (fstatat, 4, fd, file,
+			    &buf16, flag);
+	  if (result == 0)
+	    stat16_to_stat64 (&buf16, st);
+	}
+      else
+	{
+	  __set_errno (EINVAL);
+	  return -1;
+	}
+	return result;
+}
+
+libc_hidden_def (__fxstatat64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/gai_sigqueue.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <netdb.h>
+#include <signal.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+
+#include <gai_misc.h>
+
+int
+internal_function
+__gai_sigqueue (int sig, const union sigval val, pid_t caller_pid)
+{
+#if !IS_IN(libc)
+    return sigqueue(caller_pid, sig, val);
+#else
+    return __sigqueue(caller_pid, sig, val);
+#endif    
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getcwd.c
@@ -0,0 +1,103 @@
+/* Determine current working directory.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <limits.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <sysdep.h>
+
+/* If we compile the file for use in ld.so we don't need the feature
+   that getcwd() allocates the buffers itself.  */
+#if IS_IN (rtld)
+# define NO_ALLOCATION  1
+#endif
+
+/* The system calls only makes a lookup in the VFS cache, which can easily
+   fail.  Therefore we use the generic version as a fallback.  */
+extern int __syscall_getcwd (char *buf, unsigned int size);
+libc_hidden_proto (__syscall_getcwd)
+
+static char *generic_getcwd (char *buf, size_t size) internal_function;
+
+char *
+__getcwd (char *buf, size_t size)
+{
+  char tmpbuf[PATH_MAX];
+
+  if (INLINE_SYSCALL (getcwd, 2, tmpbuf, PATH_MAX) >= 0)
+    {
+      size_t len = strlen (tmpbuf) + 1;
+
+      if (size == 0)
+	{
+	  if (__builtin_expect (buf != NULL, 0))
+	    {
+	      __set_errno (EINVAL);
+	      return NULL;
+	    }
+#ifdef NO_ALLOCATION
+          buf = NULL;
+#else
+	  buf = (char *) malloc (len);
+#endif
+	  if (__builtin_expect (buf == NULL, 0))
+	    {
+	      __set_errno (ENOMEM);
+	      return NULL;
+	    }
+	}
+      else
+	{
+	  if (size < len)
+	    {
+	      __set_errno (ERANGE);
+	      return NULL;
+	    }
+
+	  if (buf == NULL)
+	    {
+#ifdef NO_ALLOCATION
+              buf = NULL;
+#else
+	      buf = (char *) malloc (size);
+#endif
+	      if (__builtin_expect (buf == NULL, 0))
+		{
+		  __set_errno (ENOMEM);
+		  return NULL;
+		}
+	    }
+	}
+
+      memcpy (buf, tmpbuf, len);
+      return buf;
+    }
+  return generic_getcwd (buf, size);
+}
+
+weak_alias (__getcwd, getcwd)
+
+/* Get the code for the generic version.  */
+#define GETCWD_RETURN_TYPE	static char * internal_function
+#define __getcwd		generic_getcwd
+#include <sysdeps/posix/getcwd.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents.c
@@ -0,0 +1,43 @@
+/* Read directory entries, 3 argument function.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sysdep.h>
+
+/* Use the 3-argument system call.  */
+
+extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
+libc_hidden_proto (__syscall_getdents)
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Returns the number of bytes read; zero when at end of directory; or
+   -1 for errors.  */
+ssize_t
+internal_function
+__getdents (int fd, char *buf, size_t nbytes)
+{
+  return __syscall_getdents (fd, buf, nbytes);
+}
+
+/* Since 'struct dirent64' == 'struct dirent', the functions '__getdents64'
+   and '__getdents' are equal.  */
+strong_alias (__getdents, __getdents64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdents64.c
@@ -0,0 +1 @@
+/* We have the function getdirentries64 in file getdirentries64.c.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries.c
@@ -0,0 +1,100 @@
+/* Read directory entries, 4 argument function.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef GETDIRENTRIES
+# define GETDIRENTRIES getdirentries
+# define OFF_T off_t
+#endif
+
+#include <dirent.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+#if 1
+
+/* Use the 4-argument system call.  */
+
+extern int __syscall_getdirentries (int fd, char *buf, unsigned int nbytes,
+				    long *basep);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Reading starts at offset *BASEP, and *BASEP is updated with the new
+   position after reading.  Returns the number of bytes read; zero when at
+   end of directory; or -1 for errors.  */
+/* FIXME: This is not what this function does.  It starts reading at the
+   current position of FD, not at *BASEP.  */
+ssize_t
+GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
+{
+  /* On 32-bit platforms, the system call differs from this function because
+     it takes a 'long *', not an 'OFF_T *'.  On 64-bit platforms, the system
+     call differs from this function because it takes an 'unsigned int', not
+     a 'size_t'.  */
+  unsigned int nbytes32;
+
+  nbytes32 = nbytes;
+  if (nbytes32 == nbytes)
+    {
+      long base;
+      int result = __syscall_getdirentries (fd, buf, nbytes32, &base);
+
+      if (result >= 0 && basep != NULL)
+	*basep = base;
+      return result;
+    }
+  else
+    {
+      /* NBYTES is too large.  */
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+
+#else
+
+/* Use the 3-argument system call.  */
+
+extern int __syscall_getdents (int fd, char *buf, size_t nbytes);
+
+/* Read directory entries from FD into BUF, reading at most NBYTES.
+   Reading starts at offset *BASEP, and *BASEP is updated with the new
+   position after reading.  Returns the number of bytes read; zero when at
+   end of directory; or -1 for errors.  */
+/* FIXME: This is not what this function does.  It starts reading at the
+   current position of FD, not at *BASEP.  */
+ssize_t
+GETDIRENTRIES (int fd, char *buf, size_t nbytes, OFF_T *basep)
+{
+  OFF_T base = 0;
+  ssize_t result;
+
+  if (basep)
+    base = __lseek (fd, (off_t) 0, SEEK_CUR);
+
+  result = __syscall_getdents (fd, buf, nbytes);
+
+  if (basep && result >= 0)
+    *basep = base;
+  return result;
+}
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdirentries64.c
@@ -0,0 +1,5 @@
+/* Since 'struct dirent64' == 'struct dirent', the functions 'getdirentries64'
+   and 'getdirentries' differ only in the type of the BASEP argument.  */
+#define GETDIRENTRIES getdirentries64
+#define OFF_T off64_t
+#include <getdirentries.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getdomain.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+
+/* Put the name of the current domain in no more than LEN bytes of NAME.
+   The result is null-terminated if LEN is large enough for the full
+   name and the terminator.  */
+
+int
+getdomainname (char *name, size_t len)
+{
+  /* Fetch the "kern.domainname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_NISDOMAINNAME };
+  size_t result_len = len;
+
+  if (__sysctl (request, 2, name, &result_len, NULL, 0) < 0)
+    {
+      if (errno == ENOMEM)
+	__set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  if (result_len >= len)
+    {
+      __set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  name[result_len] = '\0';
+  return 0;
+}
+libc_hidden_def (getdomainname)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <alloca.h>
+
+#include "statfsconv.c"
+
+int
+__getfsstat (struct statfs *buf, long bufsize, int flags)
+{
+  long bufcount;
+  struct statfs_fbsd5 *tmpbuf;
+  int count, i;
+
+  if (bufsize < 0)
+    bufsize = 0;
+  bufcount = bufsize / sizeof (struct statfs);
+
+  if ((bufcount == 0) || (buf == NULL))
+    tmpbuf = NULL;
+  else
+    tmpbuf = alloca(bufcount * sizeof (struct statfs_fbsd5));
+
+  count = __syscall_getfsstat (tmpbuf, bufcount * sizeof (struct statfs_fbsd5), flags);
+  if (tmpbuf && count > 0)
+    for (i = count - 1; i >= 0; i--)
+      statfs5_to_statfs (&tmpbuf[i], &buf[i]);
+
+  return count;
+}
+
+weak_alias (__getfsstat, getfsstat)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getfsstat64.c
@@ -0,0 +1,49 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <alloca.h>
+
+#include "statfsconv.c"
+
+int
+__getfsstat64 (struct statfs64 *buf, long bufsize, int flags)
+{
+  long bufcount;
+  struct statfs_fbsd5 *tmpbuf;
+  int count, i;
+
+  if (bufsize < 0)
+    bufsize = 0;
+  bufcount = bufsize / sizeof (struct statfs64);
+
+  if ((bufcount == 0) || (buf == NULL))
+    tmpbuf = NULL;
+  else
+    tmpbuf = alloca(bufcount * sizeof (struct statfs_fbsd5));
+
+  count = __syscall_getfsstat (tmpbuf, bufcount * sizeof (struct statfs_fbsd5), flags);
+  if (tmpbuf && count > 0)
+    for (i = count - 1; i >= 0; i--)
+      statfs5_to_statfs64 (&tmpbuf[i], &buf[i]);
+
+  return count;
+}
+
+weak_alias (__getfsstat64, getfsstat64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostid.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Return the current machine's Internet number.  */
+long int
+gethostid (void)
+{
+  /* Fetch sysctl value of "kern.hostid".  */
+  int request[2] = { CTL_KERN, KERN_HOSTID };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 0;
+
+  return result;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/gethostname.c
@@ -0,0 +1,52 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+
+/* Put the name of the current host in no more than LEN bytes of NAME.
+   The result is null-terminated if LEN is large enough for the full
+   name and the terminator.  */
+
+int
+__gethostname (char *name, size_t len)
+{
+  /* Fetch the "kern.hostname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_HOSTNAME };
+  size_t result_len = len;
+
+  if (__sysctl (request, 2, name, &result_len, NULL, 0) < 0)
+    {
+      if (errno == ENOMEM)
+	__set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  if (result_len >= len)
+    {
+      __set_errno (ENAMETOOLONG);
+      return -1;
+    }
+
+  name[result_len] = '\0';
+  return 0;
+}
+
+weak_alias (__gethostname, gethostname)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getloadavg.c
@@ -0,0 +1,53 @@
+/* Get system load averages.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+#include <sys/sysctl.h>
+
+struct loadavg
+  {
+    unsigned int ldavg[3];
+    long fscale;
+  };
+
+/* Put the 1 minute, 5 minute and 15 minute load averages into the first
+   NELEM elements of LOADAVG.  Return the number written (never more than
+   three, but may be less than NELEM), or -1 if an error occurred.  */
+int
+getloadavg (double loadavg[], int nelem)
+{
+  if (nelem > 3)
+    nelem = 3;
+  if (nelem > 0)
+    {
+      /* Fetch the "vm.loadavg" sysctl value.  */
+      int request[2] = { CTL_VM, VM_LOADAVG };
+      struct loadavg result;
+      size_t result_len = sizeof (result);
+      int i;
+
+      if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+	return -1;
+
+      for (i = 0; i < nelem; i++)
+	loadavg[i] = (double) result.ldavg[i] / (double) result.fscale;
+    }
+  return nelem;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin.c
@@ -0,0 +1,50 @@
+/* Non-reentrant function to return the current login name.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sysdep.h>
+
+/* Defined in getlogin_r.c.  */
+extern char *__getlogin_cache;
+extern char __getlogin_cache_room[MAXLOGNAME];
+
+extern int __syscall_getlogin (char *__name, size_t __name_len);
+libc_hidden_proto (__syscall_getlogin)
+
+/* Return the login name of the user, or NULL if it can't be determined.
+   The returned pointer, if not NULL, is good only until the next call.  */
+
+char *
+getlogin (void)
+{
+  if (__getlogin_cache == NULL)
+    {
+      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
+	return NULL;
+      /* The system call should return a NULL terminated name.  */
+      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
+	abort ();
+      __getlogin_cache = __getlogin_cache_room;
+    }
+  return (__getlogin_cache[0] ? __getlogin_cache : NULL);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getlogin_r.c
@@ -0,0 +1,73 @@
+/* Reentrant function to return the current login name.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/param.h>
+#include <sysdep.h>
+
+/* Cache the system call's return value.  */
+char *__getlogin_cache;
+/* The kernel never returns more than MAXLOGNAME bytes, therefore we don't
+   need more than that either.  */
+char __getlogin_cache_room[MAXLOGNAME];
+
+extern int __syscall_getlogin (char *__name, size_t __name_len);
+libc_hidden_proto (__syscall_getlogin)
+
+/* Return at most NAME_LEN characters of the login name of the user in NAME.
+   If it cannot be determined or some other error occurred, return the error
+   code.  Otherwise return 0.
+   Note that the getlogin_r function in FreeBSD libc returns a 'char *',
+   but SUSV2 wants a return type of 'int'.  */
+
+int
+__getlogin_r (char *name, size_t name_len)
+{
+  size_t len;
+
+  if (__getlogin_cache == NULL)
+    {
+      if (INLINE_SYSCALL (getlogin, 2, __getlogin_cache_room, MAXLOGNAME) < 0)
+	return errno;
+      /* The system call should return a NULL terminated name.  */
+      if (__memchr (__getlogin_cache_room, '\0', MAXLOGNAME) == NULL)
+	abort ();
+      __getlogin_cache = __getlogin_cache_room;
+    }
+
+  len = strlen (__getlogin_cache);
+  if (__builtin_expect (len < name_len, 1))
+    {
+      memcpy (name, __getlogin_cache, len + 1);
+      return 0;
+    }
+  else
+    {
+      __set_errno (ERANGE);
+      return ERANGE;
+    }
+}
+libc_hidden_def (__getlogin_r)
+weak_alias (__getlogin_r, getlogin_r)
+libc_hidden_weak (getlogin_r)
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo.c
@@ -0,0 +1,80 @@
+/* Return list of mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <stdlib.h>
+#include <errno.h>
+
+static int mntbufsize;
+static struct statfs *mntbuf;
+
+/* Return list of mounted filesystems.
+   Inherently not multithread-safe.  */
+int
+__getmntinfo (struct statfs **mntbufp, int flags)
+{
+  for (;;)
+    {
+      int count = __getfsstat (NULL, 0, flags);
+      int count2;
+
+      if (count < 0)
+	return 0;
+
+      if (count == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count > mntbufsize)
+	{
+	  if (mntbuf != NULL)
+	    free (mntbuf);
+	  mntbufsize = 0;
+	  mntbuf = (struct statfs *) malloc (count * sizeof (struct statfs));
+	  if (mntbuf == NULL)
+	    {
+	      __set_errno (ENOMEM);
+	      return 0;
+	    }
+	  mntbufsize = count;
+	}
+
+      count2 = __getfsstat (mntbuf, count * sizeof (struct statfs), flags);
+
+      if (count2 < 0)
+	return 0;
+
+      if (count2 == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count2 <= count)
+	{
+	  *mntbufp = mntbuf;
+	  return count2;
+	}
+    }
+}
+
+weak_alias (__getmntinfo, getmntinfo)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getmntinfo64.c
@@ -0,0 +1,78 @@
+/* Return list of mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mount.h>
+#include <stdlib.h>
+#include <errno.h>
+
+static int mntbufsize;
+static struct statfs64 *mntbuf;
+
+/* Return list of mounted filesystems.
+   Inherently not multithread-safe.  */
+int
+getmntinfo64 (struct statfs64 **mntbufp, int flags)
+{
+  for (;;)
+    {
+      int count = __getfsstat64 (NULL, 0, flags);
+      int count2;
+
+      if (count < 0)
+	return 0;
+
+      if (count == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count > mntbufsize)
+	{
+	  if (mntbuf != NULL)
+	    free (mntbuf);
+	  mntbufsize = 0;
+	  mntbuf = (struct statfs64 *) malloc (count * sizeof (struct statfs64));
+	  if (mntbuf == NULL)
+	    {
+	      __set_errno (ENOMEM);
+	      return 0;
+	    }
+	  mntbufsize = count;
+	}
+
+      count2 = __getfsstat64 (mntbuf, count * sizeof (struct statfs64), flags);
+
+      if (count2 < 0)
+	return 0;
+
+      if (count2 == 0)
+	{
+	  __set_errno (0);
+	  return 0;
+	}
+
+      if (count2 <= count)
+	{
+	  *mntbufp = mntbuf;
+	  return count2;
+	}
+    }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getosreldate.c
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+#include <sys/sysctl.h>
+#include <stdlib.h>
+#include <getosreldate.h>
+
+int
+__kernel_getosreldate(void)
+{
+    static int osreldate;
+
+    int mib[2];
+    size_t size;
+
+    if (osreldate == 0)
+    {
+	mib[0] = CTL_KERN;
+	mib[1] = KERN_OSRELDATE;
+	size = sizeof osreldate;
+	if (__sysctl(mib, 2, &osreldate, &size, NULL, 0) == -1)
+		return (-1);
+    }		
+    return (osreldate);
+}
+
+int
+__getosreldate(void)
+{
+    static int osreldate;
+
+    char *temp;
+
+    if (osreldate == 0)
+    {
+	if ((temp = getenv("OSVERSION"))) {
+		osreldate = atoi(temp);
+		return (osreldate);
+	}
+
+	osreldate = __kernel_getosreldate ();
+    }		
+    return (osreldate);
+}
+libc_hidden_def (__kernel_getosreldate)
+libc_hidden_def (__getosreldate)
+weak_alias (__getosreldate, getosreldate)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getosreldate.h
@@ -0,0 +1,4 @@
+int __kernel_getosreldate (void);
+int __getosreldate (void);
+libc_hidden_proto (__kernel_getosreldate)
+libc_hidden_proto (__getosreldate)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getpagesize.c
@@ -0,0 +1,42 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Return the system page size.  */
+int
+__getpagesize (void)
+{
+  static int cached_pagesize /* = 0 */;
+
+  if (cached_pagesize == 0)
+    {
+      /* Fetch sysctl value of "hw.pagesize".  */
+      int request[2] = { CTL_HW, HW_PAGESIZE };
+      size_t result_len = sizeof (cached_pagesize);
+
+      if (__sysctl (request, 2, &cached_pagesize, &result_len, NULL, 0) < 0)
+	return -1;
+    }
+  return cached_pagesize;
+}
+libc_hidden_def (__getpagesize)
+
+weak_alias (__getpagesize, getpagesize)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getpt.c
@@ -0,0 +1,51 @@
+/* Copyright (C) 1998-1999, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sysdep.h>
+
+/* The system call does not change the controlling terminal, so we have
+ * to do it ourselves.  */
+extern int __syscall_posix_openpt (int oflag);
+libc_hidden_proto (__syscall_posix_openpt)
+
+int
+__posix_openpt (int oflag)
+{
+  int fd = INLINE_SYSCALL (posix_openpt, 1, oflag);
+  if (fd >= 0)
+  {
+      if (!(oflag & O_NOCTTY))
+        __ioctl (fd, TIOCSCTTY, NULL);
+  }
+  return fd;
+}
+
+weak_alias (__posix_openpt, posix_openpt)
+
+int
+__getpt (void)
+{
+  return __posix_openpt (O_RDWR | O_NOCTTY);
+}
+
+weak_alias (__getpt, getpt)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getrlimit64.c
@@ -0,0 +1 @@
+/* 'getrlimit64' is the same as 'getrlimit', because __rlim64_t == __rlim_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getsysstats.c
@@ -0,0 +1,109 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <unistd.h>
+#include <stddef.h>
+
+
+int
+__get_nprocs (void)
+{
+  /* Fetch sysctl value of "hw.ncpu".  */
+  int request[2] = { CTL_HW, HW_NCPU };
+  int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 1;
+
+  return result;
+}
+
+weak_alias (__get_nprocs, get_nprocs)
+
+
+int
+__get_nprocs_conf (void)
+{
+  /* We don't know how to distinguish between configured and active CPUs.  */
+  return __get_nprocs ();
+}
+
+weak_alias (__get_nprocs_conf, get_nprocs_conf)
+
+
+long int
+__get_phys_pages (void)
+{
+  /* Fetch sysctl value of "hw.physmem".  This is a little smaller than
+     the real installed memory size, but so what.  */
+  int request[2] = { CTL_HW, HW_PHYSMEM };
+  unsigned long int result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    return -1;
+
+  return result / __getpagesize();
+}
+
+weak_alias (__get_phys_pages, get_phys_pages)
+
+
+long int
+__get_avphys_pages (void)
+{
+#if 1
+  int result1;
+  int result2;
+  {
+    /* Fetch sysctl value of "vm.stats.vm.v_inactive_count".  */
+    size_t result_len = sizeof (result1);
+
+    if (__sysctlbyname ("vm.stats.vm.v_inactive_count", &result1, &result_len,
+			NULL, 0) < 0)
+      return -1;
+  }
+  {
+    /* Fetch sysctl value of "vm.stats.vm.v_free_count".  */
+    size_t result_len = sizeof (result2);
+
+    if (__sysctlbyname ("vm.stats.vm.v_free_count", &result2, &result_len,
+			NULL, 0) < 0)
+      return -1;
+  }
+
+  return result1 + result2;
+#else
+  /* This does not appear to work.  */
+  /* Fetch v_inactive_count field of sysctl value of "vm.vmmeter".  */
+  int request[2] = { CTL_VM, VM_METER };
+  struct vmmeter result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    return -1;
+
+  return result.v_inactive_count;
+#endif
+}
+
+weak_alias (__get_avphys_pages, get_avphys_pages)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/getvfsbyname.c
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 1995
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <stddef.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Given a filesystem name, determine if it is resident in the kernel,
+ * and if it is resident, return its xvfsconf structure.
+ */
+int
+__getvfsbyname(const char *fsnamen, struct xvfsconf *vfcp)
+{
+	struct xvfsconf *xvfsp;
+	size_t buflen;
+	int cnt, i;
+
+	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0)
+		return (-1);
+	xvfsp = malloc(buflen);
+	if (xvfsp == NULL)
+		return (-1);
+	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
+		free(xvfsp);
+		return (-1);
+	}
+	cnt = buflen / sizeof(struct xvfsconf);
+	for (i = 0; i < cnt; i++) {
+		if (strcmp(fsname, xvfsp[i].vfc_name) == 0) {
+			memcpy(vfcp, xvfsp + i, sizeof(struct xvfsconf));
+			free(xvfsp);
+			return (0);
+		}
+	}
+	free(xvfsp);
+	__set_errno (ENOENT);
+	return (-1);
+}
+weak_alias (__getvfsbyname, getvfsbyname)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/glob.c
@@ -0,0 +1,3 @@
+/* 'glob64' is different from 'glob', because
+   'struct stat64' != 'struct stat'.  */
+#include <posix/glob.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/glob64.c
@@ -0,0 +1,3 @@
+/* 'glob64' is different from 'glob', because
+   'struct stat64' != 'struct stat'.  */
+#include <sysdeps/gnu/glob64.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/grantpt.c
@@ -0,0 +1,36 @@
+#include <assert.h>
+#include <ctype.h>
+#include <dirent.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscall.h>
+#include <not-cancel.h>
+
+#include "pty-private.h"
+
+int __syscall_closefrom(int fd);
+libc_hidden_proto (__syscall_closefrom)
+
+/* Close all file descriptors except the one specified.  */
+static void
+close_all_fds (void)
+{
+    int i;
+
+    for (i = 0 ; i < PTY_FILENO; i++)
+        close_not_cancel_no_status (i);
+        
+    INLINE_SYSCALL(closefrom, 1, PTY_FILENO + 1L);
+
+    int nullfd = open_not_cancel_2 (_PATH_DEVNULL, O_RDONLY);
+    assert (nullfd == STDIN_FILENO);
+    nullfd = open_not_cancel_2 (_PATH_DEVNULL, O_WRONLY);
+    assert (nullfd == STDOUT_FILENO);
+    __dup2 (STDOUT_FILENO, STDERR_FILENO);
+}
+#define CLOSE_ALL_FDS() close_all_fds()
+
+#include <sysdeps/unix/grantpt.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/gtty.c
@@ -0,0 +1,2 @@
+/* use stub only variant */
+#include <misc/gtty.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Implies
@@ -0,0 +1 @@
+unix/bsd/bsd4.4/kfreebsd/x86
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Makefile
@@ -0,0 +1,27 @@
+# The default ABI is 32.
+default-abi := 32
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ sys/io.h \
+ sys/perm.h \
+ sys/vm86.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),misc)
+# For <sys/io.h> and <sys/perm.h>.
+sysdep_routines += i386_get_ioperm i386_set_ioperm iopl
+# For <sys/vm86.h>.
+sysdep_routines += i386_vm86
+# For <machine/sysarch.h>.
+sysdep_routines += i386_get_ldt i386_set_ldt
+endif
+
+# special flag to avoid usage of xmm registers in ld.so
+ifeq ($(subdir),io)
+CFLAGS-rtld-fxstat64.os += -mno-sse -mno-mmx
+endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/Versions
@@ -0,0 +1,7 @@
+libc {
+  GLIBC_2.2.6 {
+    i386_get_ioperm; i386_set_ioperm; i386_vm86;
+    ioperm; iopl;
+    i386_get_ldt; i386_set_ldt;
+  }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/____longjmp_chk.S
@@ -0,0 +1,7 @@
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.
+   void __longjmp (__jmp_buf env, int val).  */
+      
+#warning longjmp_chk unimplemented
+#define __longjmp ____longjmp_chk
+#include<__longjmp.S>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/mcontext.h
@@ -0,0 +1,111 @@
+/* Machine-dependent processor state structure for FreeBSD.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  i386 version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*-
+ * Copyright (c) 1999 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * based on $FreeBSD: src/sys/i386/include/ucontext.h,v 1.10 2002/12/02 19:58:55 deischen Exp $
+ */
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+
+    int mc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    int mc_gs;
+    int mc_fs;
+    int mc_es;
+    int mc_ds;
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    int mc_edi;
+    int mc_esi;
+    int mc_ebp;
+    int mc_isp;			/* Not used; sc_esp is used instead.  */
+    int mc_ebx;
+    int mc_edx;
+    int mc_ecx;
+    int mc_eax;
+
+    int mc_trapno;
+    int mc_err;
+
+    int mc_eip;			/* Instruction pointer.  */
+    int mc_cs;			/* Code segment register.  */
+
+    int mc_efl;			/* Processor flags.  */
+
+    int mc_esp;			/* This stack pointer is used.  */
+    int mc_ss;			/* Stack segment register.  */
+
+    int mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_387		0x10001
+#define	_MC_FPFMT_XMM		0x10002
+    int mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    int mc_ownedfp;
+    int mc_spare1[1];		/* align next field to 16 bytes */
+    /*
+     * See <machine/npx.h> for the internals of mc_fpstate[].
+     */
+    int mc_fpstate[128] __attribute__((aligned(16)));
+    int mc_spare2[8];
+  } mcontext_t;
+
+/* Traditional BSD names for some members.  */
+#define mc_eflags	mc_efl
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/bits/sigcontext.h
@@ -0,0 +1,97 @@
+/* Machine-dependent signal context structure for FreeBSD.  i386 version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/* State of this thread when the signal was taken.
+   The unions below are for compatibility with Linux (whose sigcontext
+   components don't have sc_ prefix) */
+__extension__ struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    int 	sc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    union { int sc_gs; int gs; };
+    union { int sc_fs; int fs; };
+    union { int sc_es; int es; };
+    union { int sc_ds; int ds; };
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    union { int sc_edi; int edi; };
+    union { int sc_esi; int esi; };
+    union { int sc_ebp; int ebp; };
+    union { int sc_isp; int isp; };		/* Not used; sc_esp is used instead.  */
+    union { int sc_ebx; int ebx; };
+    union { int sc_edx; int edx; };
+    union { int sc_ecx; int ecx; };
+    union { int sc_eax; int eax; };
+
+    union { int sc_trapno; int trapno; };
+    union { int sc_err; int err; };
+
+    union { int sc_eip; int eip; };		/* Instruction pointer.  */
+    union { int sc_cs; int cs; };		/* Code segment register.  */
+
+    union { int sc_efl; int eflags; }; 		/* Processor flags.  */
+
+    union { int sc_esp; int esp; };		/* This stack pointer is used.  */
+    union { int sc_ss; int ss; };		/* Stack segment register.  */
+
+    int     sc_len;                 /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/npx.h> for
+     *       the following fields.
+     */
+    int     sc_fpformat;
+    int     sc_ownedfp;
+    int     sc_spare1[1];
+    int     sc_fpstate[128] __attribute__((aligned(16)));
+    int     sc_spare2[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp		sc_esp		/* Stack pointer.  */
+#define sc_fp		sc_ebp		/* Frame pointer.  */
+#define sc_pc		sc_eip		/* Process counter.  */
+#define sc_ps		sc_efl
+#define sc_eflags	sc_efl
+
+#if 1 /* FIXME: These need verification.  */
+
+/* Codes for SIGILL.  */
+#define ILL_PRIVIN_FAULT	1
+#define ILL_ALIGN_FAULT		14
+#define ILL_FPOP_FAULT		24
+
+/* Codes for SIGBUS.  */
+#define BUS_PAGE_FAULT		12
+#define BUS_SEGNP_FAULT		26
+#define BUS_STK_FAULT		27
+#define BUS_SEGM_FAULT		29
+
+#endif
+
+#endif /* _BITS_SIGCONTEXT_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/c++-types.data
@@ -0,0 +1,67 @@
+blkcnt64_t:x
+blkcnt_t:x
+blksize_t:j
+caddr_t:Pc
+clockid_t:i
+clock_t:i
+daddr_t:x
+dev_t:j
+fd_mask:l
+fsblkcnt64_t:y
+fsblkcnt_t:m
+fsfilcnt64_t:y
+fsfilcnt_t:m
+fsid_t:8__fsid_t
+gid_t:j
+id_t:j
+ino64_t:y
+ino_t:j
+int16_t:s
+int32_t:i
+int64_t:x
+int8_t:a
+intptr_t:i
+key_t:l
+loff_t:x
+mode_t:t
+nlink_t:t
+off64_t:x
+off_t:x
+pid_t:i
+pthread_attr_t:14pthread_attr_t
+pthread_barrier_t:17pthread_barrier_t
+pthread_barrierattr_t:21pthread_barrierattr_t
+pthread_cond_t:14pthread_cond_t
+pthread_condattr_t:18pthread_condattr_t
+pthread_key_t:j
+pthread_mutex_t:15pthread_mutex_t
+pthread_mutexattr_t:19pthread_mutexattr_t
+pthread_once_t:i
+pthread_rwlock_t:16pthread_rwlock_t
+pthread_rwlockattr_t:20pthread_rwlockattr_t
+pthread_spinlock_t:i
+pthread_t:m
+quad_t:x
+register_t:i
+rlim64_t:x
+rlim_t:x
+sigset_t:10__sigset_t
+size_t:j
+socklen_t:j
+ssize_t:i
+suseconds_t:l
+time_t:l
+u_char:h
+uid_t:j
+uint:j
+u_int:j
+u_int16_t:t
+u_int32_t:j
+u_int64_t:y
+u_int8_t:h
+ulong:m
+u_long:m
+u_quad_t:y
+useconds_t:j
+ushort:t
+u_short:t
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-machine.h
@@ -0,0 +1,80 @@
+/* Machine-dependent ELF dynamic relocation inline functions.
+   FreeBSD i386 specific version of dl_platform_init()
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+/* For FreeBSD we redefine an initialization function.
+   This is called very early in dl_sysdep_start.  */
+
+#if 0
+Under FreeBSD:
+#define AT_EXECPATH     15      /* Path to the executable. */
+
+Under Linux:
+#define AT_PLATFORM     15      /* String identifying platform.  */
+
+Filled entries from kernel:
+
+        if (args->execfd != -1)
+                AUXARGS_ENTRY(pos, AT_EXECFD, args->execfd);
+        AUXARGS_ENTRY(pos, AT_PHDR, args->phdr);    
+        AUXARGS_ENTRY(pos, AT_PHENT, args->phent);  
+        AUXARGS_ENTRY(pos, AT_PHNUM, args->phnum);  
+        AUXARGS_ENTRY(pos, AT_PAGESZ, args->pagesz);
+        AUXARGS_ENTRY(pos, AT_FLAGS, args->flags);
+        AUXARGS_ENTRY(pos, AT_ENTRY, args->entry);
+        AUXARGS_ENTRY(pos, AT_BASE, args->base);
+        if (imgp->execpathp != 0)
+                AUXARGS_ENTRY(pos, AT_EXECPATH, imgp->execpathp);
+        AUXARGS_ENTRY(pos, AT_NULL, 0);
+                                                                                                                
+#endif
+
+#include_next <dl-machine.h>
+
+#ifndef _DL_MACHINE_KFREEBSD
+#define _DL_MACHINE_KFREEBSD
+
+static inline void __attribute__ ((unused))
+dl_platform_kfreebsd_i386_init (void)
+{
+	/* This calls cpuid and and fills dl_x86_cpu_features */
+	DL_PLATFORM_INIT;
+
+	/* we don't have reasonable AT_PLATFORM from kernel
+	   try to use cpuid to get one, also guess AT_HWCAP */
+	GLRO(dl_hwcap) = GLRO(dl_x86_cpu_features).cpuid[COMMON_CPUID_INDEX_1].edx;
+	switch (GLRO(dl_hwcap) & 0xf00)
+	{
+	case 0x400: /* 486 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[1];
+	break;
+	case 0x500: /* 586 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[2];
+	break;
+	default:    /* 686 */
+		GLRO(dl_platform) = GLRO(dl_x86_platforms)[3];
+	}
+}
+
+#undef  DL_PLATFORM_INIT
+#define DL_PLATFORM_INIT dl_platform_kfreebsd_i386_init ()
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-procinfo.h
@@ -0,0 +1 @@
+#include <sysdeps/i386/dl-procinfo.h>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/exit-thread.h
@@ -0,0 +1,49 @@
+/* Call to terminate the current thread.  GNU/kFreeBSD i386 version
+   Copyright (C) 2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* This causes the current thread to exit, without affecting other
+   threads in the process if there are any.  If there are no other
+   threads left, then this has the effect of _exit (0).  */
+
+static inline void __attribute__ ((noreturn, always_inline, unused))
+__exit_thread (void)
+{
+  /* Doing this in a loop is mostly just to satisfy the compiler that the
+     function really qualifies as noreturn.  It also means that in some
+     pathological situation where the system call does not get made or does
+     not work, the thread will simply spin rather than running off the end
+     of the caller and doing unexpectedly strange things.  */
+  while (1)
+    {
+      asm volatile (
+	  "movl %%gs:0, %%edx\n\t"
+	  "addl %0, %%edx\n\t"    /* should be KTID, but they are at the same place anyway */
+	  "movl %%edx, 4(%%esp)\n\t"
+	  "movl %1, %%eax\n\t"
+	  "int $0x80\n\t"
+	  /* It does return only for last thread of process */
+	  "movl %2, %%eax\n\t"
+	  "movl $0, 4(%%esp)\n\t"
+	  "int $0x80\n\t"
+	  :
+	  : "i" (TID), "i" (SYS_ify(thr_exit)), "i" (SYS_ify(exit))
+	  : "memory", "cc");
+    }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fbtl/Implies
@@ -0,0 +1 @@
+unix/bsd/bsd4.4/kfreebsd/x86/fbtl
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fbtl/pt-vfork.S
@@ -0,0 +1,36 @@
+/* Copyright (C) 1999-2013 Free Software Foundation, Inc.  This file is part
+   of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include <tcb-offsets.h>
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	movl	%gs:PID, %edx; 						      \
+	negl	%edx;							      \
+	movl	%edx, %gs:PID
+
+
+/* we do not have spare register during syscall */
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID_IN_PARENT \
+	movl	%gs:PID, %edx; 						      \
+	negl	%edx;							      \
+	movl	%edx, %gs:PID
+
+#include "../vfork.S"
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fbtl/sysdep-cancel.h
@@ -0,0 +1,108 @@
+/* Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+   Modification for FreeBSD by Petr Salinger, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <fbtl/pthreadP.h>
+#endif
+
+#if IS_IN (libc) || IS_IN (libpthread) || IS_IN (librt)
+
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    cmpl $0, %gs:MULTIPLE_THREADS_OFFSET;				      \
+    jne L(pseudo_cancel);						      \
+  .type __##syscall_name##_nocancel,@function;				      \
+  .globl __##syscall_name##_nocancel;					      \
+  __##syscall_name##_nocancel:						      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	      \
+  L(pseudo_cancel):							      \
+    CENABLE								      \
+    movl %eax, %ecx;							      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    int $0x80;								      \
+    PUSHRESULT;							      	      \
+    movl %ecx, %eax; 							      \
+    CDISABLE;							 	      \
+    POPRESULT;							      	      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+/*
+  on FreeBSD some syscalls return result in pair edx+eax,
+  therefore proper way would be
+
+# define PUSHRESULT	pushl %edx; pushl %eax; pushfl
+# define POPRESULT	popfl; popl %eax; popl %edx
+
+  for FreeBSD 5.4 affected syscalls are
+
+	lseek()
+	fork()
+	vfork()
+	rfork()
+	pipe()
+
+   none of them is cancelable, therefore
+*/
+
+# define PUSHRESULT	pushl %eax; cfi_adjust_cfa_offset (4);  pushfl;    cfi_adjust_cfa_offset (4)
+# define POPRESULT	popfl;      cfi_adjust_cfa_offset (-4); popl %eax; cfi_adjust_cfa_offset (-4)
+
+# if IS_IN (libpthread)
+#  define CENABLE	call __pthread_enable_asynccancel;
+#  define CDISABLE	call __pthread_disable_asynccancel
+# elif IS_IN (libc)
+#  define CENABLE	call __libc_enable_asynccancel;
+#  define CDISABLE	call __libc_disable_asynccancel
+# elif IS_IN (librt)
+#  define CENABLE	call __librt_enable_asynccancel;
+#  define CDISABLE	call __librt_disable_asynccancel
+# else
+#  error Unsupported library
+# endif
+
+
+# ifndef __ASSEMBLER__
+#  define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+# else
+#  define SINGLE_THREAD_P cmpl $0, %gs:MULTIPLE_THREADS_OFFSET
+# endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fbtl/tls.h
@@ -0,0 +1,100 @@
+/* Definition for thread-local data handling.  fbtl/i386 version.
+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_TLS_H
+#define _FREEBSD_TLS_H
+
+#include <fbtl/sysdeps/i386/tls.h>
+
+# ifndef __ASSEMBLER__
+
+#undef TLS_INIT_TP
+#undef TLS_SETUP_GS_SEGMENT
+#undef TLS_GET_GS
+#undef TLS_SET_GS       
+#undef __NR_set_thread_area
+
+#include <sysarch.h>
+#include <sys/syscall.h>
+
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched. */
+
+#  define TLS_DO_SET_GSBASE(descr)		\
+({                                      	\
+  long base = (long) descr;             	\
+  int result;                           	\
+  asm volatile (                        	\
+                "pushl %3\n\t"          	\
+                "pushl %2\n\t"          	\
+                "pushl %1\n\t"       		\
+                "int $0x80\n\t"         	\
+                "popl %3\n\t"        		\
+                "popl %3\n\t"        		\
+                "popl %3\n\t"        		\
+                : "=a" (result)         	\
+                : "0" (SYS_sysarch),     	\
+                  "i" (I386_SET_GSBASE),       	\
+                  "d" (&base)			\
+                : "memory", "cc" );    		\
+  result;                                       \
+})
+
+#   define TLS_SETUP_GS_SEGMENT(descr, secondcall)                            \
+  (TLS_DO_SET_GSBASE(descr)                                                   \
+   ? "set_thread_area failed when setting up thread-local storage\n" : NULL)
+
+/*   The value of this macro is null if successful, or an error string.  */
+
+#  define TLS_INIT_TP(descr)						      \
+  ({									      \
+    void *_descr = (descr);						      \
+    tcbhead_t *head = _descr;						      \
+									      \
+    head->tcb = _descr;							      \
+    /* For now the thread descriptor is at the same address.  */	      \
+    head->self = _descr;						      \
+									      \
+    INIT_SYSINFO;							      \
+    TLS_SETUP_GS_SEGMENT (_descr, secondcall);				      \
+  })
+
+#if 0
+/* in Linux one; */
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  REGISTER_THREAD_AREA (32, offsetof (struct user_regs_struct, xgs), 3) \
+  REGISTER_THREAD_AREA (64, 26 * 8, 3) /* x86-64's user_regs_struct->gs */
+#else
+/* # warning proper variant needed */
+# undef DB_THREAD_SELF_INCLUDE
+# undef DB_THREAD_SELF
+# define DB_THREAD_SELF \
+  REGISTER_THREAD_AREA (32, 10 * 4, 3) /* offsetof (struct user_regs_struct, xgs) */ \
+  REGISTER_THREAD_AREA (64, 26 * 8, 3) /* x86-64's user_regs_struct->gs */
+#endif
+
+/* in fact this is OS-specific, but we do not have better header for it */
+#define NEED_STACK_SIZE_FOR_PTH_CREATE 1
+ 
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fbtl/vfork.S
@@ -0,0 +1,40 @@
+/* Copyright (C) 1999-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+
+#include <tcb-offsets.h>
+
+/* Save the PID value.  */
+#define SAVE_PID \
+	movl	%gs:PID, %edx; 						      \
+	negl	%edx;							      \
+	jne	1f;							      \
+	movl	$0x80000000, %edx;					      \
+1:	movl	%edx, %gs:PID
+
+
+/* we do not have spare register during syscall */
+/* Restore the old PID value in the parent.  */
+#define RESTORE_PID_IN_PARENT \
+	movl	%gs:PID, %edx; 						      \
+	cmpl	$0x80000000, %edx;					      \
+	jne	1f;							      \
+	xorl	%edx, %edx;						      \
+1:	negl	%edx;							      \
+	movl	%edx, %gs:PID
+
+#include "../vfork.S"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/get_clockfreq.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/i386/get_clockfreq.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/getcontext.S
@@ -0,0 +1,38 @@
+/* Save current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__getcontext)
+        clc
+        movl 0(%esp), %ecx	/* save the return PC value */
+
+        DO_CALL (getcontext, 1)
+        jb SYSCALL_ERROR_LABEL
+
+        addl $4, %esp		/* remove stale return address */
+        jmp  *%ecx
+
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__getcontext)
+
+weak_alias(__getcontext, getcontext)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ioperm.c
@@ -0,0 +1,36 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+i386_get_ioperm (unsigned long int from, unsigned long int *num, int *turned_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+
+  if (__sysarch (I386_GET_IOPERM, &args) < 0)
+    return -1;
+
+  *num = args.length;
+  *turned_on = args.enable;
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_get_ldt.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Robert Millan  <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/cdefs.h>
+#include <machine/segments.h>
+#include <sysarch.h>
+
+int
+i386_get_ldt (int from, union descriptor *descs, int num)
+{
+  struct i386_ldt_args args;
+
+  args.start = from;
+  args.descs = descs;
+  args.num = num;
+
+  if (__sysarch (I386_GET_LDT, &args) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ioperm.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+i386_set_ioperm (unsigned long int from, unsigned long int num, int turn_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+  args.length = num;
+  args.enable = turn_on;
+
+  return __sysarch (I386_SET_IOPERM, &args);
+}
+
+strong_alias (i386_set_ioperm, ioperm)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_set_ldt.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Robert Millan  <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/cdefs.h>
+#include <machine/segments.h>
+#include <sysarch.h>
+
+int
+i386_set_ldt (int from, union descriptor *descs, int num)
+{
+  struct i386_ldt_args args;
+
+  args.start = from;
+  args.descs = descs;
+  args.num = num;
+
+  if (__sysarch (I386_SET_LDT, &args) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i386_vm86.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/vm86.h>
+#include <sysarch.h>
+
+int
+i386_vm86 (int cmd, void *arg)
+{
+  struct i386_vm86_args args;
+
+  args.sub_op = cmd;
+  args.sub_args = arg;
+
+  return __sysarch (I386_VM86, &args);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i486/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i586/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i686/fbtl/tls.h
@@ -0,0 +1,2 @@
+/* no special TLS_GET_GS and TLS_SET_GS, as we do not define them at all */
+#include <sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/fbtl/tls.h>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/i686/linuxthreads/pt-machine.h
@@ -0,0 +1,8 @@
+
+/* i486+ is almost same as plain i386 version */
+#include_next <pt-machine.h>
+
+/* but compare-and-swap is always available  */
+
+#undef TEST_FOR_COMPARE_AND_SWAP
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/iopl.c
@@ -0,0 +1,54 @@
+/* Copyright (C) 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan <robertmh@gnu.org>
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>	/* open */
+#include <unistd.h>	/* close */
+
+static int __iopl_fd = -1;
+
+int
+iopl (int level)
+  {
+    switch (level)
+      {
+        case 3:
+          if (__iopl_fd != -1)
+            return 0;
+
+          __iopl_fd = __open ("/dev/io", O_RDWR);
+          if (__iopl_fd == -1)
+            {
+              if (errno == EACCES)
+                __set_errno (EPERM);
+              return -1;
+            }
+          return 0;
+
+        case 0:
+          if (__iopl_fd != -1)
+            if (__close (__iopl_fd) == -1)
+              return 1;
+          return 0;
+
+        default:
+          __set_errno (EINVAL);
+          return -1;
+      }
+  }
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ld.abilist
@@ -0,0 +1,12 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 ___tls_get_addr F
+GLIBC_2.3 __libc_memalign F
+GLIBC_2.3 __libc_stack_end D 0x4
+GLIBC_2.3 __tls_get_addr F
+GLIBC_2.3 _dl_mcount F
+GLIBC_2.3 _r_debug D 0x14
+GLIBC_2.3 calloc F
+GLIBC_2.3 free F
+GLIBC_2.3 malloc F
+GLIBC_2.3 realloc F
+GLIBC_2.4 GLIBC_2.4 A
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ldconfig.h
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },				\
+  { "/libexec/ld-elf.so.1", FLAG_ELF_LIBC5 },
+
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.0.1", FLAG_ELF_LIBC6 },				\
+  { "libm.so.1", FLAG_ELF_LIBC6 },				\
+  { "libc.so.4", FLAG_ELF_LIBC5 },				\
+  { "libm.so.4", FLAG_ELF_LIBC5 },				\
+  { "libc.so.5", FLAG_ELF_LIBC5 },				\
+  { "libm.so.5", FLAG_ELF_LIBC5 },				\
+  { "libc.so.6", FLAG_ELF_LIBC5 },				\
+  { "libm.so.6", FLAG_ELF_LIBC5 },				\
+  { "libc.so.7", FLAG_ELF_LIBC5 },				\
+  { "libm.so.7", FLAG_ELF_LIBC5 },				\
+  { "libc.so.8", FLAG_ELF_LIBC5 },				\
+  { "libm.so.8", FLAG_ELF_LIBC5 },
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libBrokenLocale.abilist
@@ -0,0 +1,2 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 __ctype_get_mb_cur_max F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libanl.abilist
@@ -0,0 +1,5 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 gai_cancel F
+GLIBC_2.3 gai_error F
+GLIBC_2.3 gai_suspend F
+GLIBC_2.3 getaddrinfo_a F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libc.abilist
@@ -0,0 +1,2194 @@
+GLIBC_2.10 GLIBC_2.10 A
+GLIBC_2.10 __cxa_at_quick_exit F
+GLIBC_2.10 __posix_getopt F
+GLIBC_2.10 accept4 F
+GLIBC_2.10 devname F
+GLIBC_2.10 devname_r F
+GLIBC_2.10 endsgent F
+GLIBC_2.10 fgetsgent F
+GLIBC_2.10 fgetsgent_r F
+GLIBC_2.10 getsgent F
+GLIBC_2.10 getsgent_r F
+GLIBC_2.10 getsgnam F
+GLIBC_2.10 getsgnam_r F
+GLIBC_2.10 kenv F
+GLIBC_2.10 malloc_info F
+GLIBC_2.10 preadv F
+GLIBC_2.10 preadv64 F
+GLIBC_2.10 psiginfo F
+GLIBC_2.10 putsgent F
+GLIBC_2.10 pwritev F
+GLIBC_2.10 pwritev64 F
+GLIBC_2.10 quick_exit F
+GLIBC_2.10 register_printf_modifier F
+GLIBC_2.10 register_printf_specifier F
+GLIBC_2.10 register_printf_type F
+GLIBC_2.10 setsgent F
+GLIBC_2.10 sgetsgent F
+GLIBC_2.10 sgetsgent_r F
+GLIBC_2.10 sysctlnametomib F
+GLIBC_2.11 GLIBC_2.11 A
+GLIBC_2.11 __longjmp_chk F
+GLIBC_2.11 _sys_errlist D 0x178
+GLIBC_2.11 _sys_nerr D 0x4
+GLIBC_2.11 execvpe F
+GLIBC_2.11 lchflags F
+GLIBC_2.11 mkostemps F
+GLIBC_2.11 mkostemps64 F
+GLIBC_2.11 mkstemps F
+GLIBC_2.11 mkstemps64 F
+GLIBC_2.11 sys_errlist D 0x178
+GLIBC_2.11 sys_nerr D 0x4
+GLIBC_2.13 GLIBC_2.13 A
+GLIBC_2.13 __fentry__ F
+GLIBC_2.13 jail_attach F
+GLIBC_2.13 jail_get F
+GLIBC_2.13 jail_remove F
+GLIBC_2.13 jail_set F
+GLIBC_2.14 GLIBC_2.14 A
+GLIBC_2.14 syncfs F
+GLIBC_2.15 GLIBC_2.15 A
+GLIBC_2.15 __fdelt_chk F
+GLIBC_2.15 __fdelt_warn F
+GLIBC_2.15 posix_spawn F
+GLIBC_2.15 posix_spawnp F
+GLIBC_2.15 scandirat F
+GLIBC_2.15 scandirat64 F
+GLIBC_2.16 GLIBC_2.16 A
+GLIBC_2.16 __getauxval F
+GLIBC_2.16 __poll_chk F
+GLIBC_2.16 __ppoll_chk F
+GLIBC_2.16 aligned_alloc F
+GLIBC_2.16 c16rtomb F
+GLIBC_2.16 c32rtomb F
+GLIBC_2.16 getauxval F
+GLIBC_2.16 mbrtoc16 F
+GLIBC_2.16 mbrtoc32 F
+GLIBC_2.16 timespec_get F
+GLIBC_2.17 GLIBC_2.17 A
+GLIBC_2.17 clock_getcpuclockid F
+GLIBC_2.17 clock_getres F
+GLIBC_2.17 clock_gettime F
+GLIBC_2.17 clock_nanosleep F
+GLIBC_2.17 clock_settime F
+GLIBC_2.17 recvmmsg F
+GLIBC_2.17 secure_getenv F
+GLIBC_2.17 sendmmsg F
+GLIBC_2.18 GLIBC_2.18 A
+GLIBC_2.18 __cxa_thread_atexit_impl F
+GLIBC_2.18 _sys_errlist D 0x184
+GLIBC_2.18 _sys_nerr D 0x4
+GLIBC_2.18 msgctl F
+GLIBC_2.18 semctl F
+GLIBC_2.18 shmctl F
+GLIBC_2.18 sys_errlist D 0x184
+GLIBC_2.18 sys_nerr D 0x4
+GLIBC_2.18 waitid F
+GLIBC_2.21 GLIBC_2.21 A
+GLIBC_2.21 __statfs F
+GLIBC_2.22 GLIBC_2.22 A
+GLIBC_2.22 fmemopen F
+GLIBC_2.23 GLIBC_2.23 A
+GLIBC_2.23 fts64_children F
+GLIBC_2.23 fts64_close F
+GLIBC_2.23 fts64_open F
+GLIBC_2.23 fts64_read F
+GLIBC_2.23 fts64_set F
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 _Exit F
+GLIBC_2.3 _IO_2_1_stderr_ D 0x9c
+GLIBC_2.3 _IO_2_1_stdin_ D 0x9c
+GLIBC_2.3 _IO_2_1_stdout_ D 0x9c
+GLIBC_2.3 _IO_adjust_column F
+GLIBC_2.3 _IO_adjust_wcolumn F
+GLIBC_2.3 _IO_default_doallocate F
+GLIBC_2.3 _IO_default_finish F
+GLIBC_2.3 _IO_default_pbackfail F
+GLIBC_2.3 _IO_default_uflow F
+GLIBC_2.3 _IO_default_xsgetn F
+GLIBC_2.3 _IO_default_xsputn F
+GLIBC_2.3 _IO_do_write F
+GLIBC_2.3 _IO_doallocbuf F
+GLIBC_2.3 _IO_fclose F
+GLIBC_2.3 _IO_fdopen F
+GLIBC_2.3 _IO_feof F
+GLIBC_2.3 _IO_ferror F
+GLIBC_2.3 _IO_fflush F
+GLIBC_2.3 _IO_fgetpos F
+GLIBC_2.3 _IO_fgetpos64 F
+GLIBC_2.3 _IO_fgets F
+GLIBC_2.3 _IO_file_attach F
+GLIBC_2.3 _IO_file_close F
+GLIBC_2.3 _IO_file_close_it F
+GLIBC_2.3 _IO_file_doallocate F
+GLIBC_2.3 _IO_file_finish F
+GLIBC_2.3 _IO_file_fopen F
+GLIBC_2.3 _IO_file_init F
+GLIBC_2.3 _IO_file_jumps D 0x54
+GLIBC_2.3 _IO_file_open F
+GLIBC_2.3 _IO_file_overflow F
+GLIBC_2.3 _IO_file_read F
+GLIBC_2.3 _IO_file_seek F
+GLIBC_2.3 _IO_file_seekoff F
+GLIBC_2.3 _IO_file_setbuf F
+GLIBC_2.3 _IO_file_stat F
+GLIBC_2.3 _IO_file_sync F
+GLIBC_2.3 _IO_file_underflow F
+GLIBC_2.3 _IO_file_write F
+GLIBC_2.3 _IO_file_xsputn F
+GLIBC_2.3 _IO_flockfile F
+GLIBC_2.3 _IO_flush_all F
+GLIBC_2.3 _IO_flush_all_linebuffered F
+GLIBC_2.3 _IO_fopen F
+GLIBC_2.3 _IO_fprintf F
+GLIBC_2.3 _IO_fputs F
+GLIBC_2.3 _IO_fread F
+GLIBC_2.3 _IO_free_backup_area F
+GLIBC_2.3 _IO_free_wbackup_area F
+GLIBC_2.3 _IO_fsetpos F
+GLIBC_2.3 _IO_fsetpos64 F
+GLIBC_2.3 _IO_ftell F
+GLIBC_2.3 _IO_ftrylockfile F
+GLIBC_2.3 _IO_funlockfile F
+GLIBC_2.3 _IO_fwrite F
+GLIBC_2.3 _IO_getc F
+GLIBC_2.3 _IO_getline F
+GLIBC_2.3 _IO_getline_info F
+GLIBC_2.3 _IO_gets F
+GLIBC_2.3 _IO_init F
+GLIBC_2.3 _IO_init_marker F
+GLIBC_2.3 _IO_init_wmarker F
+GLIBC_2.3 _IO_iter_begin F
+GLIBC_2.3 _IO_iter_end F
+GLIBC_2.3 _IO_iter_file F
+GLIBC_2.3 _IO_iter_next F
+GLIBC_2.3 _IO_least_wmarker F
+GLIBC_2.3 _IO_link_in F
+GLIBC_2.3 _IO_list_all D 0x4
+GLIBC_2.3 _IO_list_lock F
+GLIBC_2.3 _IO_list_resetlock F
+GLIBC_2.3 _IO_list_unlock F
+GLIBC_2.3 _IO_marker_delta F
+GLIBC_2.3 _IO_marker_difference F
+GLIBC_2.3 _IO_padn F
+GLIBC_2.3 _IO_peekc_locked F
+GLIBC_2.3 _IO_popen F
+GLIBC_2.3 _IO_printf F
+GLIBC_2.3 _IO_proc_close F
+GLIBC_2.3 _IO_proc_open F
+GLIBC_2.3 _IO_putc F
+GLIBC_2.3 _IO_puts F
+GLIBC_2.3 _IO_remove_marker F
+GLIBC_2.3 _IO_seekmark F
+GLIBC_2.3 _IO_seekoff F
+GLIBC_2.3 _IO_seekpos F
+GLIBC_2.3 _IO_seekwmark F
+GLIBC_2.3 _IO_setb F
+GLIBC_2.3 _IO_setbuffer F
+GLIBC_2.3 _IO_setvbuf F
+GLIBC_2.3 _IO_sgetn F
+GLIBC_2.3 _IO_sprintf F
+GLIBC_2.3 _IO_sputbackc F
+GLIBC_2.3 _IO_sputbackwc F
+GLIBC_2.3 _IO_sscanf F
+GLIBC_2.3 _IO_str_init_readonly F
+GLIBC_2.3 _IO_str_init_static F
+GLIBC_2.3 _IO_str_overflow F
+GLIBC_2.3 _IO_str_pbackfail F
+GLIBC_2.3 _IO_str_seekoff F
+GLIBC_2.3 _IO_str_underflow F
+GLIBC_2.3 _IO_sungetc F
+GLIBC_2.3 _IO_sungetwc F
+GLIBC_2.3 _IO_switch_to_get_mode F
+GLIBC_2.3 _IO_switch_to_main_wget_area F
+GLIBC_2.3 _IO_switch_to_wbackup_area F
+GLIBC_2.3 _IO_switch_to_wget_mode F
+GLIBC_2.3 _IO_un_link F
+GLIBC_2.3 _IO_ungetc F
+GLIBC_2.3 _IO_unsave_markers F
+GLIBC_2.3 _IO_unsave_wmarkers F
+GLIBC_2.3 _IO_vfprintf F
+GLIBC_2.3 _IO_vfscanf F
+GLIBC_2.3 _IO_vsprintf F
+GLIBC_2.3 _IO_wdefault_doallocate F
+GLIBC_2.3 _IO_wdefault_finish F
+GLIBC_2.3 _IO_wdefault_pbackfail F
+GLIBC_2.3 _IO_wdefault_uflow F
+GLIBC_2.3 _IO_wdefault_xsgetn F
+GLIBC_2.3 _IO_wdefault_xsputn F
+GLIBC_2.3 _IO_wdo_write F
+GLIBC_2.3 _IO_wdoallocbuf F
+GLIBC_2.3 _IO_wfile_jumps D 0x54
+GLIBC_2.3 _IO_wfile_overflow F
+GLIBC_2.3 _IO_wfile_seekoff F
+GLIBC_2.3 _IO_wfile_sync F
+GLIBC_2.3 _IO_wfile_underflow F
+GLIBC_2.3 _IO_wfile_xsputn F
+GLIBC_2.3 _IO_wmarker_delta F
+GLIBC_2.3 _IO_wsetb F
+GLIBC_2.3 __acl_aclcheck_fd F
+GLIBC_2.3 __acl_aclcheck_file F
+GLIBC_2.3 __acl_delete_fd F
+GLIBC_2.3 __acl_delete_file F
+GLIBC_2.3 __acl_get_fd F
+GLIBC_2.3 __acl_get_file F
+GLIBC_2.3 __acl_set_fd F
+GLIBC_2.3 __acl_set_file F
+GLIBC_2.3 __after_morecore_hook D 0x4
+GLIBC_2.3 __argz_count F
+GLIBC_2.3 __argz_next F
+GLIBC_2.3 __argz_stringify F
+GLIBC_2.3 __asprintf F
+GLIBC_2.3 __assert F
+GLIBC_2.3 __assert_fail F
+GLIBC_2.3 __assert_perror_fail F
+GLIBC_2.3 __backtrace F
+GLIBC_2.3 __backtrace_symbols F
+GLIBC_2.3 __backtrace_symbols_fd F
+GLIBC_2.3 __bsd_getpgrp F
+GLIBC_2.3 __bzero F
+GLIBC_2.3 __check_rhosts_file D 0x4
+GLIBC_2.3 __close F
+GLIBC_2.3 __cmsg_nxthdr F
+GLIBC_2.3 __connect F
+GLIBC_2.3 __ctype_b_loc F
+GLIBC_2.3 __ctype_get_mb_cur_max F
+GLIBC_2.3 __ctype_tolower_loc F
+GLIBC_2.3 __ctype_toupper_loc F
+GLIBC_2.3 __curbrk D 0x4
+GLIBC_2.3 __cxa_atexit F
+GLIBC_2.3 __cxa_finalize F
+GLIBC_2.3 __cyg_profile_func_enter F
+GLIBC_2.3 __cyg_profile_func_exit F
+GLIBC_2.3 __daylight D 0x4
+GLIBC_2.3 __dcgettext F
+GLIBC_2.3 __default_morecore F
+GLIBC_2.3 __dgettext F
+GLIBC_2.3 __divdi3 F
+GLIBC_2.3 __dup2 F
+GLIBC_2.3 __duplocale F
+GLIBC_2.3 __environ D 0x4
+GLIBC_2.3 __errno_location F
+GLIBC_2.3 __fbufsize F
+GLIBC_2.3 __fcntl F
+GLIBC_2.3 __ffs F
+GLIBC_2.3 __finite F
+GLIBC_2.3 __finitef F
+GLIBC_2.3 __finitel F
+GLIBC_2.3 __flbf F
+GLIBC_2.3 __fork F
+GLIBC_2.3 __fpending F
+GLIBC_2.3 __fpu_control D 0x2
+GLIBC_2.3 __fpurge F
+GLIBC_2.3 __freadable F
+GLIBC_2.3 __freading F
+GLIBC_2.3 __free_hook D 0x4
+GLIBC_2.3 __freelocale F
+GLIBC_2.3 __fsetlocking F
+GLIBC_2.3 __fwritable F
+GLIBC_2.3 __fwriting F
+GLIBC_2.3 __fxstat F
+GLIBC_2.3 __fxstat64 F
+GLIBC_2.3 __getdelim F
+GLIBC_2.3 __getpagesize F
+GLIBC_2.3 __getpgid F
+GLIBC_2.3 __getpid F
+GLIBC_2.3 __gettimeofday F
+GLIBC_2.3 __gmtime_r F
+GLIBC_2.3 __h_errno_location F
+GLIBC_2.3 __isalnum_l F
+GLIBC_2.3 __isalpha_l F
+GLIBC_2.3 __isascii_l F
+GLIBC_2.3 __isblank_l F
+GLIBC_2.3 __iscntrl_l F
+GLIBC_2.3 __isctype F
+GLIBC_2.3 __isdigit_l F
+GLIBC_2.3 __isgraph_l F
+GLIBC_2.3 __isinf F
+GLIBC_2.3 __isinff F
+GLIBC_2.3 __isinfl F
+GLIBC_2.3 __islower_l F
+GLIBC_2.3 __isnan F
+GLIBC_2.3 __isnanf F
+GLIBC_2.3 __isnanl F
+GLIBC_2.3 __isprint_l F
+GLIBC_2.3 __ispunct_l F
+GLIBC_2.3 __isspace_l F
+GLIBC_2.3 __isupper_l F
+GLIBC_2.3 __iswalnum_l F
+GLIBC_2.3 __iswalpha_l F
+GLIBC_2.3 __iswblank_l F
+GLIBC_2.3 __iswcntrl_l F
+GLIBC_2.3 __iswctype F
+GLIBC_2.3 __iswctype_l F
+GLIBC_2.3 __iswdigit_l F
+GLIBC_2.3 __iswgraph_l F
+GLIBC_2.3 __iswlower_l F
+GLIBC_2.3 __iswprint_l F
+GLIBC_2.3 __iswpunct_l F
+GLIBC_2.3 __iswspace_l F
+GLIBC_2.3 __iswupper_l F
+GLIBC_2.3 __iswxdigit_l F
+GLIBC_2.3 __isxdigit_l F
+GLIBC_2.3 __ivaliduser F
+GLIBC_2.3 __key_decryptsession_pk_LOCAL D 0x4
+GLIBC_2.3 __key_encryptsession_pk_LOCAL D 0x4
+GLIBC_2.3 __key_gendes_LOCAL D 0x4
+GLIBC_2.3 __libc_allocate_rtsig F
+GLIBC_2.3 __libc_calloc F
+GLIBC_2.3 __libc_current_sigrtmax F
+GLIBC_2.3 __libc_current_sigrtmin F
+GLIBC_2.3 __libc_free F
+GLIBC_2.3 __libc_freeres F
+GLIBC_2.3 __libc_init_first F
+GLIBC_2.3 __libc_mallinfo F
+GLIBC_2.3 __libc_malloc F
+GLIBC_2.3 __libc_mallopt F
+GLIBC_2.3 __libc_memalign F
+GLIBC_2.3 __libc_pvalloc F
+GLIBC_2.3 __libc_realloc F
+GLIBC_2.3 __libc_start_main F
+GLIBC_2.3 __libc_valloc F
+GLIBC_2.3 __lseek F
+GLIBC_2.3 __lxstat F
+GLIBC_2.3 __lxstat64 F
+GLIBC_2.3 __malloc_hook D 0x4
+GLIBC_2.3 __malloc_initialize_hook D 0x4
+GLIBC_2.3 __mbrlen F
+GLIBC_2.3 __mbrtowc F
+GLIBC_2.3 __memalign_hook D 0x4
+GLIBC_2.3 __memcpy_by2 F
+GLIBC_2.3 __memcpy_by4 F
+GLIBC_2.3 __memcpy_c F
+GLIBC_2.3 __memcpy_g F
+GLIBC_2.3 __mempcpy F
+GLIBC_2.3 __mempcpy_by2 F
+GLIBC_2.3 __mempcpy_by4 F
+GLIBC_2.3 __mempcpy_byn F
+GLIBC_2.3 __mempcpy_small F
+GLIBC_2.3 __memset_cc F
+GLIBC_2.3 __memset_ccn_by2 F
+GLIBC_2.3 __memset_ccn_by4 F
+GLIBC_2.3 __memset_cg F
+GLIBC_2.3 __memset_gcn_by2 F
+GLIBC_2.3 __memset_gcn_by4 F
+GLIBC_2.3 __memset_gg F
+GLIBC_2.3 __moddi3 F
+GLIBC_2.3 __monstartup F
+GLIBC_2.3 __morecore D 0x4
+GLIBC_2.3 __nanosleep F
+GLIBC_2.3 __newlocale F
+GLIBC_2.3 __nl_langinfo_l F
+GLIBC_2.3 __nss_configure_lookup F
+GLIBC_2.3 __nss_database_lookup F
+GLIBC_2.3 __nss_group_lookup F
+GLIBC_2.3 __nss_hostname_digits_dots F
+GLIBC_2.3 __nss_hosts_lookup F
+GLIBC_2.3 __nss_next F
+GLIBC_2.3 __nss_passwd_lookup F
+GLIBC_2.3 __open F
+GLIBC_2.3 __overflow F
+GLIBC_2.3 __pipe F
+GLIBC_2.3 __poll F
+GLIBC_2.3 __pread64 F
+GLIBC_2.3 __printf_fp F
+GLIBC_2.3 __profile_frequency F
+GLIBC_2.3 __progname D 0x4
+GLIBC_2.3 __progname_full D 0x4
+GLIBC_2.3 __pwrite64 F
+GLIBC_2.3 __rawmemchr F
+GLIBC_2.3 __rcmd_errstr D 0x4
+GLIBC_2.3 __read F
+GLIBC_2.3 __realloc_hook D 0x4
+GLIBC_2.3 __res_init F
+GLIBC_2.3 __res_nclose F
+GLIBC_2.3 __res_ninit F
+GLIBC_2.3 __res_randomid F
+GLIBC_2.3 __res_state F
+GLIBC_2.3 __rpc_thread_createerr F
+GLIBC_2.3 __rpc_thread_svc_fdset F
+GLIBC_2.3 __rpc_thread_svc_max_pollfd F
+GLIBC_2.3 __rpc_thread_svc_pollfd F
+GLIBC_2.3 __sbrk F
+GLIBC_2.3 __sched_get_priority_max F
+GLIBC_2.3 __sched_get_priority_min F
+GLIBC_2.3 __sched_getparam F
+GLIBC_2.3 __sched_getscheduler F
+GLIBC_2.3 __sched_setscheduler F
+GLIBC_2.3 __sched_yield F
+GLIBC_2.3 __secure_getenv F
+GLIBC_2.3 __select F
+GLIBC_2.3 __send F
+GLIBC_2.3 __setpgid F
+GLIBC_2.3 __sigaction F
+GLIBC_2.3 __sigaddset F
+GLIBC_2.3 __sigdelset F
+GLIBC_2.3 __sigismember F
+GLIBC_2.3 __signbit F
+GLIBC_2.3 __signbitf F
+GLIBC_2.3 __signbitl F
+GLIBC_2.3 __sigpause F
+GLIBC_2.3 __sigsetjmp F
+GLIBC_2.3 __sigsuspend F
+GLIBC_2.3 __stpcpy F
+GLIBC_2.3 __stpcpy_g F
+GLIBC_2.3 __stpcpy_small F
+GLIBC_2.3 __stpncpy F
+GLIBC_2.3 __strcasecmp F
+GLIBC_2.3 __strcasecmp_l F
+GLIBC_2.3 __strcasestr F
+GLIBC_2.3 __strcat_c F
+GLIBC_2.3 __strcat_g F
+GLIBC_2.3 __strchr_c F
+GLIBC_2.3 __strchr_g F
+GLIBC_2.3 __strchrnul_c F
+GLIBC_2.3 __strchrnul_g F
+GLIBC_2.3 __strcmp_gg F
+GLIBC_2.3 __strcoll_l F
+GLIBC_2.3 __strcpy_g F
+GLIBC_2.3 __strcpy_small F
+GLIBC_2.3 __strcspn_c1 F
+GLIBC_2.3 __strcspn_c2 F
+GLIBC_2.3 __strcspn_c3 F
+GLIBC_2.3 __strcspn_cg F
+GLIBC_2.3 __strcspn_g F
+GLIBC_2.3 __strdup F
+GLIBC_2.3 __strerror_r F
+GLIBC_2.3 __strfmon_l F
+GLIBC_2.3 __strftime_l F
+GLIBC_2.3 __strlen_g F
+GLIBC_2.3 __strncasecmp_l F
+GLIBC_2.3 __strncat_g F
+GLIBC_2.3 __strncmp_g F
+GLIBC_2.3 __strncpy_by2 F
+GLIBC_2.3 __strncpy_by4 F
+GLIBC_2.3 __strncpy_byn F
+GLIBC_2.3 __strncpy_gg F
+GLIBC_2.3 __strndup F
+GLIBC_2.3 __strpbrk_c2 F
+GLIBC_2.3 __strpbrk_c3 F
+GLIBC_2.3 __strpbrk_cg F
+GLIBC_2.3 __strpbrk_g F
+GLIBC_2.3 __strrchr_c F
+GLIBC_2.3 __strrchr_g F
+GLIBC_2.3 __strsep_1c F
+GLIBC_2.3 __strsep_2c F
+GLIBC_2.3 __strsep_3c F
+GLIBC_2.3 __strsep_g F
+GLIBC_2.3 __strspn_c1 F
+GLIBC_2.3 __strspn_c2 F
+GLIBC_2.3 __strspn_c3 F
+GLIBC_2.3 __strspn_cg F
+GLIBC_2.3 __strspn_g F
+GLIBC_2.3 __strstr_cg F
+GLIBC_2.3 __strstr_g F
+GLIBC_2.3 __strtod_internal F
+GLIBC_2.3 __strtod_l F
+GLIBC_2.3 __strtof_internal F
+GLIBC_2.3 __strtof_l F
+GLIBC_2.3 __strtok_r F
+GLIBC_2.3 __strtok_r_1c F
+GLIBC_2.3 __strtol_internal F
+GLIBC_2.3 __strtol_l F
+GLIBC_2.3 __strtold_internal F
+GLIBC_2.3 __strtold_l F
+GLIBC_2.3 __strtoll_internal F
+GLIBC_2.3 __strtoll_l F
+GLIBC_2.3 __strtoul_internal F
+GLIBC_2.3 __strtoul_l F
+GLIBC_2.3 __strtoull_internal F
+GLIBC_2.3 __strtoull_l F
+GLIBC_2.3 __strverscmp F
+GLIBC_2.3 __strxfrm_l F
+GLIBC_2.3 __syscall_aio_cancel F
+GLIBC_2.3 __syscall_aio_error F
+GLIBC_2.3 __syscall_aio_read F
+GLIBC_2.3 __syscall_aio_return F
+GLIBC_2.3 __syscall_aio_suspend F
+GLIBC_2.3 __syscall_aio_waitcomplete F
+GLIBC_2.3 __syscall_aio_write F
+GLIBC_2.3 __syscall_lio_listio F
+GLIBC_2.3 __syscall_obreak F
+GLIBC_2.3 __syscall_yield F
+GLIBC_2.3 __sysconf F
+GLIBC_2.3 __sysctl F
+GLIBC_2.3 __sysv_signal F
+GLIBC_2.3 __timezone D 0x4
+GLIBC_2.3 __toascii_l F
+GLIBC_2.3 __tolower_l F
+GLIBC_2.3 __toupper_l F
+GLIBC_2.3 __towctrans F
+GLIBC_2.3 __towctrans_l F
+GLIBC_2.3 __towlower_l F
+GLIBC_2.3 __towupper_l F
+GLIBC_2.3 __tzname D 0x8
+GLIBC_2.3 __udivdi3 F
+GLIBC_2.3 __uflow F
+GLIBC_2.3 __umoddi3 F
+GLIBC_2.3 __underflow F
+GLIBC_2.3 __uselocale F
+GLIBC_2.3 __vfork F
+GLIBC_2.3 __vfscanf F
+GLIBC_2.3 __vsnprintf F
+GLIBC_2.3 __vsscanf F
+GLIBC_2.3 __wait F
+GLIBC_2.3 __waitpid F
+GLIBC_2.3 __wcscasecmp_l F
+GLIBC_2.3 __wcscoll_l F
+GLIBC_2.3 __wcsftime_l F
+GLIBC_2.3 __wcsncasecmp_l F
+GLIBC_2.3 __wcstod_internal F
+GLIBC_2.3 __wcstod_l F
+GLIBC_2.3 __wcstof_internal F
+GLIBC_2.3 __wcstof_l F
+GLIBC_2.3 __wcstol_internal F
+GLIBC_2.3 __wcstol_l F
+GLIBC_2.3 __wcstold_internal F
+GLIBC_2.3 __wcstold_l F
+GLIBC_2.3 __wcstoll_internal F
+GLIBC_2.3 __wcstoll_l F
+GLIBC_2.3 __wcstoul_internal F
+GLIBC_2.3 __wcstoul_l F
+GLIBC_2.3 __wcstoull_internal F
+GLIBC_2.3 __wcstoull_l F
+GLIBC_2.3 __wcsxfrm_l F
+GLIBC_2.3 __wctrans_l F
+GLIBC_2.3 __wctype_l F
+GLIBC_2.3 __woverflow F
+GLIBC_2.3 __write F
+GLIBC_2.3 __wuflow F
+GLIBC_2.3 __wunderflow F
+GLIBC_2.3 __xmknod F
+GLIBC_2.3 __xpg_basename F
+GLIBC_2.3 __xpg_sigpause F
+GLIBC_2.3 __xstat F
+GLIBC_2.3 __xstat64 F
+GLIBC_2.3 _authenticate F
+GLIBC_2.3 _dl_mcount_wrapper F
+GLIBC_2.3 _dl_mcount_wrapper_check F
+GLIBC_2.3 _environ D 0x4
+GLIBC_2.3 _exit F
+GLIBC_2.3 _flushlbf F
+GLIBC_2.3 _libc_intl_domainname D 0x5
+GLIBC_2.3 _longjmp F
+GLIBC_2.3 _mcleanup F
+GLIBC_2.3 _mcount F
+GLIBC_2.3 _nl_default_dirname D 0x12
+GLIBC_2.3 _nl_domain_bindings D 0x4
+GLIBC_2.3 _nl_msg_cat_cntr D 0x4
+GLIBC_2.3 _null_auth D 0xc
+GLIBC_2.3 _obstack D 0x4
+GLIBC_2.3 _obstack_allocated_p F
+GLIBC_2.3 _obstack_begin F
+GLIBC_2.3 _obstack_begin_1 F
+GLIBC_2.3 _obstack_free F
+GLIBC_2.3 _obstack_memory_used F
+GLIBC_2.3 _obstack_newchunk F
+GLIBC_2.3 _res D 0x200
+GLIBC_2.3 _res_hconf D 0x30
+GLIBC_2.3 _rpc_dtablesize F
+GLIBC_2.3 _seterr_reply F
+GLIBC_2.3 _setjmp F
+GLIBC_2.3 _sys_errlist D 0x15c
+GLIBC_2.3 _sys_nerr D 0x4
+GLIBC_2.3 _sys_siglist D 0x204
+GLIBC_2.3 _tolower F
+GLIBC_2.3 _toupper F
+GLIBC_2.3 a64l F
+GLIBC_2.3 abort F
+GLIBC_2.3 abs F
+GLIBC_2.3 accept F
+GLIBC_2.3 access F
+GLIBC_2.3 acct F
+GLIBC_2.3 addmntent F
+GLIBC_2.3 addseverity F
+GLIBC_2.3 adjtime F
+GLIBC_2.3 advance F
+GLIBC_2.3 alarm F
+GLIBC_2.3 alphasort F
+GLIBC_2.3 alphasort64 F
+GLIBC_2.3 argp_err_exit_status D 0x4
+GLIBC_2.3 argp_error F
+GLIBC_2.3 argp_failure F
+GLIBC_2.3 argp_help F
+GLIBC_2.3 argp_parse F
+GLIBC_2.3 argp_program_bug_address D 0x4
+GLIBC_2.3 argp_program_version D 0x4
+GLIBC_2.3 argp_program_version_hook D 0x4
+GLIBC_2.3 argp_state_help F
+GLIBC_2.3 argp_usage F
+GLIBC_2.3 argz_add F
+GLIBC_2.3 argz_add_sep F
+GLIBC_2.3 argz_append F
+GLIBC_2.3 argz_count F
+GLIBC_2.3 argz_create F
+GLIBC_2.3 argz_create_sep F
+GLIBC_2.3 argz_delete F
+GLIBC_2.3 argz_extract F
+GLIBC_2.3 argz_insert F
+GLIBC_2.3 argz_next F
+GLIBC_2.3 argz_replace F
+GLIBC_2.3 argz_stringify F
+GLIBC_2.3 asctime F
+GLIBC_2.3 asctime_r F
+GLIBC_2.3 asprintf F
+GLIBC_2.3 atof F
+GLIBC_2.3 atoi F
+GLIBC_2.3 atol F
+GLIBC_2.3 atoll F
+GLIBC_2.3 authdes_create F
+GLIBC_2.3 authdes_getucred F
+GLIBC_2.3 authdes_pk_create F
+GLIBC_2.3 authnone_create F
+GLIBC_2.3 authunix_create F
+GLIBC_2.3 authunix_create_default F
+GLIBC_2.3 backtrace F
+GLIBC_2.3 backtrace_symbols F
+GLIBC_2.3 backtrace_symbols_fd F
+GLIBC_2.3 basename F
+GLIBC_2.3 bcmp F
+GLIBC_2.3 bcopy F
+GLIBC_2.3 bind F
+GLIBC_2.3 bind_textdomain_codeset F
+GLIBC_2.3 bindresvport F
+GLIBC_2.3 bindtextdomain F
+GLIBC_2.3 brk F
+GLIBC_2.3 bsd_signal F
+GLIBC_2.3 bsearch F
+GLIBC_2.3 btowc F
+GLIBC_2.3 bzero F
+GLIBC_2.3 calloc F
+GLIBC_2.3 callrpc F
+GLIBC_2.3 canonicalize_file_name F
+GLIBC_2.3 catclose F
+GLIBC_2.3 catgets F
+GLIBC_2.3 catopen F
+GLIBC_2.3 cbc_crypt F
+GLIBC_2.3 cfgetispeed F
+GLIBC_2.3 cfgetospeed F
+GLIBC_2.3 cfmakeraw F
+GLIBC_2.3 cfree F
+GLIBC_2.3 cfsetispeed F
+GLIBC_2.3 cfsetospeed F
+GLIBC_2.3 cfsetspeed F
+GLIBC_2.3 chdir F
+GLIBC_2.3 chflags F
+GLIBC_2.3 chmod F
+GLIBC_2.3 chown F
+GLIBC_2.3 chroot F
+GLIBC_2.3 clearenv F
+GLIBC_2.3 clearerr F
+GLIBC_2.3 clearerr_unlocked F
+GLIBC_2.3 clnt_broadcast F
+GLIBC_2.3 clnt_create F
+GLIBC_2.3 clnt_pcreateerror F
+GLIBC_2.3 clnt_perrno F
+GLIBC_2.3 clnt_perror F
+GLIBC_2.3 clnt_spcreateerror F
+GLIBC_2.3 clnt_sperrno F
+GLIBC_2.3 clnt_sperror F
+GLIBC_2.3 clntraw_create F
+GLIBC_2.3 clnttcp_create F
+GLIBC_2.3 clntudp_bufcreate F
+GLIBC_2.3 clntudp_create F
+GLIBC_2.3 clntunix_create F
+GLIBC_2.3 clock F
+GLIBC_2.3 clone F
+GLIBC_2.3 close F
+GLIBC_2.3 closedir F
+GLIBC_2.3 closelog F
+GLIBC_2.3 confstr F
+GLIBC_2.3 connect F
+GLIBC_2.3 copysign F
+GLIBC_2.3 copysignf F
+GLIBC_2.3 copysignl F
+GLIBC_2.3 creat F
+GLIBC_2.3 creat64 F
+GLIBC_2.3 ctermid F
+GLIBC_2.3 ctime F
+GLIBC_2.3 ctime_r F
+GLIBC_2.3 cuserid F
+GLIBC_2.3 daemon F
+GLIBC_2.3 daylight D 0x4
+GLIBC_2.3 dcgettext F
+GLIBC_2.3 dcngettext F
+GLIBC_2.3 des_setparity F
+GLIBC_2.3 dgettext F
+GLIBC_2.3 difftime F
+GLIBC_2.3 dirfd F
+GLIBC_2.3 dirname F
+GLIBC_2.3 div F
+GLIBC_2.3 dl_iterate_phdr F
+GLIBC_2.3 dngettext F
+GLIBC_2.3 dprintf F
+GLIBC_2.3 drand48 F
+GLIBC_2.3 drand48_r F
+GLIBC_2.3 dup F
+GLIBC_2.3 dup2 F
+GLIBC_2.3 duplocale F
+GLIBC_2.3 dysize F
+GLIBC_2.3 ecb_crypt F
+GLIBC_2.3 ecvt F
+GLIBC_2.3 ecvt_r F
+GLIBC_2.3 endaliasent F
+GLIBC_2.3 endfsent F
+GLIBC_2.3 endgrent F
+GLIBC_2.3 endhostent F
+GLIBC_2.3 endmntent F
+GLIBC_2.3 endnetent F
+GLIBC_2.3 endnetgrent F
+GLIBC_2.3 endprotoent F
+GLIBC_2.3 endpwent F
+GLIBC_2.3 endrpcent F
+GLIBC_2.3 endservent F
+GLIBC_2.3 endspent F
+GLIBC_2.3 endttyent F
+GLIBC_2.3 endusershell F
+GLIBC_2.3 endutent F
+GLIBC_2.3 endutxent F
+GLIBC_2.3 environ D 0x4
+GLIBC_2.3 envz_add F
+GLIBC_2.3 envz_entry F
+GLIBC_2.3 envz_get F
+GLIBC_2.3 envz_merge F
+GLIBC_2.3 envz_remove F
+GLIBC_2.3 envz_strip F
+GLIBC_2.3 erand48 F
+GLIBC_2.3 erand48_r F
+GLIBC_2.3 err F
+GLIBC_2.3 error F
+GLIBC_2.3 error_at_line F
+GLIBC_2.3 error_message_count D 0x4
+GLIBC_2.3 error_one_per_line D 0x4
+GLIBC_2.3 error_print_progname D 0x4
+GLIBC_2.3 errx F
+GLIBC_2.3 ether_aton F
+GLIBC_2.3 ether_aton_r F
+GLIBC_2.3 ether_hostton F
+GLIBC_2.3 ether_line F
+GLIBC_2.3 ether_ntoa F
+GLIBC_2.3 ether_ntoa_r F
+GLIBC_2.3 ether_ntohost F
+GLIBC_2.3 euidaccess F
+GLIBC_2.3 execl F
+GLIBC_2.3 execle F
+GLIBC_2.3 execlp F
+GLIBC_2.3 execv F
+GLIBC_2.3 execve F
+GLIBC_2.3 execvp F
+GLIBC_2.3 exit F
+GLIBC_2.3 extattr_delete_file F
+GLIBC_2.3 extattr_get_file F
+GLIBC_2.3 extattr_set_file F
+GLIBC_2.3 extattrctl F
+GLIBC_2.3 fattach F
+GLIBC_2.3 fchdir F
+GLIBC_2.3 fchflags F
+GLIBC_2.3 fchmod F
+GLIBC_2.3 fchown F
+GLIBC_2.3 fclose F
+GLIBC_2.3 fcloseall F
+GLIBC_2.3 fcntl F
+GLIBC_2.3 fcvt F
+GLIBC_2.3 fcvt_r F
+GLIBC_2.3 fdatasync F
+GLIBC_2.3 fdetach F
+GLIBC_2.3 fdopen F
+GLIBC_2.3 feof F
+GLIBC_2.3 feof_unlocked F
+GLIBC_2.3 ferror F
+GLIBC_2.3 ferror_unlocked F
+GLIBC_2.3 fexecve F
+GLIBC_2.3 fflush F
+GLIBC_2.3 fflush_unlocked F
+GLIBC_2.3 ffs F
+GLIBC_2.3 ffsl F
+GLIBC_2.3 ffsll F
+GLIBC_2.3 fgetc F
+GLIBC_2.3 fgetc_unlocked F
+GLIBC_2.3 fgetgrent F
+GLIBC_2.3 fgetgrent_r F
+GLIBC_2.3 fgetpos F
+GLIBC_2.3 fgetpos64 F
+GLIBC_2.3 fgetpwent F
+GLIBC_2.3 fgetpwent_r F
+GLIBC_2.3 fgets F
+GLIBC_2.3 fgets_unlocked F
+GLIBC_2.3 fgetspent F
+GLIBC_2.3 fgetspent_r F
+GLIBC_2.3 fgetwc F
+GLIBC_2.3 fgetwc_unlocked F
+GLIBC_2.3 fgetws F
+GLIBC_2.3 fgetws_unlocked F
+GLIBC_2.3 fgetxattr F
+GLIBC_2.3 fhopen F
+GLIBC_2.3 fhstat F
+GLIBC_2.3 fhstatfs F
+GLIBC_2.3 fileno F
+GLIBC_2.3 fileno_unlocked F
+GLIBC_2.3 finite F
+GLIBC_2.3 finitef F
+GLIBC_2.3 finitel F
+GLIBC_2.3 flistxattr F
+GLIBC_2.3 flock F
+GLIBC_2.3 flockfile F
+GLIBC_2.3 fmemopen F
+GLIBC_2.3 fmtmsg F
+GLIBC_2.3 fnmatch F
+GLIBC_2.3 fopen F
+GLIBC_2.3 fopen64 F
+GLIBC_2.3 fopencookie F
+GLIBC_2.3 fork F
+GLIBC_2.3 fpathconf F
+GLIBC_2.3 fprintf F
+GLIBC_2.3 fputc F
+GLIBC_2.3 fputc_unlocked F
+GLIBC_2.3 fputs F
+GLIBC_2.3 fputs_unlocked F
+GLIBC_2.3 fputwc F
+GLIBC_2.3 fputwc_unlocked F
+GLIBC_2.3 fputws F
+GLIBC_2.3 fputws_unlocked F
+GLIBC_2.3 fread F
+GLIBC_2.3 fread_unlocked F
+GLIBC_2.3 free F
+GLIBC_2.3 freeaddrinfo F
+GLIBC_2.3 freeifaddrs F
+GLIBC_2.3 freelocale F
+GLIBC_2.3 fremovexattr F
+GLIBC_2.3 freopen F
+GLIBC_2.3 freopen64 F
+GLIBC_2.3 frexp F
+GLIBC_2.3 frexpf F
+GLIBC_2.3 frexpl F
+GLIBC_2.3 fscanf F
+GLIBC_2.3 fseek F
+GLIBC_2.3 fseeko F
+GLIBC_2.3 fseeko64 F
+GLIBC_2.3 fsetpos F
+GLIBC_2.3 fsetpos64 F
+GLIBC_2.3 fsetxattr F
+GLIBC_2.3 fstatfs F
+GLIBC_2.3 fstatfs64 F
+GLIBC_2.3 fstatvfs F
+GLIBC_2.3 fstatvfs64 F
+GLIBC_2.3 fsync F
+GLIBC_2.3 ftell F
+GLIBC_2.3 ftello F
+GLIBC_2.3 ftello64 F
+GLIBC_2.3 ftime F
+GLIBC_2.3 ftok F
+GLIBC_2.3 ftruncate F
+GLIBC_2.3 ftruncate64 F
+GLIBC_2.3 ftrylockfile F
+GLIBC_2.3 fts_children F
+GLIBC_2.3 fts_close F
+GLIBC_2.3 fts_open F
+GLIBC_2.3 fts_read F
+GLIBC_2.3 fts_set F
+GLIBC_2.3 ftw F
+GLIBC_2.3 ftw64 F
+GLIBC_2.3 funlockfile F
+GLIBC_2.3 futimes F
+GLIBC_2.3 fwide F
+GLIBC_2.3 fwprintf F
+GLIBC_2.3 fwrite F
+GLIBC_2.3 fwrite_unlocked F
+GLIBC_2.3 fwscanf F
+GLIBC_2.3 gai_strerror F
+GLIBC_2.3 gcvt F
+GLIBC_2.3 get_avphys_pages F
+GLIBC_2.3 get_current_dir_name F
+GLIBC_2.3 get_myaddress F
+GLIBC_2.3 get_nprocs F
+GLIBC_2.3 get_nprocs_conf F
+GLIBC_2.3 get_phys_pages F
+GLIBC_2.3 getaddrinfo F
+GLIBC_2.3 getaliasbyname F
+GLIBC_2.3 getaliasbyname_r F
+GLIBC_2.3 getaliasent F
+GLIBC_2.3 getaliasent_r F
+GLIBC_2.3 getc F
+GLIBC_2.3 getc_unlocked F
+GLIBC_2.3 getchar F
+GLIBC_2.3 getchar_unlocked F
+GLIBC_2.3 getcontext F
+GLIBC_2.3 getcwd F
+GLIBC_2.3 getdate F
+GLIBC_2.3 getdate_err D 0x4
+GLIBC_2.3 getdate_r F
+GLIBC_2.3 getdelim F
+GLIBC_2.3 getdents F
+GLIBC_2.3 getdirentries F
+GLIBC_2.3 getdirentries64 F
+GLIBC_2.3 getdomainname F
+GLIBC_2.3 getdtablesize F
+GLIBC_2.3 getegid F
+GLIBC_2.3 getenv F
+GLIBC_2.3 geteuid F
+GLIBC_2.3 getfh F
+GLIBC_2.3 getfsent F
+GLIBC_2.3 getfsfile F
+GLIBC_2.3 getfsspec F
+GLIBC_2.3 getfsstat F
+GLIBC_2.3 getfsstat64 F
+GLIBC_2.3 getgid F
+GLIBC_2.3 getgrent F
+GLIBC_2.3 getgrent_r F
+GLIBC_2.3 getgrgid F
+GLIBC_2.3 getgrgid_r F
+GLIBC_2.3 getgrnam F
+GLIBC_2.3 getgrnam_r F
+GLIBC_2.3 getgrouplist F
+GLIBC_2.3 getgroups F
+GLIBC_2.3 gethostbyaddr F
+GLIBC_2.3 gethostbyaddr_r F
+GLIBC_2.3 gethostbyname F
+GLIBC_2.3 gethostbyname2 F
+GLIBC_2.3 gethostbyname2_r F
+GLIBC_2.3 gethostbyname_r F
+GLIBC_2.3 gethostent F
+GLIBC_2.3 gethostent_r F
+GLIBC_2.3 gethostid F
+GLIBC_2.3 gethostname F
+GLIBC_2.3 getifaddrs F
+GLIBC_2.3 getitimer F
+GLIBC_2.3 getline F
+GLIBC_2.3 getloadavg F
+GLIBC_2.3 getlogin F
+GLIBC_2.3 getlogin_r F
+GLIBC_2.3 getmntent F
+GLIBC_2.3 getmntent_r F
+GLIBC_2.3 getmntinfo F
+GLIBC_2.3 getmntinfo64 F
+GLIBC_2.3 getmsg F
+GLIBC_2.3 getnameinfo F
+GLIBC_2.3 getnetbyaddr F
+GLIBC_2.3 getnetbyaddr_r F
+GLIBC_2.3 getnetbyname F
+GLIBC_2.3 getnetbyname_r F
+GLIBC_2.3 getnetent F
+GLIBC_2.3 getnetent_r F
+GLIBC_2.3 getnetgrent F
+GLIBC_2.3 getnetgrent_r F
+GLIBC_2.3 getnetname F
+GLIBC_2.3 getopt F
+GLIBC_2.3 getopt_long F
+GLIBC_2.3 getopt_long_only F
+GLIBC_2.3 getpagesize F
+GLIBC_2.3 getpass F
+GLIBC_2.3 getpeername F
+GLIBC_2.3 getpgid F
+GLIBC_2.3 getpgrp F
+GLIBC_2.3 getpid F
+GLIBC_2.3 getpmsg F
+GLIBC_2.3 getppid F
+GLIBC_2.3 getpriority F
+GLIBC_2.3 getprotobyname F
+GLIBC_2.3 getprotobyname_r F
+GLIBC_2.3 getprotobynumber F
+GLIBC_2.3 getprotobynumber_r F
+GLIBC_2.3 getprotoent F
+GLIBC_2.3 getprotoent_r F
+GLIBC_2.3 getpt F
+GLIBC_2.3 getpublickey F
+GLIBC_2.3 getpw F
+GLIBC_2.3 getpwent F
+GLIBC_2.3 getpwent_r F
+GLIBC_2.3 getpwnam F
+GLIBC_2.3 getpwnam_r F
+GLIBC_2.3 getpwuid F
+GLIBC_2.3 getpwuid_r F
+GLIBC_2.3 getresgid F
+GLIBC_2.3 getresuid F
+GLIBC_2.3 getrlimit F
+GLIBC_2.3 getrlimit64 F
+GLIBC_2.3 getrpcbyname F
+GLIBC_2.3 getrpcbyname_r F
+GLIBC_2.3 getrpcbynumber F
+GLIBC_2.3 getrpcbynumber_r F
+GLIBC_2.3 getrpcent F
+GLIBC_2.3 getrpcent_r F
+GLIBC_2.3 getrpcport F
+GLIBC_2.3 getrusage F
+GLIBC_2.3 gets F
+GLIBC_2.3 getsecretkey F
+GLIBC_2.3 getservbyname F
+GLIBC_2.3 getservbyname_r F
+GLIBC_2.3 getservbyport F
+GLIBC_2.3 getservbyport_r F
+GLIBC_2.3 getservent F
+GLIBC_2.3 getservent_r F
+GLIBC_2.3 getsid F
+GLIBC_2.3 getsockname F
+GLIBC_2.3 getsockopt F
+GLIBC_2.3 getspent F
+GLIBC_2.3 getspent_r F
+GLIBC_2.3 getspnam F
+GLIBC_2.3 getspnam_r F
+GLIBC_2.3 getsubopt F
+GLIBC_2.3 gettext F
+GLIBC_2.3 gettimeofday F
+GLIBC_2.3 getttyent F
+GLIBC_2.3 getttynam F
+GLIBC_2.3 getuid F
+GLIBC_2.3 getusershell F
+GLIBC_2.3 getutent F
+GLIBC_2.3 getutent_r F
+GLIBC_2.3 getutid F
+GLIBC_2.3 getutid_r F
+GLIBC_2.3 getutline F
+GLIBC_2.3 getutline_r F
+GLIBC_2.3 getutmp F
+GLIBC_2.3 getutmpx F
+GLIBC_2.3 getutxent F
+GLIBC_2.3 getutxid F
+GLIBC_2.3 getutxline F
+GLIBC_2.3 getw F
+GLIBC_2.3 getwc F
+GLIBC_2.3 getwc_unlocked F
+GLIBC_2.3 getwchar F
+GLIBC_2.3 getwchar_unlocked F
+GLIBC_2.3 getwd F
+GLIBC_2.3 getxattr F
+GLIBC_2.3 glob F
+GLIBC_2.3 glob64 F
+GLIBC_2.3 glob_pattern_p F
+GLIBC_2.3 globfree F
+GLIBC_2.3 globfree64 F
+GLIBC_2.3 gmtime F
+GLIBC_2.3 gmtime_r F
+GLIBC_2.3 gnu_get_libc_release F
+GLIBC_2.3 gnu_get_libc_version F
+GLIBC_2.3 grantpt F
+GLIBC_2.3 group_member F
+GLIBC_2.3 gsignal F
+GLIBC_2.3 gtty F
+GLIBC_2.3 h_errlist D 0x14
+GLIBC_2.3 h_nerr D 0x4
+GLIBC_2.3 hasmntopt F
+GLIBC_2.3 hcreate F
+GLIBC_2.3 hcreate_r F
+GLIBC_2.3 hdestroy F
+GLIBC_2.3 hdestroy_r F
+GLIBC_2.3 herror F
+GLIBC_2.3 host2netname F
+GLIBC_2.3 hsearch F
+GLIBC_2.3 hsearch_r F
+GLIBC_2.3 hstrerror F
+GLIBC_2.3 htonl F
+GLIBC_2.3 htons F
+GLIBC_2.3 i386_get_ioperm F
+GLIBC_2.3 i386_get_ldt F
+GLIBC_2.3 i386_set_ioperm F
+GLIBC_2.3 i386_set_ldt F
+GLIBC_2.3 i386_vm86 F
+GLIBC_2.3 iconv F
+GLIBC_2.3 iconv_close F
+GLIBC_2.3 iconv_open F
+GLIBC_2.3 if_freenameindex F
+GLIBC_2.3 if_indextoname F
+GLIBC_2.3 if_nameindex F
+GLIBC_2.3 if_nametoindex F
+GLIBC_2.3 imaxabs F
+GLIBC_2.3 imaxdiv F
+GLIBC_2.3 in6addr_any D 0x10
+GLIBC_2.3 in6addr_loopback D 0x10
+GLIBC_2.3 index F
+GLIBC_2.3 inet_addr F
+GLIBC_2.3 inet_aton F
+GLIBC_2.3 inet_lnaof F
+GLIBC_2.3 inet_makeaddr F
+GLIBC_2.3 inet_netof F
+GLIBC_2.3 inet_network F
+GLIBC_2.3 inet_nsap_addr F
+GLIBC_2.3 inet_nsap_ntoa F
+GLIBC_2.3 inet_ntoa F
+GLIBC_2.3 inet_ntop F
+GLIBC_2.3 inet_pton F
+GLIBC_2.3 initgroups F
+GLIBC_2.3 initstate F
+GLIBC_2.3 initstate_r F
+GLIBC_2.3 innetgr F
+GLIBC_2.3 insque F
+GLIBC_2.3 ioctl F
+GLIBC_2.3 ioperm F
+GLIBC_2.3 iopl F
+GLIBC_2.3 iruserok F
+GLIBC_2.3 iruserok_af F
+GLIBC_2.3 isalnum F
+GLIBC_2.3 isalnum_l F
+GLIBC_2.3 isalpha F
+GLIBC_2.3 isalpha_l F
+GLIBC_2.3 isascii F
+GLIBC_2.3 isastream F
+GLIBC_2.3 isatty F
+GLIBC_2.3 isblank F
+GLIBC_2.3 isblank_l F
+GLIBC_2.3 iscntrl F
+GLIBC_2.3 iscntrl_l F
+GLIBC_2.3 isctype F
+GLIBC_2.3 isdigit F
+GLIBC_2.3 isdigit_l F
+GLIBC_2.3 isfdtype F
+GLIBC_2.3 isgraph F
+GLIBC_2.3 isgraph_l F
+GLIBC_2.3 isinf F
+GLIBC_2.3 isinff F
+GLIBC_2.3 isinfl F
+GLIBC_2.3 islower F
+GLIBC_2.3 islower_l F
+GLIBC_2.3 isnan F
+GLIBC_2.3 isnanf F
+GLIBC_2.3 isnanl F
+GLIBC_2.3 isprint F
+GLIBC_2.3 isprint_l F
+GLIBC_2.3 ispunct F
+GLIBC_2.3 ispunct_l F
+GLIBC_2.3 issetugid F
+GLIBC_2.3 isspace F
+GLIBC_2.3 isspace_l F
+GLIBC_2.3 isupper F
+GLIBC_2.3 isupper_l F
+GLIBC_2.3 iswalnum F
+GLIBC_2.3 iswalnum_l F
+GLIBC_2.3 iswalpha F
+GLIBC_2.3 iswalpha_l F
+GLIBC_2.3 iswblank F
+GLIBC_2.3 iswblank_l F
+GLIBC_2.3 iswcntrl F
+GLIBC_2.3 iswcntrl_l F
+GLIBC_2.3 iswctype F
+GLIBC_2.3 iswctype_l F
+GLIBC_2.3 iswdigit F
+GLIBC_2.3 iswdigit_l F
+GLIBC_2.3 iswgraph F
+GLIBC_2.3 iswgraph_l F
+GLIBC_2.3 iswlower F
+GLIBC_2.3 iswlower_l F
+GLIBC_2.3 iswprint F
+GLIBC_2.3 iswprint_l F
+GLIBC_2.3 iswpunct F
+GLIBC_2.3 iswpunct_l F
+GLIBC_2.3 iswspace F
+GLIBC_2.3 iswspace_l F
+GLIBC_2.3 iswupper F
+GLIBC_2.3 iswupper_l F
+GLIBC_2.3 iswxdigit F
+GLIBC_2.3 iswxdigit_l F
+GLIBC_2.3 isxdigit F
+GLIBC_2.3 isxdigit_l F
+GLIBC_2.3 jail F
+GLIBC_2.3 jrand48 F
+GLIBC_2.3 jrand48_r F
+GLIBC_2.3 key_decryptsession F
+GLIBC_2.3 key_decryptsession_pk F
+GLIBC_2.3 key_encryptsession F
+GLIBC_2.3 key_encryptsession_pk F
+GLIBC_2.3 key_gendes F
+GLIBC_2.3 key_get_conv F
+GLIBC_2.3 key_secretkey_is_set F
+GLIBC_2.3 key_setnet F
+GLIBC_2.3 key_setsecret F
+GLIBC_2.3 kill F
+GLIBC_2.3 killpg F
+GLIBC_2.3 kldfind F
+GLIBC_2.3 kldfirstmod F
+GLIBC_2.3 kldload F
+GLIBC_2.3 kldnext F
+GLIBC_2.3 kldstat F
+GLIBC_2.3 kldsym F
+GLIBC_2.3 kldunload F
+GLIBC_2.3 kldunloadf F
+GLIBC_2.3 ktrace F
+GLIBC_2.3 l64a F
+GLIBC_2.3 labs F
+GLIBC_2.3 lchmod F
+GLIBC_2.3 lchown F
+GLIBC_2.3 lckpwdf F
+GLIBC_2.3 lcong48 F
+GLIBC_2.3 lcong48_r F
+GLIBC_2.3 ldexp F
+GLIBC_2.3 ldexpf F
+GLIBC_2.3 ldexpl F
+GLIBC_2.3 ldiv F
+GLIBC_2.3 lfind F
+GLIBC_2.3 lgetxattr F
+GLIBC_2.3 link F
+GLIBC_2.3 listen F
+GLIBC_2.3 listxattr F
+GLIBC_2.3 llabs F
+GLIBC_2.3 lldiv F
+GLIBC_2.3 llistxattr F
+GLIBC_2.3 loc1 D 0x4
+GLIBC_2.3 loc2 D 0x4
+GLIBC_2.3 localeconv F
+GLIBC_2.3 localtime F
+GLIBC_2.3 localtime_r F
+GLIBC_2.3 lockf F
+GLIBC_2.3 lockf64 F
+GLIBC_2.3 locs D 0x4
+GLIBC_2.3 longjmp F
+GLIBC_2.3 lrand48 F
+GLIBC_2.3 lrand48_r F
+GLIBC_2.3 lremovexattr F
+GLIBC_2.3 lsearch F
+GLIBC_2.3 lseek F
+GLIBC_2.3 lseek64 F
+GLIBC_2.3 lsetxattr F
+GLIBC_2.3 lutimes F
+GLIBC_2.3 madvise F
+GLIBC_2.3 makecontext F
+GLIBC_2.3 mallinfo F
+GLIBC_2.3 malloc F
+GLIBC_2.3 malloc_get_state F
+GLIBC_2.3 malloc_set_state F
+GLIBC_2.3 malloc_stats F
+GLIBC_2.3 malloc_trim F
+GLIBC_2.3 malloc_usable_size F
+GLIBC_2.3 mallopt F
+GLIBC_2.3 mallwatch D 0x4
+GLIBC_2.3 mblen F
+GLIBC_2.3 mbrlen F
+GLIBC_2.3 mbrtowc F
+GLIBC_2.3 mbsinit F
+GLIBC_2.3 mbsnrtowcs F
+GLIBC_2.3 mbsrtowcs F
+GLIBC_2.3 mbstowcs F
+GLIBC_2.3 mbtowc F
+GLIBC_2.3 mcheck F
+GLIBC_2.3 mcheck_check_all F
+GLIBC_2.3 mcheck_pedantic F
+GLIBC_2.3 mcount F
+GLIBC_2.3 memalign F
+GLIBC_2.3 memccpy F
+GLIBC_2.3 memchr F
+GLIBC_2.3 memcmp F
+GLIBC_2.3 memcpy F
+GLIBC_2.3 memfrob F
+GLIBC_2.3 memmem F
+GLIBC_2.3 memmove F
+GLIBC_2.3 mempcpy F
+GLIBC_2.3 memrchr F
+GLIBC_2.3 memset F
+GLIBC_2.3 mincore F
+GLIBC_2.3 minherit F
+GLIBC_2.3 mkdir F
+GLIBC_2.3 mkdtemp F
+GLIBC_2.3 mkfifo F
+GLIBC_2.3 mkstemp F
+GLIBC_2.3 mkstemp64 F
+GLIBC_2.3 mktemp F
+GLIBC_2.3 mktime F
+GLIBC_2.3 mlock F
+GLIBC_2.3 mlockall F
+GLIBC_2.3 mmap F
+GLIBC_2.3 mmap64 F
+GLIBC_2.3 modf F
+GLIBC_2.3 modff F
+GLIBC_2.3 modfind F
+GLIBC_2.3 modfl F
+GLIBC_2.3 modfnext F
+GLIBC_2.3 modnext F
+GLIBC_2.3 modstat F
+GLIBC_2.3 moncontrol F
+GLIBC_2.3 monstartup F
+GLIBC_2.3 mount F
+GLIBC_2.3 mprobe F
+GLIBC_2.3 mprotect F
+GLIBC_2.3 mrand48 F
+GLIBC_2.3 mrand48_r F
+GLIBC_2.3 msgctl F
+GLIBC_2.3 msgget F
+GLIBC_2.3 msgrcv F
+GLIBC_2.3 msgsnd F
+GLIBC_2.3 msync F
+GLIBC_2.3 mtrace F
+GLIBC_2.3 munlock F
+GLIBC_2.3 munlockall F
+GLIBC_2.3 munmap F
+GLIBC_2.3 muntrace F
+GLIBC_2.3 nanosleep F
+GLIBC_2.3 netname2host F
+GLIBC_2.3 netname2user F
+GLIBC_2.3 newlocale F
+GLIBC_2.3 nftw F
+GLIBC_2.3 nftw64 F
+GLIBC_2.3 ngettext F
+GLIBC_2.3 nice F
+GLIBC_2.3 nl_langinfo F
+GLIBC_2.3 nl_langinfo_l F
+GLIBC_2.3 nmount F
+GLIBC_2.3 nrand48 F
+GLIBC_2.3 nrand48_r F
+GLIBC_2.3 ntohl F
+GLIBC_2.3 ntohs F
+GLIBC_2.3 ntp_adjtime F
+GLIBC_2.3 ntp_gettime F
+GLIBC_2.3 obstack_alloc_failed_handler D 0x4
+GLIBC_2.3 obstack_exit_failure D 0x4
+GLIBC_2.3 obstack_free F
+GLIBC_2.3 obstack_printf F
+GLIBC_2.3 obstack_vprintf F
+GLIBC_2.3 on_exit F
+GLIBC_2.3 open F
+GLIBC_2.3 open64 F
+GLIBC_2.3 open_memstream F
+GLIBC_2.3 opendir F
+GLIBC_2.3 openlog F
+GLIBC_2.3 optarg D 0x4
+GLIBC_2.3 opterr D 0x4
+GLIBC_2.3 optind D 0x4
+GLIBC_2.3 optopt D 0x4
+GLIBC_2.3 parse_printf_format F
+GLIBC_2.3 passwd2des F
+GLIBC_2.3 pathconf F
+GLIBC_2.3 pause F
+GLIBC_2.3 pclose F
+GLIBC_2.3 perror F
+GLIBC_2.3 pipe F
+GLIBC_2.3 pmap_getmaps F
+GLIBC_2.3 pmap_getport F
+GLIBC_2.3 pmap_rmtcall F
+GLIBC_2.3 pmap_set F
+GLIBC_2.3 pmap_unset F
+GLIBC_2.3 poll F
+GLIBC_2.3 popen F
+GLIBC_2.3 posix_fadvise F
+GLIBC_2.3 posix_fadvise64 F
+GLIBC_2.3 posix_fallocate F
+GLIBC_2.3 posix_fallocate64 F
+GLIBC_2.3 posix_madvise F
+GLIBC_2.3 posix_memalign F
+GLIBC_2.3 posix_openpt F
+GLIBC_2.3 posix_spawn F
+GLIBC_2.3 posix_spawn_file_actions_addclose F
+GLIBC_2.3 posix_spawn_file_actions_adddup2 F
+GLIBC_2.3 posix_spawn_file_actions_addopen F
+GLIBC_2.3 posix_spawn_file_actions_destroy F
+GLIBC_2.3 posix_spawn_file_actions_init F
+GLIBC_2.3 posix_spawnattr_destroy F
+GLIBC_2.3 posix_spawnattr_getflags F
+GLIBC_2.3 posix_spawnattr_getpgroup F
+GLIBC_2.3 posix_spawnattr_getschedparam F
+GLIBC_2.3 posix_spawnattr_getschedpolicy F
+GLIBC_2.3 posix_spawnattr_getsigdefault F
+GLIBC_2.3 posix_spawnattr_getsigmask F
+GLIBC_2.3 posix_spawnattr_init F
+GLIBC_2.3 posix_spawnattr_setflags F
+GLIBC_2.3 posix_spawnattr_setpgroup F
+GLIBC_2.3 posix_spawnattr_setschedparam F
+GLIBC_2.3 posix_spawnattr_setschedpolicy F
+GLIBC_2.3 posix_spawnattr_setsigdefault F
+GLIBC_2.3 posix_spawnattr_setsigmask F
+GLIBC_2.3 posix_spawnp F
+GLIBC_2.3 pread F
+GLIBC_2.3 pread64 F
+GLIBC_2.3 printf F
+GLIBC_2.3 printf_size F
+GLIBC_2.3 printf_size_info F
+GLIBC_2.3 profil F
+GLIBC_2.3 program_invocation_name D 0x4
+GLIBC_2.3 program_invocation_short_name D 0x4
+GLIBC_2.3 pselect F
+GLIBC_2.3 psignal F
+GLIBC_2.3 pthread_attr_destroy F
+GLIBC_2.3 pthread_attr_getdetachstate F
+GLIBC_2.3 pthread_attr_getinheritsched F
+GLIBC_2.3 pthread_attr_getschedparam F
+GLIBC_2.3 pthread_attr_getschedpolicy F
+GLIBC_2.3 pthread_attr_getscope F
+GLIBC_2.3 pthread_attr_init F
+GLIBC_2.3 pthread_attr_setdetachstate F
+GLIBC_2.3 pthread_attr_setinheritsched F
+GLIBC_2.3 pthread_attr_setschedparam F
+GLIBC_2.3 pthread_attr_setschedpolicy F
+GLIBC_2.3 pthread_attr_setscope F
+GLIBC_2.3 pthread_cond_broadcast F
+GLIBC_2.3 pthread_cond_destroy F
+GLIBC_2.3 pthread_cond_init F
+GLIBC_2.3 pthread_cond_signal F
+GLIBC_2.3 pthread_cond_timedwait F
+GLIBC_2.3 pthread_cond_wait F
+GLIBC_2.3 pthread_condattr_destroy F
+GLIBC_2.3 pthread_condattr_init F
+GLIBC_2.3 pthread_equal F
+GLIBC_2.3 pthread_exit F
+GLIBC_2.3 pthread_getschedparam F
+GLIBC_2.3 pthread_mutex_destroy F
+GLIBC_2.3 pthread_mutex_init F
+GLIBC_2.3 pthread_mutex_lock F
+GLIBC_2.3 pthread_mutex_unlock F
+GLIBC_2.3 pthread_self F
+GLIBC_2.3 pthread_setcancelstate F
+GLIBC_2.3 pthread_setcanceltype F
+GLIBC_2.3 pthread_setschedparam F
+GLIBC_2.3 ptrace F
+GLIBC_2.3 ptsname F
+GLIBC_2.3 ptsname_r F
+GLIBC_2.3 putc F
+GLIBC_2.3 putc_unlocked F
+GLIBC_2.3 putchar F
+GLIBC_2.3 putchar_unlocked F
+GLIBC_2.3 putenv F
+GLIBC_2.3 putgrent F
+GLIBC_2.3 putmsg F
+GLIBC_2.3 putpmsg F
+GLIBC_2.3 putpwent F
+GLIBC_2.3 puts F
+GLIBC_2.3 putspent F
+GLIBC_2.3 pututline F
+GLIBC_2.3 pututxline F
+GLIBC_2.3 putw F
+GLIBC_2.3 putwc F
+GLIBC_2.3 putwc_unlocked F
+GLIBC_2.3 putwchar F
+GLIBC_2.3 putwchar_unlocked F
+GLIBC_2.3 pvalloc F
+GLIBC_2.3 pwrite F
+GLIBC_2.3 pwrite64 F
+GLIBC_2.3 qecvt F
+GLIBC_2.3 qecvt_r F
+GLIBC_2.3 qfcvt F
+GLIBC_2.3 qfcvt_r F
+GLIBC_2.3 qgcvt F
+GLIBC_2.3 qsort F
+GLIBC_2.3 quotactl F
+GLIBC_2.3 raise F
+GLIBC_2.3 rand F
+GLIBC_2.3 rand_r F
+GLIBC_2.3 random F
+GLIBC_2.3 random_r F
+GLIBC_2.3 rawmemchr F
+GLIBC_2.3 rcmd F
+GLIBC_2.3 rcmd_af F
+GLIBC_2.3 re_comp F
+GLIBC_2.3 re_compile_fastmap F
+GLIBC_2.3 re_compile_pattern F
+GLIBC_2.3 re_exec F
+GLIBC_2.3 re_match F
+GLIBC_2.3 re_match_2 F
+GLIBC_2.3 re_search F
+GLIBC_2.3 re_search_2 F
+GLIBC_2.3 re_set_registers F
+GLIBC_2.3 re_set_syntax F
+GLIBC_2.3 re_syntax_options D 0x4
+GLIBC_2.3 read F
+GLIBC_2.3 readdir F
+GLIBC_2.3 readdir64 F
+GLIBC_2.3 readdir64_r F
+GLIBC_2.3 readdir_r F
+GLIBC_2.3 readlink F
+GLIBC_2.3 readv F
+GLIBC_2.3 realloc F
+GLIBC_2.3 realpath F
+GLIBC_2.3 reboot F
+GLIBC_2.3 recv F
+GLIBC_2.3 recvfrom F
+GLIBC_2.3 recvmsg F
+GLIBC_2.3 regcomp F
+GLIBC_2.3 regerror F
+GLIBC_2.3 regexec F
+GLIBC_2.3 regfree F
+GLIBC_2.3 register_printf_function F
+GLIBC_2.3 registerrpc F
+GLIBC_2.3 remove F
+GLIBC_2.3 removexattr F
+GLIBC_2.3 remque F
+GLIBC_2.3 rename F
+GLIBC_2.3 revoke F
+GLIBC_2.3 rewind F
+GLIBC_2.3 rewinddir F
+GLIBC_2.3 rexec F
+GLIBC_2.3 rexec_af F
+GLIBC_2.3 rexecoptions D 0x4
+GLIBC_2.3 rfork F
+GLIBC_2.3 rindex F
+GLIBC_2.3 rmdir F
+GLIBC_2.3 rpc_createerr D 0x10
+GLIBC_2.3 rpmatch F
+GLIBC_2.3 rresvport F
+GLIBC_2.3 rresvport_af F
+GLIBC_2.3 rtime F
+GLIBC_2.3 rtprio F
+GLIBC_2.3 ruserok F
+GLIBC_2.3 ruserok_af F
+GLIBC_2.3 ruserpass F
+GLIBC_2.3 sbrk F
+GLIBC_2.3 scalbln F
+GLIBC_2.3 scalblnf F
+GLIBC_2.3 scalblnl F
+GLIBC_2.3 scalbn F
+GLIBC_2.3 scalbnf F
+GLIBC_2.3 scalbnl F
+GLIBC_2.3 scandir F
+GLIBC_2.3 scandir64 F
+GLIBC_2.3 scanf F
+GLIBC_2.3 sched_get_priority_max F
+GLIBC_2.3 sched_get_priority_min F
+GLIBC_2.3 sched_getparam F
+GLIBC_2.3 sched_getscheduler F
+GLIBC_2.3 sched_rr_get_interval F
+GLIBC_2.3 sched_setparam F
+GLIBC_2.3 sched_setscheduler F
+GLIBC_2.3 sched_yield F
+GLIBC_2.3 seed48 F
+GLIBC_2.3 seed48_r F
+GLIBC_2.3 seekdir F
+GLIBC_2.3 select F
+GLIBC_2.3 semctl F
+GLIBC_2.3 semget F
+GLIBC_2.3 semop F
+GLIBC_2.3 send F
+GLIBC_2.3 sendfile F
+GLIBC_2.3 sendfile64 F
+GLIBC_2.3 sendmsg F
+GLIBC_2.3 sendto F
+GLIBC_2.3 setaliasent F
+GLIBC_2.3 setbuf F
+GLIBC_2.3 setbuffer F
+GLIBC_2.3 setcontext F
+GLIBC_2.3 setdomainname F
+GLIBC_2.3 setegid F
+GLIBC_2.3 setenv F
+GLIBC_2.3 seteuid F
+GLIBC_2.3 setfsent F
+GLIBC_2.3 setgid F
+GLIBC_2.3 setgrent F
+GLIBC_2.3 setgroups F
+GLIBC_2.3 sethostent F
+GLIBC_2.3 sethostid F
+GLIBC_2.3 sethostname F
+GLIBC_2.3 setitimer F
+GLIBC_2.3 setjmp F
+GLIBC_2.3 setlinebuf F
+GLIBC_2.3 setlocale F
+GLIBC_2.3 setlogin F
+GLIBC_2.3 setlogmask F
+GLIBC_2.3 setmntent F
+GLIBC_2.3 setnetent F
+GLIBC_2.3 setnetgrent F
+GLIBC_2.3 setpgid F
+GLIBC_2.3 setpgrp F
+GLIBC_2.3 setpriority F
+GLIBC_2.3 setprotoent F
+GLIBC_2.3 setpwent F
+GLIBC_2.3 setregid F
+GLIBC_2.3 setresgid F
+GLIBC_2.3 setresuid F
+GLIBC_2.3 setreuid F
+GLIBC_2.3 setrlimit F
+GLIBC_2.3 setrlimit64 F
+GLIBC_2.3 setrpcent F
+GLIBC_2.3 setservent F
+GLIBC_2.3 setsid F
+GLIBC_2.3 setsockopt F
+GLIBC_2.3 setspent F
+GLIBC_2.3 setstate F
+GLIBC_2.3 setstate_r F
+GLIBC_2.3 settimeofday F
+GLIBC_2.3 setttyent F
+GLIBC_2.3 setuid F
+GLIBC_2.3 setusershell F
+GLIBC_2.3 setutent F
+GLIBC_2.3 setutxent F
+GLIBC_2.3 setvbuf F
+GLIBC_2.3 setxattr F
+GLIBC_2.3 sgetspent F
+GLIBC_2.3 sgetspent_r F
+GLIBC_2.3 shmat F
+GLIBC_2.3 shmctl F
+GLIBC_2.3 shmdt F
+GLIBC_2.3 shmget F
+GLIBC_2.3 shutdown F
+GLIBC_2.3 sigaction F
+GLIBC_2.3 sigaddset F
+GLIBC_2.3 sigaltstack F
+GLIBC_2.3 sigandset F
+GLIBC_2.3 sigblock F
+GLIBC_2.3 sigdelset F
+GLIBC_2.3 sigemptyset F
+GLIBC_2.3 sigfillset F
+GLIBC_2.3 siggetmask F
+GLIBC_2.3 sighold F
+GLIBC_2.3 sigignore F
+GLIBC_2.3 siginterrupt F
+GLIBC_2.3 sigisemptyset F
+GLIBC_2.3 sigismember F
+GLIBC_2.3 siglongjmp F
+GLIBC_2.3 signal F
+GLIBC_2.3 sigorset F
+GLIBC_2.3 sigpause F
+GLIBC_2.3 sigpending F
+GLIBC_2.3 sigprocmask F
+GLIBC_2.3 sigqueue F
+GLIBC_2.3 sigrelse F
+GLIBC_2.3 sigreturn F
+GLIBC_2.3 sigset F
+GLIBC_2.3 sigsetmask F
+GLIBC_2.3 sigstack F
+GLIBC_2.3 sigsuspend F
+GLIBC_2.3 sigtimedwait F
+GLIBC_2.3 sigvec F
+GLIBC_2.3 sigwait F
+GLIBC_2.3 sigwaitinfo F
+GLIBC_2.3 sleep F
+GLIBC_2.3 snprintf F
+GLIBC_2.3 sockatmark F
+GLIBC_2.3 socket F
+GLIBC_2.3 socketpair F
+GLIBC_2.3 sprintf F
+GLIBC_2.3 sprofil F
+GLIBC_2.3 srand F
+GLIBC_2.3 srand48 F
+GLIBC_2.3 srand48_r F
+GLIBC_2.3 srandom F
+GLIBC_2.3 srandom_r F
+GLIBC_2.3 sscanf F
+GLIBC_2.3 ssignal F
+GLIBC_2.3 sstk F
+GLIBC_2.3 statfs F
+GLIBC_2.3 statfs64 F
+GLIBC_2.3 statvfs F
+GLIBC_2.3 statvfs64 F
+GLIBC_2.3 stderr D 0x4
+GLIBC_2.3 stdin D 0x4
+GLIBC_2.3 stdout D 0x4
+GLIBC_2.3 step F
+GLIBC_2.3 stime F
+GLIBC_2.3 stpcpy F
+GLIBC_2.3 stpncpy F
+GLIBC_2.3 strcasecmp F
+GLIBC_2.3 strcasecmp_l F
+GLIBC_2.3 strcasestr F
+GLIBC_2.3 strcat F
+GLIBC_2.3 strchr F
+GLIBC_2.3 strchrnul F
+GLIBC_2.3 strcmp F
+GLIBC_2.3 strcoll F
+GLIBC_2.3 strcoll_l F
+GLIBC_2.3 strcpy F
+GLIBC_2.3 strcspn F
+GLIBC_2.3 strdup F
+GLIBC_2.3 strerror F
+GLIBC_2.3 strerror_r F
+GLIBC_2.3 strfmon F
+GLIBC_2.3 strfmon_l F
+GLIBC_2.3 strfry F
+GLIBC_2.3 strftime F
+GLIBC_2.3 strftime_l F
+GLIBC_2.3 strlen F
+GLIBC_2.3 strncasecmp F
+GLIBC_2.3 strncasecmp_l F
+GLIBC_2.3 strncat F
+GLIBC_2.3 strncmp F
+GLIBC_2.3 strncpy F
+GLIBC_2.3 strndup F
+GLIBC_2.3 strnlen F
+GLIBC_2.3 strpbrk F
+GLIBC_2.3 strptime F
+GLIBC_2.3 strrchr F
+GLIBC_2.3 strsep F
+GLIBC_2.3 strsignal F
+GLIBC_2.3 strspn F
+GLIBC_2.3 strstr F
+GLIBC_2.3 strtod F
+GLIBC_2.3 strtod_l F
+GLIBC_2.3 strtof F
+GLIBC_2.3 strtof_l F
+GLIBC_2.3 strtoimax F
+GLIBC_2.3 strtok F
+GLIBC_2.3 strtok_r F
+GLIBC_2.3 strtol F
+GLIBC_2.3 strtol_l F
+GLIBC_2.3 strtold F
+GLIBC_2.3 strtold_l F
+GLIBC_2.3 strtoll F
+GLIBC_2.3 strtoll_l F
+GLIBC_2.3 strtoq F
+GLIBC_2.3 strtoul F
+GLIBC_2.3 strtoul_l F
+GLIBC_2.3 strtoull F
+GLIBC_2.3 strtoull_l F
+GLIBC_2.3 strtoumax F
+GLIBC_2.3 strtouq F
+GLIBC_2.3 strverscmp F
+GLIBC_2.3 strxfrm F
+GLIBC_2.3 strxfrm_l F
+GLIBC_2.3 stty F
+GLIBC_2.3 svc_exit F
+GLIBC_2.3 svc_fdset D 0x80
+GLIBC_2.3 svc_getreq F
+GLIBC_2.3 svc_getreq_common F
+GLIBC_2.3 svc_getreq_poll F
+GLIBC_2.3 svc_getreqset F
+GLIBC_2.3 svc_max_pollfd D 0x4
+GLIBC_2.3 svc_pollfd D 0x4
+GLIBC_2.3 svc_register F
+GLIBC_2.3 svc_run F
+GLIBC_2.3 svc_sendreply F
+GLIBC_2.3 svc_unregister F
+GLIBC_2.3 svcauthdes_stats D 0xc
+GLIBC_2.3 svcerr_auth F
+GLIBC_2.3 svcerr_decode F
+GLIBC_2.3 svcerr_noproc F
+GLIBC_2.3 svcerr_noprog F
+GLIBC_2.3 svcerr_progvers F
+GLIBC_2.3 svcerr_systemerr F
+GLIBC_2.3 svcerr_weakauth F
+GLIBC_2.3 svcfd_create F
+GLIBC_2.3 svcraw_create F
+GLIBC_2.3 svctcp_create F
+GLIBC_2.3 svcudp_bufcreate F
+GLIBC_2.3 svcudp_create F
+GLIBC_2.3 svcudp_enablecache F
+GLIBC_2.3 svcunix_create F
+GLIBC_2.3 svcunixfd_create F
+GLIBC_2.3 swab F
+GLIBC_2.3 swapcontext F
+GLIBC_2.3 swapoff F
+GLIBC_2.3 swapon F
+GLIBC_2.3 swprintf F
+GLIBC_2.3 swscanf F
+GLIBC_2.3 symlink F
+GLIBC_2.3 sync F
+GLIBC_2.3 sys_errlist D 0x15c
+GLIBC_2.3 sys_nerr D 0x4
+GLIBC_2.3 sys_sigabbrev D 0x204
+GLIBC_2.3 sys_siglist D 0x204
+GLIBC_2.3 sysarch F
+GLIBC_2.3 syscall F
+GLIBC_2.3 sysconf F
+GLIBC_2.3 sysctl F
+GLIBC_2.3 sysctlbyname F
+GLIBC_2.3 syslog F
+GLIBC_2.3 system F
+GLIBC_2.3 sysv_signal F
+GLIBC_2.3 tcdrain F
+GLIBC_2.3 tcflow F
+GLIBC_2.3 tcflush F
+GLIBC_2.3 tcgetattr F
+GLIBC_2.3 tcgetpgrp F
+GLIBC_2.3 tcgetsid F
+GLIBC_2.3 tcsendbreak F
+GLIBC_2.3 tcsetattr F
+GLIBC_2.3 tcsetpgrp F
+GLIBC_2.3 tdelete F
+GLIBC_2.3 tdestroy F
+GLIBC_2.3 telldir F
+GLIBC_2.3 tempnam F
+GLIBC_2.3 textdomain F
+GLIBC_2.3 tfind F
+GLIBC_2.3 time F
+GLIBC_2.3 timegm F
+GLIBC_2.3 timelocal F
+GLIBC_2.3 times F
+GLIBC_2.3 timezone D 0x4
+GLIBC_2.3 tmpfile F
+GLIBC_2.3 tmpfile64 F
+GLIBC_2.3 tmpnam F
+GLIBC_2.3 tmpnam_r F
+GLIBC_2.3 toascii F
+GLIBC_2.3 tolower F
+GLIBC_2.3 tolower_l F
+GLIBC_2.3 toupper F
+GLIBC_2.3 toupper_l F
+GLIBC_2.3 towctrans F
+GLIBC_2.3 towctrans_l F
+GLIBC_2.3 towlower F
+GLIBC_2.3 towlower_l F
+GLIBC_2.3 towupper F
+GLIBC_2.3 towupper_l F
+GLIBC_2.3 tr_break F
+GLIBC_2.3 truncate F
+GLIBC_2.3 truncate64 F
+GLIBC_2.3 tsearch F
+GLIBC_2.3 ttyname F
+GLIBC_2.3 ttyname_r F
+GLIBC_2.3 ttyslot F
+GLIBC_2.3 twalk F
+GLIBC_2.3 tzname D 0x8
+GLIBC_2.3 tzset F
+GLIBC_2.3 ualarm F
+GLIBC_2.3 ulckpwdf F
+GLIBC_2.3 ulimit F
+GLIBC_2.3 umask F
+GLIBC_2.3 uname F
+GLIBC_2.3 undelete F
+GLIBC_2.3 ungetc F
+GLIBC_2.3 ungetwc F
+GLIBC_2.3 unlink F
+GLIBC_2.3 unlockpt F
+GLIBC_2.3 unmount F
+GLIBC_2.3 unsetenv F
+GLIBC_2.3 updwtmp F
+GLIBC_2.3 updwtmpx F
+GLIBC_2.3 uselocale F
+GLIBC_2.3 user2netname F
+GLIBC_2.3 usleep F
+GLIBC_2.3 ustat F
+GLIBC_2.3 utime F
+GLIBC_2.3 utimes F
+GLIBC_2.3 utmpname F
+GLIBC_2.3 utmpxname F
+GLIBC_2.3 utrace F
+GLIBC_2.3 valloc F
+GLIBC_2.3 vasprintf F
+GLIBC_2.3 vdprintf F
+GLIBC_2.3 verr F
+GLIBC_2.3 verrx F
+GLIBC_2.3 versionsort F
+GLIBC_2.3 versionsort64 F
+GLIBC_2.3 vfork F
+GLIBC_2.3 vfprintf F
+GLIBC_2.3 vfscanf F
+GLIBC_2.3 vfwprintf F
+GLIBC_2.3 vfwscanf F
+GLIBC_2.3 vhangup F
+GLIBC_2.3 vlimit F
+GLIBC_2.3 vprintf F
+GLIBC_2.3 vscanf F
+GLIBC_2.3 vsnprintf F
+GLIBC_2.3 vsprintf F
+GLIBC_2.3 vsscanf F
+GLIBC_2.3 vswprintf F
+GLIBC_2.3 vswscanf F
+GLIBC_2.3 vsyslog F
+GLIBC_2.3 vtimes F
+GLIBC_2.3 vwarn F
+GLIBC_2.3 vwarnx F
+GLIBC_2.3 vwprintf F
+GLIBC_2.3 vwscanf F
+GLIBC_2.3 wait F
+GLIBC_2.3 wait3 F
+GLIBC_2.3 wait4 F
+GLIBC_2.3 waitid F
+GLIBC_2.3 waitpid F
+GLIBC_2.3 warn F
+GLIBC_2.3 warnx F
+GLIBC_2.3 wcpcpy F
+GLIBC_2.3 wcpncpy F
+GLIBC_2.3 wcrtomb F
+GLIBC_2.3 wcscasecmp F
+GLIBC_2.3 wcscasecmp_l F
+GLIBC_2.3 wcscat F
+GLIBC_2.3 wcschr F
+GLIBC_2.3 wcschrnul F
+GLIBC_2.3 wcscmp F
+GLIBC_2.3 wcscoll F
+GLIBC_2.3 wcscoll_l F
+GLIBC_2.3 wcscpy F
+GLIBC_2.3 wcscspn F
+GLIBC_2.3 wcsdup F
+GLIBC_2.3 wcsftime F
+GLIBC_2.3 wcsftime_l F
+GLIBC_2.3 wcslen F
+GLIBC_2.3 wcsncasecmp F
+GLIBC_2.3 wcsncasecmp_l F
+GLIBC_2.3 wcsncat F
+GLIBC_2.3 wcsncmp F
+GLIBC_2.3 wcsncpy F
+GLIBC_2.3 wcsnlen F
+GLIBC_2.3 wcsnrtombs F
+GLIBC_2.3 wcspbrk F
+GLIBC_2.3 wcsrchr F
+GLIBC_2.3 wcsrtombs F
+GLIBC_2.3 wcsspn F
+GLIBC_2.3 wcsstr F
+GLIBC_2.3 wcstod F
+GLIBC_2.3 wcstod_l F
+GLIBC_2.3 wcstof F
+GLIBC_2.3 wcstof_l F
+GLIBC_2.3 wcstoimax F
+GLIBC_2.3 wcstok F
+GLIBC_2.3 wcstol F
+GLIBC_2.3 wcstol_l F
+GLIBC_2.3 wcstold F
+GLIBC_2.3 wcstold_l F
+GLIBC_2.3 wcstoll F
+GLIBC_2.3 wcstoll_l F
+GLIBC_2.3 wcstombs F
+GLIBC_2.3 wcstoq F
+GLIBC_2.3 wcstoul F
+GLIBC_2.3 wcstoul_l F
+GLIBC_2.3 wcstoull F
+GLIBC_2.3 wcstoull_l F
+GLIBC_2.3 wcstoumax F
+GLIBC_2.3 wcstouq F
+GLIBC_2.3 wcswcs F
+GLIBC_2.3 wcswidth F
+GLIBC_2.3 wcsxfrm F
+GLIBC_2.3 wcsxfrm_l F
+GLIBC_2.3 wctob F
+GLIBC_2.3 wctomb F
+GLIBC_2.3 wctrans F
+GLIBC_2.3 wctrans_l F
+GLIBC_2.3 wctype F
+GLIBC_2.3 wctype_l F
+GLIBC_2.3 wcwidth F
+GLIBC_2.3 wmemchr F
+GLIBC_2.3 wmemcmp F
+GLIBC_2.3 wmemcpy F
+GLIBC_2.3 wmemmove F
+GLIBC_2.3 wmempcpy F
+GLIBC_2.3 wmemset F
+GLIBC_2.3 wordexp F
+GLIBC_2.3 wordfree F
+GLIBC_2.3 wprintf F
+GLIBC_2.3 write F
+GLIBC_2.3 writev F
+GLIBC_2.3 wscanf F
+GLIBC_2.3 xdecrypt F
+GLIBC_2.3 xdr_accepted_reply F
+GLIBC_2.3 xdr_array F
+GLIBC_2.3 xdr_authdes_cred F
+GLIBC_2.3 xdr_authdes_verf F
+GLIBC_2.3 xdr_authunix_parms F
+GLIBC_2.3 xdr_bool F
+GLIBC_2.3 xdr_bytes F
+GLIBC_2.3 xdr_callhdr F
+GLIBC_2.3 xdr_callmsg F
+GLIBC_2.3 xdr_char F
+GLIBC_2.3 xdr_cryptkeyarg F
+GLIBC_2.3 xdr_cryptkeyarg2 F
+GLIBC_2.3 xdr_cryptkeyres F
+GLIBC_2.3 xdr_des_block F
+GLIBC_2.3 xdr_double F
+GLIBC_2.3 xdr_enum F
+GLIBC_2.3 xdr_float F
+GLIBC_2.3 xdr_free F
+GLIBC_2.3 xdr_getcredres F
+GLIBC_2.3 xdr_hyper F
+GLIBC_2.3 xdr_int F
+GLIBC_2.3 xdr_int16_t F
+GLIBC_2.3 xdr_int32_t F
+GLIBC_2.3 xdr_int64_t F
+GLIBC_2.3 xdr_int8_t F
+GLIBC_2.3 xdr_key_netstarg F
+GLIBC_2.3 xdr_key_netstres F
+GLIBC_2.3 xdr_keybuf F
+GLIBC_2.3 xdr_keystatus F
+GLIBC_2.3 xdr_long F
+GLIBC_2.3 xdr_longlong_t F
+GLIBC_2.3 xdr_netnamestr F
+GLIBC_2.3 xdr_netobj F
+GLIBC_2.3 xdr_opaque F
+GLIBC_2.3 xdr_opaque_auth F
+GLIBC_2.3 xdr_pmap F
+GLIBC_2.3 xdr_pmaplist F
+GLIBC_2.3 xdr_pointer F
+GLIBC_2.3 xdr_reference F
+GLIBC_2.3 xdr_rejected_reply F
+GLIBC_2.3 xdr_replymsg F
+GLIBC_2.3 xdr_rmtcall_args F
+GLIBC_2.3 xdr_rmtcallres F
+GLIBC_2.3 xdr_short F
+GLIBC_2.3 xdr_sizeof F
+GLIBC_2.3 xdr_string F
+GLIBC_2.3 xdr_u_char F
+GLIBC_2.3 xdr_u_hyper F
+GLIBC_2.3 xdr_u_int F
+GLIBC_2.3 xdr_u_long F
+GLIBC_2.3 xdr_u_longlong_t F
+GLIBC_2.3 xdr_u_short F
+GLIBC_2.3 xdr_uint16_t F
+GLIBC_2.3 xdr_uint32_t F
+GLIBC_2.3 xdr_uint64_t F
+GLIBC_2.3 xdr_uint8_t F
+GLIBC_2.3 xdr_union F
+GLIBC_2.3 xdr_unixcred F
+GLIBC_2.3 xdr_vector F
+GLIBC_2.3 xdr_void F
+GLIBC_2.3 xdr_wrapstring F
+GLIBC_2.3 xdrmem_create F
+GLIBC_2.3 xdrrec_create F
+GLIBC_2.3 xdrrec_endofrecord F
+GLIBC_2.3 xdrrec_eof F
+GLIBC_2.3 xdrrec_skiprecord F
+GLIBC_2.3 xdrstdio_create F
+GLIBC_2.3 xencrypt F
+GLIBC_2.3 xprt_register F
+GLIBC_2.3 xprt_unregister F
+GLIBC_2.3.2 GLIBC_2.3.2 A
+GLIBC_2.3.2 __register_atfork F
+GLIBC_2.3.2 pthread_cond_broadcast F
+GLIBC_2.3.2 pthread_cond_destroy F
+GLIBC_2.3.2 pthread_cond_init F
+GLIBC_2.3.2 pthread_cond_signal F
+GLIBC_2.3.2 pthread_cond_timedwait F
+GLIBC_2.3.2 pthread_cond_wait F
+GLIBC_2.3.2 strptime_l F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 inet6_option_alloc F
+GLIBC_2.3.3 inet6_option_append F
+GLIBC_2.3.3 inet6_option_find F
+GLIBC_2.3.3 inet6_option_init F
+GLIBC_2.3.3 inet6_option_next F
+GLIBC_2.3.3 inet6_option_space F
+GLIBC_2.3.3 nftw F
+GLIBC_2.3.3 nftw64 F
+GLIBC_2.3.3 posix_fallocate64 F
+GLIBC_2.3.3 remap_file_pages F
+GLIBC_2.3.3 sched_getaffinity F
+GLIBC_2.3.3 sched_setaffinity F
+GLIBC_2.3.3 semtimedop F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 __chk_fail F
+GLIBC_2.3.4 __fprintf_chk F
+GLIBC_2.3.4 __gets_chk F
+GLIBC_2.3.4 __libc_sa_len F
+GLIBC_2.3.4 __memcpy_chk F
+GLIBC_2.3.4 __memmove_chk F
+GLIBC_2.3.4 __mempcpy_chk F
+GLIBC_2.3.4 __memset_chk F
+GLIBC_2.3.4 __printf_chk F
+GLIBC_2.3.4 __snprintf_chk F
+GLIBC_2.3.4 __sprintf_chk F
+GLIBC_2.3.4 __stpcpy_chk F
+GLIBC_2.3.4 __strcat_chk F
+GLIBC_2.3.4 __strcpy_chk F
+GLIBC_2.3.4 __strncat_chk F
+GLIBC_2.3.4 __strncpy_chk F
+GLIBC_2.3.4 __vfprintf_chk F
+GLIBC_2.3.4 __vprintf_chk F
+GLIBC_2.3.4 __vsnprintf_chk F
+GLIBC_2.3.4 __vsprintf_chk F
+GLIBC_2.3.4 __xpg_strerror_r F
+GLIBC_2.3.4 _sys_errlist D 0x174
+GLIBC_2.3.4 _sys_nerr D 0x4
+GLIBC_2.3.4 fhstat64 F
+GLIBC_2.3.4 fhstatfs64 F
+GLIBC_2.3.4 getipv4sourcefilter F
+GLIBC_2.3.4 getsourcefilter F
+GLIBC_2.3.4 kevent F
+GLIBC_2.3.4 kqueue F
+GLIBC_2.3.4 regexec F
+GLIBC_2.3.4 setipv4sourcefilter F
+GLIBC_2.3.4 setsourcefilter F
+GLIBC_2.3.4 sys_errlist D 0x174
+GLIBC_2.3.4 sys_nerr D 0x4
+GLIBC_2.3.4 xdr_quad_t F
+GLIBC_2.3.4 xdr_u_quad_t F
+GLIBC_2.4 GLIBC_2.4 A
+GLIBC_2.4 __confstr_chk F
+GLIBC_2.4 __fgets_chk F
+GLIBC_2.4 __fgets_unlocked_chk F
+GLIBC_2.4 __fgetws_chk F
+GLIBC_2.4 __fgetws_unlocked_chk F
+GLIBC_2.4 __fwprintf_chk F
+GLIBC_2.4 __fxstatat F
+GLIBC_2.4 __fxstatat64 F
+GLIBC_2.4 __getcwd_chk F
+GLIBC_2.4 __getdomainname_chk F
+GLIBC_2.4 __getgroups_chk F
+GLIBC_2.4 __gethostname_chk F
+GLIBC_2.4 __getlogin_r_chk F
+GLIBC_2.4 __getwd_chk F
+GLIBC_2.4 __mbsnrtowcs_chk F
+GLIBC_2.4 __mbsrtowcs_chk F
+GLIBC_2.4 __mbstowcs_chk F
+GLIBC_2.4 __pread64_chk F
+GLIBC_2.4 __pread_chk F
+GLIBC_2.4 __ptsname_r_chk F
+GLIBC_2.4 __read_chk F
+GLIBC_2.4 __readlink_chk F
+GLIBC_2.4 __realpath_chk F
+GLIBC_2.4 __recv_chk F
+GLIBC_2.4 __recvfrom_chk F
+GLIBC_2.4 __stack_chk_fail F
+GLIBC_2.4 __stpncpy_chk F
+GLIBC_2.4 __swprintf_chk F
+GLIBC_2.4 __syslog_chk F
+GLIBC_2.4 __ttyname_r_chk F
+GLIBC_2.4 __vfwprintf_chk F
+GLIBC_2.4 __vswprintf_chk F
+GLIBC_2.4 __vsyslog_chk F
+GLIBC_2.4 __vwprintf_chk F
+GLIBC_2.4 __wcpcpy_chk F
+GLIBC_2.4 __wcpncpy_chk F
+GLIBC_2.4 __wcrtomb_chk F
+GLIBC_2.4 __wcscat_chk F
+GLIBC_2.4 __wcscpy_chk F
+GLIBC_2.4 __wcsncat_chk F
+GLIBC_2.4 __wcsncpy_chk F
+GLIBC_2.4 __wcsnrtombs_chk F
+GLIBC_2.4 __wcsrtombs_chk F
+GLIBC_2.4 __wcstombs_chk F
+GLIBC_2.4 __wctomb_chk F
+GLIBC_2.4 __wmemcpy_chk F
+GLIBC_2.4 __wmemmove_chk F
+GLIBC_2.4 __wmempcpy_chk F
+GLIBC_2.4 __wmemset_chk F
+GLIBC_2.4 __wprintf_chk F
+GLIBC_2.4 __xmknodat F
+GLIBC_2.4 eaccess F
+GLIBC_2.4 faccessat F
+GLIBC_2.4 fchmodat F
+GLIBC_2.4 fchownat F
+GLIBC_2.4 fdopendir F
+GLIBC_2.4 futimesat F
+GLIBC_2.4 linkat F
+GLIBC_2.4 mkdirat F
+GLIBC_2.4 mkfifoat F
+GLIBC_2.4 open_wmemstream F
+GLIBC_2.4 openat F
+GLIBC_2.4 openat64 F
+GLIBC_2.4 ppoll F
+GLIBC_2.4 readlinkat F
+GLIBC_2.4 renameat F
+GLIBC_2.4 symlinkat F
+GLIBC_2.4 unlinkat F
+GLIBC_2.5 GLIBC_2.5 A
+GLIBC_2.5 __readlinkat_chk F
+GLIBC_2.5 inet6_opt_append F
+GLIBC_2.5 inet6_opt_find F
+GLIBC_2.5 inet6_opt_finish F
+GLIBC_2.5 inet6_opt_get_val F
+GLIBC_2.5 inet6_opt_init F
+GLIBC_2.5 inet6_opt_next F
+GLIBC_2.5 inet6_opt_set_val F
+GLIBC_2.5 inet6_rth_add F
+GLIBC_2.5 inet6_rth_getaddr F
+GLIBC_2.5 inet6_rth_init F
+GLIBC_2.5 inet6_rth_reverse F
+GLIBC_2.5 inet6_rth_segments F
+GLIBC_2.5 inet6_rth_space F
+GLIBC_2.6 GLIBC_2.6 A
+GLIBC_2.6 __sched_cpucount F
+GLIBC_2.6 futimens F
+GLIBC_2.6 strerror_l F
+GLIBC_2.6 utimensat F
+GLIBC_2.7 GLIBC_2.7 A
+GLIBC_2.7 __fread_chk F
+GLIBC_2.7 __fread_unlocked_chk F
+GLIBC_2.7 __isoc99_fscanf F
+GLIBC_2.7 __isoc99_fwscanf F
+GLIBC_2.7 __isoc99_scanf F
+GLIBC_2.7 __isoc99_sscanf F
+GLIBC_2.7 __isoc99_swscanf F
+GLIBC_2.7 __isoc99_vfscanf F
+GLIBC_2.7 __isoc99_vfwscanf F
+GLIBC_2.7 __isoc99_vscanf F
+GLIBC_2.7 __isoc99_vsscanf F
+GLIBC_2.7 __isoc99_vswscanf F
+GLIBC_2.7 __isoc99_vwscanf F
+GLIBC_2.7 __isoc99_wscanf F
+GLIBC_2.7 __open64_2 F
+GLIBC_2.7 __open_2 F
+GLIBC_2.7 __openat64_2 F
+GLIBC_2.7 __openat_2 F
+GLIBC_2.7 __sched_cpualloc F
+GLIBC_2.7 __sched_cpufree F
+GLIBC_2.7 mkostemp F
+GLIBC_2.7 mkostemp64 F
+GLIBC_2.8 GLIBC_2.8 A
+GLIBC_2.8 __asprintf_chk F
+GLIBC_2.8 __dprintf_chk F
+GLIBC_2.8 __obstack_printf_chk F
+GLIBC_2.8 __obstack_vprintf_chk F
+GLIBC_2.8 __vasprintf_chk F
+GLIBC_2.8 __vdprintf_chk F
+GLIBC_2.8 qsort_r F
+GLIBC_2.9 GLIBC_2.9 A
+GLIBC_2.9 dup3 F
+GLIBC_2.9 pipe2 F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libcrypt.abilist
@@ -0,0 +1,8 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 crypt F
+GLIBC_2.3 crypt_r F
+GLIBC_2.3 encrypt F
+GLIBC_2.3 encrypt_r F
+GLIBC_2.3 fcrypt F
+GLIBC_2.3 setkey F
+GLIBC_2.3 setkey_r F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libdl.abilist
@@ -0,0 +1,12 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 dladdr F
+GLIBC_2.3 dlclose F
+GLIBC_2.3 dlerror F
+GLIBC_2.3 dlopen F
+GLIBC_2.3 dlsym F
+GLIBC_2.3 dlvsym F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 dladdr1 F
+GLIBC_2.3.3 dlinfo F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 dlmopen F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libm.abilist
@@ -0,0 +1,409 @@
+GLIBC_2.15 GLIBC_2.15 A
+GLIBC_2.15 __acos_finite F
+GLIBC_2.15 __acosf_finite F
+GLIBC_2.15 __acosh_finite F
+GLIBC_2.15 __acoshf_finite F
+GLIBC_2.15 __acoshl_finite F
+GLIBC_2.15 __acosl_finite F
+GLIBC_2.15 __asin_finite F
+GLIBC_2.15 __asinf_finite F
+GLIBC_2.15 __asinl_finite F
+GLIBC_2.15 __atan2_finite F
+GLIBC_2.15 __atan2f_finite F
+GLIBC_2.15 __atan2l_finite F
+GLIBC_2.15 __atanh_finite F
+GLIBC_2.15 __atanhf_finite F
+GLIBC_2.15 __atanhl_finite F
+GLIBC_2.15 __cosh_finite F
+GLIBC_2.15 __coshf_finite F
+GLIBC_2.15 __coshl_finite F
+GLIBC_2.15 __exp10_finite F
+GLIBC_2.15 __exp10f_finite F
+GLIBC_2.15 __exp10l_finite F
+GLIBC_2.15 __exp2_finite F
+GLIBC_2.15 __exp2f_finite F
+GLIBC_2.15 __exp2l_finite F
+GLIBC_2.15 __exp_finite F
+GLIBC_2.15 __expf_finite F
+GLIBC_2.15 __expl_finite F
+GLIBC_2.15 __fmod_finite F
+GLIBC_2.15 __fmodf_finite F
+GLIBC_2.15 __fmodl_finite F
+GLIBC_2.15 __gamma_r_finite F
+GLIBC_2.15 __gammaf_r_finite F
+GLIBC_2.15 __gammal_r_finite F
+GLIBC_2.15 __hypot_finite F
+GLIBC_2.15 __hypotf_finite F
+GLIBC_2.15 __hypotl_finite F
+GLIBC_2.15 __j0_finite F
+GLIBC_2.15 __j0f_finite F
+GLIBC_2.15 __j0l_finite F
+GLIBC_2.15 __j1_finite F
+GLIBC_2.15 __j1f_finite F
+GLIBC_2.15 __j1l_finite F
+GLIBC_2.15 __jn_finite F
+GLIBC_2.15 __jnf_finite F
+GLIBC_2.15 __jnl_finite F
+GLIBC_2.15 __lgamma_r_finite F
+GLIBC_2.15 __lgammaf_r_finite F
+GLIBC_2.15 __lgammal_r_finite F
+GLIBC_2.15 __log10_finite F
+GLIBC_2.15 __log10f_finite F
+GLIBC_2.15 __log10l_finite F
+GLIBC_2.15 __log2_finite F
+GLIBC_2.15 __log2f_finite F
+GLIBC_2.15 __log2l_finite F
+GLIBC_2.15 __log_finite F
+GLIBC_2.15 __logf_finite F
+GLIBC_2.15 __logl_finite F
+GLIBC_2.15 __pow_finite F
+GLIBC_2.15 __powf_finite F
+GLIBC_2.15 __powl_finite F
+GLIBC_2.15 __remainder_finite F
+GLIBC_2.15 __remainderf_finite F
+GLIBC_2.15 __remainderl_finite F
+GLIBC_2.15 __scalb_finite F
+GLIBC_2.15 __scalbf_finite F
+GLIBC_2.15 __scalbl_finite F
+GLIBC_2.15 __sinh_finite F
+GLIBC_2.15 __sinhf_finite F
+GLIBC_2.15 __sinhl_finite F
+GLIBC_2.15 __sqrt_finite F
+GLIBC_2.15 __sqrtf_finite F
+GLIBC_2.15 __sqrtl_finite F
+GLIBC_2.15 __y0_finite F
+GLIBC_2.15 __y0f_finite F
+GLIBC_2.15 __y0l_finite F
+GLIBC_2.15 __y1_finite F
+GLIBC_2.15 __y1f_finite F
+GLIBC_2.15 __y1l_finite F
+GLIBC_2.15 __yn_finite F
+GLIBC_2.15 __ynf_finite F
+GLIBC_2.15 __ynl_finite F
+GLIBC_2.18 GLIBC_2.18 A
+GLIBC_2.18 __issignaling F
+GLIBC_2.18 __issignalingf F
+GLIBC_2.18 __issignalingl F
+GLIBC_2.23 GLIBC_2.23 A
+GLIBC_2.23 __signgam D 0x4
+GLIBC_2.23 lgamma F
+GLIBC_2.23 lgammaf F
+GLIBC_2.23 lgammal F
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 _LIB_VERSION D 0x4
+GLIBC_2.3 __clog10 F
+GLIBC_2.3 __clog10f F
+GLIBC_2.3 __clog10l F
+GLIBC_2.3 __expl F
+GLIBC_2.3 __expm1l F
+GLIBC_2.3 __finite F
+GLIBC_2.3 __finitef F
+GLIBC_2.3 __finitel F
+GLIBC_2.3 __fpclassify F
+GLIBC_2.3 __fpclassifyf F
+GLIBC_2.3 __fpclassifyl F
+GLIBC_2.3 __signbit F
+GLIBC_2.3 __signbitf F
+GLIBC_2.3 __signbitl F
+GLIBC_2.3 acos F
+GLIBC_2.3 acosf F
+GLIBC_2.3 acosh F
+GLIBC_2.3 acoshf F
+GLIBC_2.3 acoshl F
+GLIBC_2.3 acosl F
+GLIBC_2.3 asin F
+GLIBC_2.3 asinf F
+GLIBC_2.3 asinh F
+GLIBC_2.3 asinhf F
+GLIBC_2.3 asinhl F
+GLIBC_2.3 asinl F
+GLIBC_2.3 atan F
+GLIBC_2.3 atan2 F
+GLIBC_2.3 atan2f F
+GLIBC_2.3 atan2l F
+GLIBC_2.3 atanf F
+GLIBC_2.3 atanh F
+GLIBC_2.3 atanhf F
+GLIBC_2.3 atanhl F
+GLIBC_2.3 atanl F
+GLIBC_2.3 cabs F
+GLIBC_2.3 cabsf F
+GLIBC_2.3 cabsl F
+GLIBC_2.3 cacos F
+GLIBC_2.3 cacosf F
+GLIBC_2.3 cacosh F
+GLIBC_2.3 cacoshf F
+GLIBC_2.3 cacoshl F
+GLIBC_2.3 cacosl F
+GLIBC_2.3 carg F
+GLIBC_2.3 cargf F
+GLIBC_2.3 cargl F
+GLIBC_2.3 casin F
+GLIBC_2.3 casinf F
+GLIBC_2.3 casinh F
+GLIBC_2.3 casinhf F
+GLIBC_2.3 casinhl F
+GLIBC_2.3 casinl F
+GLIBC_2.3 catan F
+GLIBC_2.3 catanf F
+GLIBC_2.3 catanh F
+GLIBC_2.3 catanhf F
+GLIBC_2.3 catanhl F
+GLIBC_2.3 catanl F
+GLIBC_2.3 cbrt F
+GLIBC_2.3 cbrtf F
+GLIBC_2.3 cbrtl F
+GLIBC_2.3 ccos F
+GLIBC_2.3 ccosf F
+GLIBC_2.3 ccosh F
+GLIBC_2.3 ccoshf F
+GLIBC_2.3 ccoshl F
+GLIBC_2.3 ccosl F
+GLIBC_2.3 ceil F
+GLIBC_2.3 ceilf F
+GLIBC_2.3 ceill F
+GLIBC_2.3 cexp F
+GLIBC_2.3 cexpf F
+GLIBC_2.3 cexpl F
+GLIBC_2.3 cimag F
+GLIBC_2.3 cimagf F
+GLIBC_2.3 cimagl F
+GLIBC_2.3 clog F
+GLIBC_2.3 clog10 F
+GLIBC_2.3 clog10f F
+GLIBC_2.3 clog10l F
+GLIBC_2.3 clogf F
+GLIBC_2.3 clogl F
+GLIBC_2.3 conj F
+GLIBC_2.3 conjf F
+GLIBC_2.3 conjl F
+GLIBC_2.3 copysign F
+GLIBC_2.3 copysignf F
+GLIBC_2.3 copysignl F
+GLIBC_2.3 cos F
+GLIBC_2.3 cosf F
+GLIBC_2.3 cosh F
+GLIBC_2.3 coshf F
+GLIBC_2.3 coshl F
+GLIBC_2.3 cosl F
+GLIBC_2.3 cpow F
+GLIBC_2.3 cpowf F
+GLIBC_2.3 cpowl F
+GLIBC_2.3 cproj F
+GLIBC_2.3 cprojf F
+GLIBC_2.3 cprojl F
+GLIBC_2.3 creal F
+GLIBC_2.3 crealf F
+GLIBC_2.3 creall F
+GLIBC_2.3 csin F
+GLIBC_2.3 csinf F
+GLIBC_2.3 csinh F
+GLIBC_2.3 csinhf F
+GLIBC_2.3 csinhl F
+GLIBC_2.3 csinl F
+GLIBC_2.3 csqrt F
+GLIBC_2.3 csqrtf F
+GLIBC_2.3 csqrtl F
+GLIBC_2.3 ctan F
+GLIBC_2.3 ctanf F
+GLIBC_2.3 ctanh F
+GLIBC_2.3 ctanhf F
+GLIBC_2.3 ctanhl F
+GLIBC_2.3 ctanl F
+GLIBC_2.3 drem F
+GLIBC_2.3 dremf F
+GLIBC_2.3 dreml F
+GLIBC_2.3 erf F
+GLIBC_2.3 erfc F
+GLIBC_2.3 erfcf F
+GLIBC_2.3 erfcl F
+GLIBC_2.3 erff F
+GLIBC_2.3 erfl F
+GLIBC_2.3 exp F
+GLIBC_2.3 exp10 F
+GLIBC_2.3 exp10f F
+GLIBC_2.3 exp10l F
+GLIBC_2.3 exp2 F
+GLIBC_2.3 exp2f F
+GLIBC_2.3 exp2l F
+GLIBC_2.3 expf F
+GLIBC_2.3 expl F
+GLIBC_2.3 expm1 F
+GLIBC_2.3 expm1f F
+GLIBC_2.3 expm1l F
+GLIBC_2.3 fabs F
+GLIBC_2.3 fabsf F
+GLIBC_2.3 fabsl F
+GLIBC_2.3 fdim F
+GLIBC_2.3 fdimf F
+GLIBC_2.3 fdiml F
+GLIBC_2.3 feclearexcept F
+GLIBC_2.3 fedisableexcept F
+GLIBC_2.3 feenableexcept F
+GLIBC_2.3 fegetenv F
+GLIBC_2.3 fegetexcept F
+GLIBC_2.3 fegetexceptflag F
+GLIBC_2.3 fegetround F
+GLIBC_2.3 feholdexcept F
+GLIBC_2.3 feraiseexcept F
+GLIBC_2.3 fesetenv F
+GLIBC_2.3 fesetexceptflag F
+GLIBC_2.3 fesetround F
+GLIBC_2.3 fetestexcept F
+GLIBC_2.3 feupdateenv F
+GLIBC_2.3 finite F
+GLIBC_2.3 finitef F
+GLIBC_2.3 finitel F
+GLIBC_2.3 floor F
+GLIBC_2.3 floorf F
+GLIBC_2.3 floorl F
+GLIBC_2.3 fma F
+GLIBC_2.3 fmaf F
+GLIBC_2.3 fmal F
+GLIBC_2.3 fmax F
+GLIBC_2.3 fmaxf F
+GLIBC_2.3 fmaxl F
+GLIBC_2.3 fmin F
+GLIBC_2.3 fminf F
+GLIBC_2.3 fminl F
+GLIBC_2.3 fmod F
+GLIBC_2.3 fmodf F
+GLIBC_2.3 fmodl F
+GLIBC_2.3 frexp F
+GLIBC_2.3 frexpf F
+GLIBC_2.3 frexpl F
+GLIBC_2.3 gamma F
+GLIBC_2.3 gammaf F
+GLIBC_2.3 gammal F
+GLIBC_2.3 hypot F
+GLIBC_2.3 hypotf F
+GLIBC_2.3 hypotl F
+GLIBC_2.3 ilogb F
+GLIBC_2.3 ilogbf F
+GLIBC_2.3 ilogbl F
+GLIBC_2.3 j0 F
+GLIBC_2.3 j0f F
+GLIBC_2.3 j0l F
+GLIBC_2.3 j1 F
+GLIBC_2.3 j1f F
+GLIBC_2.3 j1l F
+GLIBC_2.3 jn F
+GLIBC_2.3 jnf F
+GLIBC_2.3 jnl F
+GLIBC_2.3 ldexp F
+GLIBC_2.3 ldexpf F
+GLIBC_2.3 ldexpl F
+GLIBC_2.3 lgamma F
+GLIBC_2.3 lgamma_r F
+GLIBC_2.3 lgammaf F
+GLIBC_2.3 lgammaf_r F
+GLIBC_2.3 lgammal F
+GLIBC_2.3 lgammal_r F
+GLIBC_2.3 llrint F
+GLIBC_2.3 llrintf F
+GLIBC_2.3 llrintl F
+GLIBC_2.3 llround F
+GLIBC_2.3 llroundf F
+GLIBC_2.3 llroundl F
+GLIBC_2.3 log F
+GLIBC_2.3 log10 F
+GLIBC_2.3 log10f F
+GLIBC_2.3 log10l F
+GLIBC_2.3 log1p F
+GLIBC_2.3 log1pf F
+GLIBC_2.3 log1pl F
+GLIBC_2.3 log2 F
+GLIBC_2.3 log2f F
+GLIBC_2.3 log2l F
+GLIBC_2.3 logb F
+GLIBC_2.3 logbf F
+GLIBC_2.3 logbl F
+GLIBC_2.3 logf F
+GLIBC_2.3 logl F
+GLIBC_2.3 lrint F
+GLIBC_2.3 lrintf F
+GLIBC_2.3 lrintl F
+GLIBC_2.3 lround F
+GLIBC_2.3 lroundf F
+GLIBC_2.3 lroundl F
+GLIBC_2.3 matherr F
+GLIBC_2.3 modf F
+GLIBC_2.3 modff F
+GLIBC_2.3 modfl F
+GLIBC_2.3 nan F
+GLIBC_2.3 nanf F
+GLIBC_2.3 nanl F
+GLIBC_2.3 nearbyint F
+GLIBC_2.3 nearbyintf F
+GLIBC_2.3 nearbyintl F
+GLIBC_2.3 nextafter F
+GLIBC_2.3 nextafterf F
+GLIBC_2.3 nextafterl F
+GLIBC_2.3 nexttoward F
+GLIBC_2.3 nexttowardf F
+GLIBC_2.3 nexttowardl F
+GLIBC_2.3 pow F
+GLIBC_2.3 pow10 F
+GLIBC_2.3 pow10f F
+GLIBC_2.3 pow10l F
+GLIBC_2.3 powf F
+GLIBC_2.3 powl F
+GLIBC_2.3 remainder F
+GLIBC_2.3 remainderf F
+GLIBC_2.3 remainderl F
+GLIBC_2.3 remquo F
+GLIBC_2.3 remquof F
+GLIBC_2.3 remquol F
+GLIBC_2.3 rint F
+GLIBC_2.3 rintf F
+GLIBC_2.3 rintl F
+GLIBC_2.3 round F
+GLIBC_2.3 roundf F
+GLIBC_2.3 roundl F
+GLIBC_2.3 scalb F
+GLIBC_2.3 scalbf F
+GLIBC_2.3 scalbl F
+GLIBC_2.3 scalbln F
+GLIBC_2.3 scalblnf F
+GLIBC_2.3 scalblnl F
+GLIBC_2.3 scalbn F
+GLIBC_2.3 scalbnf F
+GLIBC_2.3 scalbnl F
+GLIBC_2.3 signgam D 0x4
+GLIBC_2.3 significand F
+GLIBC_2.3 significandf F
+GLIBC_2.3 significandl F
+GLIBC_2.3 sin F
+GLIBC_2.3 sincos F
+GLIBC_2.3 sincosf F
+GLIBC_2.3 sincosl F
+GLIBC_2.3 sinf F
+GLIBC_2.3 sinh F
+GLIBC_2.3 sinhf F
+GLIBC_2.3 sinhl F
+GLIBC_2.3 sinl F
+GLIBC_2.3 sqrt F
+GLIBC_2.3 sqrtf F
+GLIBC_2.3 sqrtl F
+GLIBC_2.3 tan F
+GLIBC_2.3 tanf F
+GLIBC_2.3 tanh F
+GLIBC_2.3 tanhf F
+GLIBC_2.3 tanhl F
+GLIBC_2.3 tanl F
+GLIBC_2.3 tgamma F
+GLIBC_2.3 tgammaf F
+GLIBC_2.3 tgammal F
+GLIBC_2.3 trunc F
+GLIBC_2.3 truncf F
+GLIBC_2.3 truncl F
+GLIBC_2.3 y0 F
+GLIBC_2.3 y0f F
+GLIBC_2.3 y0l F
+GLIBC_2.3 y1 F
+GLIBC_2.3 y1f F
+GLIBC_2.3 y1l F
+GLIBC_2.3 yn F
+GLIBC_2.3 ynf F
+GLIBC_2.3 ynl F
+GLIBC_2.4 GLIBC_2.4 A
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libnsl.abilist
@@ -0,0 +1,122 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 __free_fdresult F
+GLIBC_2.3 __nis_default_access F
+GLIBC_2.3 __nis_default_group F
+GLIBC_2.3 __nis_default_owner F
+GLIBC_2.3 __nis_default_ttl F
+GLIBC_2.3 __nis_finddirectory F
+GLIBC_2.3 __nis_hash F
+GLIBC_2.3 __nisbind_connect F
+GLIBC_2.3 __nisbind_create F
+GLIBC_2.3 __nisbind_destroy F
+GLIBC_2.3 __nisbind_next F
+GLIBC_2.3 __yp_check F
+GLIBC_2.3 nis_add F
+GLIBC_2.3 nis_add_entry F
+GLIBC_2.3 nis_addmember F
+GLIBC_2.3 nis_checkpoint F
+GLIBC_2.3 nis_clone_directory F
+GLIBC_2.3 nis_clone_object F
+GLIBC_2.3 nis_clone_result F
+GLIBC_2.3 nis_creategroup F
+GLIBC_2.3 nis_destroy_object F
+GLIBC_2.3 nis_destroygroup F
+GLIBC_2.3 nis_dir_cmp F
+GLIBC_2.3 nis_domain_of F
+GLIBC_2.3 nis_domain_of_r F
+GLIBC_2.3 nis_first_entry F
+GLIBC_2.3 nis_free_directory F
+GLIBC_2.3 nis_free_object F
+GLIBC_2.3 nis_free_request F
+GLIBC_2.3 nis_freenames F
+GLIBC_2.3 nis_freeresult F
+GLIBC_2.3 nis_freeservlist F
+GLIBC_2.3 nis_freetags F
+GLIBC_2.3 nis_getnames F
+GLIBC_2.3 nis_getservlist F
+GLIBC_2.3 nis_ismember F
+GLIBC_2.3 nis_leaf_of F
+GLIBC_2.3 nis_leaf_of_r F
+GLIBC_2.3 nis_lerror F
+GLIBC_2.3 nis_list F
+GLIBC_2.3 nis_local_directory F
+GLIBC_2.3 nis_local_group F
+GLIBC_2.3 nis_local_host F
+GLIBC_2.3 nis_local_principal F
+GLIBC_2.3 nis_lookup F
+GLIBC_2.3 nis_mkdir F
+GLIBC_2.3 nis_modify F
+GLIBC_2.3 nis_modify_entry F
+GLIBC_2.3 nis_name_of F
+GLIBC_2.3 nis_name_of_r F
+GLIBC_2.3 nis_next_entry F
+GLIBC_2.3 nis_perror F
+GLIBC_2.3 nis_ping F
+GLIBC_2.3 nis_print_directory F
+GLIBC_2.3 nis_print_entry F
+GLIBC_2.3 nis_print_group F
+GLIBC_2.3 nis_print_group_entry F
+GLIBC_2.3 nis_print_link F
+GLIBC_2.3 nis_print_object F
+GLIBC_2.3 nis_print_result F
+GLIBC_2.3 nis_print_rights F
+GLIBC_2.3 nis_print_table F
+GLIBC_2.3 nis_read_obj F
+GLIBC_2.3 nis_remove F
+GLIBC_2.3 nis_remove_entry F
+GLIBC_2.3 nis_removemember F
+GLIBC_2.3 nis_rmdir F
+GLIBC_2.3 nis_servstate F
+GLIBC_2.3 nis_sperrno F
+GLIBC_2.3 nis_sperror F
+GLIBC_2.3 nis_sperror_r F
+GLIBC_2.3 nis_stats F
+GLIBC_2.3 nis_verifygroup F
+GLIBC_2.3 nis_write_obj F
+GLIBC_2.3 readColdStartFile F
+GLIBC_2.3 writeColdStartFile F
+GLIBC_2.3 xdr_cback_data F
+GLIBC_2.3 xdr_domainname F
+GLIBC_2.3 xdr_keydat F
+GLIBC_2.3 xdr_mapname F
+GLIBC_2.3 xdr_obj_p F
+GLIBC_2.3 xdr_peername F
+GLIBC_2.3 xdr_valdat F
+GLIBC_2.3 xdr_yp_buf F
+GLIBC_2.3 xdr_ypall F
+GLIBC_2.3 xdr_ypbind_binding F
+GLIBC_2.3 xdr_ypbind_resp F
+GLIBC_2.3 xdr_ypbind_resptype F
+GLIBC_2.3 xdr_ypbind_setdom F
+GLIBC_2.3 xdr_ypdelete_args F
+GLIBC_2.3 xdr_ypmap_parms F
+GLIBC_2.3 xdr_ypmaplist F
+GLIBC_2.3 xdr_yppush_status F
+GLIBC_2.3 xdr_yppushresp_xfr F
+GLIBC_2.3 xdr_ypreq_key F
+GLIBC_2.3 xdr_ypreq_nokey F
+GLIBC_2.3 xdr_ypreq_xfr F
+GLIBC_2.3 xdr_ypresp_all F
+GLIBC_2.3 xdr_ypresp_key_val F
+GLIBC_2.3 xdr_ypresp_maplist F
+GLIBC_2.3 xdr_ypresp_master F
+GLIBC_2.3 xdr_ypresp_order F
+GLIBC_2.3 xdr_ypresp_val F
+GLIBC_2.3 xdr_ypresp_xfr F
+GLIBC_2.3 xdr_ypstat F
+GLIBC_2.3 xdr_ypupdate_args F
+GLIBC_2.3 xdr_ypxfrstat F
+GLIBC_2.3 yp_all F
+GLIBC_2.3 yp_bind F
+GLIBC_2.3 yp_first F
+GLIBC_2.3 yp_get_default_domain F
+GLIBC_2.3 yp_maplist F
+GLIBC_2.3 yp_master F
+GLIBC_2.3 yp_match F
+GLIBC_2.3 yp_next F
+GLIBC_2.3 yp_order F
+GLIBC_2.3 yp_unbind F
+GLIBC_2.3 yp_update F
+GLIBC_2.3 ypbinderr_string F
+GLIBC_2.3 yperr_string F
+GLIBC_2.3 ypprot_err F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libpthread.abilist
@@ -0,0 +1,227 @@
+GLIBC_2.12 GLIBC_2.12 A
+GLIBC_2.12 pthread_getname_np F
+GLIBC_2.12 pthread_setname_np F
+GLIBC_2.18 GLIBC_2.18 A
+GLIBC_2.18 pthread_getattr_default_np F
+GLIBC_2.18 pthread_setattr_default_np F
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 _IO_flockfile F
+GLIBC_2.3 _IO_ftrylockfile F
+GLIBC_2.3 _IO_funlockfile F
+GLIBC_2.3 __close F
+GLIBC_2.3 __connect F
+GLIBC_2.3 __errno_location F
+GLIBC_2.3 __fcntl F
+GLIBC_2.3 __fork F
+GLIBC_2.3 __h_errno_location F
+GLIBC_2.3 __libc_allocate_rtsig F
+GLIBC_2.3 __libc_current_sigrtmax F
+GLIBC_2.3 __libc_current_sigrtmin F
+GLIBC_2.3 __lseek F
+GLIBC_2.3 __nanosleep F
+GLIBC_2.3 __open F
+GLIBC_2.3 __open64 F
+GLIBC_2.3 __pread64 F
+GLIBC_2.3 __pthread_getspecific F
+GLIBC_2.3 __pthread_key_create F
+GLIBC_2.3 __pthread_mutex_destroy F
+GLIBC_2.3 __pthread_mutex_init F
+GLIBC_2.3 __pthread_mutex_lock F
+GLIBC_2.3 __pthread_mutex_trylock F
+GLIBC_2.3 __pthread_mutex_unlock F
+GLIBC_2.3 __pthread_mutexattr_destroy F
+GLIBC_2.3 __pthread_mutexattr_init F
+GLIBC_2.3 __pthread_mutexattr_settype F
+GLIBC_2.3 __pthread_once F
+GLIBC_2.3 __pthread_rwlock_destroy F
+GLIBC_2.3 __pthread_rwlock_init F
+GLIBC_2.3 __pthread_rwlock_rdlock F
+GLIBC_2.3 __pthread_rwlock_tryrdlock F
+GLIBC_2.3 __pthread_rwlock_trywrlock F
+GLIBC_2.3 __pthread_rwlock_unlock F
+GLIBC_2.3 __pthread_rwlock_wrlock F
+GLIBC_2.3 __pthread_setspecific F
+GLIBC_2.3 __pwrite64 F
+GLIBC_2.3 __read F
+GLIBC_2.3 __res_state F
+GLIBC_2.3 __send F
+GLIBC_2.3 __sigaction F
+GLIBC_2.3 __vfork F
+GLIBC_2.3 __wait F
+GLIBC_2.3 __write F
+GLIBC_2.3 _pthread_cleanup_pop F
+GLIBC_2.3 _pthread_cleanup_pop_restore F
+GLIBC_2.3 _pthread_cleanup_push F
+GLIBC_2.3 _pthread_cleanup_push_defer F
+GLIBC_2.3 accept F
+GLIBC_2.3 close F
+GLIBC_2.3 connect F
+GLIBC_2.3 fcntl F
+GLIBC_2.3 flockfile F
+GLIBC_2.3 fork F
+GLIBC_2.3 fsync F
+GLIBC_2.3 ftrylockfile F
+GLIBC_2.3 funlockfile F
+GLIBC_2.3 longjmp F
+GLIBC_2.3 lseek F
+GLIBC_2.3 lseek64 F
+GLIBC_2.3 msync F
+GLIBC_2.3 nanosleep F
+GLIBC_2.3 open F
+GLIBC_2.3 open64 F
+GLIBC_2.3 pause F
+GLIBC_2.3 pread F
+GLIBC_2.3 pread64 F
+GLIBC_2.3 pthread_atfork F
+GLIBC_2.3 pthread_attr_destroy F
+GLIBC_2.3 pthread_attr_getdetachstate F
+GLIBC_2.3 pthread_attr_getguardsize F
+GLIBC_2.3 pthread_attr_getinheritsched F
+GLIBC_2.3 pthread_attr_getschedparam F
+GLIBC_2.3 pthread_attr_getschedpolicy F
+GLIBC_2.3 pthread_attr_getscope F
+GLIBC_2.3 pthread_attr_getstack F
+GLIBC_2.3 pthread_attr_getstackaddr F
+GLIBC_2.3 pthread_attr_getstacksize F
+GLIBC_2.3 pthread_attr_init F
+GLIBC_2.3 pthread_attr_setdetachstate F
+GLIBC_2.3 pthread_attr_setguardsize F
+GLIBC_2.3 pthread_attr_setinheritsched F
+GLIBC_2.3 pthread_attr_setschedparam F
+GLIBC_2.3 pthread_attr_setschedpolicy F
+GLIBC_2.3 pthread_attr_setscope F
+GLIBC_2.3 pthread_attr_setstack F
+GLIBC_2.3 pthread_attr_setstackaddr F
+GLIBC_2.3 pthread_attr_setstacksize F
+GLIBC_2.3 pthread_barrier_destroy F
+GLIBC_2.3 pthread_barrier_init F
+GLIBC_2.3 pthread_barrier_wait F
+GLIBC_2.3 pthread_barrierattr_destroy F
+GLIBC_2.3 pthread_barrierattr_init F
+GLIBC_2.3 pthread_barrierattr_setpshared F
+GLIBC_2.3 pthread_cancel F
+GLIBC_2.3 pthread_cond_broadcast F
+GLIBC_2.3 pthread_cond_destroy F
+GLIBC_2.3 pthread_cond_init F
+GLIBC_2.3 pthread_cond_signal F
+GLIBC_2.3 pthread_cond_timedwait F
+GLIBC_2.3 pthread_cond_wait F
+GLIBC_2.3 pthread_condattr_destroy F
+GLIBC_2.3 pthread_condattr_getpshared F
+GLIBC_2.3 pthread_condattr_init F
+GLIBC_2.3 pthread_condattr_setpshared F
+GLIBC_2.3 pthread_create F
+GLIBC_2.3 pthread_detach F
+GLIBC_2.3 pthread_equal F
+GLIBC_2.3 pthread_exit F
+GLIBC_2.3 pthread_getattr_np F
+GLIBC_2.3 pthread_getconcurrency F
+GLIBC_2.3 pthread_getcpuclockid F
+GLIBC_2.3 pthread_getschedparam F
+GLIBC_2.3 pthread_getspecific F
+GLIBC_2.3 pthread_join F
+GLIBC_2.3 pthread_key_create F
+GLIBC_2.3 pthread_key_delete F
+GLIBC_2.3 pthread_kill F
+GLIBC_2.3 pthread_kill_other_threads_np F
+GLIBC_2.3 pthread_mutex_destroy F
+GLIBC_2.3 pthread_mutex_init F
+GLIBC_2.3 pthread_mutex_lock F
+GLIBC_2.3 pthread_mutex_timedlock F
+GLIBC_2.3 pthread_mutex_trylock F
+GLIBC_2.3 pthread_mutex_unlock F
+GLIBC_2.3 pthread_mutexattr_destroy F
+GLIBC_2.3 pthread_mutexattr_getkind_np F
+GLIBC_2.3 pthread_mutexattr_getpshared F
+GLIBC_2.3 pthread_mutexattr_gettype F
+GLIBC_2.3 pthread_mutexattr_init F
+GLIBC_2.3 pthread_mutexattr_setkind_np F
+GLIBC_2.3 pthread_mutexattr_setpshared F
+GLIBC_2.3 pthread_mutexattr_settype F
+GLIBC_2.3 pthread_once F
+GLIBC_2.3 pthread_rwlock_destroy F
+GLIBC_2.3 pthread_rwlock_init F
+GLIBC_2.3 pthread_rwlock_rdlock F
+GLIBC_2.3 pthread_rwlock_timedrdlock F
+GLIBC_2.3 pthread_rwlock_timedwrlock F
+GLIBC_2.3 pthread_rwlock_tryrdlock F
+GLIBC_2.3 pthread_rwlock_trywrlock F
+GLIBC_2.3 pthread_rwlock_unlock F
+GLIBC_2.3 pthread_rwlock_wrlock F
+GLIBC_2.3 pthread_rwlockattr_destroy F
+GLIBC_2.3 pthread_rwlockattr_getkind_np F
+GLIBC_2.3 pthread_rwlockattr_getpshared F
+GLIBC_2.3 pthread_rwlockattr_init F
+GLIBC_2.3 pthread_rwlockattr_setkind_np F
+GLIBC_2.3 pthread_rwlockattr_setpshared F
+GLIBC_2.3 pthread_self F
+GLIBC_2.3 pthread_setcancelstate F
+GLIBC_2.3 pthread_setcanceltype F
+GLIBC_2.3 pthread_setconcurrency F
+GLIBC_2.3 pthread_setschedparam F
+GLIBC_2.3 pthread_setspecific F
+GLIBC_2.3 pthread_sigmask F
+GLIBC_2.3 pthread_spin_destroy F
+GLIBC_2.3 pthread_spin_init F
+GLIBC_2.3 pthread_spin_lock F
+GLIBC_2.3 pthread_spin_trylock F
+GLIBC_2.3 pthread_spin_unlock F
+GLIBC_2.3 pthread_testcancel F
+GLIBC_2.3 pthread_yield F
+GLIBC_2.3 pwrite F
+GLIBC_2.3 pwrite64 F
+GLIBC_2.3 raise F
+GLIBC_2.3 read F
+GLIBC_2.3 recv F
+GLIBC_2.3 recvfrom F
+GLIBC_2.3 recvmsg F
+GLIBC_2.3 sem_close F
+GLIBC_2.3 sem_destroy F
+GLIBC_2.3 sem_getvalue F
+GLIBC_2.3 sem_init F
+GLIBC_2.3 sem_open F
+GLIBC_2.3 sem_post F
+GLIBC_2.3 sem_timedwait F
+GLIBC_2.3 sem_trywait F
+GLIBC_2.3 sem_unlink F
+GLIBC_2.3 sem_wait F
+GLIBC_2.3 send F
+GLIBC_2.3 sendmsg F
+GLIBC_2.3 sendto F
+GLIBC_2.3 sigaction F
+GLIBC_2.3 siglongjmp F
+GLIBC_2.3 sigwait F
+GLIBC_2.3 system F
+GLIBC_2.3 tcdrain F
+GLIBC_2.3 vfork F
+GLIBC_2.3 wait F
+GLIBC_2.3 waitpid F
+GLIBC_2.3 write F
+GLIBC_2.3.2 GLIBC_2.3.2 A
+GLIBC_2.3.2 pthread_cond_broadcast F
+GLIBC_2.3.2 pthread_cond_destroy F
+GLIBC_2.3.2 pthread_cond_init F
+GLIBC_2.3.2 pthread_cond_signal F
+GLIBC_2.3.2 pthread_cond_timedwait F
+GLIBC_2.3.2 pthread_cond_wait F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 __pthread_cleanup_routine F
+GLIBC_2.3.3 __pthread_register_cancel F
+GLIBC_2.3.3 __pthread_register_cancel_defer F
+GLIBC_2.3.3 __pthread_unregister_cancel F
+GLIBC_2.3.3 __pthread_unregister_cancel_restore F
+GLIBC_2.3.3 __pthread_unwind_next F
+GLIBC_2.3.3 pthread_attr_getaffinity_np F
+GLIBC_2.3.3 pthread_attr_setaffinity_np F
+GLIBC_2.3.3 pthread_barrierattr_getpshared F
+GLIBC_2.3.3 pthread_condattr_getclock F
+GLIBC_2.3.3 pthread_condattr_setclock F
+GLIBC_2.3.3 pthread_getaffinity_np F
+GLIBC_2.3.3 pthread_setaffinity_np F
+GLIBC_2.3.3 pthread_timedjoin_np F
+GLIBC_2.3.3 pthread_tryjoin_np F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 pthread_attr_getaffinity_np F
+GLIBC_2.3.4 pthread_attr_setaffinity_np F
+GLIBC_2.3.4 pthread_getaffinity_np F
+GLIBC_2.3.4 pthread_setaffinity_np F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libresolv.abilist
@@ -0,0 +1,94 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 __b64_ntop F
+GLIBC_2.3 __b64_pton F
+GLIBC_2.3 __dn_comp F
+GLIBC_2.3 __dn_count_labels F
+GLIBC_2.3 __dn_expand F
+GLIBC_2.3 __dn_skipname F
+GLIBC_2.3 __fp_nquery F
+GLIBC_2.3 __fp_query F
+GLIBC_2.3 __fp_resstat F
+GLIBC_2.3 __hostalias F
+GLIBC_2.3 __loc_aton F
+GLIBC_2.3 __loc_ntoa F
+GLIBC_2.3 __p_cdname F
+GLIBC_2.3 __p_cdnname F
+GLIBC_2.3 __p_class F
+GLIBC_2.3 __p_class_syms D 0x54
+GLIBC_2.3 __p_fqname F
+GLIBC_2.3 __p_fqnname F
+GLIBC_2.3 __p_option F
+GLIBC_2.3 __p_query F
+GLIBC_2.3 __p_secstodate F
+GLIBC_2.3 __p_time F
+GLIBC_2.3 __p_type F
+GLIBC_2.3 __p_type_syms D 0x228
+GLIBC_2.3 __putlong F
+GLIBC_2.3 __putshort F
+GLIBC_2.3 __res_close F
+GLIBC_2.3 __res_dnok F
+GLIBC_2.3 __res_hnok F
+GLIBC_2.3 __res_hostalias F
+GLIBC_2.3 __res_isourserver F
+GLIBC_2.3 __res_mailok F
+GLIBC_2.3 __res_mkquery F
+GLIBC_2.3 __res_nameinquery F
+GLIBC_2.3 __res_nmkquery F
+GLIBC_2.3 __res_nquery F
+GLIBC_2.3 __res_nquerydomain F
+GLIBC_2.3 __res_nsearch F
+GLIBC_2.3 __res_nsend F
+GLIBC_2.3 __res_ownok F
+GLIBC_2.3 __res_queriesmatch F
+GLIBC_2.3 __res_query F
+GLIBC_2.3 __res_querydomain F
+GLIBC_2.3 __res_search F
+GLIBC_2.3 __res_send F
+GLIBC_2.3 __sym_ntop F
+GLIBC_2.3 __sym_ntos F
+GLIBC_2.3 __sym_ston F
+GLIBC_2.3 _gethtbyaddr F
+GLIBC_2.3 _gethtbyname F
+GLIBC_2.3 _gethtbyname2 F
+GLIBC_2.3 _gethtent F
+GLIBC_2.3 _getlong F
+GLIBC_2.3 _getshort F
+GLIBC_2.3 _res_opcodes D 0x40
+GLIBC_2.3 _sethtent F
+GLIBC_2.3 inet_net_ntop F
+GLIBC_2.3 inet_net_pton F
+GLIBC_2.3 inet_neta F
+GLIBC_2.3 res_gethostbyaddr F
+GLIBC_2.3 res_gethostbyname F
+GLIBC_2.3 res_gethostbyname2 F
+GLIBC_2.3 res_send_setqhook F
+GLIBC_2.3 res_send_setrhook F
+GLIBC_2.3.2 GLIBC_2.3.2 A
+GLIBC_2.3.2 __p_rcode F
+GLIBC_2.9 GLIBC_2.9 A
+GLIBC_2.9 ns_datetosecs F
+GLIBC_2.9 ns_format_ttl F
+GLIBC_2.9 ns_get16 F
+GLIBC_2.9 ns_get32 F
+GLIBC_2.9 ns_initparse F
+GLIBC_2.9 ns_makecanon F
+GLIBC_2.9 ns_msg_getflag F
+GLIBC_2.9 ns_name_compress F
+GLIBC_2.9 ns_name_ntol F
+GLIBC_2.9 ns_name_ntop F
+GLIBC_2.9 ns_name_pack F
+GLIBC_2.9 ns_name_pton F
+GLIBC_2.9 ns_name_rollback F
+GLIBC_2.9 ns_name_skip F
+GLIBC_2.9 ns_name_uncompress F
+GLIBC_2.9 ns_name_unpack F
+GLIBC_2.9 ns_parse_ttl F
+GLIBC_2.9 ns_parserr F
+GLIBC_2.9 ns_put16 F
+GLIBC_2.9 ns_put32 F
+GLIBC_2.9 ns_samedomain F
+GLIBC_2.9 ns_samename F
+GLIBC_2.9 ns_skiprr F
+GLIBC_2.9 ns_sprintrr F
+GLIBC_2.9 ns_sprintrrf F
+GLIBC_2.9 ns_subdomain F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/librt.abilist
@@ -0,0 +1,46 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 aio_cancel F
+GLIBC_2.3 aio_cancel64 F
+GLIBC_2.3 aio_error F
+GLIBC_2.3 aio_error64 F
+GLIBC_2.3 aio_fsync F
+GLIBC_2.3 aio_fsync64 F
+GLIBC_2.3 aio_init F
+GLIBC_2.3 aio_read F
+GLIBC_2.3 aio_read64 F
+GLIBC_2.3 aio_return F
+GLIBC_2.3 aio_return64 F
+GLIBC_2.3 aio_suspend F
+GLIBC_2.3 aio_suspend64 F
+GLIBC_2.3 aio_write F
+GLIBC_2.3 aio_write64 F
+GLIBC_2.3 clock_getcpuclockid F
+GLIBC_2.3 clock_getres F
+GLIBC_2.3 clock_gettime F
+GLIBC_2.3 clock_nanosleep F
+GLIBC_2.3 clock_settime F
+GLIBC_2.3 lio_listio F
+GLIBC_2.3 lio_listio64 F
+GLIBC_2.3 shm_open F
+GLIBC_2.3 shm_unlink F
+GLIBC_2.3 timer_create F
+GLIBC_2.3 timer_delete F
+GLIBC_2.3 timer_getoverrun F
+GLIBC_2.3 timer_gettime F
+GLIBC_2.3 timer_settime F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 mq_close F
+GLIBC_2.3.4 mq_getattr F
+GLIBC_2.3.4 mq_notify F
+GLIBC_2.3.4 mq_open F
+GLIBC_2.3.4 mq_receive F
+GLIBC_2.3.4 mq_send F
+GLIBC_2.3.4 mq_setattr F
+GLIBC_2.3.4 mq_timedreceive F
+GLIBC_2.3.4 mq_timedsend F
+GLIBC_2.3.4 mq_unlink F
+GLIBC_2.4 GLIBC_2.4 A
+GLIBC_2.4 lio_listio F
+GLIBC_2.4 lio_listio64 F
+GLIBC_2.7 GLIBC_2.7 A
+GLIBC_2.7 __mq_open_2 F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libthread_db.abilist
@@ -0,0 +1,42 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 td_init F
+GLIBC_2.3 td_log F
+GLIBC_2.3 td_symbol_list F
+GLIBC_2.3 td_ta_clear_event F
+GLIBC_2.3 td_ta_delete F
+GLIBC_2.3 td_ta_enable_stats F
+GLIBC_2.3 td_ta_event_addr F
+GLIBC_2.3 td_ta_event_getmsg F
+GLIBC_2.3 td_ta_get_nthreads F
+GLIBC_2.3 td_ta_get_ph F
+GLIBC_2.3 td_ta_get_stats F
+GLIBC_2.3 td_ta_map_id2thr F
+GLIBC_2.3 td_ta_map_lwp2thr F
+GLIBC_2.3 td_ta_new F
+GLIBC_2.3 td_ta_reset_stats F
+GLIBC_2.3 td_ta_set_event F
+GLIBC_2.3 td_ta_setconcurrency F
+GLIBC_2.3 td_ta_thr_iter F
+GLIBC_2.3 td_ta_tsd_iter F
+GLIBC_2.3 td_thr_clear_event F
+GLIBC_2.3 td_thr_dbresume F
+GLIBC_2.3 td_thr_dbsuspend F
+GLIBC_2.3 td_thr_event_enable F
+GLIBC_2.3 td_thr_event_getmsg F
+GLIBC_2.3 td_thr_get_info F
+GLIBC_2.3 td_thr_getfpregs F
+GLIBC_2.3 td_thr_getgregs F
+GLIBC_2.3 td_thr_getxregs F
+GLIBC_2.3 td_thr_getxregsize F
+GLIBC_2.3 td_thr_set_event F
+GLIBC_2.3 td_thr_setfpregs F
+GLIBC_2.3 td_thr_setgregs F
+GLIBC_2.3 td_thr_setprio F
+GLIBC_2.3 td_thr_setsigpending F
+GLIBC_2.3 td_thr_setxregs F
+GLIBC_2.3 td_thr_sigsetmask F
+GLIBC_2.3 td_thr_tls_get_addr F
+GLIBC_2.3 td_thr_tsd F
+GLIBC_2.3 td_thr_validate F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 td_thr_tlsbase F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/libutil.abilist
@@ -0,0 +1,7 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 forkpty F
+GLIBC_2.3 login F
+GLIBC_2.3 login_tty F
+GLIBC_2.3 logout F
+GLIBC_2.3 logwtmp F
+GLIBC_2.3 openpty F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/localplt.data
@@ -0,0 +1,19 @@
+# See scripts/check-localplt.awk for how this file is processed.
+# PLT use is required for the malloc family and for matherr because
+# users can define their own functions and have library internals call them.
+# Linker in binutils 2.26 and newer consolidates R_386_JUMP_SLOT
+# relocation with R_386_GLOB_DAT relocation against the same symbol.
+libc.so: calloc
+libc.so: free + REL R_386_GLOB_DAT
+libc.so: malloc + REL R_386_GLOB_DAT
+libc.so: memalign
+libc.so: realloc
+libm.so: matherr
+# The dynamic loader uses __libc_memalign internally to allocate aligned
+# TLS storage. The other malloc family of functions are expected to allow
+# user symbol interposition.
+ld.so: __libc_memalign
+ld.so: malloc
+ld.so: calloc
+ld.so: realloc
+ld.so: free + REL R_386_GLOB_DAT
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/lseek.S
@@ -0,0 +1,53 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* lseek returns a 64-bit result in %eax, %edx.  This means that in the
+   error case we have to set both %eax and %edx to -1.  */
+
+PSEUDO_NOERRNO(__lseek, lseek, 3)
+        jnb L(no_error)
+	call SYSCALL_ERROR_LABEL;
+	orl $-1, %edx;
+L(pseudo_end):
+L(no_error):
+	ret
+PSEUDO_END(__lseek)
+libc_hidden_def (__lseek)
+
+strong_alias (__lseek, __libc_lseek)
+libc_hidden_def (__libc_lseek)
+
+strong_alias (__lseek, __libc_lseek64)
+libc_hidden_def (__libc_lseek64)
+
+strong_alias (__lseek, __lseek64)
+libc_hidden_def (__lseek64)
+
+strong_alias (__lseek, __llseek)
+libc_hidden_def (__llseek)
+
+weak_alias (__lseek, lseek)
+libc_hidden_weak (lseek)
+
+weak_alias (__lseek, lseek64)
+libc_hidden_weak (lseek64)
+
+weak_alias (__lseek, llseek)
+libc_hidden_weak (llseek)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/makecontext.S
@@ -0,0 +1,120 @@
+/* Create new context.
+   Copyright (C) 2001,02 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2001.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+#include <ucontext_i.h>
+
+
+ENTRY(__makecontext)
+	movl	4(%esp), %eax
+
+	/* Load the address of the function we are supposed to run.  */
+	movl	8(%esp), %ecx
+
+	/* Compute the address of the stack.  The information comes from
+	   to us_stack element.  */
+	movl	oSS_SP(%eax), %edx
+	movl	%ecx, oEIP(%eax)
+	addl	oSS_SIZE(%eax), %edx
+
+	/* Put the next context on the new stack (from the uc_link
+	   element).  */
+	movl	oLINK(%eax), %ecx
+	movl	%ecx, -4(%edx)
+
+	/* Remember the number of parameters for the exit handler since
+	   it has to remove them.  We store the number in the EBX register
+	   which the function we will call must preserve.  */
+	movl	12(%esp), %ecx
+	movl	%ecx, oEBX(%eax)
+
+	/* Make room on the new stack for the parameters.  */
+	negl	%ecx
+	leal	-8(%edx,%ecx,4), %edx
+	negl	%ecx
+	/* Store the future stack pointer.  */
+	movl	%edx, oESP(%eax)
+
+	/* Copy all the parameters.  */
+	jecxz	2f
+1:	movl	12(%esp,%ecx,4), %eax
+	movl	%eax, (%edx,%ecx,4)
+	decl	%ecx
+	jnz	1b
+2:
+
+	/* If the function we call returns we must continue with the
+	   context which is given in the uc_link element.  To do this
+	   set the return address for the function the user provides
+	   to a little bit of helper code which does the magic (see
+	   below).  */
+#ifdef PIC
+	call	1f
+	cfi_adjust_cfa_offset (4)
+1:	popl	%ecx
+	cfi_adjust_cfa_offset (-4)
+	addl	$L(exitcode)-1b, %ecx
+	movl	%ecx, (%edx)
+#else
+	movl	$L(exitcode), (%edx)
+#endif
+	/* We need to terminate the FDE here instead of after ret because
+	   the unwinder looks at ra-1 for unwind information.  */
+	cfi_endproc
+
+	/* 'makecontext' returns no value.  */
+	ret
+
+	/* This is the helper code which gets called if a function which
+	   is registered with 'makecontext' returns.  In this case we
+	   have to install the context listed in the uc_link element of
+	   the context 'makecontext' manipulated at the time of the
+	   'makecontext' call.  If the pointer is NULL the process must
+	   terminate.  */
+L(exitcode):
+	/* This removes the parameters passed to the function given to
+	   'makecontext' from the stack.  EBX contains the number of
+	   parameters (see above).  */
+	leal	(%esp,%ebx,4), %esp
+
+#ifdef	PIC
+	call	1f
+1:	popl	%ebx
+	addl	$_GLOBAL_OFFSET_TABLE_+[.-1b], %ebx
+#endif
+	popl	%eax			/* This is the next context.  */
+	testl	%eax, %eax
+	je	2f			/* If it is zero exit.  */
+
+	pushl	%eax
+	call	JUMPTARGET(__setcontext)
+	/* If this returns (which can happen if the syscall fails) we'll
+	   exit the program with the return error value (-1).  */
+
+2:	pushl	%eax
+	call	HIDDEN_JUMPTARGET(exit)
+	/* The 'exit' call should never return.  In case it does cause
+	   the process to terminate.  */
+	hlt
+	cfi_startproc
+END(__makecontext)
+
+weak_alias(__makecontext, makecontext)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/pipe.S
@@ -0,0 +1,30 @@
+/* Copyright (C) 1991,92,93,95,97,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+SYSCALL__ (pipe, 1)
+	movl 4(%esp), scratch
+	movl %eax, (scratch)
+	movl r1, 4(scratch)
+	xorl %eax, %eax
+	ret
+PSEUDO_END (__pipe)
+
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/rfork.S
@@ -0,0 +1,44 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__rfork)
+	/* save the return PC value into ECX,
+	   preserve stack frame with argument  */
+	movl 0(%esp), %ecx;
+	DO_CALL (rfork, 1)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decl %edx
+	andl %edx, %eax
+
+	popl %edx
+	cfi_adjust_cfa_offset(-4)
+	jmp  *%ecx
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__rfork)
+
+weak_alias (__rfork, rfork)
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/shlib-versions
@@ -0,0 +1 @@
+ld=ld.so.1
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sigcontextinfo.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+native FreeBSD:
+        sighandler(int signum, int code,       struct sigcontext * sg, void * fault_ip)
+posix like:
+        sighandler(int signum, siginfo_t * si, struct sigcontext * sg, void * fault_ip)
+*/
+
+#define SIGCONTEXT long _code, struct sigcontext * _sg, void *
+#define SIGCONTEXT_EXTRA_ARGS _code, _sg,
+
+/* really, really, rest of glibc expects that struct sigcontext is the last argument */
+#define GET_PC(ctx)	((void *) (_sg)->sc_eip)
+#define GET_FRAME(ctx)	((void *) (_sg)->sc_ebp)
+#define GET_STACK(ctx)	((void *) (_sg)->sc_esp)
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start.S
@@ -0,0 +1,151 @@
+/* Startup code compliant to the ELF i386 ABI.
+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/i386 ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for:
+
+   %edx		Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   %esp		The stack contains the arguments and environment:
+		0(%esp)			argc
+		4(%esp)			argv[0]
+		...
+		(4*argc)(%esp)		NULL
+		(4*(argc+1))(%esp)	envp[0]
+		...
+					NULL
+*/
+
+#include <libc-symbols.h>
+
+	weak_extern (_end)
+
+	.text
+	.globl _start
+	.type _start,@function
+_start:
+	/* Clear the frame pointer.  The ABI suggests this be done, to mark
+	   the outermost frame obviously.  */
+	xorl %ebp, %ebp
+
+	/* Extract the arguments as encoded on the stack and set up
+	   the arguments for `main': argc, argv.  envp will be determined
+	   later in __libc_start_main.  */
+	popl %esi		/* Pop the argument count.  */
+	movl %esp, %ecx		/* argv starts just at the current stack top.*/
+
+	/* Before pushing the arguments align the stack to a 16-byte
+	(SSE needs 16-byte alignment) boundary to avoid penalties from
+	misaligned accesses.  Thanks to Edward Seidl <seidl@janed.com>
+	for pointing this out.  */
+	andl $0xfffffff0, %esp
+	pushl %eax		/* Push garbage because we allocate
+				   28 more bytes.  */
+
+	/* Provide the highest stack address to the user code (for stacks
+	   which grow downwards).  */
+	pushl %esp
+
+	pushl %edx		/* Push address of the shared library
+				   termination function.  */
+
+#ifdef SHARED
+	/* Load PIC register.  */
+	call 1f
+	addl $_GLOBAL_OFFSET_TABLE_, %ebx
+
+	/* Push address of our own entry points to .fini and .init.  */
+	leal __libc_csu_fini@GOTOFF(%ebx), %eax
+	pushl %eax
+	leal __libc_csu_init@GOTOFF(%ebx), %eax
+	pushl %eax
+
+	pushl %ecx		/* Push second argument: argv.  */
+	pushl %esi		/* Push first argument: argc.  */
+
+	pushl main@GOT(%ebx)
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.    */
+	call __libc_start_main@PLT
+#else
+	/* Push address of our own entry points to .fini and .init.  */
+	pushl $__libc_csu_fini
+	pushl $__libc_csu_init
+
+	pushl %ecx		/* Push second argument: argv.  */
+	pushl %esi		/* Push first argument: argc.  */
+
+	pushl $main
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.    */
+	call __libc_start_main
+#endif
+
+	hlt			/* Crash if somehow `exit' does return.  */
+
+#ifdef SHARED
+1:	movl	(%esp), %ebx
+	ret
+#endif
+	/* just reference _end, 
+	   it is needed as global symbol for brk() usage,
+	   it is a dead code on purpose.  */
+#ifdef SHARED
+	leal _end@GOTOFF(%ebx), %eax
+#else
+	mov $_end, %eax
+#endif
+
+/* To fulfill the System V/i386 ABI we need this symbol.  Yuck, it's so
+   meaningless since we don't support machines < 80386.  */
+	.section .rodata
+	.globl _fp_hw
+_fp_hw:	.long 3
+	.size _fp_hw, 4
+	.type _fp_hw,@object
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/start_thread.S
@@ -0,0 +1,207 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+#define SIG_SETMASK	3
+
+	.text
+ENTRY (__start_thread)
+	/* End FDE now, because in the child the unwind info will be
+	   wrong.  */
+	cfi_endproc
+
+	/* There is a window of a few instructions, right after the rfork
+	   system call, where the handling of a signal would write garbage
+	   into the stack shared by the parent and the child (assuming
+	   RFMEM is set in flags).  To solve this: 1. We block all signals
+	   around the rfork system call and unblock them afterwards in
+	   the parent and in the child (but only after changing the stack
+	   pointer).  2. The child accesses only values passed in registers
+	   and on its own stack.  This way, if the parent is scheduled to
+	   run first, and handles a signal, it will not affect the child;
+	   and if the child runs first, and handles a signal, it will use
+	   the child's stack and not affect the parent.
+	   We need to pass 7 words of info to the child: stack, func, arg,
+	   and the signal mask to restore.  Since we have only 4 call-saved
+	   registers available (%ebx, %esi, %edi, %ebp), we pass only the
+	   stack pointer in a register, and the rest through the child's
+	   stack.  */
+	pushl	%ebp
+	movl	%esp, %ebp
+	subl	$36, %esp
+	movl	%ebx, 32(%esp)
+
+	movl	8(%ebp), %eax	/* flags */
+	testl	$32, %eax	/* flags & RFMEM */
+	jz	L(simple)
+
+	/* Block all signals.  */
+	movl	$-1, %eax
+	movl	%eax, 16(%esp)
+	movl	%eax, 20(%esp)
+	movl	%eax, 24(%esp)
+	movl	%eax, 28(%esp)
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	%eax, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+	jb	L(error)
+
+	/* Copy all info to the child's stack.  */
+	movl	12(%ebp), %ebx	/* stack */
+	subl	$32, %ebx	/* room for func, arg, sigset_t */
+	andl	$-16, %ebx	/* make it 16-bytes aligned */
+	movl	16(%ebp), %eax	/* func */
+	movl	20(%ebp), %edx	/* arg */
+	movl	%eax, 4(%ebx)
+	movl	%edx, (%ebx)
+	movl	16(%esp), %eax	/* sigset_t word 0 */
+	movl	20(%esp), %edx	/* sigset_t word 1 */
+	movl	%eax, 16(%ebx)
+	movl	%edx, 20(%ebx)
+	movl	24(%esp), %eax	/* sigset_t word 2 */
+	movl	28(%esp), %edx	/* sigset_t word 3 */
+	movl	%eax, 24(%ebx)
+	movl	%edx, 28(%ebx)
+
+	/* Perform the rfork system call.  */
+	movl	8(%ebp), %eax	/* flags */
+	movl	%eax, 4(%esp)
+	DO_CALL (rfork, 1)
+	jb	L(error_unmask)
+
+	/* %edx is now 0 for the parent and 1 for the child.  */
+	testl	%edx, %edx
+	jnz	L(child)
+
+	/* Save the child pid, currently in %eax.  */
+	movl	%eax, %ebx
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+	/* Return the child pid, currently in %ebx.  */
+	movl	%ebx, %eax
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+	ret
+
+L(child):/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	movl	%ebx, %esp
+	/* Terminate the stack frame.  */
+	subl	%ebp, %ebp
+
+	movl	4(%esp), %edi
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+L(child1):
+	/* Call func (arg).  */
+	call	*%edi
+
+	/* Call _exit.  */
+#ifdef PIC
+	call	L(here)
+L(here):
+	popl	%ebx
+	addl	$_GLOBAL_OFFSET_TABLE_+[.-L(here)], %ebx
+#endif
+	pushl	%eax
+	call	HIDDEN_JUMPTARGET (_exit)
+
+L(simple):/* Simple case without signal mask handling.  */
+
+	/* Copy all info to the child's stack.  */
+	movl	12(%ebp), %ebx	/* stack */
+	subl	$8, %ebx	/* room for func, arg */
+	andl	$-16, %ebx	/* make it 16-bytes aligned */
+	movl	16(%ebp), %eax	/* func */
+	movl	20(%ebp), %edx	/* arg */
+	movl	%eax, 4(%ebx)
+	movl	%edx, (%ebx)
+
+	/* Perform the rfork system call.  */
+	movl	8(%ebp), %eax	/* flags */
+	movl	%eax, 4(%esp)
+	DO_CALL (rfork, 1)
+	jb	L(error)
+
+	/* %edx is now 0 for the parent and 1 for the child.  */
+	testl	%edx, %edx
+	jnz	L(simple_child)
+
+	/* Return the child pid, currently in %eax.  */
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+L(pseudo_end):
+	ret
+
+L(simple_child):/* Here we are in the child thread.  */
+
+	/* Set the stack pointer.  */
+	movl	%ebx, %esp
+	/* Terminate the stack frame.  */
+	subl	%ebp, %ebp
+
+	movl	4(%esp), %edi
+
+	jmp	L(child1)
+
+L(error_unmask):
+
+	/* Save the error code, currently in %eax.  */
+	movl	%eax, %ebx
+
+	/* Restore the previous signal mask.  */
+	leal	16(%esp), %eax
+	movl	$SIG_SETMASK, 4(%esp)
+	movl	%eax, 8(%esp)
+	movl	$0, 12(%esp)
+	DO_CALL (sigprocmask, 3)
+
+	/* load saved error code */
+	movl	%ebx, %eax
+
+L(error):
+	addl	$32, %esp
+	popl	%ebx
+	popl	%ebp
+	jmp	SYSCALL_ERROR_LABEL
+	cfi_startproc
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/swapcontext.S
@@ -0,0 +1,32 @@
+/* swap current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__swapcontext)
+        clc
+        DO_CALL (swapcontext, 2)
+        jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__swapcontext)
+
+weak_alias(__swapcontext, swapcontext)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/io.h
@@ -0,0 +1,184 @@
+/* Copyright (C) 1996, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#ifdef _MACHINE_CPUFUNC_H_
+#error "This header must not be used in combination with <machine/cpufunc.h>."
+#endif
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.
+
+   Portability note: not all kFreeBSD platforms support this call.  Most
+   platforms based on the PC I/O architecture probably will, however. */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+                   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/perm.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PERM_H
+#define _SYS_PERM_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Set port input/output permissions.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+
+/* Change I/O privilege level.  */
+extern int iopl (int __level) __THROW;
+
+extern int i386_set_ioperm (unsigned long int __from, unsigned long int __num,
+			    int __turn_on) __THROW;
+
+/* Retrieve a contiguous range of port input/output permissions.  */
+extern int i386_get_ioperm (unsigned long int __from, unsigned long int *__num,
+			    int *__turned_on) __THROW;
+
+__END_DECLS
+
+#endif	/* _SYS_PERM_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys/vm86.h
@@ -0,0 +1,53 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_VM86_H
+#define _SYS_VM86_H	1
+
+#include <features.h>
+
+/* Possible values for the 'cmd' argument to i386_vm86.  */
+enum
+  {
+    VM86_INIT = 1,
+#define VM86_INIT VM86_INIT
+    VM86_GET_VME = 3
+#define VM86_GET_VME VM86_GET_VME
+  };
+
+/* Argument structure for VM86_INIT.  */
+struct vm86_init_args
+  {
+    int debug;
+    int cpu_type;
+    unsigned char int_map[32];
+  };
+
+/* Argument structure for VM86_GET_VME.  */
+struct vm86_vme_args
+  {
+    int state;
+  };
+
+__BEGIN_DECLS
+
+extern int i386_vm86 (int __cmd, void *__arg);
+
+__END_DECLS
+
+#endif	/* _SYS_VM86_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sys_fork.S
@@ -0,0 +1,34 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__syscall_fork)
+	DO_CALL (fork, 0)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decl r1
+	andl r1, r0
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall_fork)
+libc_hidden_def (__syscall_fork)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysarch.h
@@ -0,0 +1,81 @@
+/* Parameters for the architecture specific system call.  i386 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSARCH_H
+#define _SYSARCH_H	1
+
+#include <features.h>
+
+/* Function that can be used as first argument to 'sysarch'.  */
+enum
+  {
+    I386_GET_LDT = 0,
+#define I386_GET_LDT I386_GET_LDT
+    I386_SET_LDT = 1,
+#define I386_SET_LDT I386_SET_LDT
+    I386_GET_IOPERM = 3,
+#define I386_GET_IOPERM I386_GET_IOPERM
+    I386_SET_IOPERM = 4,
+#define I386_SET_IOPERM I386_SET_IOPERM
+    I386_VM86 = 6,
+#define I386_VM86 I386_VM86
+    I386_GET_FSBASE = 7,
+#define I386_GET_FSBASE I386_GET_FSBASE
+    I386_SET_FSBASE = 8,
+#define I386_SET_FSBASE I386_SET_FSBASE
+    I386_GET_GSBASE = 9,
+#define I386_GET_GSBASE I386_GET_GSBASE
+    I386_SET_GSBASE = 10
+#define I386_SET_GSBASE I386_SET_GSBASE
+  };
+
+/* Argument struct for I386_GET_LDT and I386_SET_LDT.  */
+struct i386_ldt_args
+  {
+    int start;
+    union descriptor *descs;
+    int num;
+  };
+
+/* Argument struct for I386_GET_IOPERM and I386_SET_IOPERM.  */
+struct i386_ioperm_args
+  {
+    unsigned int start;
+    unsigned int length;
+    int enable;
+  };
+
+/* Argument struct for I386_VM86.  */
+struct i386_vm86_args
+  {
+    int sub_op;
+    void *sub_args;
+  };
+
+__BEGIN_DECLS
+
+extern int sysarch (int __cmd, void *__arg);
+
+#ifdef _LIBC
+extern int __sysarch (int __cmd, void *__arg);
+#endif
+
+__END_DECLS
+
+#endif /* _SYSARCH_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscall.S
@@ -0,0 +1,34 @@
+/* Copyright (C) 1993, 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	  .text;
+ENTRY (__syscall)
+	popl %ecx		/* Pop return address into %ecx.  */
+	cfi_adjust_cfa_offset (-4)
+	movl 0(%esp), %eax	/* Load syscall number into %eax. */
+	int $0x80		/* Do the system call.  */
+	pushl %ecx		/* Push back return address.  */
+	cfi_adjust_cfa_offset (4)
+	jb SYSCALL_ERROR_LABEL;	/* Jump to error handler if error.  */
+
+L(pseudo_end):
+	ret			/* Return to caller.  */
+PSEUDO_END (__syscall)
+weak_alias (__syscall, syscall)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/syscalls-internal.h
@@ -0,0 +1,157 @@
+/* generally used "internal syscalls"
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef KFREEBSD_INTERNAL_SYSCALLS_H
+#define KFREEBSD_INTERNAL_SYSCALLS_H
+
+#include <sys/syscall.h>
+
+/* 
+   for now, we do not care whether syscall succeeded,
+   we do not have defined 
+   INTERNAL_SYSCALL_ERROR_P and INTERNAL_SYSCALL_ERRNO
+   we do not store errno at all
+   to be sure, we return void
+*/
+
+#undef INTERNAL_SYSCALL_DECL
+#undef INTERNAL_SYSCALL_NCS
+#undef INTERNAL_SYSCALL
+#undef INTERNAL_SYSCALL_ERROR_P
+#undef INTERNAL_SYSCALL_ERRNO
+
+#define INTERNAL_SYSCALL_DECL(err)		\
+  do { } while (0)
+
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  INTERNAL_SYSCALL_##name(name, err, nr, ##args)
+
+
+#define INTERNAL_SYSCALL_clock_gettime(name, err, nr, clkid, ts) \
+(void)({                                        \
+  register long int _a1 = (long int) (clkid);	\
+  register long int _a2 = (long int) (ts);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (                                \
+                "pushl %4\n\t"                  \
+                "pushl %3\n\t"                  \
+                "pushl %2\n\t"                  \
+                "int $0x80\n\t"                 \
+                "addl $12,%%esp\n\t"		\
+                : "=a" (result),		\
+                  "=d" (_trash)                 \
+                : "0" ((long int) SYS_##name),	\
+                  "ri" (_a1),			\
+                  "ri" (_a2)			\
+                : "memory", "cc" );             \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_close(name, err, nr, fd) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int result;			\
+  asm volatile (                                \
+                "pushl %2\n\t"                  \
+                "pushl %1\n\t"                  \
+                "int $0x80\n\t"                 \
+                "popl %2\n\t"                   \
+                "popl %2\n\t"                   \
+                : "=a" (result)                 \
+                : "0" ((long int) SYS_##name),	\
+                  "d" (_a1)                   	\
+                : "memory", "cc" );             \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_kill(name, err, nr, pid, sig) \
+(void)({                                        \
+  register long int _a1 = (long int) (pid);	\
+  register long int _a2 = (long int) (sig);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (                                \
+                "pushl %4\n\t"                  \
+                "pushl %3\n\t"                  \
+                "pushl %2\n\t"                  \
+                "int $0x80\n\t"                 \
+                "addl $12,%%esp\n\t"		\
+                : "=a" (result),		\
+                  "=d" (_trash)                 \
+                : "0" ((long int) SYS_##name),	\
+                  "ri" (_a1),			\
+                  "ri" (_a2)			\
+                : "memory", "cc" );             \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_write(name, err, nr, fd, buf, cnt) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int _a2 = (long int) (buf);	\
+  register long int _a3 = (long int) (cnt);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (                                \
+                "pushl %5\n\t"                  \
+                "pushl %4\n\t"                  \
+                "pushl %3\n\t"                  \
+                "pushl %2\n\t"                  \
+                "int $0x80\n\t"                 \
+                "addl $16,%%esp\n\t"		\
+                : "=a" (result),		\
+                  "=d" (_trash)                 \
+                : "0" ((long int) SYS_##name),	\
+                  "ri" (_a1),			\
+                  "ri" (_a2),			\
+                  "ri" (_a3)			\
+              /*   may be even "g" constraint could be used */ \
+              /*   but we have to worry about esp register and esp based address */ \
+                : "memory", "cc" );             \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_writev(name, err, nr, fd, iov, cnt) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int _a2 = (long int) (iov);	\
+  register long int _a3 = (long int) (cnt);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (                                \
+                "pushl %5\n\t"                  \
+                "pushl %4\n\t"                  \
+                "pushl %3\n\t"                  \
+                "pushl %2\n\t"                  \
+                "int $0x80\n\t"                 \
+                "addl $16,%%esp\n\t"		\
+                : "=a" (result),		\
+                  "=d" (_trash)                 \
+                : "0" ((long int) SYS_##name),	\
+                  "ri" (_a1),			\
+                  "ri" (_a2),			\
+                  "ri" (_a3)			\
+              /*   may be even "g" constraint could be used */ \
+              /*   but we have to worry about esp register and esp based address */ \
+                : "memory", "cc" );             \
+  result;                                       \
+})
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.S
@@ -0,0 +1,38 @@
+/* Copyright (C) 1995-1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* The following code is only used in the shared library when we
+   compile the reentrant version.  Otherwise each system call defines
+   its own version.  */
+
+#ifndef PIC
+
+/* The syscall stubs jump here when they detect an error.
+   The code for FreeBSD is identical to the canonical Unix/i386 code.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %eax.  */
+
+	.text
+ENTRY (__syscall_error)
+#define __syscall_error __syscall_error_1
+#include <sysdeps/unix/i386/sysdep.S>
+
+#endif	/* !PIC */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/sysdep.h
@@ -0,0 +1,200 @@
+/* Copyright (C) 1992,1993,1995-2000,2002,2003,2004
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper, <drepper@gnu.org>, August 1995.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_I386_SYSDEP_H
+#define _FREEBSD_I386_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/i386/sysdep.h>
+/* Defines RTLD_PRIVATE_ERRNO and USE_DL_SYSINFO.  */
+#include <dl-sysdep.h>
+#include <tls.h>
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handle to be global when we define
+   it here.  */
+#ifdef PIC
+# define SYSCALL_ERROR_LABEL 0f
+#else
+# define SYSCALL_ERROR_LABEL syscall_error
+#endif
+
+#undef	PSEUDO
+#define	PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args)			      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name)					      \
+  END (name)
+
+#define ret_NOERRNO ret
+
+/* The function has to return the error code.  */
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
+#ifndef PIC
+# define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#else
+
+# if RTLD_PRIVATE_ERRNO
+#  define SYSCALL_ERROR_HANDLER						      \
+0:SETUP_PIC_REG(cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl %eax, rtld_errno@GOTOFF(%ecx);					      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+
+# elif defined _LIBC_REENTRANT
+
+#  if IS_IN (libc)
+#   define SYSCALL_ERROR_ERRNO __libc_errno
+#  else
+#   define SYSCALL_ERROR_ERRNO errno
+#  endif
+#  define SYSCALL_ERROR_HANDLER					      \
+0:SETUP_PIC_REG (cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl SYSCALL_ERROR_ERRNO@GOTNTPOFF(%ecx), %ecx;			      \
+  SYSCALL_ERROR_HANDLER_TLS_STORE (%eax, %ecx);				      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+#  ifndef NO_TLS_DIRECT_SEG_REFS
+#   define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  movl src, %gs:(destoff)
+#  else
+#   define SYSCALL_ERROR_HANDLER_TLS_STORE(src, destoff)		      \
+  addl %gs:0, destoff;							      \
+  movl src, (destoff)
+#  endif
+# else
+/* Store (%eax) into errno through the GOT.  */
+#  define SYSCALL_ERROR_HANDLER						      \
+0:SETUP_PIC_REG(cx);							      \
+  addl $_GLOBAL_OFFSET_TABLE_, %ecx;					      \
+  movl errno@GOT(%ecx), %ecx;						      \
+  movl %eax, (%ecx);							      \
+  orl $-1, %eax;							      \
+  jmp L(pseudo_end);
+# endif	/* _LIBC_REENTRANT */
+#endif	/* PIC */
+
+/*
+    FreeBSD expects the system call arguments on the stack,
+   syscall number is in %eax.
+   return value is in %eax + %edx
+   error is signaled via cflags.
+   all other data registers are preserved
+
+	syscall number	%eax	     call-clobbered
+
+   The stack layout upon entering the function is:
+
+	20(%esp)	Arg# 5
+	16(%esp)	Arg# 4
+	12(%esp)	Arg# 3
+	 8(%esp)	Arg# 2
+	 4(%esp)	Arg# 1
+	  (%esp)	Return address
+
+   (Of course a function with say 3 arguments does not have entries for
+   arguments 4 and 5.)
+
+*/
+
+#undef	DO_CALL
+#define DO_CALL(syscall_name, args)			      		      \
+    movl $SYS_ify (syscall_name), %eax;					      \
+    int $0x80								      \
+
+#else	/* !__ASSEMBLER__ */
+
+#include <syscalls-inline.h>
+
+/* Consistency check for position-independent code.  */
+#if defined __PIC__ && !__GNUC_PREREQ (5,0)
+# define check_consistency()						      \
+  ({ int __res;								      \
+     __asm__ __volatile__						      \
+       (LOAD_PIC_REG_STR (cx) ";"					      \
+	"subl %%ebx, %%ecx;"						      \
+	"je 1f;"							      \
+	"ud2;"								      \
+	"1:\n"								      \
+	: "=c" (__res));						      \
+     __res; })
+#endif
+
+#endif	/* __ASSEMBLER__ */
+
+
+/* Pointer mangling support.  */
+#if IS_IN (rtld)
+/* We cannot use the thread descriptor because in ld.so we use setjmp
+   earlier than the descriptor is initialized.  Using a global variable
+   is too complicated here since we have no PC-relative addressing mode.  */
+#else
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorl %gs:POINTER_GUARD, reg;		      \
+				roll $9, reg
+#  define PTR_DEMANGLE(reg)	rorl $9, reg;				      \
+				xorl %gs:POINTER_GUARD, reg
+# else
+#  define PTR_MANGLE(var)	asm ("xorl %%gs:%c2, %0\n"		      \
+				     "roll $9, %0"			      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+#  define PTR_DEMANGLE(var)	asm ("rorl $9, %0\n"			      \
+				     "xorl %%gs:%c2, %0"		      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+# endif
+#endif
+
+#endif /* _FREEBSD_I386_SYSDEP_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/ucontext_i.h
@@ -0,0 +1,38 @@
+/* Offsets and other constants needed in the *context() function
+   implementation.
+   Copyright (C) 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Offsets of the fields in the ucontext_t structure.  */
+#define oSIGMASK	0
+#define oGS		20
+#define oFS		24
+#define oEDI		36
+#define oESI		40
+#define oEBP		44
+#define oEBX		52
+#define oEDX		56
+#define oECX		60
+#define oEAX		64
+
+#define oEIP		76
+#define oESP		88
+
+#define oLINK		656
+#define oSS_SP		660
+#define oSS_SIZE	664
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/vfork.S
@@ -0,0 +1,73 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+	/* Pop the return PC value into ECX.  */
+	popl	%ecx
+	cfi_adjust_cfa_offset(-4)
+	cfi_register (%eip, %ecx)
+
+#ifdef SAVE_PID
+        SAVE_PID
+#endif
+
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %edx == 0, %eax == child pid.  */
+	/* In the child process, %edx == 1, %eax == parent pid.  */
+
+	/* Change %eax to be 0 in the child process.  */
+	decl	%edx
+	andl	%edx, %eax
+
+#ifdef RESTORE_PID_IN_PARENT
+        jz L(norestore)
+        RESTORE_PID_IN_PARENT
+L(norestore):
+#endif
+
+	/* Jump to the return PC.  */
+	jmp	*%ecx
+
+L(error):
+	/* Push back the return PC.  */
+	pushl	%ecx
+	cfi_adjust_cfa_offset(4)
+
+#ifdef RESTORE_PID_IN_PARENT
+        RESTORE_PID_IN_PARENT
+#endif
+
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/if_index.c
@@ -0,0 +1,317 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <net/if.h>
+#include <sys/sysctl.h>
+#include <sys/socket.h>
+#include <net/route.h>
+#include <net/if_dl.h>
+#include <alloca.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+
+typedef int (*if_fn) (void *private, unsigned int index, const char *name);
+
+/* Iterate through all present interfaces.
+   Call FN once for every interface, returning immediately if FN returns
+   a nonzero value.  */
+static void
+if_iterate (if_fn fn, void *private)
+{
+  int request[6] = { CTL_NET, PF_ROUTE, 0, 0, NET_RT_IFLIST, 0 };
+  char *buf;
+  size_t bufsize = 512;
+  char *bufend;
+  char *p;
+
+  /* Call the kernel function sysctl_iflist() in /usr/src/sys/net/rtsock.c.  */
+  for (;;)
+    {
+      buf = alloca (bufsize);
+      if (__sysctl (request, 6, buf, &bufsize, NULL, 0) >= 0)
+	break;
+      if (errno != ENOMEM)
+	return;
+      bufsize *= 2;
+    }
+
+  bufend = buf + bufsize;
+  for (p = buf; p < bufend; )
+    {
+      struct if_msghdr *msg = (struct if_msghdr *) p;
+
+      if (msg->ifm_version != RTM_VERSION)
+	abort ();
+
+      switch (msg->ifm_type)
+	{
+	case RTM_IFINFO:
+	  if (msg->ifm_addrs & RTA_IFP)
+	    {
+	      unsigned int index;
+	      struct sockaddr_dl *sdl;
+	      char namebuf[IFNAMSIZ + 1];
+	      size_t namelen;
+
+	      index = msg->ifm_index;
+	      if (index == 0)
+		abort ();
+
+	      /* FIXME: 'struct if_msghdr' contains a 'struct if_data' which in turns
+	         contains 'unsigned long' values. Their size therefore depends on
+		 the running kernel (32 or 64 bits). This should be fixed in the
+		 compat layer of the kernel. Meanwhile just workaround the bug here/ */
+#if 0
+	      sdl = (struct sockaddr_dl *) (msg + 1);
+#else
+	      sdl = (struct sockaddr_dl *) (p + msg->ifm_msglen - sizeof(struct sockaddr_dl) - 2);
+#endif
+	      namelen = sdl->sdl_nlen;
+	      /* Avoid overflowing namebuf[].  */
+	      if (namelen > IFNAMSIZ)
+		namelen = IFNAMSIZ;
+	      memcpy (namebuf, sdl->sdl_data, namelen);
+	      namebuf[namelen] = '\0';
+
+	      /* Call FN now.  */
+	      if (fn (private, index, namebuf))
+		return;
+	    }
+	  break;
+
+	case RTM_NEWADDR:
+	  break;
+
+	default:
+	  abort ();
+	}
+
+      p += msg->ifm_msglen;
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+
+struct nametoindex_locals
+  {
+    const char *name;
+    unsigned int index;
+  };
+
+static int
+nametoindex_aux (void *private, unsigned int index, const char *name)
+{
+  struct nametoindex_locals *l = (struct nametoindex_locals *) private;
+  if (strcmp (name, l->name) == 0)
+    {
+      l->index = index;
+      return 1;
+    }
+  return 0;
+}
+
+/* Return the index of an interface given by name.  */
+unsigned int
+__if_nametoindex (const char *ifname)
+{
+  struct nametoindex_locals l;
+
+  l.name = ifname;
+  l.index = 0;
+  if_iterate (nametoindex_aux, &l);
+
+  return l.index;
+}
+libc_hidden_def (__if_nametoindex)
+weak_alias (__if_nametoindex, if_nametoindex)
+libc_hidden_weak (if_nametoindex)
+
+/* ------------------------------------------------------------------------- */
+
+struct indextoname_locals
+  {
+    unsigned int index;
+    char *name;
+    char *retval;
+  };
+
+static int
+indextoname_aux (void *private, unsigned int index, const char *name)
+{
+  struct indextoname_locals *l = (struct indextoname_locals *) private;
+  if (index == l->index)
+    {
+      strncpy (l->name, name, IF_NAMESIZE);
+      l->retval = l->name;
+      return 1;
+    }
+  __set_errno (ENXIO);
+  return 0;
+}
+
+/* Return the name of an interface given by name.  */
+char *
+__if_indextoname (unsigned int ifindex, char *ifname)
+{
+  struct indextoname_locals l;
+
+  l.index = ifindex;
+  l.name = ifname;
+  l.retval = NULL;
+  if_iterate (indextoname_aux, &l);
+  return l.retval;
+}
+weak_alias (__if_indextoname, if_indextoname)
+libc_hidden_weak (if_indextoname)
+
+/* ------------------------------------------------------------------------- */
+
+struct nameindex_locals
+  {
+    /* Resizable array of 'struct if_nameindex'.  */
+    struct if_nameindex *s_array;
+    size_t s_len;
+    size_t s_allocated;
+    /* Resizable array of char.  */
+    char *c_array;
+    size_t c_len;
+    size_t c_allocated;
+    /* Out-of-memory indicator.  */
+    int oom;
+  };
+
+static void
+add_s (struct nameindex_locals *l, unsigned int index, char *name)
+{
+  if (l->s_len == l->s_allocated)
+    {
+      size_t new_allocated = 2 * l->s_allocated + 1;
+      struct if_nameindex *new_array =
+	(struct if_nameindex *)
+	realloc (l->s_array, new_allocated * sizeof (struct if_nameindex));
+      if (new_array == NULL)
+	{
+	  l->oom = 1;
+	  return;
+	}
+      l->s_array = new_array;
+      l->s_allocated = new_allocated;
+    }
+  /* Now l->s_len < l->s_allocated.  */
+  l->s_array[l->s_len].if_index = index;
+  l->s_array[l->s_len].if_name = name;
+  l->s_len++;
+}
+
+static __inline size_t
+add_c (struct nameindex_locals *l, const char *name)
+{
+  size_t n = strlen (name) + 1;
+  size_t result_offset;
+  if (l->c_len + n > l->c_allocated)
+    {
+      size_t new_allocated =
+	(l->c_len + n < 2 * l->c_allocated + 1
+	 ? 2 * l->c_allocated + 1
+	 : l->c_len + n);
+      char *new_array = (char *) realloc (l->c_array, new_allocated);
+      if (new_array == NULL)
+	{
+	  l->oom = 1;
+	  return 0;
+	}
+      l->c_array = new_array;
+      l->c_allocated = new_allocated;
+    }
+  /* Now l->c_len + n <= l->c_allocated.  */
+  result_offset = l->c_len;
+  memcpy (l->c_array + l->c_len, name, n);
+  l->c_len += n;
+  return result_offset;
+}
+
+static int
+nameindex_aux (void *private, unsigned int index, const char *name)
+{
+  struct nameindex_locals *l = (struct nameindex_locals *) private;
+
+  size_t name_offset = add_c (l, name);
+  if (!l->oom)
+    {
+      add_s (l, index, (char *) NULL + name_offset);
+      if (!l->oom)
+	return 0;
+    }
+  return 1;
+}
+
+/* Return an array of 'struct if_nameindex', one for each present
+   interface.  */
+struct if_nameindex *
+__if_nameindex (void)
+{
+  struct nameindex_locals l;
+
+  l.s_array = NULL; l.s_len = 0; l.s_allocated = 0;
+  l.c_array = NULL; l.c_len = 0; l.c_allocated = 0;
+  l.oom = 0;
+  if_iterate (nameindex_aux, &l);
+  if (!l.oom)
+    {
+      /* Convert all offsets to real pointers.  */
+      struct if_nameindex *p;
+      struct if_nameindex *p_end;
+
+      for (p = l.s_array, p_end = p + l.s_len; p < p_end; p++)
+	p->if_name = l.c_array + (p->if_name - (char *) NULL);
+
+      /* Add a terminating entry.  */
+      add_s (&l, 0, NULL);
+    }
+  if (l.oom)
+    {
+      free (l.s_array);
+      free (l.c_array);
+      __set_errno (ENOMEM);
+      return NULL;
+    }
+  return l.s_array;
+}
+weak_alias (__if_nameindex, if_nameindex)
+libc_hidden_weak (if_nameindex)
+
+/* ------------------------------------------------------------------------- */
+
+/* Free an array returned by if_nameindex().  */
+void
+__if_freenameindex (struct if_nameindex *ifn)
+{
+  if (ifn != NULL)
+    {
+      /* Free c_array.  */
+      free (ifn[0].if_name);
+      /* Free s_array.  */
+      free (ifn);
+    }
+}
+libc_hidden_def (__if_freenameindex)
+weak_alias (__if_freenameindex, if_freenameindex)
+libc_hidden_weak (if_freenameindex)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ifaddrs.c
@@ -0,0 +1,382 @@
+/*	$KAME: getifaddrs.c,v 1.9 2001/08/20 02:31:20 itojun Exp $	*/
+
+/*
+ * Copyright (c) 1995, 1999
+ *	Berkeley Software Design, Inc.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Berkeley Software Design, Inc. ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL Berkeley Software Design, Inc. BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	BSDI getifaddrs.c,v 2.12 2000/02/23 14:51:59 dab Exp
+ */
+
+#include <sys/cdefs.h>
+
+ /*
+__FBSDID("$FreeBSD: src/lib/libc/net/getifaddrs.c,v 1.6 2002/07/25 08:08:30 ume Exp $");
+ */
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/sysctl.h>
+#include <net/if.h>
+
+#ifdef	NET_RT_IFLIST
+#include <sys/param.h>
+#include <net/route.h>
+#include <sys/sysctl.h>
+#include <net/if_dl.h>
+#else
+#error NET_RT_IFLIST is required
+#endif
+
+#include <errno.h>
+#include <ifaddrs.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if !defined(AF_LINK)
+#define	SA_LEN(sa)	sizeof(struct sockaddr)
+#endif
+
+#if !defined(SA_LEN)
+#define	SA_LEN(sa)	(sa)->sa_len
+#endif
+
+#define	SALIGN	(sizeof(long) - 1)
+#define	SA_RLEN(sa)	((sa)->sa_len ? (((sa)->sa_len + SALIGN) & ~SALIGN) : (SALIGN + 1))
+
+#ifndef	ALIGNBYTES
+/*
+ * On systems with a routing socket, ALIGNBYTES should match the value
+ * that the kernel uses when building the messages.
+ */
+#define	ALIGNBYTES	XXX
+#endif
+#ifndef	ALIGN
+#define	ALIGN(p)	(((u_long)(p) + ALIGNBYTES) &~ ALIGNBYTES)
+#endif
+
+#define	HAVE_IFM_DATA
+#define MAX_SYSCTL_TRY 5
+
+int
+__getifaddrs(struct ifaddrs **pif)
+{
+	int icnt = 1;
+	int dcnt = 0;
+	int ncnt = 0;
+#ifdef	NET_RT_IFLIST
+	int ntry = 0;
+	int mib[6];
+	size_t needed;
+	char *buf;
+	char *next;
+	struct ifaddrs *cif = 0;
+	char *p, *p0;
+	struct rt_msghdr *rtm;
+	struct if_msghdr *ifm;
+	struct ifa_msghdr *ifam;
+	struct sockaddr_dl *dl;
+	struct sockaddr *sa;
+	struct ifaddrs *ifa, *ift;
+	u_short idx = 0;
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+	int i;
+	size_t len, alen;
+	char *data;
+	char *names;
+
+#ifdef	NET_RT_IFLIST
+	mib[0] = CTL_NET;
+	mib[1] = PF_ROUTE;
+	mib[2] = 0;             /* protocol */
+	mib[3] = 0;             /* wildcard address family */
+	mib[4] = NET_RT_IFLIST;
+	mib[5] = 0;             /* no flags */
+	do {
+		/*
+		 * We'll try to get addresses several times in case that
+		 * the number of addresses is unexpectedly increased during
+		 * the two sysctl calls.  This should rarely happen, but we'll
+		 * try to do our best for applications that assume success of
+		 * this library (which should usually be the case).
+		 * Portability note: since FreeBSD does not add margin of
+		 * memory at the first sysctl, the possibility of failure on
+		 * the second sysctl call is a bit higher.
+		 */
+
+		if (__sysctl(mib, 6, NULL, &needed, NULL, 0) < 0)
+			return (-1);
+		if ((buf = malloc(needed)) == NULL)
+			return (-1);
+		if (__sysctl(mib, 6, buf, &needed, NULL, 0) < 0) {
+			if (errno != ENOMEM || ++ntry >= MAX_SYSCTL_TRY) {
+				free(buf);
+				return (-1);
+			}
+			free(buf);
+			buf = NULL;
+		}
+	} while (buf == NULL);
+
+	for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
+		rtm = (struct rt_msghdr *)(void *)next;
+		if (rtm->rtm_version != RTM_VERSION)
+			continue;
+		switch (rtm->rtm_type) {
+		case RTM_IFINFO:
+			ifm = (struct if_msghdr *)(void *)rtm;
+			if (ifm->ifm_addrs & RTA_IFP) {
+				idx = ifm->ifm_index;
+				++icnt;
+				dl = (struct sockaddr_dl *)(void *)(ifm + 1);
+				/* XXX: smooth over a kfreebsd 9.0->10.1 ABI break */
+				if (rtm->rtm_msglen == 152) {
+					/* on kfreebsd-i386 9.0, struct rt_msghdr is 96 bytes */
+					dl = (struct sockaddr_dl *)((char *)ifm + 96);
+				}
+				if (rtm->rtm_msglen == 156) {
+					/* on kfreebsd-i386 10.1, struct rt_msghdr is 100 bytes */
+					dl = (struct sockaddr_dl *)((char *)ifm + 100);
+				}
+				dcnt += SA_RLEN((struct sockaddr *)(void*)dl) +
+				    ALIGNBYTES;
+#ifdef	HAVE_IFM_DATA
+				dcnt += sizeof(ifm->ifm_data);
+#endif	/* HAVE_IFM_DATA */
+				ncnt += dl->sdl_nlen + 1;
+			} else
+				idx = 0;
+			break;
+
+		case RTM_NEWADDR:
+			ifam = (struct ifa_msghdr *)(void *)rtm;
+			if (idx && ifam->ifam_index != idx)
+			{
+				errno = EINVAL;		/* this cannot happen */
+				return -1;
+			};
+#define	RTA_MASKS	(RTA_NETMASK | RTA_IFA | RTA_BRD)
+			if (idx == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0)
+				break;
+			p = (char *)(void *)(ifam + 1);
+			++icnt;
+#ifdef	HAVE_IFAM_DATA
+			dcnt += sizeof(ifam->ifam_data) + ALIGNBYTES;
+#endif	/* HAVE_IFAM_DATA */
+			/* Scan to look for length of address */
+			alen = 0;
+			for (p0 = p, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_IFA) {
+					alen = len;
+					break;
+				}
+				p += len;
+			}
+			for (p = p0, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_NETMASK && SA_LEN(sa) == 0)
+					dcnt += alen;
+				else
+					dcnt += len;
+				p += len;
+			}
+			break;
+		}
+	}
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+
+	if (icnt + dcnt + ncnt == 1) {
+		*pif = NULL;
+		free(buf);
+		return (0);
+	}
+	data = malloc(sizeof(struct ifaddrs) * icnt + dcnt + ncnt);
+	if (data == NULL) {
+		free(buf);
+		return(-1);
+	}
+
+	ifa = (struct ifaddrs *)(void *)data;
+	data += sizeof(struct ifaddrs) * icnt;
+	names = data + dcnt;
+
+	memset(ifa, 0, sizeof(struct ifaddrs) * icnt);
+	ift = ifa;
+
+#ifdef	NET_RT_IFLIST
+	idx = 0;
+	for (next = buf; next < buf + needed; next += rtm->rtm_msglen) {
+		rtm = (struct rt_msghdr *)(void *)next;
+		if (rtm->rtm_version != RTM_VERSION)
+			continue;
+		switch (rtm->rtm_type) {
+		case RTM_IFINFO:
+			ifm = (struct if_msghdr *)(void *)rtm;
+			if (ifm->ifm_addrs & RTA_IFP) {
+				idx = ifm->ifm_index;
+				dl = (struct sockaddr_dl *)(void *)(ifm + 1);
+				/* XXX: smooth over a kfreebsd 9.0->10.1 ABI break */
+				if (rtm->rtm_msglen == 152) {
+					/* on kfreebsd-i386 9.0, struct rt_msghdr is 96 bytes */
+					dl = (struct sockaddr_dl *)((char *)ifm + 96);
+				}
+				if (rtm->rtm_msglen == 156) {
+					/* on kfreebsd-i386 10.1, struct rt_msghdr is 100 bytes */
+					dl = (struct sockaddr_dl *)((char *)ifm + 100);
+				}
+
+				cif = ift;
+				ift->ifa_name = names;
+				ift->ifa_flags = (int)ifm->ifm_flags;
+				memcpy(names, dl->sdl_data,
+				    (size_t)dl->sdl_nlen);
+				names[dl->sdl_nlen] = 0;
+				names += dl->sdl_nlen + 1;
+
+				ift->ifa_addr = (struct sockaddr *)(void *)data;
+				memcpy(data, dl,
+				    (size_t)SA_LEN((struct sockaddr *)
+				    (void *)dl));
+				data += SA_RLEN((struct sockaddr *)(void *)dl);
+
+#ifdef	HAVE_IFM_DATA
+				/* ifm_data needs to be aligned */
+				ift->ifa_data = data = (void *)ALIGN(data);
+				memcpy(data, &ifm->ifm_data, sizeof(ifm->ifm_data));
+ 				data += sizeof(ifm->ifm_data);
+#else	/* HAVE_IFM_DATA */
+				ift->ifa_data = NULL;
+#endif	/* HAVE_IFM_DATA */
+
+				ift = (ift->ifa_next = ift + 1);
+			} else
+				idx = 0;
+			break;
+
+		case RTM_NEWADDR:
+			ifam = (struct ifa_msghdr *)(void *)rtm;
+			if (idx && ifam->ifam_index != idx)
+			{
+				errno = EINVAL;		/* this cannot happen */
+				return -1;
+			};
+			if (idx == 0 || (ifam->ifam_addrs & RTA_MASKS) == 0)
+				break;
+			ift->ifa_name = cif->ifa_name;
+			ift->ifa_flags = cif->ifa_flags;
+			ift->ifa_data = NULL;
+			p = (char *)(void *)(ifam + 1);
+			/* Scan to look for length of address */
+			alen = 0;
+			for (p0 = p, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				if (i == RTAX_IFA) {
+					alen = len;
+					break;
+				}
+				p += len;
+			}
+			for (p = p0, i = 0; i < RTAX_MAX; i++) {
+				if ((RTA_MASKS & ifam->ifam_addrs & (1 << i))
+				    == 0)
+					continue;
+				sa = (struct sockaddr *)(void *)p;
+				len = SA_RLEN(sa);
+				switch (i) {
+				case RTAX_IFA:
+					ift->ifa_addr =
+					    (struct sockaddr *)(void *)data;
+					memcpy(data, p, len);
+					data += len;
+					break;
+
+				case RTAX_NETMASK:
+					ift->ifa_netmask =
+					    (struct sockaddr *)(void *)data;
+					if (SA_LEN(sa) == 0) {
+						memset(data, 0, alen);
+						data += alen;
+						break;
+					}
+					memcpy(data, p, len);
+					data += len;
+					break;
+
+				case RTAX_BRD:
+					ift->ifa_broadaddr =
+					    (struct sockaddr *)(void *)data;
+					memcpy(data, p, len);
+					data += len;
+					break;
+				}
+				p += len;
+			}
+
+#ifdef	HAVE_IFAM_DATA
+			/* ifam_data needs to be aligned */
+			ift->ifa_data = data = (void *)ALIGN(data);
+			memcpy(data, &ifam->ifam_data, sizeof(ifam->ifam_data));
+			data += sizeof(ifam->ifam_data);
+#endif	/* HAVE_IFAM_DATA */
+
+			ift = (ift->ifa_next = ift + 1);
+			break;
+		}
+	}
+
+	free(buf);
+#else	/* NET_RT_IFLIST */
+#endif	/* NET_RT_IFLIST */
+	if (--ift >= ifa) {
+		ift->ifa_next = NULL;
+		*pif = ifa;
+	} else {
+		*pif = NULL;
+		free(ifa);
+	}
+	return (0);
+}
+weak_alias (__getifaddrs, getifaddrs)
+libc_hidden_weak (getifaddrs)
+
+void
+__freeifaddrs(struct ifaddrs *ifp)
+{
+
+	free(ifp);
+}
+weak_alias (__freeifaddrs, freeifaddrs)
+libc_hidden_weak (freeifaddrs)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ifreq.c
@@ -0,0 +1,93 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+
+#include <ifreq.h>
+
+/* The FreeBSD ioctl SIOCGIFCONF returns the list if interfaces as a
+   concatenation of records of different size, each having at least
+   sizeof (struct ifreq) bytes.  */
+
+
+void
+__ifreq (struct ifreq **ifreqs, int *num_ifs, int sockfd)
+{
+  int fd = sockfd;
+  struct ifconf ifc;
+  int rq_len;
+  int nifs;
+  char *ifstart;
+  char *ifend;
+  struct ifreq *ifr;
+  /* FreeBSD has many interfaces, many of them are usually down.  */
+# define RQ_IFS	16
+  /* We have to assume all records are of limited size, so that we know
+     when we can stop enlarging the buffer.  */
+# define RQ_MAXSIZE 256
+
+  if (fd < 0)
+    fd = __opensock ();
+  if (fd < 0)
+    {
+      *num_ifs = 0;
+      *ifreqs = NULL;
+      return;
+    }
+
+  ifc.ifc_buf = NULL;
+  rq_len = RQ_IFS * sizeof (struct ifreq) + RQ_MAXSIZE;
+  for (;;)
+    {
+      ifc.ifc_len = rq_len;
+      ifc.ifc_buf = realloc (ifc.ifc_buf, ifc.ifc_len);
+      if (ifc.ifc_buf == NULL || __ioctl (fd, SIOCGIFCONF, &ifc) < 0)
+	{
+	  if (ifc.ifc_buf)
+	    free (ifc.ifc_buf);
+
+	  if (fd != sockfd)
+	    __close (fd);
+	  *num_ifs = 0;
+	  *ifreqs = NULL;
+	  return;
+	}
+      if (ifc.ifc_len + RQ_MAXSIZE <= rq_len)
+	break;
+      rq_len *= 2;
+    }
+
+  nifs = 0;
+  ifstart = (char *) ifc.ifc_buf;
+  ifend = ifstart + ifc.ifc_len;
+  for (ifr = (struct ifreq *) ifstart;
+       (char *) ifr < ifend;
+       ifr = __if_nextreq (ifr))
+    nifs++;
+
+  if (fd != sockfd)
+    __close (fd);
+
+  *num_ifs = nifs;
+  *ifreqs = realloc (ifc.ifc_buf, ifc.ifc_len);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/init-first.c
@@ -0,0 +1,139 @@
+/* Initialization code run first thing by the ELF startup code.
+   Copyright (C) 1995-2004, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <signal.h>
+#include <fpu_control.h>
+#include <sys/param.h>
+#include <sys/types.h>
+#include <libc-internal.h>
+
+#include <ldsodefs.h>
+
+extern int __syscall_sigaction (int __sig,  const struct sigaction *__act, struct sigaction *__oact) __THROW;
+libc_hidden_proto (__syscall_sigaction)
+
+/* Set nonzero if we have to be prepared for more then one libc being
+   used in the process.  Safe assumption if initializer never runs.  */
+int __libc_multiple_libcs attribute_hidden = 1;
+
+/* Remember the command line argument and enviroment contents for
+   later calls of initializers for dynamic libraries.  */
+int __libc_argc attribute_hidden;
+char **__libc_argv attribute_hidden;
+
+
+void
+__libc_init_first (int argc, char **argv, char **envp)
+{
+#ifdef SHARED
+  /* For DSOs we do not need __libc_init_first but instead _init.  */
+}
+
+void
+attribute_hidden
+_init (int argc, char **argv, char **envp)
+{
+#endif
+#ifdef USE_NONOPTION_FLAGS
+  extern void __getopt_clean_environment (char **);
+#endif
+
+  __libc_multiple_libcs = &_dl_starting_up && !_dl_starting_up;
+
+  /* Make sure we don't initialize twice.  */
+  if (!__libc_multiple_libcs)
+    {
+      /* Set the FPU control word to the proper default value if the
+	 kernel would use a different value.  (In a static program we
+	 don't have this information.)  */
+#if 0
+      /* at least on kFreeBSD set it even if SHARED,
+      fixes "make check" failures like math/test-fpucw.out */
+#ifdef SHARED
+      if (__fpu_control != GLRO(dl_fpu_control))
+#endif
+#endif
+	__setfpucw (__fpu_control);
+    }
+
+  /* By default on kFreeBSD when a call to non existing syscall is
+     made, the program is terminated. As we want to be able to detect
+     missing syscalls and provide a fallback code, we ignore the SIGSYS
+     signal. */
+  {
+    struct sigaction act;
+    
+    act.sa_handler = SIG_IGN;
+    __sigemptyset (&act.sa_mask);
+    act.sa_flags = 0;
+    
+    INLINE_SYSCALL (sigaction, 3, SIGSYS, &act, NULL); 
+  }  
+
+  /* Save the command-line arguments.  */
+  __libc_argc = argc;
+  __libc_argv = argv;
+  __environ = envp;
+
+#ifndef SHARED
+  __libc_init_secure ();
+
+  /* First the initialization which normally would be done by the
+     dynamic linker.  */
+  _dl_non_dynamic_init ();
+#endif
+
+#ifdef VDSO_SETUP
+  VDSO_SETUP ();
+#endif
+
+  __init_misc (argc, argv, envp);
+
+#ifdef USE_NONOPTION_FLAGS
+  /* This is a hack to make the special getopt in GNU libc working.  */
+  __getopt_clean_environment (envp);
+#endif
+
+  /* Initialize ctype data.  */
+  __ctype_init ();
+
+#if defined SHARED && !defined NO_CTORS_DTORS_SECTIONS
+  __libc_global_ctors ();
+#endif
+}
+
+
+/* This function is defined here so that if this file ever gets into
+   ld.so we will get a link error.  Having this file silently included
+   in ld.so causes disaster, because the _init definition above will
+   cause ld.so to gain an init function, which is not a cool thing. */
+
+extern void _dl_start (void) __attribute__ ((noreturn));
+
+void
+_dl_start (void)
+{
+  abort ();
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/init-posix.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 1991, 94, 95, 97, 98, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <time.h>
+
+/* This must be initialized data or its presence will not be sufficient to
+   merit linkage of this file, which is necessary for the real
+   initialization function below to be called.  */
+time_t _posix_start_time = -1;
+
+void
+__init_posix (void)
+{
+  _posix_start_time = time ((time_t *) NULL);
+}
+
+text_set_element(__libc_subinit, __init_posix);
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ipc_priv.h
@@ -0,0 +1,53 @@
+/* 
+   Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+struct ipc_perm_old
+  {
+    __uint16_t /* yuck! */ cuid;	/* creator's user ID */
+    __uint16_t /* yuck! */ cgid;	/* creator's group ID */
+    __uint16_t /* yuck! */ uid;		/* owner's user ID */
+    __uint16_t /* yuck! */ gid;		/* owner's group ID */
+    __mode_t mode;			/* read/write permission */
+    __uint16_t __seq;
+    __key_t __key;
+  };
+
+static inline void
+ipc_perm_old2new(const struct ipc_perm_old *in, struct ipc_perm *out)
+{
+  out->cuid  = in->cuid;
+  out->cgid  = in->cgid;
+  out->uid   = in->uid;
+  out->gid   = in->gid;
+  out->mode  = in->mode;
+  out->__seq = in->__seq;
+  out->__key = in->__key;
+}
+
+static inline void
+ipc_perm_new2old(const struct ipc_perm *in, struct ipc_perm_old *out)
+{
+  out->cuid  = in->cuid;
+  out->cgid  = in->cgid;
+  out->uid   = in->uid;
+  out->gid   = in->gid;
+  out->mode  = in->mode;
+  out->__seq = in->__seq;
+  out->__key = in->__key;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/kenv.h
@@ -0,0 +1,39 @@
+/*-
+ * Copyright (c) 2002 Maxime Henrion <mux@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/include/kenv.h,v 1.2.8.1 2009/04/15 03:14:26 kensmith Exp $
+ */
+
+#ifndef _KENV_H_
+#define _KENV_H 	1
+
+#include <sys/cdefs.h>
+#include <sys/kenv.h>
+
+__BEGIN_DECLS
+int kenv(int action, const char *name, char *value, int len);
+__END_DECLS
+
+#endif /* !_KENV_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-features.h
@@ -0,0 +1,93 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __KFREEBSD_KERNEL_VERSION
+/* We assume the worst; all kernels should be supported.  */
+# define __KFREEBSD_KERNEL_VERSION	0
+#endif
+
+/* The encoding for __KFREEBSD_KERNEL_VERSION is defined the following
+   way: the major, minor, and subminor all get a byte with the major
+   number being in the highest byte.  This means we can do numeric
+   comparisons.
+
+   In the following we will define certain symbols depending on
+   whether the describes kernel feature is available in the kernel
+   version given by __KFREEBSD_KERNEL_VERSION.  We are not always exactly
+   recording the correct versions in which the features were
+   introduced.  If somebody cares these values can afterwards be
+   corrected.  */
+
+/* 
+   The used encoding corresponds to the following in elf/dl-load.c:
+
+            osversion = (abi_note[5] & 0xff) * 65536
+                        + (abi_note[6] & 0xff) * 256
+                        + (abi_note[7] & 0xff);
+            if (abi_note[4] != __ABI_TAG_OS
+                || (GLRO(dl_osversion) && GLRO(dl_osversion) < osversion))
+            
+   Therefore, the __KFREEBSD_KERNEL_VERSION have different value compared to
+   __FreeBSD_version/__FreeBSD_kernel__version. 
+   The transformation is not just prepend 0x to __FreeBSD_kernel_version.
+
+   For changes see i.e.
+   http://www.freebsd.org/doc/en/books/porters-handbook/freebsd-versions.html
+*/
+
+/* Real-time signals introduced in FreeBSD 7.x.  */
+# define __ASSUME_REALTIME_SIGNALS	1
+
+/* Use signals #32, #33, #34 for internal linuxthreads communication */
+#define PTHREAD_SIGBASE 32
+
+/* The `ftruncate' syscall was introduced in kFreeBSD 7.0. */
+# define __ASSUME_TRUNCATE_SYSCALL	1
+
+/* The `lseek' syscall was introduced in kFreeBSD 7.0. */
+# define __ASSUME_LSEEK_SYSCALL		1
+
+/* The `mmap' syscall was introduced in kFreeBSD 7.0. */
+# define __ASSUME_MMAP_SYSCALL		1
+
+/* The `pread' and `pwrite' syscalls were introduced in kFreeBSD 7.0. */
+# define __ASSUME_PREAD_PWRITE_SYSCALLS	1
+
+/* The `shm_*' syscalls were introduced in kFreeBSD 8.0 */
+# define __ASSUME_SHMFCTS		1
+
+/* The `*at' syscalls were introduced in kFreeBSD 8.0. */
+# define __ASSUME_ATFCTS		1
+
+/* The pselect syscall was introduced in kFreeBSD 8.1. */
+# define __ASSUME_PSELECT		1
+
+/* The posix_fallocate syscall was introduced in kFreeBSD 8.3. */
+#if __KFREEBSD_KERNEL_VERSION >= 0x80300
+# define __ASSUME_FALLOCATE		1
+#endif
+
+/* The wait6 syscall was introduced in kFreeBSD 9.2. */
+#if __KFREEBSD_KERNEL_VERSION >= 0x90200
+# define __ASSUME_WAIT6			1
+#endif
+
+/* Support for private "futexes" was added before we start with fbtl. */
+# define __ASSUME_PRIVATE_FUTEX		1
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/kernel-posix-cpu-timers.h
@@ -0,0 +1,5 @@
+/* Parameters for the FreeBSD kernel ABI for CPU clocks.  */
+
+#define CPUCLOCK_WHICH(clock)   ((clock) & (clockid_t) CPUCLOCK_CLOCK_MASK)
+#define CPUCLOCK_CLOCK_MASK     15
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ldsodefs.h
@@ -0,0 +1,60 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_LDSODEFS_H
+
+/* Get the real definitions.  */
+#include_next <ldsodefs.h>
+
+/* Now define our stuff.  */
+
+/* FreeBSD puts some extra information into an auxiliary vector when it
+   execs ELF executables.  Note that it uses AT_* values of 10 and 11
+   to denote something different than AT_NOTELF and AT_UID, but this is
+   not a problem since elf/dl-support.c ignores these AT_* values.  */
+#define HAVE_AUX_VECTOR
+
+/* Used by static binaries to check the auxiliary vector.  */
+extern void _dl_aux_init (ElfW(auxv_t) *av) internal_function;
+
+/* Initialization which is normally done by the dynamic linker.  */
+extern void _dl_non_dynamic_init (void) internal_function;
+
+/* Contrary to most kernels which use ELFOSABI_SYSV aka ELFOSABI_NONE,
+   FreeBSD uses ELFOSABI_FREEBSD for the OSABI field. */
+#undef VALID_ELF_HEADER
+#define VALID_ELF_HEADER(hdr,exp,size)	(memcmp (hdr, expected2, size) == 0)
+#undef VALID_ELF_OSABI
+#define VALID_ELF_OSABI(osabi)		(osabi == ELFOSABI_FREEBSD)
+#undef MORE_ELF_HEADER_DATA
+#define MORE_ELF_HEADER_DATA \
+  static const unsigned char expected2[EI_PAD] =	\
+  {							\
+    [EI_MAG0] = ELFMAG0,				\
+    [EI_MAG1] = ELFMAG1,				\
+    [EI_MAG2] = ELFMAG2,				\
+    [EI_MAG3] = ELFMAG3,				\
+    [EI_CLASS] = ELFW(CLASS),				\
+    [EI_DATA] = byteorder,				\
+    [EI_VERSION] = EV_CURRENT,				\
+    [EI_OSABI] = ELFOSABI_FREEBSD,			\
+    [EI_ABIVERSION] = 0					\
+  }
+
+#endif /* ldsodefs.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/llseek.c
@@ -0,0 +1,6 @@
+/* We don't need a definition since the lseek64 function is what we need.  */
+/* llseek doesn't have a prototype.  Since the second parameter is a
+   64bit type, this results in wrong behaviour if no prototype is
+   provided.  */
+link_warning (llseek, "\
+the `llseek' function may be dangerous; use `lseek64' instead.")
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/lowlevelumtx.h
@@ -0,0 +1,131 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LOWLEVELUMTX_H
+#define _LOWLEVELUMTX_H	1
+
+#include <kernel-features.h>
+#include <sysdep.h>
+#include <atomic.h>
+
+/* from <sys/umtx.h> */
+/* op code for _umtx_op */
+#define	UMTX_OP_WAIT		2
+#define	UMTX_OP_WAKE		3
+#define	UMTX_OP_WAIT_UINT	11
+#define	UMTX_OP_WAIT_UINT_PRIVATE	15
+#define	UMTX_OP_WAKE_PRIVATE	16
+
+int __syscall__umtx_op(void *, int, long, void*, void*);
+libc_hidden_proto (__syscall__umtx_op)
+
+#define UMTX_SYSCALL __syscall__umtx_op
+
+/*
+ * 
+   we provide set of functions
+   lll_umtx_{int,long}_{wait,wake}_{private,shared}
+ *  
+ */
+
+/*******************************************************/
+
+#define lll_umtx_int_wait_private(addr, val, timeout)	\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAIT_UINT_PRIVATE, 			\
+        (long)((unsigned int)(val)),			\
+        NULL,						\
+        timeout);					\
+   })
+
+#define lll_umtx_int_wait_shared(addr, val, timeout)	\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAIT_UINT,	 			\
+        (long)((unsigned int)(val)),			\
+        NULL,						\
+        timeout);					\
+   })
+
+#define lll_umtx_long_wait_private(addr, val, timeout)	\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAIT,  /* only autoshare available */	\
+        val,						\
+        NULL,						\
+        timeout);					\
+   })
+
+#define lll_umtx_long_wait_shared(addr, val, timeout)	\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAIT,  /* only autoshare available */	\
+        val,						\
+        NULL,						\
+        timeout);					\
+   })
+
+/*******************************************************/
+
+#define lll_umtx_int_wake_private(addr, num)  		\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAKE_PRIVATE,	 			\
+        num,						\
+        NULL,						\
+        NULL);						\
+   })
+
+#define lll_umtx_int_wake_shared(addr, num)  		\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAKE,		 			\
+        num,						\
+        NULL,						\
+        NULL);						\
+   })
+
+#define lll_umtx_long_wake_private(addr, num) 		\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAKE_PRIVATE,	 			\
+        num,						\
+        NULL,						\
+        NULL);						\
+   })
+
+#define lll_umtx_long_wake_shared(addr, num)  		\
+  ({							\
+    UMTX_SYSCALL(					\
+        addr,						\
+        UMTX_OP_WAKE,		 			\
+        num,						\
+        NULL,						\
+        NULL);						\
+   })
+
+/*******************************************************/
+
+#endif	/* _LOWLEVELUMTX_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/lseek64.c
@@ -0,0 +1 @@
+/* 'lseek64' is the same as 'lseek', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat.c
@@ -0,0 +1,47 @@
+/* lxstat using FreeBSD lstat, nlstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include "stat16conv.c"
+
+int
+__lxstat (int vers, const char *file, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_lstat (file, &buf16);
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_lstat (file, (struct stat16 *) buf);
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__lxstat)
+
+weak_alias (__lxstat, _lxstat)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/lxstat64.c
@@ -0,0 +1,43 @@
+/* lxstat using FreeBSD lstat, nlstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include "stat16conv.c"
+
+int
+__lxstat64 (int vers, const char *file, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_lstat (file, &buf16);
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__lxstat64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/____longjmp_chk.c
@@ -0,0 +1,7 @@
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.
+   void __longjmp (__jmp_buf env, int val).  */
+      
+#warning longjmp_chk unimplemented
+#define __longjmp ____longjmp_chk
+#include <__longjmp.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/dl-machine.h
@@ -0,0 +1,97 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  MIPS version.
+   Copyright (C) 1996-2001, 2002, 2003, 2004, 2005, 2006, 2007, 2010
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Kazumoto Kojima <kkojima@info.kanagawa-u.ac.jp>.
+   Port to kFreeBSD (kernel of FreeBSD) by Robert Millan.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include_next <dl-machine.h>
+
+/* kFreeBSD puts arguments in a different location (see start.S).  */
+#undef RTLD_START
+#define RTLD_START asm (\
+	".text\n\
+	" _RTLD_PROLOGUE(ENTRY_POINT) "\
+	" STRINGXV(SETUP_GPX($25)) "\n\
+	" STRINGXV(SETUP_GPX64($18,$25)) "\n\
+	# i386 ABI book says that the first entry of GOT holds\n\
+	# the address of the dynamic structure. Though MIPS ABI\n\
+	# doesn't say nothing about this, I emulate this here.\n\
+	" STRINGXP(PTR_LA) " $9, _DYNAMIC\n\
+	# Subtract OFFSET_GP_GOT\n\
+	" STRINGXP(PTR_S) " $9, -0x7ff0($28)\n\
+	move $9, $29\n\
+	" STRINGXP(PTR_SUBIU) " $29, 16\n\
+	\n\
+	" STRINGXP(PTR_LA) " $8, .Lcoff\n\
+	bltzal $8, .Lcoff\n\
+.Lcoff:	" STRINGXP(PTR_SUBU) " $8, $31, $8\n\
+	\n\
+	" STRINGXP(PTR_LA) " $25, _dl_start\n\
+	" STRINGXP(PTR_ADDU) " $25, $8\n\
+	jalr $25\n\
+	\n\
+	" STRINGXP(PTR_ADDIU) " $29, 16\n\
+	# Get the value of label '_dl_start_user' in t9 ($25).\n\
+	" STRINGXP(PTR_LA) " $25, _dl_start_user\n\
+	" _RTLD_EPILOGUE(ENTRY_POINT) "\
+	\n\
+	\n\
+	" _RTLD_PROLOGUE(_dl_start_user) "\
+	" STRINGXP(SETUP_GP) "\n\
+	" STRINGXV(SETUP_GP64($18,_dl_start_user)) "\n\
+	move $16, $28\n\
+	# Save the user entry point address in a saved register.\n\
+	move $17, $2\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	lw $2, _dl_skip_args\n\
+	beq $2, $0, 1f\n\
+	# Load the original argument count.\n\
+	" STRINGXP(PTR_L) " $10, 0($4)\n\
+	# Subtract _dl_skip_args from it.\n\
+	subu $10, $2\n\
+	# FIXME: unnecessary? Adjust the stack pointer to skip _dl_skip_args words.\n\
+	sll $2, " STRINGXP (PTRLOG) "\n\
+	" STRINGXP(PTR_ADDU) " $29, $2\n\
+	# Save back the modified argument count.\n\
+	" STRINGXP(PTR_S) " $10, 0($4)\n\
+1:	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env) \n\
+	" STRINGXP(PTR_L) /* or lw???  fixme */ " $5, 0($4)\n\
+	" STRINGXP(PTR_LA) " $6, " STRINGXP (PTRSIZE) "($4)\n\
+	" STRINGXP(PTR_L) " $4, _rtld_local\n\
+	sll $7, $5, " STRINGXP (PTRLOG) "\n\
+	" STRINGXP(PTR_ADDU) " $7, $7, $6\n\
+	" STRINGXP(PTR_ADDU) " $7, $7, " STRINGXP (PTRSIZE) " \n\
+	# Make sure the stack pointer is aligned for _dl_init.\n\
+	and $2, $29, -2 * " STRINGXP(SZREG) "\n\
+	" STRINGXP(PTR_S) " $29, -" STRINGXP(SZREG) "($2)\n\
+	" STRINGXP(PTR_SUBIU) " $29, $2, 32\n\
+	" STRINGXP(SAVE_GP(16)) "\n\
+	# Call the function to run the initializers.\n\
+	jal _dl_init\n\
+	# Restore the stack pointer for _start.\n\
+	" STRINGXP(PTR_L)  " $29, 32-" STRINGXP(SZREG) "($29)\n\
+	# Pass our finalizer function to the user in $2 as per ELF ABI.\n\
+	" STRINGXP(PTR_LA) " $2, _dl_fini\n\
+	# Jump to the user entry point.\n\
+	move $25, $17\n\
+	jr $25\n\t"\
+	_RTLD_EPILOGUE(_dl_start_user)\
+	".previous"\
+);
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/entry.h
@@ -0,0 +1,7 @@
+/* http://sources.redhat.com/bugzilla/show_bug.cgi?id=12297 */
+
+#ifndef __ASSEMBLY__
+extern void __start (void);
+#endif
+
+#define ENTRY_POINT __start
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/Makefile
@@ -0,0 +1,2 @@
+# pull in __syscall_error routine (needed by sysdep.h in this directory)
+libpthread-routines += sysdep
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/bits/mcontext.h
@@ -0,0 +1,116 @@
+/* Machine-dependent processor state structure for kFreeBSD.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  mips version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ucontext.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: ucontext.h,v 1.2 2007/08/09 11:23:32 katta
+ * $FreeBSD$
+ */
+
+typedef struct	__mcontext {
+	/*
+	 * These fields must match the corresponding fields in struct 
+	 * sigcontext which follow 'sc_mask'. That way we can support
+	 * struct sigcontext and ucontext_t at the same time.
+	 */
+	int		mc_onstack;	/* sigstack state to restore */
+	int	mc_pc;		/* pc at time of signal */
+	int	mc_regs[32];	/* processor regs 0 to 31 */
+        int      sr;             /* status register */
+        int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		mc_fpused;	/* fp has been used */
+	int	mc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	int	mc_fpc_eir;	/* fp exception instruction reg */
+	int	__spare__[8];	/* XXX reserved */ 
+} mcontext_t;
+
+#define	SZREG		4
+
+/* offsets into mcontext_t */
+#define	UCTX_REG(x)	(8 + (x)*SZREG)
+
+#define	UCR_ZERO	UCTX_REG(0)
+#define	UCR_AT		UCTX_REG(1)
+#define	UCR_V0		UCTX_REG(2)
+#define	UCR_V1		UCTX_REG(3)
+#define	UCR_A0		UCTX_REG(4)
+#define	UCR_A1		UCTX_REG(5)
+#define	UCR_A2		UCTX_REG(6)
+#define	UCR_A3		UCTX_REG(7)
+#define	UCR_T0		UCTX_REG(8)
+#define	UCR_T1		UCTX_REG(9)
+#define	UCR_T2		UCTX_REG(10)
+#define	UCR_T3		UCTX_REG(11)
+#define	UCR_T4		UCTX_REG(12)
+#define	UCR_T5		UCTX_REG(13)
+#define	UCR_T6		UCTX_REG(14)
+#define	UCR_T7		UCTX_REG(15)
+#define	UCR_S0		UCTX_REG(16)
+#define	UCR_S1		UCTX_REG(17)
+#define	UCR_S2		UCTX_REG(18)
+#define	UCR_S3		UCTX_REG(19)
+#define	UCR_S4		UCTX_REG(20)
+#define	UCR_S5		UCTX_REG(21)
+#define	UCR_S6		UCTX_REG(22)
+#define	UCR_S7		UCTX_REG(23)
+#define	UCR_T8		UCTX_REG(24)
+#define	UCR_T9		UCTX_REG(25)
+#define	UCR_K0		UCTX_REG(26)
+#define	UCR_K1		UCTX_REG(27)
+#define	UCR_GP		UCTX_REG(28)
+#define	UCR_SP		UCTX_REG(29)
+#define	UCR_S8		UCTX_REG(30)
+#define	UCR_RA		UCTX_REG(31)
+#define UCR_SR          UCTX_REG(32)
+#define	UCR_MDLO	UCTX_REG(33)
+#define	UCR_MDHI	UCTX_REG(34)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/bits/sigcontext.h
@@ -0,0 +1,92 @@
+/* Machine-dependent signal context structure for kFreeBSD.  mips version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/*	$OpenBSD: signal.h,v 1.2 1999/01/27 04:10:03 imp Exp $	*/
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)signal.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: signal.h,v 1.4 2007/01/08 04:58:37 katta
+ * $FreeBSD$
+ */
+
+/*
+ * Information pushed on stack when a signal is delivered.
+ * This is used by the kernel to restore state following
+ * execution of the signal handler.  It is also made available
+ * to the handler to allow it to restore state properly if
+ * a non-standard exit is performed.
+ */
+
+__extension__ struct sigcontext {
+	/*
+	 * The fields following 'sc_mask' must match the definition
+	 * of struct __mcontext. That way we can support
+	 * struct sigcontext and ucontext_t at the same
+	 * time.
+	 */
+	__sigset_t	sc_mask;	/* signal mask to restore */
+	int		sc_onstack;	/* sigstack state to restore */
+	int	sc_pc;		/* pc at time of signal */
+	int	sc_regs[32];	/* processor regs 0 to 31 */
+	int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		sc_fpused;	/* fp has been used */
+	int	sc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	int	sc_fpc_eir;	/* fp exception instruction reg */
+	int		xxx[8];		/* XXX reserved */ 
+};
+
+#endif /* _BITS_SIGCONTEXT_H */
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips32/sysdep.h
@@ -0,0 +1,49 @@
+/* Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _KFREEBSD_MIPS_SYSDEP_H
+#define _KFREEBSD_MIPS_SYSDEP_H 1
+
+/* This drags in __syscall_error, keep in sync with Makefile in
+   this directory.  */
+#include <sysdeps/unix/sysv/linux/mips/mips32/sysdep.h>
+
+/* Default INLINE_SYSCALL works but is buggy for 64-bit arguments
+   (breaks mmap, lseek...).  */
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...) __syscall_##name(args)
+
+/* Revert Linux kludge.  */
+#undef SYS_ify
+#ifdef __STDC__
+# define SYS_ify(syscall_name)  SYS_##syscall_name
+#else
+# define SYS_ify(syscall_name)  SYS_/**/syscall_name
+#endif
+
+/* Workaround for http://sources.redhat.com/bugzilla/show_bug.cgi?id=12301 */
+#ifdef __ASSEMBLER__
+/* We don't want the label for the error handler to be visible in the symbol
+   table when we define it here.  */
+#ifdef __PIC__
+# define SYSCALL_ERROR_LABEL 99b
+#endif
+#endif   /* ! __ASSEMBLER__ */
+
+#endif /* _KFREEBSD_MIPS_SYSDEP_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips64/bits/mcontext.h
@@ -0,0 +1,116 @@
+/* Machine-dependent processor state structure for kFreeBSD.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  mips version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ucontext.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: ucontext.h,v 1.2 2007/08/09 11:23:32 katta
+ * $FreeBSD$
+ */
+
+typedef struct	__mcontext {
+	/*
+	 * These fields must match the corresponding fields in struct 
+	 * sigcontext which follow 'sc_mask'. That way we can support
+	 * struct sigcontext and ucontext_t at the same time.
+	 */
+	int		mc_onstack;	/* sigstack state to restore */
+	long int	mc_pc;		/* pc at time of signal */
+	long int	mc_regs[32];	/* processor regs 0 to 31 */
+        long int      sr;             /* status register */
+        long int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		mc_fpused;	/* fp has been used */
+	long int	mc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	long int	mc_fpc_eir;	/* fp exception instruction reg */
+	int	__spare__[8];	/* XXX reserved */ 
+} mcontext_t;
+
+#define	SZREG		4
+
+/* offsets into mcontext_t */
+#define	UCTX_REG(x)	(8 + (x)*SZREG)
+
+#define	UCR_ZERO	UCTX_REG(0)
+#define	UCR_AT		UCTX_REG(1)
+#define	UCR_V0		UCTX_REG(2)
+#define	UCR_V1		UCTX_REG(3)
+#define	UCR_A0		UCTX_REG(4)
+#define	UCR_A1		UCTX_REG(5)
+#define	UCR_A2		UCTX_REG(6)
+#define	UCR_A3		UCTX_REG(7)
+#define	UCR_T0		UCTX_REG(8)
+#define	UCR_T1		UCTX_REG(9)
+#define	UCR_T2		UCTX_REG(10)
+#define	UCR_T3		UCTX_REG(11)
+#define	UCR_T4		UCTX_REG(12)
+#define	UCR_T5		UCTX_REG(13)
+#define	UCR_T6		UCTX_REG(14)
+#define	UCR_T7		UCTX_REG(15)
+#define	UCR_S0		UCTX_REG(16)
+#define	UCR_S1		UCTX_REG(17)
+#define	UCR_S2		UCTX_REG(18)
+#define	UCR_S3		UCTX_REG(19)
+#define	UCR_S4		UCTX_REG(20)
+#define	UCR_S5		UCTX_REG(21)
+#define	UCR_S6		UCTX_REG(22)
+#define	UCR_S7		UCTX_REG(23)
+#define	UCR_T8		UCTX_REG(24)
+#define	UCR_T9		UCTX_REG(25)
+#define	UCR_K0		UCTX_REG(26)
+#define	UCR_K1		UCTX_REG(27)
+#define	UCR_GP		UCTX_REG(28)
+#define	UCR_SP		UCTX_REG(29)
+#define	UCR_S8		UCTX_REG(30)
+#define	UCR_RA		UCTX_REG(31)
+#define UCR_SR          UCTX_REG(32)
+#define	UCR_MDLO	UCTX_REG(33)
+#define	UCR_MDHI	UCTX_REG(34)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/mips64/bits/sigcontext.h
@@ -0,0 +1,92 @@
+/* Machine-dependent signal context structure for kFreeBSD.  mips version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+/*	$OpenBSD: signal.h,v 1.2 1999/01/27 04:10:03 imp Exp $	*/
+
+/*
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ralph Campbell.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)signal.h	8.1 (Berkeley) 6/10/93
+ *	JNPR: signal.h,v 1.4 2007/01/08 04:58:37 katta
+ * $FreeBSD$
+ */
+
+/*
+ * Information pushed on stack when a signal is delivered.
+ * This is used by the kernel to restore state following
+ * execution of the signal handler.  It is also made available
+ * to the handler to allow it to restore state properly if
+ * a non-standard exit is performed.
+ */
+
+__extension__ struct sigcontext {
+	/*
+	 * The fields following 'sc_mask' must match the definition
+	 * of struct __mcontext. That way we can support
+	 * struct sigcontext and ucontext_t at the same
+	 * time.
+	 */
+	__sigset_t	sc_mask;	/* signal mask to restore */
+	int		sc_onstack;	/* sigstack state to restore */
+	long int	sc_pc;		/* pc at time of signal */
+	long int	sc_regs[32];	/* processor regs 0 to 31 */
+	long int	mullo, mulhi;	/* mullo and mulhi registers... */
+	int		sc_fpused;	/* fp has been used */
+	long int	sc_fpregs[33];	/* fp regs 0 to 31 and csr */
+	long int	sc_fpc_eir;	/* fp exception instruction reg */
+	int		xxx[8];		/* XXX reserved */ 
+};
+
+#endif /* _BITS_SIGCONTEXT_H */
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/start.S
@@ -0,0 +1,121 @@
+/* Startup code compliant to the ELF Mips ABI.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002, 2003, 2004, 2010
+	Free Software Foundation, Inc.
+   Port to kFreeBSD (kernel of FreeBSD) by Robert Millan.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sgidefs.h>
+#include <sys/asm.h>
+
+#ifndef ENTRY_POINT
+#error ENTRY_POINT needs to be defined for start.S on MIPS/ELF.
+#endif
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/Mips ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for:
+
+   v0 ($2)	Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   a0 ($4)	Contains a pointer to the arguments and environment:
+		0(a0)			argc
+		4(a0)			argv[0]
+		...
+		(4*argc)(a0)		NULL
+		(4*(argc+1))(a0)	envp[0]
+		...
+					NULL
+   ra ($31)	The return address register is set to zero so that programs
+		that search backword through stack frames recognize the last
+		stack frame.
+*/
+
+
+/* We need to call:
+   __libc_start_main (int (*main) (int, char **, char **), int argc,
+		      char **argv, void (*init) (void), void (*fini) (void),
+		      void (*rtld_fini) (void), void *stack_end)
+*/
+	
+	.text
+	.globl ENTRY_POINT
+	.type ENTRY_POINT,@function
+ENTRY_POINT:
+#ifdef __PIC__
+	SETUP_GPX($0)
+	SETUP_GPX64($25,$0)
+#else
+	PTR_LA $28, _gp		/* Setup GP correctly if we're non-PIC.  */
+	move $31, $0
+#endif
+
+	PTR_L $5, 0($4)			/* argc */
+	PTR_ADDIU $6, $4, PTRSIZE	/* argv  */
+	PTR_LA $4, main		/* main */
+	
+	/* Allocate space on the stack for seven arguments (o32 only)
+	   and make sure the stack is aligned to double words (8 bytes) 
+	   on o32 and quad words (16 bytes) on n32 and n64.  */
+	
+	and $29, -2 * SZREG
+#if _MIPS_SIM == _ABIO32
+	PTR_SUBIU $29, 32
+#endif
+	PTR_LA $7, __libc_csu_init		/* init */
+	PTR_LA $8, __libc_csu_fini
+#if _MIPS_SIM == _ABIO32
+	PTR_S $8, 16($29)		/* fini */
+	PTR_S $2, 20($29)		/* rtld_fini */
+	PTR_S $29, 24($29)		/* stack_end */
+#else
+	move $9, $2		/* rtld_fini */
+	move $10, $29		/* stack_end */
+#endif
+	jal __libc_start_main
+hlt:	b hlt			/* Crash if somehow it does return.  */
+
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/start_thread.S
@@ -0,0 +1,56 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Modification for amd64 contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+/*
+   The parameters are passed in registers:
+   rdi: flags for rfork
+   rsi: child_stack
+   rdx: func
+   rcx: arg
+*/
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+
+#define SIG_SETMASK	3
+
+/* There is a window of a few instructions, right after the rfork
+   system call, where the handling of a signal would write garbage
+   into the stack shared by the parent and the child (assuming
+   RFMEM is set in flags).  To solve this: 1. We block all signals
+   around the rfork system call and unblock them afterwards in
+   the parent and in the child (but only after changing the stack
+   pointer).  2. The child accesses only values passed in registers
+   and on its own stack.  This way, if the parent is scheduled to
+   run first, and handles a signal, it will not affect the child;
+   and if the child runs first, and handles a signal, it will use
+   the child's stack and not affect the parent.
+*/
+
+/* FIXME */
+
+	.text
+ENTRY (__start_thread)
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mips/sys/tas.h
@@ -0,0 +1,2 @@
+/* workaround for http://sources.redhat.com/bugzilla/show_bug.cgi?id=12298 */
+#include <sysdeps/unix/sysv/linux/mips/sys/tas.h>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap.c
@@ -0,0 +1,57 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+extern void *__syscall_mmap (void *__addr, size_t __len, int __prot,
+			     int __flags, int __fd, __off_t __offset) __THROW;
+libc_hidden_proto (__syscall_mmap)
+
+void *
+__mmap (void *addr, size_t len, int prot, int flags, int fd, __off_t offset)
+{
+  /* Validity checks not done by the kernel.  */
+  if (offset != 0)
+    {
+      int pagesize = __getpagesize ();
+      if ((__builtin_expect (pagesize & (pagesize - 1), 0)
+        ? offset % pagesize
+	: offset & (pagesize - 1)))
+	{
+	  __set_errno (EINVAL);
+	  return (void *) (-1);
+	}
+    }
+
+  /* for ANON mapping we must pass -1 in place of fd */
+  if (flags & MAP_ANON)
+    fd = -1;
+
+  return INLINE_SYSCALL (mmap, 6, addr, len, prot, flags, fd, offset);
+}
+
+weak_alias (__mmap, mmap)
+
+/* 'mmap64' is the same as 'mmap', because __off64_t == __off_t.  */
+strong_alias (__mmap, __mmap64)
+weak_alias (__mmap64, mmap64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/mmap64.c
@@ -0,0 +1 @@
+/* 'mmap64' is the same as 'mmap', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/msgctl.c
@@ -0,0 +1,104 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/msg.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/wordsize.h>
+#include <shlib-compat.h>
+
+#include <kernel-features.h>
+
+/* Provide operations to control over shared memory segments.  */
+
+extern int __syscall_msgctl(int msqid, int cmd, struct msqid_ds *buf);
+libc_hidden_proto (__syscall_msgctl)
+
+int
+__new_msgctl(int msqid, int cmd, struct msqid_ds *buf)
+{
+  return INLINE_SYSCALL (msgctl, 3, msqid, cmd, buf);
+}
+versioned_symbol (libc, __new_msgctl, msgctl, GLIBC_2_18);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_18)
+struct msqid_ds_old
+{
+  struct ipc_perm_old msg_perm;	/* structure describing operation permission */
+  void *__msg_first;
+  void *__msg_last;
+  msglen_t __msg_cbytes;	/* current number of bytes on queue */
+  msgqnum_t msg_qnum;		/* number of messages currently on queue */
+  msglen_t msg_qbytes;		/* max number of bytes allowed on queue */
+  __pid_t msg_lspid;		/* pid of last msgsnd() */
+  __pid_t msg_lrpid;		/* pid of last msgrcv() */
+  __time_t msg_stime;		/* time of last msgsnd command */
+  long __unused1;
+  __time_t msg_rtime;		/* time of last msgrcv command */
+  long __unused2;
+  __time_t msg_ctime;		/* time of last change */
+  long __unused3;
+  long __unused4[4];
+};
+
+int
+attribute_compat_text_section
+__old_msgctl(int msqid, int cmd, struct msqid_ds_old *buf)
+{
+    struct msqid_ds newbuf;
+    int rv;
+    
+    if (cmd == IPC_SET)
+    {
+        ipc_perm_old2new(&(buf->msg_perm), &(newbuf.msg_perm));
+        newbuf.__msg_first   = buf->__msg_first;
+        newbuf.__msg_last    = buf->__msg_first;
+        newbuf.__msg_cbytes  = buf->__msg_cbytes;
+        newbuf.msg_qnum      = buf->msg_qnum;
+        newbuf.msg_qbytes    = buf->msg_qbytes;
+        newbuf.msg_lspid     = buf->msg_lspid;
+        newbuf.msg_lrpid     = buf->msg_lrpid;
+        newbuf.msg_stime     = buf->msg_stime;
+        newbuf.msg_rtime     = buf->msg_rtime;
+        newbuf.msg_ctime     = buf->msg_ctime;
+    }
+    
+    rv = __new_msgctl (msqid, cmd, &newbuf);
+    
+    if ((rv != -1) && (cmd == IPC_STAT))
+    {
+        ipc_perm_new2old(&(newbuf.msg_perm), &(buf->msg_perm));
+        buf->__msg_first   = newbuf.__msg_first;
+        buf->__msg_last    = newbuf.__msg_first;
+        buf->__msg_cbytes  = newbuf.__msg_cbytes;
+        buf->msg_qnum      = newbuf.msg_qnum;
+        buf->msg_qbytes    = newbuf.msg_qbytes;
+        buf->msg_lspid     = newbuf.msg_lspid;
+        buf->msg_lrpid     = newbuf.msg_lrpid;
+        buf->msg_stime     = newbuf.msg_stime;
+        buf->msg_rtime     = newbuf.msg_rtime;
+        buf->msg_ctime     = newbuf.msg_ctime;   
+    }
+        
+    return rv;
+}
+compat_symbol (libc, __old_msgctl, msgctl, GLIBC_2_0);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/munmap.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sysdep.h>
+
+extern int __syscall_munmap (void *__addr, size_t __len) __THROW;
+libc_hidden_proto (__syscall_munmap)
+
+int
+__munmap (void *addr, size_t len)
+{
+    int pagesize = __getpagesize ();
+    if ((unsigned long) addr & (pagesize - 1))
+    {
+	__set_errno (EINVAL);
+	return -1;
+    }
+  return INLINE_SYSCALL (munmap, 2, addr, len);
+}
+
+weak_alias (__munmap, munmap)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/ethernet.h
@@ -0,0 +1,77 @@
+/* Copyright (C) 1997, 1999, 2001, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Based on the FreeBSD version of this file. Curiously, that file
+   lacks a copyright in the header. */
+
+#ifndef __NET_ETHERNET_H
+#define __NET_ETHERNET_H 1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <net/if_ether.h>     /* IEEE 802.3 Ethernet constants */
+
+__BEGIN_DECLS
+
+/* This is a name for the 48 bit ethernet address available on many
+   systems.  */
+struct ether_addr
+{
+  u_int8_t octet[ETH_ALEN];
+#define ether_addr_octet octet  
+} __attribute__ ((__packed__));
+
+/* 10Mb/s ethernet header */
+struct ether_header
+{
+  u_int8_t  ether_dhost[ETH_ALEN];	/* destination eth addr	*/
+  u_int8_t  ether_shost[ETH_ALEN];	/* source ether addr	*/
+  u_int16_t ether_type;		        /* packet type ID field	*/
+} __attribute__ ((__packed__));
+
+/* Ethernet protocol ID's */
+#define	ETHERTYPE_PUP		0x0200          /* Xerox PUP */
+#define	ETHERTYPE_IP		0x0800		/* IP */
+#define	ETHERTYPE_ARP		0x0806		/* Address resolution */
+#define	ETHERTYPE_REVARP	0x8035		/* Reverse ARP */
+
+#define	ETHER_ADDR_LEN	ETH_ALEN                 /* size of ethernet addr */
+#define	ETHER_TYPE_LEN	2                        /* bytes in type field */
+#define	ETHER_CRC_LEN	4                        /* bytes in CRC field */
+#define	ETHER_HDR_LEN	ETH_HLEN                 /* total octets in header */
+#define	ETHER_MIN_LEN	(ETH_ZLEN + ETHER_CRC_LEN) /* min packet length */
+#define	ETHER_MAX_LEN	(ETH_FRAME_LEN + ETHER_CRC_LEN) /* max packet length */
+
+/* make sure ethenet length is valid */
+#define	ETHER_IS_VALID_LEN(foo)	\
+	((foo) >= ETHER_MIN_LEN && (foo) <= ETHER_MAX_LEN)
+
+/*
+ * The ETHERTYPE_NTRAILER packet types starting at ETHERTYPE_TRAIL have
+ * (type-ETHERTYPE_TRAIL)*512 bytes of data followed
+ * by an ETHER type (as given above) and then the (variable-length) header.
+ */
+#define	ETHERTYPE_TRAIL		0x1000		/* Trailer packet */
+#define	ETHERTYPE_NTRAILER	16
+
+#define	ETHERMTU	ETH_DATA_LEN
+#define	ETHERMIN	(ETHER_MIN_LEN - ETHER_HDR_LEN - ETHER_CRC_LEN)
+
+__END_DECLS
+
+#endif	/* net/ethernet.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if.h
@@ -0,0 +1,438 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if.h	8.1 (Berkeley) 6/10/93
+ * $FreeBSD: src/sys/net/if.h,v 1.108 2007/06/11 20:08:11 andre Exp $
+ */
+
+#ifndef _NET_IF_H_
+#define	_NET_IF_H_
+
+#include <sys/cdefs.h>
+
+#include <features.h>
+
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+struct ifnet;
+
+/*
+ * Length of interface external name, including terminating '\0'.
+ * Note: this is the same size as a generic device's external name.
+ */
+#define		IF_NAMESIZE	16
+#define		IFNAMSIZ	IF_NAMESIZE
+#define		IF_MAXUNIT	0x7fff	/* historical value */
+
+/*
+ * Structure used to query names of interface cloners.
+ */
+
+struct if_clonereq {
+	int	ifcr_total;		/* total cloners (out) */
+	int	ifcr_count;		/* room for this many in user buffer */
+	char	*ifcr_buffer;		/* buffer for cloner names */
+};
+
+/*
+ * Structure describing information about an interface
+ * which may be of interest to management entities.
+ */
+struct if_data {
+	/* generic interface information */
+	unsigned char	ifi_type;		/* ethernet, tokenring, etc */
+	unsigned char	ifi_physical;		/* e.g., AUI, Thinnet, 10base-T, etc */
+	unsigned char	ifi_addrlen;		/* media address length */
+	unsigned char	ifi_hdrlen;		/* media header length */
+	unsigned char	ifi_link_state;		/* current link state */
+	unsigned char	ifi_vhid;		/* carp vhid */
+	unsigned char	ifi_baudrate_pf;	/* baudrate power factor */
+	unsigned char	ifi_datalen;		/* length of this data struct */
+	unsigned long	ifi_mtu;		/* maximum transmission unit */
+	unsigned long	ifi_metric;		/* routing metric (external only) */
+	unsigned long	ifi_baudrate;		/* linespeed */
+	/* volatile statistics */
+	unsigned long	ifi_ipackets;		/* packets received on interface */
+	unsigned long	ifi_ierrors;		/* input errors on interface */
+	unsigned long	ifi_opackets;		/* packets sent on interface */
+	unsigned long	ifi_oerrors;		/* output errors on interface */
+	unsigned long	ifi_collisions;		/* collisions on csma interfaces */
+	unsigned long	ifi_ibytes;		/* total number of octets received */
+	unsigned long	ifi_obytes;		/* total number of octets sent */
+	unsigned long	ifi_imcasts;		/* packets received via multicast */
+	unsigned long	ifi_omcasts;		/* packets sent via multicast */
+	unsigned long	ifi_iqdrops;		/* dropped on input, this interface */
+	unsigned long	ifi_noproto;		/* destined for unsupported protocol */
+	unsigned long	ifi_hwassist;		/* HW offload capabilities, see IFCAP */
+	time_t	ifi_epoch;		/* uptime at attach or stat reset */
+	struct	timeval ifi_lastchange;	/* time of last administrative change */
+};
+
+/*-
+ * Interface flags are of two types: network stack owned flags, and driver
+ * owned flags.  Historically, these values were stored in the same ifnet
+ * flags field, but with the advent of fine-grained locking, they have been
+ * broken out such that the network stack is responsible for synchronizing
+ * the stack-owned fields, and the device driver the device-owned fields.
+ * Both halves can perform lockless reads of the other half's field, subject
+ * to accepting the involved races.
+ *
+ * Both sets of flags come from the same number space, and should not be
+ * permitted to conflict, as they are exposed to user space via a single
+ * field.
+ *
+ * The following symbols identify read and write requirements for fields:
+ *
+ * (i) if_flags field set by device driver before attach, read-only there
+ *     after.
+ * (n) if_flags field written only by the network stack, read by either the
+ *     stack or driver.
+ * (d) if_drv_flags field written only by the device driver, read by either
+ *     the stack or driver.
+ */
+#define	IFF_UP		0x1		/* (n) interface is up */
+#define	IFF_BROADCAST	0x2		/* (i) broadcast address valid */
+#define	IFF_DEBUG	0x4		/* (n) turn on debugging */
+#define	IFF_LOOPBACK	0x8		/* (i) is a loopback net */
+#define	IFF_POINTOPOINT	0x10		/* (i) is a point-to-point link */
+#define	IFF_SMART	0x20		/* (i) interface manages own routes */
+#define	IFF_DRV_RUNNING	0x40		/* (d) resources allocated */
+#define	IFF_NOARP	0x80		/* (n) no address resolution protocol */
+#define	IFF_PROMISC	0x100		/* (n) receive all packets */
+#define	IFF_ALLMULTI	0x200		/* (n) receive all multicast packets */
+#define	IFF_DRV_OACTIVE	0x400		/* (d) tx hardware queue is full */
+#define	IFF_SIMPLEX	0x800		/* (i) can't hear own transmissions */
+#define	IFF_LINK0	0x1000		/* per link layer defined bit */
+#define	IFF_LINK1	0x2000		/* per link layer defined bit */
+#define	IFF_LINK2	0x4000		/* per link layer defined bit */
+#define	IFF_ALTPHYS	IFF_LINK2	/* use alternate physical connection */
+#define	IFF_MULTICAST	0x8000		/* (i) supports multicast */
+#define	IFF_CANTCONFIG	0x10000		/* (i) unconfigurable using ioctl(2) */
+#define	IFF_PPROMISC	0x20000		/* (n) user-requested promisc mode */
+#define	IFF_MONITOR	0x40000		/* (n) user-requested monitor mode */
+#define	IFF_STATICARP	0x80000		/* (n) static ARP */
+#define	IFF_NEEDSGIANT	0x100000	/* (i) hold Giant over if_start calls */
+#define IFF_DYING       0x200000        /* (n) interface is winding down */
+#define	IFF_RENAMING    0x400000        /* (n) interface is being renamed */
+
+/*
+ * Old names for driver flags so that user space tools can continue to use
+ * the old (portable) names.
+ */
+#ifndef _KERNEL
+#define	IFF_RUNNING	IFF_DRV_RUNNING
+#define	IFF_OACTIVE	IFF_DRV_OACTIVE
+#endif
+
+/* flags set internally only: */
+#define	IFF_CANTCHANGE \
+	(IFF_BROADCAST|IFF_POINTOPOINT|IFF_DRV_RUNNING|IFF_DRV_OACTIVE|\
+	    IFF_SIMPLEX|IFF_MULTICAST|IFF_ALLMULTI|IFF_SMART|IFF_PROMISC|\
+	    IFF_DYING|IFF_CANTCONFIG)
+
+/*
+ * Values for if_link_state.
+ */
+#define	LINK_STATE_UNKNOWN	0	/* link invalid/unknown */
+#define	LINK_STATE_DOWN		1	/* link is down */
+#define	LINK_STATE_UP		2	/* link is up */
+
+/*
+ * Some convenience macros used for setting ifi_baudrate.
+ * XXX 1000 vs. 1024? --thorpej@netbsd.org
+ */
+#define	IF_Kbps(x)	((x) * 1000)		/* kilobits/sec. */
+#define	IF_Mbps(x)	(IF_Kbps((x) * 1000))	/* megabits/sec. */
+#define	IF_Gbps(x)	(IF_Mbps((x) * 1000))	/* gigabits/sec. */
+
+/*
+ * Capabilities that interfaces can advertise.
+ *
+ * struct ifnet.if_capabilities
+ *   contains the optional features & capabilities a particular interface
+ *   supports (not only the driver but also the detected hw revision).
+ *   Capabilities are defined by IFCAP_* below.
+ * struct ifnet.if_capenable
+ *   contains the enabled (either by default or through ifconfig) optional
+ *   features & capabilities on this interface.
+ *   Capabilities are defined by IFCAP_* below.
+ * struct if_data.ifi_hwassist in mbuf CSUM_ flag form, controlled by above
+ *   contains the enabled optional feature & capabilites that can be used
+ *   individually per packet and are specified in the mbuf pkthdr.csum_flags
+ *   field.  IFCAP_* and CSUM_* do not match one to one and CSUM_* may be
+ *   more detailed or differenciated than IFCAP_*.
+ *   Hwassist features are defined CSUM_* in sys/mbuf.h
+ */
+#define	IFCAP_RXCSUM		0x00001  /* can offload checksum on RX */
+#define	IFCAP_TXCSUM		0x00002  /* can offload checksum on TX */
+#define	IFCAP_NETCONS		0x00004  /* can be a network console */
+#define	IFCAP_VLAN_MTU		0x00008	/* VLAN-compatible MTU */
+#define	IFCAP_VLAN_HWTAGGING	0x00010	/* hardware VLAN tag support */
+#define	IFCAP_JUMBO_MTU		0x00020	/* 9000 byte MTU supported */
+#define	IFCAP_POLLING		0x00040	/* driver supports polling */
+#define	IFCAP_VLAN_HWCSUM	0x00080	/* can do IFCAP_HWCSUM on VLANs */
+#define	IFCAP_TSO4		0x00100	/* can do TCP Segmentation Offload */
+#define	IFCAP_TSO6		0x00200	/* can do TCP6 Segmentation Offload */
+#define	IFCAP_LRO		0x00400	/* can do Large Receive Offload */
+#define	IFCAP_WOL_UCAST		0x00800	/* wake on any unicast frame */
+#define	IFCAP_WOL_MCAST		0x01000	/* wake on any multicast frame */
+#define	IFCAP_WOL_MAGIC		0x02000	/* wake on any Magic Packet */
+#define	IFCAP_TOE4		0x04000	/* interface can offload TCP */
+#define	IFCAP_TOE6		0x08000	/* interface can offload TCP6 */
+#define	IFCAP_VLAN_HWFILTER	0x10000 /* interface hw can filter vlan tag */
+#define IFCAP_POLLING_NOCOUNT   0x20000 /* polling ticks cannot be fragmented */
+#define	IFCAP_VLAN_HWTSO        0x40000 /* can do IFCAP_TSO on VLANs */
+#define	IFCAP_LINKSTATE         0x80000 /* the runtime link state is dynamic */
+#define	IFCAP_NETMAP		0x100000 /* netmap mode supported/enabled */
+#define	IFCAP_RXCSUM_IPV6	0x200000  /* can offload checksum on IPv6 RX */
+#define	IFCAP_TXCSUM_IPV6	0x400000  /* can offload checksum on IPv6 TX */
+
+#define	IFCAP_HWCSUM_IPV6	(IFCAP_RXCSUM_IPV6 | IFCAP_TXCSUM_IPV6)
+
+#define	IFCAP_HWCSUM		(IFCAP_RXCSUM | IFCAP_TXCSUM)
+#define	IFCAP_TSO		(IFCAP_TSO4 | IFCAP_TSO6)
+#define	IFCAP_WOL		(IFCAP_WOL_UCAST | IFCAP_WOL_MCAST | IFCAP_WOL_MAGIC)
+#define	IFCAP_TOE		(IFCAP_TOE4 | IFCAP_TOE6)
+
+#define	IFCAP_CANTCHANGE	(IFCAP_NETMAP)
+
+#define	IFQ_MAXLEN	50
+#define	IFNET_SLOWHZ	1		/* granularity is 1 second */
+
+/*
+ * Message format for use in obtaining information about interfaces
+ * from getkerninfo and the routing socket
+ */
+struct if_msghdr {
+	unsigned short	ifm_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifm_version;	/* future binary compatibility */
+	unsigned char	ifm_type;	/* message type */
+	int	ifm_addrs;	/* like rtm_addrs */
+	int	ifm_flags;	/* value of if_flags */
+	unsigned short	ifm_index;	/* index for associated ifp */
+	struct	if_data ifm_data;/* statistics and other data about if */
+};
+
+/*
+ * Message format for use in obtaining information about interface addresses
+ * from getkerninfo and the routing socket
+ */
+struct ifa_msghdr {
+	unsigned short	ifam_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifam_version;	/* future binary compatibility */
+	unsigned char	ifam_type;	/* message type */
+	int	ifam_addrs;	/* like rtm_addrs */
+	int	ifam_flags;	/* value of ifa_flags */
+	unsigned short	ifam_index;	/* index for associated ifp */
+	int	ifam_metric;	/* value of ifa_metric */
+};
+
+/*
+ * Message format for use in obtaining information about multicast addresses
+ * from the routing socket
+ */
+struct ifma_msghdr {
+	unsigned short	ifmam_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifmam_version;	/* future binary compatibility */
+	unsigned char	ifmam_type;	/* message type */
+	int	ifmam_addrs;	/* like rtm_addrs */
+	int	ifmam_flags;	/* value of ifa_flags */
+	unsigned short	ifmam_index;	/* index for associated ifp */
+};
+
+/*
+ * Message format announcing the arrival or departure of a network interface.
+ */
+struct if_announcemsghdr {
+	unsigned short	ifan_msglen;	/* to skip over non-understood messages */
+	unsigned char	ifan_version;	/* future binary compatibility */
+	unsigned char	ifan_type;	/* message type */
+	unsigned short	ifan_index;	/* index for associated ifp */
+	char	ifan_name[IFNAMSIZ]; /* if name, e.g. "en0" */
+	unsigned short	ifan_what;	/* what type of announcement */
+};
+
+#define	IFAN_ARRIVAL	0	/* interface arrival */
+#define	IFAN_DEPARTURE	1	/* interface departure */
+
+/*
+ * Buffer with length to be used in SIOCGIFDESCR/SIOCSIFDESCR requests
+ */
+struct ifreq_buffer {
+	size_t  length;
+	void    *buffer;
+};
+ 
+/*
+ * Interface request structure used for socket
+ * ioctl's.  All interface ioctl's must have parameter
+ * definitions which begin with ifr_name.  The
+ * remainder may be interface specific.
+ */
+struct	ifreq {
+	char	ifr_name[IFNAMSIZ];		/* if name, e.g. "en0" */
+	union {
+		struct	sockaddr ifru_addr;
+		struct	sockaddr ifru_dstaddr;
+		struct	sockaddr ifru_broadaddr;
+		struct	sockaddr ifru_netmask;
+		struct  ifreq_buffer ifru_buffer;
+		short	ifru_flags[2];
+		short	ifru_index;
+		int	ifru_jid;
+		int	ifru_metric;
+		int	ifru_mtu;
+		int	ifru_phys;
+		int	ifru_media;
+		char *	ifru_data;
+		int	ifru_cap[2];
+		unsigned int ifru_fib;
+	} ifr_ifru;
+#define	ifr_addr	ifr_ifru.ifru_addr	/* address */
+#define	ifr_dstaddr	ifr_ifru.ifru_dstaddr	/* other end of p-to-p link */
+#define	ifr_broadaddr	ifr_ifru.ifru_broadaddr	/* broadcast address */
+#define	ifr_netmask	ifr_ifru.ifru_netmask	/* interface net mask */
+#define	ifr_buffer      ifr_ifru.ifru_buffer    /* user supplied buffer with its length */
+#define	ifr_flags	ifr_ifru.ifru_flags[0]	/* flags (low 16 bits) */
+#define	ifr_flagshigh	ifr_ifru.ifru_flags[1]	/* flags (high 16 bits) */
+#define ifr_jid         ifr_ifru.ifru_jid       /* jail/vnet */
+#define	ifr_metric	ifr_ifru.ifru_metric	/* metric */
+#define	ifr_mtu		ifr_ifru.ifru_mtu	/* mtu */
+#define ifr_phys	ifr_ifru.ifru_phys	/* physical wire */
+#define ifr_media	ifr_ifru.ifru_media	/* physical media */
+#define	ifr_data	ifr_ifru.ifru_data	/* for use by interface */
+#define	ifr_reqcap	ifr_ifru.ifru_cap[0]	/* requested capabilities */
+#define	ifr_curcap	ifr_ifru.ifru_cap[1]	/* current capabilities */
+#define	ifr_index	ifr_ifru.ifru_index	/* interface index */
+#define	ifr_fib		ifr_ifru.ifru_fib	/* interface fib */
+};
+
+#define	_SIZEOF_ADDR_IFREQ(ifr) \
+	((ifr).ifr_addr.sa_len > sizeof(struct sockaddr) ? \
+	 (sizeof(struct ifreq) - sizeof(struct sockaddr) + \
+	  (ifr).ifr_addr.sa_len) : sizeof(struct ifreq))
+
+#include <sys/kglue/net/if.h>
+
+/*
+ * Structure used to retrieve aux status data from interfaces.
+ * Kernel suppliers to this interface should respect the formatting
+ * needed by ifconfig(8): each line starts with a TAB and ends with
+ * a newline.  The canonical example to copy and paste is in if_tun.c.
+ */
+
+#define	IFSTATMAX	800		/* 10 lines of text */
+struct ifstat {
+	char	ifs_name[IFNAMSIZ];	/* if name, e.g. "en0" */
+	char	ascii[IFSTATMAX + 1];
+};
+
+/*
+ * Structure used in SIOCGIFCONF request.
+ * Used to retrieve interface configuration
+ * for machine (useful for programs which
+ * must know all networks accessible).
+ */
+struct	ifconf {
+	int	ifc_len;		/* size of associated buffer */
+	union {
+		char    *ifcu_buf;
+		struct	ifreq *ifcu_req;
+	} ifc_ifcu;
+#define	ifc_buf	ifc_ifcu.ifcu_buf	/* buffer address */
+#define	ifc_req	ifc_ifcu.ifcu_req	/* array of structures returned */
+};
+
+#if defined (__amd64__) || defined (COMPAT_32BIT)
+struct ifconf32 {
+	int	ifc_len;		/* size of associated buffer */
+	union {
+		unsigned int	ifcu_buf;
+		unsigned int	ifcu_req;
+	} ifc_ifcu;
+};
+#endif
+
+/*
+ * interface groups
+ */
+
+#define	IFG_ALL		"all"		/* group contains all interfaces */
+/* XXX: will we implement this? */
+#define	IFG_EGRESS	"egress"	/* if(s) default route(s) point to */
+
+struct ifg_req {
+	union {
+		char			 ifgrqu_group[IFNAMSIZ];
+		char			 ifgrqu_member[IFNAMSIZ];
+	} ifgrq_ifgrqu;
+#define	ifgrq_group	ifgrq_ifgrqu.ifgrqu_group
+#define	ifgrq_member	ifgrq_ifgrqu.ifgrqu_member
+};
+
+/*
+ * Used to lookup groups for an interface
+ */
+struct ifgroupreq {
+	char	ifgr_name[IFNAMSIZ];
+	unsigned int	ifgr_len;
+	union {
+		char	ifgru_group[IFNAMSIZ];
+		struct	ifg_req *ifgru_groups;
+	} ifgr_ifgru;
+#define ifgr_group	ifgr_ifgru.ifgru_group
+#define ifgr_groups	ifgr_ifgru.ifgru_groups
+};
+
+/*
+ * Structure for SIOC[AGD]LIFADDR
+ */
+struct if_laddrreq {
+	char	iflr_name[IFNAMSIZ];
+	unsigned int	flags;
+#define	IFLR_PREFIX	0x8000  /* in: prefix given  out: kernel fills id */
+	unsigned int	prefixlen;         /* in/out */
+	struct	sockaddr_storage addr;   /* in/out */
+	struct	sockaddr_storage dstaddr; /* out */
+};
+
+struct if_nameindex {
+	unsigned int	if_index;	/* 1, 2, ... */
+	char		*if_name;	/* null terminated name: "le0", ... */
+};
+
+__BEGIN_DECLS
+void			 if_freenameindex(struct if_nameindex *);
+char			*if_indextoname(unsigned int, char *);
+struct if_nameindex	*if_nameindex(void);
+unsigned int		 if_nametoindex(const char *);
+__END_DECLS
+
+#endif /* !_NET_IF_H_ */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/net/if_ether.h
@@ -0,0 +1,104 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NET_IF_ETHER_H
+#define _NET_IF_ETHER_H	1
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence).
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+
+/*
+ *	This is an Ethernet frame header.
+ */
+
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	unsigned short	h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+#endif	/* net/if_ether.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/icmp6.h
@@ -0,0 +1,561 @@
+/* Copyright (C) 1991-1997,2000,2006,2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _NETINET_ICMP6_H
+#define _NETINET_ICMP6_H 1
+
+#include <inttypes.h>
+#include <string.h>
+#include <sys/types.h>
+#include <netinet/in.h>
+
+#define ICMP6_FILTER 18
+
+#define ICMP6_FILTER_BLOCK		1
+#define ICMP6_FILTER_PASS		2
+#define ICMP6_FILTER_BLOCKOTHERS	3
+#define ICMP6_FILTER_PASSONLY		4
+
+#define ICMPV6_PLD_MAXLEN	1232	/* IPV6_MMTU - sizeof(struct ip6_hdr)
+					   - sizeof(struct icmp6_hdr) */
+
+struct icmp6_filter
+  {
+    uint32_t icmp6_filt[8];
+  } __attribute__ ((__packed__));
+
+struct icmp6_hdr
+  {
+    uint8_t     icmp6_type;   /* type field */
+    uint8_t     icmp6_code;   /* code field */
+    uint16_t    icmp6_cksum;  /* checksum field */
+    union
+      {
+	uint32_t  icmp6_un_data32[1]; /* type-specific field */
+	uint16_t  icmp6_un_data16[2]; /* type-specific field */
+	uint8_t   icmp6_un_data8[4];  /* type-specific field */
+      } icmp6_dataun;
+  } __attribute__ ((__packed__));
+
+#define icmp6_data32    icmp6_dataun.icmp6_un_data32
+#define icmp6_data16    icmp6_dataun.icmp6_un_data16
+#define icmp6_data8     icmp6_dataun.icmp6_un_data8
+#define icmp6_pptr      icmp6_data32[0]  /* parameter prob */
+#define icmp6_mtu       icmp6_data32[0]  /* packet too big */
+#define icmp6_id        icmp6_data16[0]  /* echo request/reply */
+#define icmp6_seq       icmp6_data16[1]  /* echo request/reply */
+#define icmp6_maxdelay  icmp6_data16[0]  /* mcast group membership */
+
+#define ICMP6_DST_UNREACH             1
+#define ICMP6_PACKET_TOO_BIG          2
+#define ICMP6_TIME_EXCEEDED           3
+#define ICMP6_PARAM_PROB              4
+
+#define ICMP6_INFOMSG_MASK  0x80    /* all informational messages */
+
+#define ICMP6_NI_SUBJ_IPV6            0 /* Query Subject is an IPv6 address */
+#define ICMP6_NI_SUBJ_FQDN            1 /* Query Subject is a Domain name */
+#define ICMP6_NI_SUBJ_IPV4            2 /* Query Subject is an IPv4 address */
+
+#define ICMP6_NI_SUCCESS              0 /* node information successful reply */
+#define ICMP6_NI_REFUSED              1 /* node information request is refused */
+#define ICMP6_NI_UNKNOWN              2 /* unknown Qtype */
+
+#define ICMP6_ECHO_REQUEST          128
+#define ICMP6_ECHO_REPLY            129
+#define MLD_LISTENER_QUERY          130
+#define MLD_LISTENER_REPORT         131
+#define MLD_LISTENER_DONE           132
+#define MLD_LISTENER_REDUCTION      MLD_LISTENER_DONE
+
+/* RFC2292 decls */
+#define ICMP6_MEMBERSHIP_QUERY      130 /* group membership query */
+#define ICMP6_MEMBERSHIP_REPORT     131 /* group membership report */
+#define ICMP6_MEMBERSHIP_REDUCTION  132 /* group membership termination */
+/* the followings are for backward compatibility to old KAME apps. */
+#define MLD6_LISTENER_QUERY         MLD_LISTENER_QUERY
+#define MLD6_LISTENER_REPORT        MLD_LISTENER_REPORT
+#define MLD6_LISTENER_DONE          MLD_LISTENER_DONE
+
+
+#define ICMP6_DST_UNREACH_NOROUTE     0 /* no route to destination */
+#define ICMP6_DST_UNREACH_ADMIN       1 /* communication with destination */
+                                        /* administratively prohibited */
+#define ICMP6_DST_UNREACH_BEYONDSCOPE 2 /* beyond scope of source address */
+#define ICMP6_DST_UNREACH_ADDR        3 /* address unreachable */
+#define ICMP6_DST_UNREACH_NOPORT      4 /* bad port */
+
+#define ICMP6_TIME_EXCEED_TRANSIT     0 /* Hop Limit == 0 in transit */
+#define ICMP6_TIME_EXCEED_REASSEMBLY  1 /* Reassembly time out */
+
+#define ICMP6_PARAMPROB_HEADER        0 /* erroneous header field */
+#define ICMP6_PARAMPROB_NEXTHEADER    1 /* unrecognized Next Header */
+#define ICMP6_PARAMPROB_OPTION        2 /* unrecognized IPv6 option */
+
+#define ICMP6_FILTER_WILLPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) != 0)
+
+#define ICMP6_FILTER_WILLBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) & (1 << ((type) & 31))) == 0)
+
+#define ICMP6_FILTER_SETPASS(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) |= (1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETBLOCK(type, filterp) \
+	((((filterp)->icmp6_filt[(type) >> 5]) &= ~(1 << ((type) & 31))))
+
+#define ICMP6_FILTER_SETPASSALL(filterp) \
+	memset (filterp, 0xFF, sizeof (struct icmp6_filter));
+
+#define ICMP6_FILTER_SETBLOCKALL(filterp) \
+	memset (filterp, 0, sizeof (struct icmp6_filter));
+
+#define ND_ROUTER_SOLICIT           133
+#define ND_ROUTER_ADVERT            134
+#define ND_NEIGHBOR_SOLICIT         135
+#define ND_NEIGHBOR_ADVERT          136
+#define ND_REDIRECT                 137
+
+struct nd_router_solicit      /* router solicitation */
+  {
+    struct icmp6_hdr  nd_rs_hdr;
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_rs_type               nd_rs_hdr.icmp6_type
+#define nd_rs_code               nd_rs_hdr.icmp6_code
+#define nd_rs_cksum              nd_rs_hdr.icmp6_cksum
+#define nd_rs_reserved           nd_rs_hdr.icmp6_data32[0]
+
+struct nd_router_advert       /* router advertisement */
+  {
+    struct icmp6_hdr  nd_ra_hdr;
+    uint32_t   nd_ra_reachable;   /* reachable time */
+    uint32_t   nd_ra_retransmit;  /* retransmit timer */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_ra_type               nd_ra_hdr.icmp6_type
+#define nd_ra_code               nd_ra_hdr.icmp6_code
+#define nd_ra_cksum              nd_ra_hdr.icmp6_cksum
+#define nd_ra_curhoplimit        nd_ra_hdr.icmp6_data8[0]
+#define nd_ra_flags_reserved     nd_ra_hdr.icmp6_data8[1]
+#define ND_RA_FLAG_MANAGED       0x80
+#define ND_RA_FLAG_OTHER         0x40
+#define ND_RA_FLAG_HOME_AGENT    0x20
+#define nd_ra_router_lifetime    nd_ra_hdr.icmp6_data16[1]
+
+struct nd_neighbor_solicit    /* neighbor solicitation */
+  {
+    struct icmp6_hdr  nd_ns_hdr;
+    struct in6_addr   nd_ns_target; /* target address */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_ns_type               nd_ns_hdr.icmp6_type
+#define nd_ns_code               nd_ns_hdr.icmp6_code
+#define nd_ns_cksum              nd_ns_hdr.icmp6_cksum
+#define nd_ns_reserved           nd_ns_hdr.icmp6_data32[0]
+
+struct nd_neighbor_advert     /* neighbor advertisement */
+  {
+    struct icmp6_hdr  nd_na_hdr;
+    struct in6_addr   nd_na_target; /* target address */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));
+
+#define nd_na_type               nd_na_hdr.icmp6_type
+#define nd_na_code               nd_na_hdr.icmp6_code
+#define nd_na_cksum              nd_na_hdr.icmp6_cksum
+#define nd_na_flags_reserved     nd_na_hdr.icmp6_data32[0]
+#if     BYTE_ORDER == BIG_ENDIAN
+#define ND_NA_FLAG_ROUTER        0x80000000
+#define ND_NA_FLAG_SOLICITED     0x40000000
+#define ND_NA_FLAG_OVERRIDE      0x20000000
+#else   /* BYTE_ORDER == LITTLE_ENDIAN */
+#define ND_NA_FLAG_ROUTER        0x00000080
+#define ND_NA_FLAG_SOLICITED     0x00000040
+#define ND_NA_FLAG_OVERRIDE      0x00000020
+#endif
+
+struct nd_redirect            /* redirect */
+  {
+    struct icmp6_hdr  nd_rd_hdr;
+    struct in6_addr   nd_rd_target; /* target address */
+    struct in6_addr   nd_rd_dst;    /* destination address */
+    /* could be followed by options */
+  } __attribute__ ((__packed__));;
+
+#define nd_rd_type               nd_rd_hdr.icmp6_type
+#define nd_rd_code               nd_rd_hdr.icmp6_code
+#define nd_rd_cksum              nd_rd_hdr.icmp6_cksum
+#define nd_rd_reserved           nd_rd_hdr.icmp6_data32[0]
+
+struct nd_opt_hdr             /* Neighbor discovery option header */
+  {
+    uint8_t  nd_opt_type;
+    uint8_t  nd_opt_len;        /* in units of 8 octets */
+    /* followed by option specific data */
+  } __attribute__ ((__packed__));
+
+#define ND_OPT_SOURCE_LINKADDR		1
+#define ND_OPT_TARGET_LINKADDR		2
+#define ND_OPT_PREFIX_INFORMATION	3
+#define ND_OPT_REDIRECTED_HEADER	4
+#define ND_OPT_MTU			5
+#define ND_OPT_RTR_ADV_INTERVAL		7
+#define ND_OPT_HOME_AGENT_INFO		8
+
+struct nd_opt_prefix_info     /* prefix information */
+  {
+    uint8_t   nd_opt_pi_type;
+    uint8_t   nd_opt_pi_len;
+    uint8_t   nd_opt_pi_prefix_len;
+    uint8_t   nd_opt_pi_flags_reserved;
+    uint32_t  nd_opt_pi_valid_time;
+    uint32_t  nd_opt_pi_preferred_time;
+    uint32_t  nd_opt_pi_reserved2;
+    struct in6_addr  nd_opt_pi_prefix;
+  } __attribute__ ((__packed__));
+
+#define ND_OPT_PI_FLAG_ONLINK	0x80
+#define ND_OPT_PI_FLAG_AUTO	0x40
+#define ND_OPT_PI_FLAG_RADDR	0x20
+
+struct nd_opt_rd_hdr          /* redirected header */
+  {
+    uint8_t   nd_opt_rh_type;
+    uint8_t   nd_opt_rh_len;
+    uint16_t  nd_opt_rh_reserved1;
+    uint32_t  nd_opt_rh_reserved2;
+    /* followed by IP header and data */
+  } __attribute__ ((__packed__));
+
+struct nd_opt_mtu             /* MTU option */
+  {
+    uint8_t   nd_opt_mtu_type;
+    uint8_t   nd_opt_mtu_len;
+    uint16_t  nd_opt_mtu_reserved;
+    uint32_t  nd_opt_mtu_mtu;
+  } __attribute__ ((__packed__));
+
+struct mld_hdr
+  {
+    struct icmp6_hdr    mld_icmp6_hdr;
+    struct in6_addr     mld_addr; /* multicast address */
+  } __attribute__ ((__packed__));
+
+#define mld_type        mld_icmp6_hdr.icmp6_type
+#define mld_code        mld_icmp6_hdr.icmp6_code
+#define mld_cksum       mld_icmp6_hdr.icmp6_cksum
+#define mld_maxdelay    mld_icmp6_hdr.icmp6_data16[0]
+#define mld_reserved    mld_icmp6_hdr.icmp6_data16[1]
+
+/* definitions to provide backward compatibility to old KAME applications */
+#define mld6_hdr        mld_hdr
+#define mld6_type       mld_type
+#define mld6_code       mld_code
+#define mld6_cksum      mld_cksum
+#define mld6_maxdelay   mld_maxdelay
+#define mld6_reserved   mld_reserved
+#define mld6_addr       mld_addr
+
+#define ICMP6_ROUTER_RENUMBERING    138
+
+#define ICMP6_ROUTER_RENUMBERING_COMMAND  0 /* rr command */
+#define ICMP6_ROUTER_RENUMBERING_RESULT   1 /* rr result */
+#define ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET   255 /* rr seq num reset */
+
+struct icmp6_router_renum    /* router renumbering header */
+  {
+    struct icmp6_hdr    rr_hdr;
+    uint8_t             rr_segnum;
+    uint8_t             rr_flags;
+    uint16_t            rr_maxdelay;
+    uint32_t            rr_reserved;
+  } __attribute__ ((__packed__));
+
+#define rr_type		rr_hdr.icmp6_type
+#define rr_code         rr_hdr.icmp6_code
+#define rr_cksum        rr_hdr.icmp6_cksum
+#define rr_seqnum       rr_hdr.icmp6_data32[0]
+
+/* Router renumbering flags */
+#define ICMP6_RR_FLAGS_TEST             0x80
+#define ICMP6_RR_FLAGS_REQRESULT        0x40
+#define ICMP6_RR_FLAGS_FORCEAPPLY       0x20
+#define ICMP6_RR_FLAGS_SPECSITE         0x10
+#define ICMP6_RR_FLAGS_PREVDONE         0x08
+
+#define ICMP6_WRUREQUEST                139     /* who are you request */
+#define ICMP6_WRUREPLY                  140     /* who are you reply */
+#define ICMP6_FQDN_QUERY                139     /* FQDN query */
+#define ICMP6_FQDN_REPLY                140     /* FQDN reply */
+#define ICMP6_NI_QUERY                  139     /* node information request */
+#define ICMP6_NI_REPLY                  140     /* node information reply */
+#define MLDV2_LISTENER_REPORT		143	/* RFC3810 listener report */
+
+/* The definitions below are experimental. TBA */
+#define MLD_MTRACE_RESP			200	/* mtrace resp (to sender) */
+#define MLD_MTRACE			201	/* mtrace messages */
+
+#define ICMP6_DST_UNREACH_NOROUTE	0	/* no route to destination */
+#define ICMP6_DST_UNREACH_ADMIN	 	1	/* administratively prohibited */
+#define ICMP6_DST_UNREACH_NOTNEIGHBOR	2	/* not a neighbor(obsolete) */
+#define ICMP6_DST_UNREACH_BEYONDSCOPE	2	/* beyond scope of source address */
+#define ICMP6_DST_UNREACH_ADDR		3	/* address unreachable */
+#define ICMP6_DST_UNREACH_NOPORT	4	/* port unreachable */
+
+#define ICMP6_TIME_EXCEED_TRANSIT 	0	/* ttl==0 in transit */
+#define ICMP6_TIME_EXCEED_REASSEMBLY	1	/* ttl==0 in reass */
+
+#define ICMP6_PARAMPROB_HEADER 	 	0	/* erroneous header field */
+#define ICMP6_PARAMPROB_NEXTHEADER	1	/* unrecognized next header */
+#define ICMP6_PARAMPROB_OPTION		2	/* unrecognized option */
+
+#define ICMP6_INFOMSG_MASK		0x80	/* all informational messages */
+
+#define ICMP6_NI_SUBJ_IPV6	0	/* Query Subject is an IPv6 address */
+#define ICMP6_NI_SUBJ_FQDN	1	/* Query Subject is a Domain name */
+#define ICMP6_NI_SUBJ_IPV4	2	/* Query Subject is an IPv4 address */
+
+#define ICMP6_NI_SUCCESS	0	/* node information successful reply */
+#define ICMP6_NI_REFUSED	1	/* node information request is refused */
+#define ICMP6_NI_UNKNOWN	2	/* unknown Qtype */
+
+#define ICMP6_ROUTER_RENUMBERING_COMMAND  0	/* rr command */
+#define ICMP6_ROUTER_RENUMBERING_RESULT   1	/* rr result */
+#define ICMP6_ROUTER_RENUMBERING_SEQNUM_RESET   255	/* rr seq num reset */
+
+#define ND_REDIRECT_ONLINK	0	/* redirect to an on-link node */
+#define ND_REDIRECT_ROUTER	1	/* redirect to a better router */
+
+struct rr_pco_match    /* match prefix part */
+  {
+    uint8_t             rpm_code;
+    uint8_t             rpm_len;
+    uint8_t             rpm_ordinal;
+    uint8_t             rpm_matchlen;
+    uint8_t             rpm_minlen;
+    uint8_t             rpm_maxlen;
+    uint16_t            rpm_reserved;
+    struct in6_addr     rpm_prefix;
+  } __attribute__ ((__packed__));
+
+/* PCO code values */
+#define RPM_PCO_ADD             1
+#define RPM_PCO_CHANGE          2
+#define RPM_PCO_SETGLOBAL       3
+#define RPM_PCO_MAX             4
+
+struct rr_pco_use      /* use prefix part */
+  {
+    uint8_t             rpu_uselen;
+    uint8_t             rpu_keeplen;
+    uint8_t             rpu_ramask;
+    uint8_t             rpu_raflags;
+    uint32_t            rpu_vltime;
+    uint32_t            rpu_pltime;
+    uint32_t            rpu_flags;
+    struct in6_addr     rpu_prefix;
+  } __attribute__ ((__packed__));
+
+#define ICMP6_RR_PCOUSE_RAFLAGS_ONLINK  0x80
+#define ICMP6_RR_PCOUSE_RAFLAGS_AUTO    0x40
+
+#if BYTE_ORDER == BIG_ENDIAN
+# define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80000000
+# define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40000000
+#elif BYTE_ORDER == LITTLE_ENDIAN
+# define ICMP6_RR_PCOUSE_FLAGS_DECRVLTIME 0x80
+# define ICMP6_RR_PCOUSE_FLAGS_DECRPLTIME 0x40
+#endif
+
+struct rr_result       /* router renumbering result message */
+  {
+    uint16_t            rrr_flags;
+    uint8_t             rrr_ordinal;
+    uint8_t             rrr_matchedlen;
+    uint32_t            rrr_ifid;
+    struct in6_addr     rrr_prefix;
+  } __attribute__ ((__packed__));
+
+#if BYTE_ORDER == BIG_ENDIAN
+# define ICMP6_RR_RESULT_FLAGS_OOB       0x0002
+# define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0001
+#elif BYTE_ORDER == LITTLE_ENDIAN
+# define ICMP6_RR_RESULT_FLAGS_OOB       0x0200
+# define ICMP6_RR_RESULT_FLAGS_FORBIDDEN 0x0100
+#endif
+
+/* Mobile IPv6 extension: Advertisement Interval.  */
+struct nd_opt_adv_interval
+  {
+    uint8_t   nd_opt_adv_interval_type;
+    uint8_t   nd_opt_adv_interval_len;
+    uint16_t  nd_opt_adv_interval_reserved;
+    uint32_t  nd_opt_adv_interval_ival;
+  };
+
+/* Mobile IPv6 extension: Home Agent Info.  */
+struct nd_opt_home_agent_info
+  {
+    uint8_t   nd_opt_home_agent_info_type;
+    uint8_t   nd_opt_home_agent_info_len;
+    uint16_t  nd_opt_home_agent_info_reserved;
+    uint16_t  nd_opt_home_agent_info_preference;
+    uint16_t  nd_opt_home_agent_info_lifetime;
+  };
+
+/*-
+ * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the project nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+/*
+ * IP6 route structure
+ */
+
+struct route_in6 {
+        struct  rtentry *ro_rt;
+        struct  llentry *ro_lle;
+        struct  sockaddr_in6 ro_dst;
+};
+
+/*
+ * Variables related to this implementation
+ * of the internet control message protocol version 6.
+ */
+struct icmp6errstat {
+	u_quad_t icp6errs_dst_unreach_noroute;
+	u_quad_t icp6errs_dst_unreach_admin;
+	u_quad_t icp6errs_dst_unreach_beyondscope;
+	u_quad_t icp6errs_dst_unreach_addr;
+	u_quad_t icp6errs_dst_unreach_noport;
+	u_quad_t icp6errs_packet_too_big;
+	u_quad_t icp6errs_time_exceed_transit;
+	u_quad_t icp6errs_time_exceed_reassembly;
+	u_quad_t icp6errs_paramprob_header;
+	u_quad_t icp6errs_paramprob_nextheader;
+	u_quad_t icp6errs_paramprob_option;
+	u_quad_t icp6errs_redirect; /* we regard redirect as an error here */
+	u_quad_t icp6errs_unknown;
+};
+
+struct icmp6stat {
+/* statistics related to icmp6 packets generated */
+	u_quad_t icp6s_error;		/* # of calls to icmp6_error */
+	u_quad_t icp6s_canterror;	/* no error 'cuz old was icmp */
+	u_quad_t icp6s_toofreq;		/* no error 'cuz rate limitation */
+	u_quad_t icp6s_outhist[256];
+/* statistics related to input message processed */
+	u_quad_t icp6s_badcode;		/* icmp6_code out of range */
+	u_quad_t icp6s_tooshort;	/* packet < sizeof(struct icmp6_hdr) */
+	u_quad_t icp6s_checksum;	/* bad checksum */
+	u_quad_t icp6s_badlen;		/* calculated bound mismatch */
+	/*
+	 * number of responses: this member is inherited from netinet code, but
+	 * for netinet6 code, it is already available in icp6s_outhist[].
+	 */
+	u_quad_t icp6s_reflect;
+	u_quad_t icp6s_inhist[256];	
+	u_quad_t icp6s_nd_toomanyopt;	/* too many ND options */
+	struct icmp6errstat icp6s_outerrhist;
+#define icp6s_odst_unreach_noroute \
+	icp6s_outerrhist.icp6errs_dst_unreach_noroute
+#define icp6s_odst_unreach_admin icp6s_outerrhist.icp6errs_dst_unreach_admin
+#define icp6s_odst_unreach_beyondscope \
+	icp6s_outerrhist.icp6errs_dst_unreach_beyondscope
+#define icp6s_odst_unreach_addr icp6s_outerrhist.icp6errs_dst_unreach_addr
+#define icp6s_odst_unreach_noport icp6s_outerrhist.icp6errs_dst_unreach_noport
+#define icp6s_opacket_too_big icp6s_outerrhist.icp6errs_packet_too_big
+#define icp6s_otime_exceed_transit \
+	icp6s_outerrhist.icp6errs_time_exceed_transit
+#define icp6s_otime_exceed_reassembly \
+	icp6s_outerrhist.icp6errs_time_exceed_reassembly
+#define icp6s_oparamprob_header icp6s_outerrhist.icp6errs_paramprob_header
+#define icp6s_oparamprob_nextheader \
+	icp6s_outerrhist.icp6errs_paramprob_nextheader
+#define icp6s_oparamprob_option icp6s_outerrhist.icp6errs_paramprob_option
+#define icp6s_oredirect icp6s_outerrhist.icp6errs_redirect
+#define icp6s_ounknown icp6s_outerrhist.icp6errs_unknown
+	u_quad_t icp6s_pmtuchg;		/* path MTU changes */
+	u_quad_t icp6s_nd_badopt;	/* bad ND options */
+	u_quad_t icp6s_badns;		/* bad neighbor solicitation */
+	u_quad_t icp6s_badna;		/* bad neighbor advertisement */
+	u_quad_t icp6s_badrs;		/* bad router advertisement */
+	u_quad_t icp6s_badra;		/* bad router advertisement */
+	u_quad_t icp6s_badredirect;	/* bad redirect message */
+};
+
+#endif /* netinet/icmpv6.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/if_ether.h
@@ -0,0 +1,139 @@
+/* Copyright (C) 1996, 1997, 1999, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IF_ETHER_H
+
+#define __NETINET_IF_ETHER_H	1
+#include <features.h>
+#include <sys/types.h>
+
+#include <sys/kglue/sys/types.h>
+#include <net/if_ether.h>
+
+#ifdef __USE_MISC
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)if_ether.h	8.3 (Berkeley) 5/2/95
+ *	$FreeBSD$
+ */
+
+#include <net/ethernet.h>
+#include <net/if_arp.h>
+#include <netinet/in.h>
+
+__BEGIN_DECLS
+/*
+ * Ethernet Address Resolution Protocol.
+ *
+ * See RFC 826 for protocol description.  Structure below is adapted
+ * to resolving internet addresses.  Field names used correspond to
+ * RFC 826.
+ */
+struct	ether_arp {
+	struct	arphdr ea_hdr;		/* fixed-size header */
+	u_int8_t arp_sha[ETH_ALEN];	/* sender hardware address */
+	u_int8_t arp_spa[4];		/* sender protocol address */
+	u_int8_t arp_tha[ETH_ALEN];	/* target hardware address */
+	u_int8_t arp_tpa[4];		/* target protocol address */
+};
+#define	arp_hrd	ea_hdr.ar_hrd
+#define	arp_pro	ea_hdr.ar_pro
+#define	arp_hln	ea_hdr.ar_hln
+#define	arp_pln	ea_hdr.ar_pln
+#define	arp_op	ea_hdr.ar_op
+
+struct sockaddr_inarp {
+	__SOCKADDR_COMMON (sin_);
+	in_port_t sin_port;                 /* Port number.  */
+	struct in_addr sin_addr;            /* Internet address.  */
+	struct in_addr sin_srcaddr;
+	unsigned short sin_tos;
+	unsigned short sin_other;
+#define SIN_PROXY 1
+};
+
+/*
+ * IP and ethernet specific routing flags
+ */
+#define	RTF_USETRAILERS	RTF_PROTO1	/* use trailers */
+#define RTF_ANNOUNCE	RTF_PROTO2	/* announce new arp entry */
+
+/*
+ * Macro to map an IP multicast address to an Ethernet multicast address.
+ * The high-order 25 bits of the Ethernet address are statically assigned,
+ * and the low-order 23 bits are taken from the low end of the IP address.
+ */
+#define ETHER_MAP_IP_MULTICAST(ipaddr, enaddr) \
+	/* struct in_addr *ipaddr; */ \
+	/* u_char enaddr[ETH_ALEN];	   */ \
+{ \
+	(enaddr)[0] = 0x01; \
+	(enaddr)[1] = 0x00; \
+	(enaddr)[2] = 0x5e; \
+	(enaddr)[3] = ((u_int8_t *)ipaddr)[1] & 0x7f; \
+	(enaddr)[4] = ((u_int8_t *)ipaddr)[2]; \
+	(enaddr)[5] = ((u_int8_t *)ipaddr)[3]; \
+}
+
+/*
+ * Macro to map an IP6 multicast address to an Ethernet multicast address.
+ * The high-order 16 bits of the Ethernet address are statically assigned,
+ * and the low-order 32 bits are taken from the low end of the IP6 address.
+ */
+#define ETHER_MAP_IPV6_MULTICAST(ip6addr, enaddr)			\
+/* struct	in6_addr *ip6addr; */					\
+/* u_char	enaddr[ETH_ALEN]; */				\
+{                                                                       \
+	(enaddr)[0] = 0x33;						\
+	(enaddr)[1] = 0x33;						\
+	(enaddr)[2] = ((u_int8_t *)ip6addr)[12];				\
+	(enaddr)[3] = ((u_int8_t *)ip6addr)[13];				\
+	(enaddr)[4] = ((u_int8_t *)ip6addr)[14];				\
+	(enaddr)[5] = ((u_int8_t *)ip6addr)[15];				\
+}
+
+__END_DECLS
+#endif /* __USE_MISC */
+
+#endif /* netinet/if_ether.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/ip_icmp.h
@@ -0,0 +1,296 @@
+/* Copyright (C) 1991-1993, 1995-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __NETINET_IP_ICMP_H
+#define __NETINET_IP_ICMP_H    1
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+__BEGIN_DECLS
+
+struct icmphdr
+{
+  u_int8_t type;		/* message type */
+  u_int8_t code;		/* type sub-code */
+  u_int16_t checksum;
+  union
+  {
+    struct
+    {
+      u_int16_t	id;
+      u_int16_t	sequence;
+    } echo;			/* echo datagram */
+    u_int32_t	gateway;	/* gateway address */
+    struct
+    {
+      u_int16_t	__unused;
+      u_int16_t	mtu;
+    } frag;			/* path mtu discovery */
+  } un;
+};
+
+#define ICMP_ECHOREPLY		0	/* Echo Reply			*/
+#define ICMP_DEST_UNREACH	3	/* Destination Unreachable	*/
+#define ICMP_SOURCE_QUENCH	4	/* Source Quench		*/
+#define ICMP_REDIRECT		5	/* Redirect (change route)	*/
+#define ICMP_ECHO		8	/* Echo Request			*/
+#define ICMP_TIME_EXCEEDED	11	/* Time Exceeded		*/
+#define ICMP_PARAMETERPROB	12	/* Parameter Problem		*/
+#define ICMP_TIMESTAMP		13	/* Timestamp Request		*/
+#define ICMP_TIMESTAMPREPLY	14	/* Timestamp Reply		*/
+#define ICMP_INFO_REQUEST	15	/* Information Request		*/
+#define ICMP_INFO_REPLY		16	/* Information Reply		*/
+#define ICMP_ADDRESS		17	/* Address Mask Request		*/
+#define ICMP_ADDRESSREPLY	18	/* Address Mask Reply		*/
+#define NR_ICMP_TYPES		18
+
+
+/* Codes for UNREACH. */
+#define ICMP_NET_UNREACH	0	/* Network Unreachable		*/
+#define ICMP_HOST_UNREACH	1	/* Host Unreachable		*/
+#define ICMP_PROT_UNREACH	2	/* Protocol Unreachable		*/
+#define ICMP_PORT_UNREACH	3	/* Port Unreachable		*/
+#define ICMP_FRAG_NEEDED	4	/* Fragmentation Needed/DF set	*/
+#define ICMP_SR_FAILED		5	/* Source Route failed		*/
+#define ICMP_NET_UNKNOWN	6
+#define ICMP_HOST_UNKNOWN	7
+#define ICMP_HOST_ISOLATED	8
+#define ICMP_NET_ANO		9
+#define ICMP_HOST_ANO		10
+#define ICMP_NET_UNR_TOS	11
+#define ICMP_HOST_UNR_TOS	12
+#define ICMP_PKT_FILTERED	13	/* Packet filtered */
+#define ICMP_PREC_VIOLATION	14	/* Precedence violation */
+#define ICMP_PREC_CUTOFF	15	/* Precedence cut off */
+#define NR_ICMP_UNREACH		15	/* instead of hardcoding immediate value */
+
+/* Codes for REDIRECT. */
+#define ICMP_REDIR_NET		0	/* Redirect Net			*/
+#define ICMP_REDIR_HOST		1	/* Redirect Host		*/
+#define ICMP_REDIR_NETTOS	2	/* Redirect Net for TOS		*/
+#define ICMP_REDIR_HOSTTOS	3	/* Redirect Host for TOS	*/
+
+/* Codes for TIME_EXCEEDED. */
+#define ICMP_EXC_TTL		0	/* TTL count exceeded		*/
+#define ICMP_EXC_FRAGTIME	1	/* Fragment Reass time exceeded	*/
+
+
+#ifdef __USE_MISC
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ip_icmp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#include <netinet/in.h>
+#include <netinet/ip.h>
+
+/*
+ * Internal of an ICMP Router Advertisement
+ */
+struct icmp_ra_addr
+{
+  u_int32_t ira_addr;
+  u_int32_t ira_preference;
+};
+
+struct icmp
+{
+  u_int8_t  icmp_type;	/* type of message, see below */
+  u_int8_t  icmp_code;	/* type sub code */
+  u_int16_t icmp_cksum;	/* ones complement checksum of struct */
+  union
+  {
+    u_char ih_pptr;		/* ICMP_PARAMPROB */
+    struct in_addr ih_gwaddr;	/* gateway address */
+    struct ih_idseq		/* echo datagram */
+    {
+      u_int16_t icd_id;
+      u_int16_t icd_seq;
+    } ih_idseq;
+    u_int32_t ih_void;
+
+    /* ICMP_UNREACH_NEEDFRAG -- Path MTU Discovery (RFC1191) */
+    struct ih_pmtu
+    {
+      u_int16_t ipm_void;
+      u_int16_t ipm_nextmtu;
+    } ih_pmtu;
+
+    struct ih_rtradv
+    {
+      u_int8_t irt_num_addrs;
+      u_int8_t irt_wpa;
+      u_int16_t irt_lifetime;
+    } ih_rtradv;
+  } icmp_hun;
+#define	icmp_pptr	icmp_hun.ih_pptr
+#define	icmp_gwaddr	icmp_hun.ih_gwaddr
+#define	icmp_id		icmp_hun.ih_idseq.icd_id
+#define	icmp_seq	icmp_hun.ih_idseq.icd_seq
+#define	icmp_void	icmp_hun.ih_void
+#define	icmp_pmvoid	icmp_hun.ih_pmtu.ipm_void
+#define	icmp_nextmtu	icmp_hun.ih_pmtu.ipm_nextmtu
+#define	icmp_num_addrs	icmp_hun.ih_rtradv.irt_num_addrs
+#define	icmp_wpa	icmp_hun.ih_rtradv.irt_wpa
+#define	icmp_lifetime	icmp_hun.ih_rtradv.irt_lifetime
+  union
+  {
+    struct
+    {
+      u_int32_t its_otime;
+      u_int32_t its_rtime;
+      u_int32_t its_ttime;
+    } id_ts;
+    struct
+    {
+      struct ip idi_ip;
+      /* options and then 64 bits of data */
+    } id_ip;
+    struct icmp_ra_addr id_radv;
+    u_int32_t   id_mask;
+    u_int8_t    id_data[1];
+  } icmp_dun;
+#define	icmp_otime	icmp_dun.id_ts.its_otime
+#define	icmp_rtime	icmp_dun.id_ts.its_rtime
+#define	icmp_ttime	icmp_dun.id_ts.its_ttime
+#define	icmp_ip		icmp_dun.id_ip.idi_ip
+#define	icmp_radv	icmp_dun.id_radv
+#define	icmp_mask	icmp_dun.id_mask
+#define	icmp_data	icmp_dun.id_data
+};
+
+/*
+ * Lower bounds on packet lengths for various types.
+ * For the error advice packets must first insure that the
+ * packet is large enough to contain the returned ip header.
+ * Only then can we do the check to see if 64 bits of packet
+ * data have been returned, since we need to check the returned
+ * ip header length.
+ */
+#define	ICMP_MINLEN	8				/* abs minimum */
+#define	ICMP_TSLEN	(8 + 3 * sizeof (n_time))	/* timestamp */
+#define	ICMP_MASKLEN	12				/* address mask */
+#define	ICMP_ADVLENMIN	(8 + sizeof (struct ip) + 8)	/* min */
+#ifndef _IP_VHL
+#define	ICMP_ADVLEN(p)	(8 + ((p)->icmp_ip.ip_hl << 2) + 8)
+	/* N.B.: must separately check that ip_hl >= 5 */
+#else
+#define	ICMP_ADVLEN(p)	(8 + (IP_VHL_HL((p)->icmp_ip.ip_vhl) << 2) + 8)
+	/* N.B.: must separately check that header length >= 5 */
+#endif
+
+/*
+ * Definition of type and code field values.
+ */
+#define	ICMP_ECHOREPLY		0		/* echo reply */
+#define	ICMP_UNREACH		3		/* dest unreachable, codes: */
+#define		ICMP_UNREACH_NET	0		/* bad net */
+#define		ICMP_UNREACH_HOST	1		/* bad host */
+#define		ICMP_UNREACH_PROTOCOL	2		/* bad protocol */
+#define		ICMP_UNREACH_PORT	3		/* bad port */
+#define		ICMP_UNREACH_NEEDFRAG	4		/* IP_DF caused drop */
+#define		ICMP_UNREACH_SRCFAIL	5		/* src route failed */
+#define		ICMP_UNREACH_NET_UNKNOWN 6		/* unknown net */
+#define		ICMP_UNREACH_HOST_UNKNOWN 7		/* unknown host */
+#define		ICMP_UNREACH_ISOLATED	8		/* src host isolated */
+#define		ICMP_UNREACH_NET_PROHIB	9		/* prohibited access */
+#define		ICMP_UNREACH_HOST_PROHIB 10		/* ditto */
+#define		ICMP_UNREACH_TOSNET	11		/* bad tos for net */
+#define		ICMP_UNREACH_TOSHOST	12		/* bad tos for host */
+#define		ICMP_UNREACH_FILTER_PROHIB 13		/* admin prohib */
+#define		ICMP_UNREACH_HOST_PRECEDENCE 14		/* host prec vio. */
+#define		ICMP_UNREACH_PRECEDENCE_CUTOFF 15	/* prec cutoff */
+#define	ICMP_SOURCEQUENCH	4		/* packet lost, slow down */
+#define	ICMP_REDIRECT		5		/* shorter route, codes: */
+#define		ICMP_REDIRECT_NET	0		/* for network */
+#define		ICMP_REDIRECT_HOST	1		/* for host */
+#define		ICMP_REDIRECT_TOSNET	2		/* for tos and net */
+#define		ICMP_REDIRECT_TOSHOST	3		/* for tos and host */
+#define	ICMP_ALTHOSTADDR	6		/* alternate host address */
+#define	ICMP_ECHO		8		/* echo service */
+#define	ICMP_ROUTERADVERT	9		/* router advertisement */
+#define		ICMP_ROUTERADVERT_NORMAL		0	/* normal advertisement */
+#define		ICMP_ROUTERADVERT_NOROUTE_COMMON	16	/* selective routing */
+#define	ICMP_ROUTERSOLICIT	10		/* router solicitation */
+#define	ICMP_TIMXCEED		11		/* time exceeded, code: */
+#define		ICMP_TIMXCEED_INTRANS	0		/* ttl==0 in transit */
+#define		ICMP_TIMXCEED_REASS	1		/* ttl==0 in reass */
+#define	ICMP_PARAMPROB		12		/* ip header bad */
+#define		ICMP_PARAMPROB_ERRATPTR 0		/* error at param ptr */
+#define		ICMP_PARAMPROB_OPTABSENT 1		/* req. opt. absent */
+#define		ICMP_PARAMPROB_LENGTH 2			/* bad length */
+#define	ICMP_TSTAMP		13		/* timestamp request */
+#define	ICMP_TSTAMPREPLY	14		/* timestamp reply */
+#define	ICMP_IREQ		15		/* information request */
+#define	ICMP_IREQREPLY		16		/* information reply */
+#define	ICMP_MASKREQ		17		/* address mask request */
+#define	ICMP_MASKREPLY		18		/* address mask reply */
+#define	ICMP_TRACEROUTE		30		/* traceroute */
+#define	ICMP_DATACONVERR	31		/* data conversion error */
+#define	ICMP_MOBILE_REDIRECT	32		/* mobile host redirect */
+#define	ICMP_IPV6_WHEREAREYOU	33		/* IPv6 where-are-you */
+#define	ICMP_IPV6_IAMHERE	34		/* IPv6 i-am-here */
+#define	ICMP_MOBILE_REGREQUEST	35		/* mobile registration req */
+#define	ICMP_MOBILE_REGREPLY	36		/* mobile registration reply */
+#define	ICMP_SKIP		39		/* SKIP */
+#define	ICMP_PHOTURIS		40		/* Photuris */
+#define		ICMP_PHOTURIS_UNKNOWN_INDEX	1	/* unknown sec index */
+#define		ICMP_PHOTURIS_AUTH_FAILED	2	/* auth failed */
+#define		ICMP_PHOTURIS_DECRYPT_FAILED	3	/* decrypt failed */
+
+#define	ICMP_MAXTYPE		40
+
+#define	ICMP_INFOTYPE(type) \
+	((type) == ICMP_ECHOREPLY || (type) == ICMP_ECHO || \
+	(type) == ICMP_ROUTERADVERT || (type) == ICMP_ROUTERSOLICIT || \
+	(type) == ICMP_TSTAMP || (type) == ICMP_TSTAMPREPLY || \
+	(type) == ICMP_IREQ || (type) == ICMP_IREQREPLY || \
+	(type) == ICMP_MASKREQ || (type) == ICMP_MASKREPLY)
+
+#endif /* __USE_MISC */
+
+__END_DECLS
+
+#endif /* netinet/ip_icmp.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/netinet/tcp.h
@@ -0,0 +1,269 @@
+/* netinet/tcp.h
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)tcp.h	8.1 (Berkeley) 6/10/93
+ */
+
+#ifndef _NETINET_TCP_H
+#define _NETINET_TCP_H	1
+
+#include <features.h>
+#include <sys/queue.h>
+
+/*
+ * User-settable options (used with setsockopt).
+ */
+#define	TCP_NODELAY	 1	/* Don't delay send to coalesce packets  */
+#define	TCP_MAXSEG	 2	/* Set maximum segment size  */
+#define TCP_NOPUSH	 4	/* Don't push last block of write  */
+#define TCP_NOOPT	 8	/* Don't use TCP options  */
+#define TCP_MD5SIG	16	/* use MD5 digests (RFC2385) */
+#define TCP_INFO	32	/* retrieve tcp_info structure */
+#define TCP_CONGESTION  64	/* get/set congestion control algorithm */
+
+#ifdef __USE_MISC
+# include <sys/types.h>
+
+typedef	u_int32_t tcp_seq;
+typedef	u_int32_t tcp_cc;	/* connection count, per RFC 1644 */
+
+/* Miscellaneous constants */
+#define MAX_SACK_BLKS   6       /* Max # SACK blocks stored at receiver side */   
+#define TCP_MAX_SACK    4       /* MAX # SACKs sent in any segment */
+
+/*
+ * TCP header.
+ * Per RFC 793, September, 1981.
+ */
+struct tcphdr
+  {
+    __extension__ union
+    {
+      struct
+      {
+    u_int16_t th_sport;		/* source port */
+    u_int16_t th_dport;		/* destination port */
+    tcp_seq th_seq;		/* sequence number */
+    tcp_seq th_ack;		/* acknowledgement number */
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+    u_int8_t th_x2:4;		/* (unused) */
+    u_int8_t th_off:4;		/* data offset */
+#  endif
+#  if __BYTE_ORDER == __BIG_ENDIAN
+    u_int8_t th_off:4;		/* data offset */
+    u_int8_t th_x2:4;		/* (unused) */
+#  endif
+    u_int8_t th_flags;
+#  define TH_FIN	0x01
+#  define TH_SYN	0x02
+#  define TH_RST	0x04
+#  define TH_PUSH	0x08
+#  define TH_ACK	0x10
+#  define TH_URG	0x20
+    u_int16_t th_win;		/* window */
+    u_int16_t th_sum;		/* checksum */
+    u_int16_t th_urp;		/* urgent pointer */
+};
+      struct
+      {
+    u_int16_t source;
+    u_int16_t dest;
+    u_int32_t seq;
+    u_int32_t ack_seq;
+#  if __BYTE_ORDER == __LITTLE_ENDIAN
+    u_int16_t res1:4;
+    u_int16_t doff:4;
+    u_int16_t fin:1;
+    u_int16_t syn:1;
+    u_int16_t rst:1;
+    u_int16_t psh:1;
+    u_int16_t ack:1;
+    u_int16_t urg:1;
+    u_int16_t res2:2;
+#  elif __BYTE_ORDER == __BIG_ENDIAN
+    u_int16_t doff:4;
+    u_int16_t res1:4;
+    u_int16_t res2:2;
+    u_int16_t urg:1;
+    u_int16_t ack:1;
+    u_int16_t psh:1;
+    u_int16_t rst:1;
+    u_int16_t syn:1;
+    u_int16_t fin:1;
+#  else
+#   error "Adjust your <bits/endian.h> defines"
+#  endif
+    u_int16_t window;
+    u_int16_t check;
+    u_int16_t urg_ptr;
+};
+    };
+};
+
+enum
+{
+  TCP_ESTABLISHED = 1,
+  TCP_SYN_SENT,
+  TCP_SYN_RECV,
+  TCP_FIN_WAIT1,
+  TCP_FIN_WAIT2,
+  TCP_TIME_WAIT,
+  TCP_CLOSE,
+  TCP_CLOSE_WAIT,
+  TCP_LAST_ACK,
+  TCP_LISTEN,
+  TCP_CLOSING   /* now a valid state */
+};
+
+# define TCPOPT_EOL		0
+# define TCPOPT_NOP		1
+# define TCPOPT_MAXSEG		2
+# define    TCPOLEN_MAXSEG		4
+# define TCPOPT_WINDOW		3
+# define    TCPOLEN_WINDOW		3
+# define TCPOPT_SACK_PERMITTED	4		/* Experimental */
+# define    TCPOLEN_SACK_PERMITTED	2
+# define TCPOPT_SACK		5		/* Experimental */
+# define TCPOPT_TIMESTAMP	8
+# define    TCPOLEN_TIMESTAMP	10
+# define    TCPOLEN_TSTAMP_APPA	(TCPOLEN_TIMESTAMP+2) /* appendix A */
+# define    TCPOPT_TSTAMP_HDR	\
+    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|TCPOPT_TIMESTAMP<<8|TCPOLEN_TIMESTAMP)
+#define	TCPOPT_CC		11		/* CC options: RFC-1644 */
+#define TCPOPT_CCNEW		12
+#define TCPOPT_CCECHO		13
+#define	   TCPOLEN_CC			6
+#define	   TCPOLEN_CC_APPA		(TCPOLEN_CC+2)
+#define	   TCPOPT_CC_HDR(ccopt)		\
+    (TCPOPT_NOP<<24|TCPOPT_NOP<<16|(ccopt)<<8|TCPOLEN_CC)
+
+/*
+ * Default maximum segment size for TCP.
+ * With an IP MSS of 576, this is 536,
+ * but 512 is probably more convenient.
+ * This should be defined as MIN(512, IP_MSS - sizeof (struct tcpiphdr)).
+ */
+# define TCP_MSS	512
+
+/*
+ * Default maximum segment size for TCP6.
+ * With an IP MSS of 1280, this is 1220,
+ * but 1024 is probably more convenient.
+ * This should be defined as MIN(1024, IP6_MSS - sizeof (struct tcpip6hdr)).
+ */
+# define TCP6_MSS	1024
+
+# define TCP_MAXWIN	65535	/* largest value for (unscaled) window */
+# define TTCP_CLIENT_SND_WND 4096 /* default send window for T/TCP client */
+
+# define TCP_MAX_WINSHIFT	14	/* maximum window shift */
+
+#define TCP_MAXBURST		4	/* maximum segments in a burst */
+
+#define TCP_MAXHLEN	(0xf<<2)	/* max length of header in bytes */
+#define TCP_MAXOLEN	(TCP_MAXHLEN - sizeof (struct tcphdr))
+					/* max space left for options */
+
+# define SOL_TCP		6	/* TCP level */
+
+
+# define TCPI_OPT_TIMESTAMPS	1
+# define TCPI_OPT_SACK		2
+# define TCPI_OPT_WSCALE	4
+# define TCPI_OPT_ECN		8
+
+/* Values for tcpi_state.  */
+enum tcp_ca_state
+{
+  TCP_CA_Open = 0,
+  TCP_CA_Disorder = 1,
+  TCP_CA_CWR = 2,
+  TCP_CA_Recovery = 3,
+  TCP_CA_Loss = 4
+};
+
+struct tcp_info
+{
+  u_int8_t	tcpi_state;
+  u_int8_t	tcpi_ca_state;
+  u_int8_t	tcpi_retransmits;
+  u_int8_t	tcpi_probes;
+  u_int8_t	tcpi_backoff;
+  u_int8_t	tcpi_options;
+  u_int8_t	tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;
+
+  u_int32_t	tcpi_rto;
+  u_int32_t	tcpi_ato;
+  u_int32_t	tcpi_snd_mss;
+  u_int32_t	tcpi_rcv_mss;
+
+  u_int32_t	tcpi_unacked;
+  u_int32_t	tcpi_sacked;
+  u_int32_t	tcpi_lost;
+  u_int32_t	tcpi_retrans;
+  u_int32_t	tcpi_fackets;
+
+  /* Times. */
+  u_int32_t	tcpi_last_data_sent;
+  u_int32_t	tcpi_last_ack_sent;	/* Not remembered, sorry.  */
+  u_int32_t	tcpi_last_data_recv;
+  u_int32_t	tcpi_last_ack_recv;
+
+  /* Metrics. */
+  u_int32_t	tcpi_pmtu;
+  u_int32_t	tcpi_rcv_ssthresh;
+  u_int32_t	tcpi_rtt;
+  u_int32_t	tcpi_rttvar;
+  u_int32_t	tcpi_snd_ssthresh;
+  u_int32_t	tcpi_snd_cwnd;
+  u_int32_t	tcpi_advmss;
+  u_int32_t	tcpi_reordering;
+};
+
+#endif /* Misc.  */
+
+#endif /* netinet/tcp.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/nfs/nfs.h
@@ -0,0 +1,3 @@
+#include <stdint.h>
+#include <sys/mount.h>
+#include <nfs/nfsproto.h>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/not-cancel.h
@@ -0,0 +1,91 @@
+/* Uncancelable versions of cancelable interfaces.  kFreeBSD version.
+   Copyright (C) 2003, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sysdep.h>
+
+/* Uncancelable open.  */
+#define open_not_cancel(name, flags, mode) \
+   INLINE_SYSCALL (open, 3, (const char *) (name), (flags), (mode))
+#define open_not_cancel_2(name, flags) \
+   INLINE_SYSCALL (open, 2, (const char *) (name), (flags))
+
+/* Uncancelable openat.  */
+#if IS_IN (libc) || IS_IN (libpthread) || IS_IN (librt)
+extern int __openat_nocancel (int fd, const char *fname, int oflag,
+			      mode_t mode) attribute_hidden;
+extern int __openat64_nocancel (int fd, const char *fname, int oflag,
+				mode_t mode) attribute_hidden;
+#else
+# define __openat_nocancel(fd, fname, oflag, mode) \
+  openat (fd, fname, oflag, mode)
+# define __openat64_nocancel(fd, fname, oflag, mode) \
+  openat64 (fd, fname, oflag, mode)
+#endif
+
+#define openat_not_cancel(fd, fname, oflag, mode) \
+  __openat_nocancel (fd, fname, oflag, mode)
+#define openat_not_cancel_3(fd, fname, oflag) \
+  __openat_nocancel (fd, fname, oflag, 0)
+#define openat64_not_cancel(fd, fname, oflag, mode) \
+  __openat64_nocancel (fd, fname, oflag, mode)
+#define openat64_not_cancel_3(fd, fname, oflag) \
+  __openat64_nocancel (fd, fname, oflag, 0)
+
+/* Uncancelable close.  */
+#define close_not_cancel(fd) \
+  INLINE_SYSCALL (close, 1, fd)
+
+#define close_not_cancel_no_status(fd) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err); \
+	    INTERNAL_SYSCALL (close, err, 1, (fd)); })
+
+/* Uncancelable read.  */
+#define read_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (read, 3, (fd), (buf), (n))
+
+/* Uncancelable write.  */
+#define write_not_cancel(fd, buf, n) \
+  INLINE_SYSCALL (write, 3, (fd), (buf), (n))
+
+/* Uncancelable writev.  */
+#define writev_not_cancel_no_status(fd, iov, n) \
+  (void) ({ INTERNAL_SYSCALL_DECL (err); \
+	    INTERNAL_SYSCALL (writev, err, 3, (fd), (iov), (n)); })
+
+/* Uncancelable fcntl.  */
+#define fcntl_not_cancel(fd, cmd, val) \
+  __fcntl_nocancel (fd, cmd, val)
+
+/* Uncancelable waitpid.  */
+# define waitpid_not_cancel(pid, stat_loc, options) \
+  INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL)
+
+/* Uncancelable pause.  */
+# define pause_not_cancel() \
+  __pause_nocancel ()
+
+/* Uncancelable nanosleep.  */
+# define nanosleep_not_cancel(requested_time, remaining) \
+  INLINE_SYSCALL (nanosleep, 2, requested_time, remaining)
+
+/* Uncancelable sigsuspend.  */
+#define sigsuspend_not_cancel(set) \
+  INLINE_SYSCALL (sigsuspend, 1, set)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/open.c
@@ -0,0 +1,63 @@
+/* Copyright (C) 1999, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <fcntl.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sysdep-cancel.h>
+
+int
+__libc_open (const char *file, int oflag, ...)
+{
+  int mode = 0;
+  int fd;
+
+  if (oflag & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, oflag);
+      mode = va_arg (arg, int);
+      va_end (arg);
+    }
+
+  if (SINGLE_THREAD_P)
+  {
+    fd = INLINE_SYSCALL (open, 3, file, oflag, mode);
+  }
+  else
+  {
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    fd = INLINE_SYSCALL (open, 3, file, oflag, mode);
+    LIBC_CANCEL_RESET (oldtype);
+  }
+  return fd;
+}
+libc_hidden_def (__libc_open)
+
+weak_alias (__libc_open, __open)
+libc_hidden_weak (__open)
+
+weak_alias (__libc_open, open)
+
+strong_alias (__libc_open, __libc_open64)
+weak_alias (__libc_open64, __open64)
+weak_alias (__libc_open64, open64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/open64.c
@@ -0,0 +1,2 @@
+/* 'open64' is the same as 'open', because __off64_t == __off_t and
+   O_LARGEFILE == 0.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/openat.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+#include <sysdep-cancel.h>
+#include <not-cancel.h>
+
+extern int __syscall_openat (int fd, const char *path, int flag, mode_t mode);
+libc_hidden_proto (__syscall_openat)
+
+/* Open FILE with access OFLAG.  Interpret relative paths relative to
+   the directory associated with FD.  If OFLAG includes O_CREAT, a
+   third argument is the file protection.  */
+int
+__openat (int fd, const char *file, int oflag, ...)
+{
+  int mode = 0;
+  int result;
+
+  if (oflag & O_CREAT)
+    {
+      va_list arg;
+      va_start (arg, oflag);
+      mode = va_arg (arg, int);
+      va_end (arg);
+    }
+  
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (openat, 4, fd, file, oflag, mode);
+  else
+    {
+      int oldtype = LIBC_CANCEL_ASYNC ();
+      result = INLINE_SYSCALL (openat, 4, fd, file, oflag, mode);
+      LIBC_CANCEL_RESET (oldtype);
+    }
+  return result;
+}
+
+libc_hidden_def (__openat)
+weak_alias (__openat, openat)
+
+/* 'openat64' is the same as 'openat', because __off64_t == __off_t.  */
+strong_alias (__openat, __openat64)
+libc_hidden_def (__openat64)
+weak_alias (__openat64, openat64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/openat64.c
@@ -0,0 +1,2 @@
+/* 'openat64' is the same as 'openat', because __off64_t == __off_t and
+   O_LARGEFILE == 0.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/paths.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)paths.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _PATHS_H_
+#define	_PATHS_H_
+
+/* Default search path. */
+#define	_PATH_DEFPATH	"/usr/bin:/bin"
+/* All standard utilities path. */
+#define	_PATH_STDPATH \
+	"/usr/bin:/bin:/usr/sbin:/sbin"
+
+#define	_PATH_BSHELL	"/bin/sh"
+#define	_PATH_CONSOLE	"/dev/console"
+#define	_PATH_CSHELL	"/bin/csh"
+#define	_PATH_DEVDB	"/var/run/dev.db"
+#define	_PATH_DEVNULL	"/dev/null"
+#define	_PATH_DRUM	"/dev/drum"
+#define	_PATH_KLOG	"/dev/klog"
+#define	_PATH_KMEM	"/dev/kmem"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+#define	_PATH_MAILDIR	"/var/mail"
+#define	_PATH_MAN	"/usr/share/man"
+#define	_PATH_MEM	"/dev/mem"
+#define	_PATH_MNTTAB	"/etc/fstab"
+#define	_PATH_MOUNTED	"/etc/mtab"
+#define	_PATH_NOLOGIN	"/etc/nologin"
+#define	_PATH_PRESERVE	"/var/lib"
+#define	_PATH_RWHODIR	"/var/spool/rwho"
+#define	_PATH_SENDMAIL	"/usr/sbin/sendmail"
+#define	_PATH_SHADOW	"/etc/shadow"
+#define	_PATH_SHELLS	"/etc/shells"
+#define	_PATH_TTY	"/dev/tty"
+#define	_PATH_UNIX	"/kernel"
+#define _PATH_UTMP	"/var/run/utmp"
+#define	_PATH_VI	"/usr/bin/vi"
+#define _PATH_WTMP	"/var/log/wtmp"
+
+/* Provide trailing slash, since mostly used for building pathnames. */
+#define	_PATH_DEV	"/dev/"
+#define	_PATH_TMP	"/tmp/"
+#define	_PATH_VARDB	"/var/lib/misc/"
+#define	_PATH_VARRUN	"/var/run/"
+#define	_PATH_VARTMP	"/var/tmp/"
+
+#endif /* !_PATHS_H_ */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise.c
@@ -0,0 +1,51 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_posix_fadvise(int fd, off_t offset, off_t len, int advice);
+libc_hidden_proto (__syscall_posix_fadvise)
+
+/* the syscall is available in 8.x since 8.3 and in 9.1 and above */
+/* i.e. it is not supported in 9.0 kernel */
+
+int
+posix_fadvise(int fd, off_t offset, off_t len, int advice)
+{
+    int rv;
+    rv = INLINE_SYSCALL (posix_fadvise, 4, fd, offset, len, advice);
+    if (rv == -1)
+    {
+        if (errno == ENOSYS)	/* cheat under old kernels as successfull */
+            return 0;
+        return errno;
+    }
+    return rv;
+}
+
+weak_alias (posix_fadvise, posix_fadvise64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fadvise64.c
@@ -0,0 +1 @@
+/* 'posix_fadvise64' is the same as 'posix_fadvise', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate.c
@@ -0,0 +1,81 @@
+/* Copyright (C) 2007-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <fcntl.h>
+#include <kernel-features.h>
+#include <sysdep.h>
+
+extern int __syscall_posix_fallocate(int fd, off_t offset, off_t len);
+libc_hidden_proto (__syscall_posix_fallocate)
+
+#define posix_fallocate static internal_fallocate
+#include <sysdeps/posix/posix_fallocate.c>
+#undef posix_fallocate
+
+#if !defined __ASSUME_FALLOCATE
+static int __have_fallocate;
+#endif
+
+
+/* Reserve storage for the data of the file associated with FD.  */
+int
+__posix_fallocate (int fd, __off_t offset, __off_t len)
+{
+#ifndef __ASSUME_FALLOCATE
+    if (__have_fallocate >= 0)
+#endif
+    {
+        int res = INLINE_SYSCALL (posix_fallocate, 3, fd, offset, len);
+      
+        if (res == -1)
+            res = errno;
+#ifndef __ASSUME_FALLOCATE
+        if (res == ENOSYS)
+        {
+            __have_fallocate = -1;
+        }
+        else
+#endif
+        {
+            if (res != EOPNOTSUPP)
+                return res;
+        }
+    }      
+    return internal_fallocate (fd, offset, len);
+}
+strong_alias (__posix_fallocate, posix_fallocate)
+
+/* 'posix_fallocate64' is the same as 'posix_fallocate', because __off64_t == __off_t.  */
+/*  but previous prototype have different size of len parameter */
+
+#include <shlib-compat.h>
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 32 && SHLIB_COMPAT(libc, GLIBC_2_2, GLIBC_2_3_3)
+
+int
+attribute_compat_text_section
+__posix_fallocate64_l32 (int fd, off64_t offset, size_t len)
+{
+  return __posix_fallocate (fd, offset, len);
+}
+
+versioned_symbol (libc, __posix_fallocate, posix_fallocate64, GLIBC_2_3_3);
+compat_symbol (libc, __posix_fallocate64_l32, posix_fallocate64, GLIBC_2_2);
+#else
+weak_alias (__posix_fallocate, posix_fallocate64)
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/posix_fallocate64.c
@@ -0,0 +1 @@
+/* 'posix_fallocate64' is the same as 'posix_fallocate', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/powerpc/bits/elf.h
@@ -0,0 +1,39 @@
+/* This file defines standard ELF types, structures, and macros.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _BITS_ELF_H
+#define _BITS_ELF_H
+
+__BEGIN_DECLS
+
+#define	AT_DCACHEBSIZE	10	/* Data cache block size for the processor. */
+#define	AT_ICACHEBSIZE	11	/* Instruction cache block size for the uP. */
+#define	AT_UCACHEBSIZE	12	/* Cache block size, or `0' if cache not unified. */
+#define	AT_EXECPATH	13	/* Path to the executable. */
+#define	AT_CANARY	14	/* Canary for SSP */
+#define	AT_CANARYLEN	15	/* Length of the canary. */
+#define	AT_OSRELDATE	16	/* OSRELDATE. */
+#define	AT_NCPUS	17	/* Number of CPUs. */
+#define	AT_PAGESIZES	18	/* Pagesizes. */
+#define	AT_PAGESIZESLEN	19	/* Number of pagesizes. */
+#define	AT_STACKPROT	21	/* Initial stack protection. */
+
+__END_DECLS
+
+#endif	/* elf.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/pread64.c
@@ -0,0 +1 @@
+/* 'pread64' is the same as 'pread', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/preadv64.c
@@ -0,0 +1 @@
+/* 'preadv64' is the same as 'preadv', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/prof-freq.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <libc-internal.h>
+#include <stddef.h>
+#include <sys/sysctl.h>
+
+struct clockinfo
+{
+  int hz;		/* Clock frequency.  */
+  int tick;		/* Microseconds per hz tick, = 1000000 / hz.  */
+  int tickadj;		/* Clock skew rate for adjtime().  */
+  int stathz;		/* Statistics clock frequency.  */
+  int profhz;		/* Profiling clock frequency.  */
+};
+
+int
+__profile_frequency (void)
+{
+  /* Fetch the "kern.clockrate" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_CLOCKRATE };
+  struct clockinfo result;
+  size_t result_len = sizeof (result);
+
+  if (__sysctl (request, 2, &result, &result_len, NULL, 0) < 0)
+    /* Dummy result.  */
+    return 1;
+
+  /* Yes, hz, not profhz.  On i386, the value is 100, not 1024.  */
+  return result.hz;
+}
+libc_hidden_def (__profile_frequency)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ptsname.c
@@ -0,0 +1,110 @@
+/* Copyright (C) 1998-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <paths.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <sys/sysmacros.h>
+#include <termios.h>
+#include <unistd.h>
+
+
+/* Directory where we can find the slave pty nodes.  */
+#define _PATH_DEVPTS "/dev/pts/"
+
+/* Static buffer for `ptsname'.  */
+static char buffer[sizeof (_PATH_DEVPTS) + 20];
+
+
+/* Return the pathname of the pseudo terminal slave associated with
+   the master FD is open on, or NULL on errors.
+   The returned storage is good until the next call to this function.  */
+char *
+ptsname (int fd)
+{
+  return __ptsname_r (fd, buffer, sizeof (buffer)) != 0 ? NULL : buffer;
+}
+
+
+int
+__isptymaster(int fd)
+{
+  if (0 == __ioctl(fd, TIOCPTMASTER))
+    return 0;
+
+  if (errno != EBADF)
+    __set_errno (EINVAL);
+
+  return -1;
+}
+
+
+int
+__ptsname_internal (int fd, char *buf, size_t buflen, struct stat64 *stp)
+{
+  struct fiodgname_arg fiodgname;
+  char *p;
+  if (buf == NULL)
+    {
+      __set_errno (EINVAL);
+      return EINVAL;
+    }
+    
+  /* Check if FD really is a master pseudo terminal.  */
+  if (0 != __isptymaster(fd))
+  {
+      __set_errno (ENOTTY);
+      return ENOTTY;
+  }
+
+  if (buflen < sizeof (_PATH_DEV) + 5) /* "/dev/" + "pts/"   */
+  {
+      __set_errno (ERANGE);
+      return ERANGE;
+  }
+
+  /* Construct the slave's pathname.  */
+  /* instead of strlen(_PATH_DEV) we use (sizeof (_PATH_DEV) - 1)  */
+  p = __mempcpy (buf, _PATH_DEV, sizeof (_PATH_DEV) - 1);
+  buflen -= (sizeof (_PATH_DEV) - 1);
+
+  fiodgname.buf = p;
+  fiodgname.len = buflen;
+
+  if (0 != __ioctl(fd, FIODGNAME, &fiodgname))
+    return errno;
+
+  if (__xstat64 (_STAT_VER, buf, stp) < 0)
+    return errno;
+
+  return 0;
+}
+
+
+/* Store at most BUFLEN characters of the pathname of the slave pseudo
+   terminal associated with the master FD is open on in BUF.
+   Return 0 on success, otherwise an error number.  */
+int
+__ptsname_r (int fd, char *buf, size_t buflen)
+{
+  struct stat64 st;
+  return __ptsname_internal (fd, buf, buflen, &st);
+}
+weak_alias (__ptsname_r, ptsname_r)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/pwrite64.c
@@ -0,0 +1 @@
+/* 'pwrite64' is the same as 'pwrite', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/pwritev64.c
@@ -0,0 +1 @@
+/* 'pwritev64' is the same as 'pwritev', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir.c
@@ -0,0 +1,11 @@
+/* 'readdir64' is the same as 'readdir', because
+   struct dirent64 == struct dirent.  */
+
+#define readdir64 __no_readdir64_decl
+#define __readdir64 __no___readdir64_decl
+#include <sysdeps/posix/readdir.c>
+#undef __readdir64
+#undef readdir64
+
+strong_alias (__readdir, __readdir64)
+weak_alias (__readdir64, readdir64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64.c
@@ -0,0 +1,2 @@
+/* 'readdir64' is the same as 'readdir', because
+   struct dirent64 == struct dirent.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir64_r.c
@@ -0,0 +1,2 @@
+/* 'readdir64_r' is the same as 'readdir_r', because
+   struct dirent64 == struct dirent.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/readdir_r.c
@@ -0,0 +1,11 @@
+/* 'readdir64_r' is the same as 'readdir_r', because
+   struct dirent64 == struct dirent.  */
+
+#define readdir64_r __no_readdir64_r_decl
+#define __readdir64_r __no___readdir64_r_decl
+#include <sysdeps/posix/readdir_r.c>
+#undef __readdir64_r
+#undef readdir64_r
+
+strong_alias (__readdir_r, __readdir64_r)
+weak_alias (__readdir64_r, readdir64_r)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/readonly-area.c
@@ -0,0 +1,96 @@
+/* Copyright (C) 2004, 2005, 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdio_ext.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/sysctl.h>
+#include <sys/user.h>
+#include "libio/libioP.h"
+
+/* Return 1 if the whole area PTR .. PTR+SIZE is not writable.
+   Return -1 if it is writable.  */
+
+int
+__readonly_area (const char *ptr, size_t size)
+{
+  const void *ptr_end = ptr + size;
+
+  int mib[4];
+  size_t kve_len = 0;
+  char *kve_buf, *kve_bufp;
+
+  mib[0] = CTL_KERN;
+  mib[1] = KERN_PROC;
+  mib[2] = KERN_PROC_VMMAP;
+  mib[3] = __getpid ();
+
+  if (__sysctl (mib, 4, NULL, &kve_len, NULL, 0) != 0)
+    {
+      __set_errno (ENOSYS);
+      return 1;
+    }
+
+  kve_buf = alloca (kve_len);
+  if (__sysctl (mib, 4, kve_buf, &kve_len, NULL, 0) != 0)
+    {
+      __set_errno (ENOSYS);
+      return 1;
+    }
+
+  kve_bufp = kve_buf;
+  while (kve_bufp < kve_buf + kve_len)
+    {
+      struct kinfo_vmentry *kve = (struct kinfo_vmentry *) (uintptr_t) kve_bufp;
+      kve_bufp += kve->kve_structsize;
+
+      uintptr_t from = kve->kve_start;
+      uintptr_t to = kve->kve_end;
+
+      if (from < (uintptr_t) ptr_end && to > (uintptr_t) ptr)
+	{
+	  /* Found an entry that at least partially covers the area.  */
+	  if (!(kve->kve_protection & KVME_PROT_READ)
+	      || (kve->kve_protection & KVME_PROT_WRITE))
+	    break;
+
+	  if (from <= (uintptr_t) ptr && to >= (uintptr_t) ptr_end)
+	    {
+	      size = 0;
+	      break;
+	    }
+	  else if (from <= (uintptr_t) ptr)
+	    size -= to - (uintptr_t) ptr;
+	  else if (to >= (uintptr_t) ptr_end)
+	    size -= (uintptr_t) ptr_end - from;
+	  else
+	    size -= to - from;
+
+	  if (!size)
+	    break;
+	}
+    }
+
+  /* If the whole area between ptr and ptr_end is covered by read-only
+     VMAs, return 1.  Otherwise return -1.  */
+  return size == 0 ? 1 : -1;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/readv.c
@@ -0,0 +1,57 @@
+/* readv for FreeBSD.
+   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_readv (int, __const struct iovec *, int);
+libc_hidden_proto(__syscall_readv)
+
+static ssize_t __atomic_readv_replacement (int, __const struct iovec *,
+					   int) internal_function;
+
+ssize_t
+__readv (int fd, const struct iovec *vector, int count)
+{
+  if (count <= UIO_MAXIOV)
+  {
+    if (SINGLE_THREAD_P)
+      return INLINE_SYSCALL (readv, 3, fd, vector, count);
+
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    ssize_t result = INLINE_SYSCALL (readv, 3, fd, vector, count);
+    LIBC_CANCEL_RESET (oldtype);
+    return result;
+
+  }
+  else
+    return __atomic_readv_replacement (fd, vector, count);
+}
+weak_alias (__readv, readv)
+
+#undef weak_alias
+#define weak_alias(a,b)
+#define __readv static internal_function __atomic_readv_replacement
+#include <sysdeps/posix/readv.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/recv.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* The real syscall's name.  See sysdeps/unix/inet/syscalls.list.  */
+#define __syscall_recvfrom __libc_recvfrom
+ssize_t __libc_recvfrom(int s, void *buf, size_t len, int flags,
+                        struct sockaddr *from, socklen_t *fromlen);
+libc_hidden_proto (__libc_recvfrom)
+
+/* Read N bytes into BUF from socket FD.
+   Return the number of bytes read or -1 for error.  */
+
+ssize_t
+__libc_recv (int fd, void *buf, size_t n, int flags)
+{
+  return INLINE_SYSCALL (recvfrom, 6, fd, buf, n, flags, NULL, NULL);
+}
+
+weak_alias (__libc_recv, __recv)
+weak_alias (__libc_recv, recv)
+
+LIBC_CANCEL_HANDLED (); /* in __libc_recvfrom */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/remove.c
@@ -0,0 +1,39 @@
+/* ANSI C `remove' function to delete a file or directory.  POSIX.1 version.
+   Copyright (C) 1995,96,97,2002,2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stdio.h>
+#include <unistd.h>
+
+int
+remove (const char *file)
+{
+  /* First try to unlink since this is more frequently the necessary action. */
+  if (__unlink (file) != 0
+      /* If it is indeed a directory...  */
+      /* Linux returns EISDIR, POSIX mandates EPERM */
+      && (((errno != EISDIR) && (errno != EPERM))
+	  /* ...try to remove it.  */
+	  || __rmdir (file) != 0))
+    /* Cannot remove the object for whatever reason.  */
+    return -1;
+
+  return 0;
+}
+libc_hidden_def (remove)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/rtld-lowlevel.h
@@ -0,0 +1,131 @@
+/* Definitions for lowlevel handling in ld.so, FreeBSD variant
+   Copyright (C) 2006-2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _RTLD_LOWLEVEL_H
+#define  _RTLD_LOWLEVEL_H 1
+
+#include <atomic.h>
+#include <lowlevellock.h>
+
+/* Special multi-reader lock used in ld.so.  */
+#define __RTLD_MRLOCK_WRITER 1
+#define __RTLD_MRLOCK_RWAIT 2
+#define __RTLD_MRLOCK_WWAIT 4
+#define __RTLD_MRLOCK_RBITS \
+  ~(__RTLD_MRLOCK_WRITER | __RTLD_MRLOCK_RWAIT | __RTLD_MRLOCK_WWAIT)
+#define __RTLD_MRLOCK_INC 8
+#define __RTLD_MRLOCK_TRIES 5
+
+#define __rtld_mrlock_define(CLASS,NAME) \
+  CLASS __rtld_mrlock_t NAME;
+
+
+#define _RTLD_MRLOCK_INITIALIZER 0
+#define __rtld_mrlock_initialize(NAME) \
+  (void) ((NAME).lv = 0)
+
+
+#define __rtld_mrlock_lock(lock) \
+  do {									      \
+    __label__ out;							      \
+    while (1)								      \
+      {									      \
+	int oldval;							      \
+	for (int tries = 0; tries < __RTLD_MRLOCK_TRIES; ++tries)	      \
+	  {								      \
+	    oldval = (lock).iv;						      \
+	    while (__builtin_expect ((oldval				      \
+				      & (__RTLD_MRLOCK_WRITER		      \
+					 | __RTLD_MRLOCK_WWAIT))	      \
+				     == 0, 1))				      \
+	      {								      \
+		int newval = ((oldval & __RTLD_MRLOCK_RBITS)		      \
+			      + __RTLD_MRLOCK_INC);			      \
+		int ret = atomic_compare_and_exchange_val_acq (&(lock.iv),	      \
+							       newval,	      \
+							       oldval);	      \
+		if (__builtin_expect (ret == oldval, 1))		      \
+		  goto out;						      \
+		oldval = ret;						      \
+	      }								      \
+	    atomic_delay ();						      \
+	  }								      \
+	if ((oldval & __RTLD_MRLOCK_RWAIT) == 0)			      \
+	  {								      \
+	    atomic_or (&(lock.iv), __RTLD_MRLOCK_RWAIT);			      \
+	    oldval |= __RTLD_MRLOCK_RWAIT;				      \
+	  }								      \
+	lll_futex_wait (&(lock), oldval);					      \
+      }									      \
+  out:;									      \
+  } while (0)
+
+
+#define __rtld_mrlock_unlock(lock) \
+  do {									      \
+    int oldval = atomic_exchange_and_add (&(lock.iv), -__RTLD_MRLOCK_INC);	      \
+    if (__builtin_expect ((oldval					      \
+			   & (__RTLD_MRLOCK_RBITS | __RTLD_MRLOCK_WWAIT))     \
+			  == (__RTLD_MRLOCK_INC | __RTLD_MRLOCK_WWAIT), 0))   \
+      /* We have to wake all threads since there might be some queued	      \
+	 readers already.  */						      \
+      lll_futex_wake (&(lock), 0x7fffffff);				      \
+  } while (0)
+
+
+/* There can only ever be one thread trying to get the exclusive lock.  */
+#define __rtld_mrlock_change(lock) \
+  do {									      \
+    __label__ out;							      \
+    while (1)								      \
+      {									      \
+	int oldval;							      \
+	for (int tries = 0; tries < __RTLD_MRLOCK_TRIES; ++tries)	      \
+	  {								      \
+	    oldval = lock.iv;						      \
+	    while (__builtin_expect ((oldval & __RTLD_MRLOCK_RBITS) == 0, 1)) \
+	      {								      \
+		int newval = ((oldval & __RTLD_MRLOCK_RWAIT)		      \
+			      + __RTLD_MRLOCK_WRITER);			      \
+		int ret = atomic_compare_and_exchange_val_acq (&(lock.iv),	      \
+							       newval,	      \
+							       oldval);	      \
+		if (__builtin_expect (ret == oldval, 1))		      \
+		  goto out;						      \
+		oldval = ret;						      \
+	      }								      \
+	    atomic_delay ();						      \
+	  }								      \
+	atomic_or (&(lock.iv), __RTLD_MRLOCK_WWAIT);			      \
+	oldval |= __RTLD_MRLOCK_WWAIT;					      \
+	lll_futex_wait (&(lock), oldval);					      \
+      }									      \
+  out:;									      \
+  } while (0)
+
+
+#define __rtld_mrlock_done(lock) \
+  do {				 \
+    int oldval = atomic_exchange_and_add (&(lock.iv), -__RTLD_MRLOCK_WRITER);    \
+    if (__builtin_expect ((oldval & __RTLD_MRLOCK_RWAIT) != 0, 0))	      \
+      lll_futex_wake (&(lock), 0x7fffffff);				      \
+  } while (0)
+
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sa_len.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 1998, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+
+#include <netatalk/at.h>
+#include <netinet/in.h>
+#include <netipx/ipx.h>
+#include <sys/un.h>
+
+extern int __libc_sa_len (sa_family_t __af);
+libc_hidden_proto (__libc_sa_len)
+
+int
+__libc_sa_len (sa_family_t af)
+{
+  switch (af)
+    {
+    case AF_APPLETALK:
+      return sizeof (struct sockaddr_at);
+    case AF_INET:
+      return sizeof (struct sockaddr_in);
+    case AF_INET6:
+      return sizeof (struct sockaddr_in6);
+    case AF_IPX:
+      return sizeof (struct sockaddr_ipx);
+    case AF_LOCAL:
+      return __SOCKADDR_COMMON_SIZE + sizeof(((struct sockaddr_un *) 0)->sun_path);
+    }
+  return 0;
+}
+libc_hidden_def (__libc_sa_len)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sbrk.c
@@ -0,0 +1 @@
+#include <misc/sbrk.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getaffinity.c
@@ -0,0 +1,65 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include "cpuset-kern.h"
+
+int
+__libc_sched_getaffinity (pid_t pid, size_t cpusetsize, cpu_set_t *cpuset)
+{
+  int res;
+  int64_t id;
+
+  if (pid < 0)
+    {
+      __set_errno(ESRCH);
+      return -1;
+    }
+
+  if (pid == 0)		// user   level "self"
+      id = -1;		// kernel level "self"
+  else
+      id = pid;
+
+  if (cpusetsize > sizeof(cpu_set_t))
+    {
+      /* Clean the rest of the memory the kernel won't do.  */
+      memset ((char *) cpuset + sizeof(cpu_set_t), '\0', cpusetsize - sizeof(cpu_set_t));
+
+      cpusetsize = sizeof(cpu_set_t);
+    }
+
+  res = INLINE_SYSCALL (cpuset_getaffinity, 5, CPU_LEVEL_WHICH,
+			CPU_WHICH_PID, id, cpusetsize, cpuset);
+
+  if (errno == ERANGE)
+    {
+      __set_errno(EINVAL);
+    }
+
+  return res;
+}
+
+strong_alias (__libc_sched_getaffinity, __sched_getaffinity)
+weak_alias (__sched_getaffinity, sched_getaffinity)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_getp.c
@@ -0,0 +1,45 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sched.h>
+#include <sys/types.h>
+#include <errno.h>
+#include <sys/rtprio.h>
+
+/* Retrieve scheduling parameters for a particular process.  */
+int
+__sched_getparam (pid_t pid, struct sched_param *param)
+{
+  /* kFreeBSD return bogus values for SYS_sched_param (see PR kern/76485);
+     fortunately the same information can be retrieved through the rtprio()
+     system call.  */
+  struct rtprio rtp;
+
+  if (__rtprio (RTP_LOOKUP, pid, &rtp) >= 0)
+    {
+      if (RTP_PRIO_IS_REALTIME (rtp.type))
+        param->sched_priority = RTP_PRIO_MAX - rtp.prio;
+      else
+        param->sched_priority = 0;
+    }
+
+  return 0;
+}
+
+weak_alias (__sched_getparam, sched_getparam)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sched_setaffinity.c
@@ -0,0 +1,57 @@
+/* Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sched.h>
+#include <string.h>
+#include <sysdep.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include "cpuset-kern.h"
+
+int
+__libc_sched_setaffinity (pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset)
+{
+  int res;
+  int64_t id;
+
+  if (pid < 0)
+    {
+      __set_errno(ESRCH);
+      return -1;
+    }
+
+  if (pid == 0)		// user   level "self"
+      id = -1;		// kernel level "self"
+  else
+      id = pid;
+
+  res = INLINE_SYSCALL (cpuset_setaffinity, 5, CPU_LEVEL_WHICH,
+			CPU_WHICH_PID, id, cpusetsize, cpuset);
+
+  if (errno == ERANGE || errno == EDEADLK)
+    {
+      __set_errno(EINVAL);
+    }
+
+  return res;
+}
+
+strong_alias (__libc_sched_setaffinity, __sched_setaffinity)
+weak_alias (__sched_setaffinity, sched_setaffinity)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/seekdir.c
@@ -0,0 +1,2 @@
+/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
+#include <sysdeps/posix/seekdir.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/semctl.c
@@ -0,0 +1,175 @@
+/* Copyright (C) 2004, 2010 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Robert Millan
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*-
+ * Copyright (c) 2002 Doug Rabson
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ */
+
+#include <sysdep.h>
+#include <sys/sem.h>
+#include <stdarg.h> /* va_list */
+#include <stdlib.h> /* NULL */
+#include <unistd.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/wordsize.h>
+#include <shlib-compat.h>
+
+
+/* union semun from FreeBSD <sys/sem.h> */
+/*
+ * semctl's arg parameter structure
+ */
+union semun
+{
+  int val;			/* value for SETVAL */
+  struct semid_ds *buf;		/* buffer for IPC_STAT & IPC_SET */
+  struct semid_ds_old *oldbuf;	/* buffer for IPC_STAT & IPC_SET */
+  unsigned short *array;	/* array for GETALL & SETALL */
+};
+
+extern int __syscall_semctl (int semid, int semnum,
+                             int cmd, union semun *arg);
+libc_hidden_proto (__syscall_semctl)
+
+int
+__new_semctl (int semid, int semnum, int cmd, ...)
+{
+    va_list ap;
+    union semun semun;
+    union semun *semun_ptr;
+
+    va_start (ap, cmd);
+    switch (cmd) 
+    {
+        case SEM_STAT:
+        case IPC_SET: 
+        case IPC_STAT: 
+        case GETALL:
+        case SETVAL:  
+        case SETALL:
+            semun = va_arg (ap, union semun);
+            semun_ptr = &semun;
+        break;
+        default:                                                  
+            semun_ptr = NULL;
+    }
+    va_end (ap);
+    return INLINE_SYSCALL (semctl, 4, semid, semnum, cmd, semun_ptr);
+}
+versioned_symbol (libc, __new_semctl, semctl, GLIBC_2_18);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_18)
+
+struct semid_ds_old
+{
+  struct ipc_perm_old sem_perm;		/* operation permission struct */
+  void *__sem_base;
+  unsigned short int sem_nsems;		/* number of semaphores in set */
+  __time_t sem_otime;			/* last semop() time */
+  long __unused1;
+  __time_t sem_ctime;			/* last time changed by semctl() */
+  long __unused2;
+  long __unused3[4];
+};
+
+int
+attribute_compat_text_section
+__old_semctl (int semid, int semnum, int cmd, ...)
+{
+    struct semid_ds newbuf;
+    struct semid_ds_old *buf;
+    int rv;
+
+    va_list ap;
+    union semun semun;
+    union semun *semun_ptr;
+
+    va_start (ap, cmd);
+    switch (cmd) 
+    {
+        case SEM_STAT:
+        case IPC_SET: 
+        case IPC_STAT:
+            semun = va_arg (ap, union semun);
+            buf = semun.oldbuf;
+            semun.buf = &newbuf;
+	    semun_ptr = &semun;
+	break;
+        case GETALL:
+        case SETVAL:  
+        case SETALL:
+            semun = va_arg (ap, union semun);
+	    semun_ptr = &semun;
+        break;
+        default:                                                  
+            semun_ptr = NULL;
+    }
+    va_end (ap);
+  
+    if (cmd == IPC_SET)
+    {
+        ipc_perm_old2new(&(buf->sem_perm), &(newbuf.sem_perm));
+        newbuf.__sem_base = buf->__sem_base;
+        newbuf.sem_nsems  = buf->sem_nsems;
+        newbuf.sem_otime  = buf->sem_otime;
+        newbuf.sem_ctime  = buf->sem_ctime;
+    }
+    
+    rv = INLINE_SYSCALL (semctl, 4, semid, semnum, cmd, semun_ptr);
+    
+    if ((rv != -1) && ((cmd == IPC_STAT) || (cmd == SEM_STAT)))
+    {
+        ipc_perm_new2old(&(newbuf.sem_perm), &(buf->sem_perm));
+        buf->__sem_base = newbuf.__sem_base;
+        buf->sem_nsems  = newbuf.sem_nsems;
+        buf->sem_otime  = newbuf.sem_otime;
+        buf->sem_ctime  = newbuf.sem_ctime;
+    }
+        
+    return rv;
+}
+compat_symbol (libc, __old_semctl, semctl, GLIBC_2_0);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/send.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_sendto (int fd, __const __ptr_t buf,
+		                 size_t n, int flags,
+				 __CONST_SOCKADDR_ARG addr,
+				 socklen_t addrlen);
+libc_hidden_proto (__syscall_sendto)
+
+/* Send N bytes of BUF to socket FD.
+   Return the number of bytes sent or -1.  */
+
+ssize_t
+__libc_send (int fd, const void *buf, size_t n, int flags)
+{
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, 0);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, NULL, 0);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+weak_alias (__libc_send, __send)
+libc_hidden_weak (__send)
+
+weak_alias (__send, send)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sendto.c
@@ -0,0 +1,69 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Aurelien Jarno <aurelien@aurel32.net>, 2005.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/socket.h>
+#include <sysdep.h>
+#include <sysdep-cancel.h>
+
+/* According to POSIX.1-2004 the len argument specifies the length of
+   the sockaddr structure pointed to by the addrarg argument. However
+   the FreeBSD kernel waits the actual length of the address stored
+   there. The code below emulate this behaviour.  */
+
+extern int __libc_sa_len (sa_family_t __af);
+libc_hidden_proto (__libc_sa_len)
+
+extern ssize_t __syscall_sendto (int fd, __const void * buf,
+		                 size_t n, int flags,
+				 __CONST_SOCKADDR_ARG addr,
+				 socklen_t addrlen);
+libc_hidden_proto (__syscall_sendto)
+
+/* Send N bytes of BUF on socket FD to peer at address ADDR (which is
+ *    ADDR_LEN bytes long).  Returns the number sent, or -1 for errors.  */
+
+
+ssize_t
+__libc_sendto (int fd, __const void * buf, size_t n, int flags,
+	       __CONST_SOCKADDR_ARG addr, socklen_t addrlen)
+{
+  socklen_t new_addrlen;
+
+  if (addr.__sockaddr__)
+    {
+      new_addrlen = __libc_sa_len ((addr.__sockaddr__)->sa_family);
+
+      /* Only allow a smaller size, otherwise it could lead to
+        stack corruption */
+      if ((new_addrlen != 0) && (new_addrlen < addrlen))
+	addrlen = new_addrlen;
+    }
+
+  /* We pass 6 arguments.  */
+  if (SINGLE_THREAD_P)
+    return INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, addr.__sockaddr__, addrlen);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+  int result = INLINE_SYSCALL (sendto, 6, fd, buf, n, flags, addr.__sockaddr__, addrlen);
+  LIBC_CANCEL_RESET (oldtype);
+  return result;
+}
+
+weak_alias (__libc_sendto, __sendto)
+weak_alias (__libc_sendto, sendto)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/setdomain.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the name of the current domain to NAME, which is LEN bytes long
+   (excluding a possible trailing NUL byte).  This call is restricted to
+   the super-user.  */
+
+int
+setdomainname (const char *name, size_t len)
+{
+  /* Set the "kern.domainname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_NISDOMAINNAME };
+
+  if (__sysctl (request, 2, NULL, NULL, (void *) name, len) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostid.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the current machine's Internet number to ID.
+   This call is restricted to the super-user.  */
+
+int
+sethostid (long int id)
+{
+  /* Set the "kern.hostid" sysctl value.  */
+  int value = id;
+  int request[2] = { CTL_KERN, KERN_HOSTID };
+
+  if (__sysctl (request, 2, NULL, NULL, &value, sizeof (value)) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sethostname.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sys/sysctl.h>
+
+/* Set the name of the current host to NAME, which is LEN bytes long
+   (excluding a possible trailing NUL byte).  This call is restricted to
+   the super-user.  */
+
+int
+sethostname (const char *name, size_t len)
+{
+  /* Set the "kern.hostname" sysctl value.  */
+  int request[2] = { CTL_KERN, KERN_HOSTNAME };
+
+  if (__sysctl (request, 2, NULL, NULL, (void *) name, len) < 0)
+    return -1;
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/setlogin.c
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <unistd.h>
+#include <sysdep.h>
+
+/* Defined in getlogin_r.c.  */
+extern char *__getlogin_cache;
+
+extern int __syscall_setlogin (const char *__name);
+
+int
+setlogin (const char *name)
+{
+  /* FIXME: Not multithread-safe.  */
+  __getlogin_cache = NULL;
+  return INLINE_SYSCALL (setlogin, 1, name);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/setrlimit64.c
@@ -0,0 +1 @@
+/* 'setrlimit64' is the same as 'setrlimit', because __rlim64_t == __rlim_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/shlib-versions
@@ -0,0 +1,5 @@
+# DEFAULT			Earliest symbol set
+# ---------------		------------------------------
+DEFAULT				GLIBC_2.3
+libc=0.1       
+libm=1
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/shm-directory.c
@@ -0,0 +1,102 @@
+/* Determine directory for shm/sem files.  GNU/kFreeBSD version.
+   Copyright (C) 2000-2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "shm-directory.h"
+
+#include <errno.h>
+#include <mntent.h>
+#include <paths.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/statfs.h>
+#include <libc-lock.h>
+
+/* Mount point of the shared memory filesystem.  */
+static struct
+{
+  char *dir;
+  size_t dirlen;
+} mountpoint;
+
+/* This is the default directory.  */
+static const char defaultdir[] = "/dev/shm/";
+
+/* This is the alternate debian directory.  */
+static const char alternatedir[] = "/run/shm";
+
+/* Protect the `mountpoint' variable above.  */
+__libc_once_define (static, once);
+
+
+/* Determine where the shmfs is mounted (if at all).  */
+static void
+where_is_shmfs (void)
+{
+  struct statfs f;
+
+  /* The canonical place is /dev/shm.  This is at least what the
+     documentation tells everybody to do.  */
+  if (__statfs (defaultdir, &f) == 0)
+    {
+      /* It is in the normal place.  */
+      mountpoint.dir = (char *) defaultdir;
+      mountpoint.dirlen = sizeof (defaultdir) - 1;
+
+      return;
+    }
+
+  /* The alternate place is /run/shm.  */
+  if (__statfs (alternatedir, &f) == 0)
+    {
+      /* It is in the normal place.  */
+      mountpoint.dir = (char *) alternatedir;
+      mountpoint.dirlen = sizeof (alternatedir) - 1;
+
+      return;
+    }
+}
+
+
+const char *
+__shm_directory (size_t *len)
+{
+  /* Determine where the shmfs is mounted.  */
+  __libc_once (once, where_is_shmfs);
+
+  /* If we don't know the mount points there is nothing we can do.  Ever.  */
+  if (__glibc_unlikely (mountpoint.dir == NULL))
+    {
+      __set_errno (ENOSYS);
+      return NULL;
+    }
+
+  *len = mountpoint.dirlen;
+  return mountpoint.dir;
+}
+#if IS_IN (libpthread)
+hidden_def (__shm_directory)
+#endif
+
+
+/* Make sure the table is freed if we want to free everything before
+   exiting.  */
+libc_freeres_fn (freeit)
+{
+  if (mountpoint.dir != defaultdir)
+    free (mountpoint.dir);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/shm_open.c
@@ -0,0 +1,37 @@
+/* Copyright (C) 2014 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/mman.h>
+#include <fcntl.h>
+#include <sysdep.h>
+
+extern int __syscall_shm_open (const char *name, int flag, mode_t mode);
+libc_hidden_proto (__syscall_shm_open)
+
+int
+shm_open (const char *name, int flag, mode_t mode)
+{
+  /*
+   * O_CLOEXEC never has any effect on shm_open(). However, old kernel
+   * versions (prior to rev 261138 in HEAD) return EINVAL when this
+   * (otherwise harmless) flag is used.
+   */
+  flag &= ~O_CLOEXEC;
+
+  return INLINE_SYSCALL (shm_open, 3, name, flag, mode);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/shmctl.c
@@ -0,0 +1,91 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <sys/shm.h>
+#include <ipc_priv.h>
+
+#include <sysdep.h>
+#include <string.h>
+#include <sys/syscall.h>
+#include <bits/wordsize.h>
+#include <shlib-compat.h>
+
+#include <kernel-features.h>
+
+/* Provide operations to control over shared memory segments.  */
+extern int __syscall_shmctl (int shmid, int cmd, struct shmid_ds *buf);
+libc_hidden_proto (__syscall_shmctl)
+
+
+int
+__new_shmctl (int shmid, int cmd, struct shmid_ds *buf)
+{
+  return INLINE_SYSCALL (shmctl, 3, shmid, cmd, buf);
+}
+versioned_symbol (libc, __new_shmctl, shmctl, GLIBC_2_18);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_18)
+struct shmid_ds_old {
+        struct ipc_perm_old shm_perm;   /* operation permission structure */
+        int             shm_segsz;      /* size of segment in bytes */
+        pid_t           shm_lpid;   /* process ID of last shared memory op */
+        pid_t           shm_cpid;       /* process ID of creator */
+        unsigned short  shm_nattch;     /* number of current attaches */
+        time_t          shm_atime;      /* time of last shmat() */
+        time_t          shm_dtime;      /* time of last shmdt() */
+        time_t          shm_ctime;      /* time of last change by shmctl() */
+        void           *shm_internal;   /* sysv stupidity */
+};
+
+int
+attribute_compat_text_section
+__old_shmctl (int shmid, int cmd, struct shmid_ds_old *buf)
+{
+    struct shmid_ds newbuf;
+    int rv;
+    
+    if (cmd == IPC_SET)
+    {
+        ipc_perm_old2new(&(buf->shm_perm), &(newbuf.shm_perm));
+        newbuf.shm_segsz = buf->shm_segsz;
+        newbuf.shm_lpid  = buf->shm_lpid;
+        newbuf.shm_cpid  = buf->shm_cpid;
+        newbuf.shm_nattch= buf->shm_nattch;
+        newbuf.shm_atime = buf->shm_atime;
+        newbuf.shm_dtime = buf->shm_dtime;
+        newbuf.shm_ctime = buf->shm_ctime;
+    }
+    
+    rv = __new_shmctl (shmid, cmd, &newbuf);
+    
+    if ((rv != -1) && (cmd == IPC_STAT))
+    {
+        ipc_perm_new2old(&(newbuf.shm_perm), &(buf->shm_perm));
+        buf->shm_segsz = newbuf.shm_segsz;
+        buf->shm_lpid  = newbuf.shm_lpid;
+        buf->shm_cpid  = newbuf.shm_cpid;
+        buf->shm_nattch= newbuf.shm_nattch;
+        buf->shm_atime = newbuf.shm_atime;
+        buf->shm_dtime = newbuf.shm_dtime;
+        buf->shm_ctime = newbuf.shm_ctime;
+    }
+        
+    return rv;
+}
+compat_symbol (libc, __old_shmctl, shmctl, GLIBC_2_0);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigaction.c
@@ -0,0 +1,48 @@
+/* Copyright (C) 1991,1995,1996,1997,2002,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <errno.h>
+#include <stddef.h>
+#include <signal.h>
+
+extern int __syscall_sigaction (int __sig,  const struct sigaction *__act, struct sigaction *__oact) __THROW;
+libc_hidden_proto (__syscall_sigaction)
+
+int
+__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+  if (sig <= 0 || sig >= NSIG)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  return INLINE_SYSCALL (sigaction, 3, sig, act, oact);
+}
+libc_hidden_def (__libc_sigaction)
+
+#ifdef WRAPPER_INCLUDE
+# include WRAPPER_INCLUDE
+#endif
+
+#ifndef LIBC_SIGACTION
+weak_alias (__libc_sigaction, __sigaction)
+libc_hidden_weak (__sigaction)
+weak_alias (__libc_sigaction, sigaction)
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigreturn.c
@@ -0,0 +1,3 @@
+/* The sigreturn syscall cannot be explicitly called on FreeBSD, only
+   implicitly by returning from a signal handler.  */
+#include <signal/sigreturn.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigset-cvt-mask.h
@@ -0,0 +1,36 @@
+/* Convert between lowlevel sigmask and libc representation of sigset_t.
+   FreeBSD version.
+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+static inline int __attribute__ ((unused))
+sigset_set_old_mask (sigset_t *set, int mask)
+{
+  set->__sigbits[0] = (unsigned int) mask;
+  set->__sigbits[1] = 0;
+  set->__sigbits[2] = 0;
+  set->__sigbits[3] = 0;
+
+  return 0;
+}
+
+static inline int __attribute__ ((unused))
+sigset_get_old_mask (const sigset_t *set)
+{
+  return (unsigned int) set->__sigbits[0];
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sigstack.c
@@ -0,0 +1,3 @@
+/* We can reuse the Linux implementation with some tricks.  */
+#define __NR_sigaltstack 1
+#include <sysdeps/unix/sysv/linux/sigstack.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sleep.c
@@ -0,0 +1,49 @@
+/* Implementation of the POSIX sleep function using nanosleep.
+   Copyright (C) 1996-1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <time.h>
+
+/* The default implementation of sleep() in sysdeps/posix/sleep.c, based on
+   SIGALRM, does not mix well with threads.  Therefore we use the nanosleep()
+   system call.  */
+unsigned int
+__sleep (unsigned int seconds)
+{
+  struct timespec ts = { tv_sec: seconds, tv_nsec: 0 };
+  int ret;
+
+  /* This is not necessary but some buggy programs depend on this.  */
+  if (__builtin_expect (seconds == 0, 0))
+    {
+#ifdef CANCELLATION_P
+      CANCELLATION_P (THREAD_SELF);
+#endif
+      return 0;
+    }
+                        
+  ret = __nanosleep (&ts, &ts);
+
+  if (ret == 0)
+    return 0;
+
+  /* Round remaining time.  */
+  return (unsigned int) ts.tv_sec + (ts.tv_nsec >= 500000000L);
+}
+
+weak_alias (__sleep, sleep)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/socket/sys/un.h
@@ -0,0 +1,2 @@
+/* kludge to satisfy $SRC/include/sys/un.h */
+#include <kfreebsd/sys/un.h>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/stat16conv.c
@@ -0,0 +1,84 @@
+/* Convert between different 'struct stat' formats.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <sys/mount.h>
+#include <bits/stat16.h>
+
+extern int __syscall_fhstat (const fhandle_t *fhp, struct stat16 *buf);
+extern int __syscall_fstat (int, struct stat16 *);
+extern int __syscall_lstat (const char *, struct stat16 *);
+extern int __syscall_stat (const char *, struct stat16 *);
+libc_hidden_proto (__syscall_fhstat)
+libc_hidden_proto (__syscall_fstat)
+libc_hidden_proto (__syscall_lstat)
+libc_hidden_proto (__syscall_stat)
+
+/* Convert a 'struct stat16' to 'struct stat'.  */
+static inline void
+stat16_to_stat (const struct stat16 *p16, struct stat *q)
+{
+  q->st_dev = p16->st_dev;
+  q->st_ino = p16->st_ino;
+  q->st_mode = p16->st_mode;
+  q->__pad_mode = 0;
+  q->st_nlink = p16->st_nlink;
+  q->__pad_nlink = 0;
+  q->st_uid = p16->st_uid;
+  q->st_gid = p16->st_gid;
+  q->st_rdev = p16->st_rdev;
+  q->st_atim = p16->st_atimespec;
+  q->st_mtim = p16->st_mtimespec;
+  q->st_ctim = p16->st_ctimespec;
+  q->st_size = p16->st_size;
+  q->st_blocks = p16->st_blocks;
+  q->st_blksize = p16->st_blksize;
+  q->st_flags = p16->st_flags;
+  q->st_gen = p16->st_gen;
+#if 0
+  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
+#endif
+}
+
+/* Convert a 'struct stat16' to 'struct stat64'.  */
+static inline void
+stat16_to_stat64 (const struct stat16 *p16, struct stat64 *q)
+{
+  q->st_dev = p16->st_dev;
+  q->st_ino = p16->st_ino;
+  q->st_mode = p16->st_mode;
+  q->__pad_mode = 0;
+  q->st_nlink = p16->st_nlink;
+  q->__pad_nlink = 0;
+  q->st_uid = p16->st_uid;
+  q->st_gid = p16->st_gid;
+  q->st_rdev = p16->st_rdev;
+  q->st_atim = p16->st_atimespec;
+  q->st_mtim = p16->st_mtimespec;
+  q->st_ctim = p16->st_ctimespec;
+  q->st_size = p16->st_size;
+  q->st_blocks = p16->st_blocks;
+  q->st_blksize = p16->st_blksize;
+  q->st_flags = p16->st_flags;
+  q->st_gen = p16->st_gen;
+#if 0
+  memcpy (q->__unused1, p16->__unused2, sizeof (p16->__unused2));
+#endif
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statfs (const char *file, struct statfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_def (__statfs)
+weak_alias (__statfs, statfs)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfs64.c
@@ -0,0 +1,37 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+statfs64 (const char *file, struct statfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  statfs5_to_statfs64 (&kbuf, buf);
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/statfsconv.c
@@ -0,0 +1,203 @@
+/* Convert between different 'struct statfs' and 'struct statvfs' formats.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+#include <stdint.h>
+#include <string.h>
+#include <sys/mount.h>
+#include <sys/syslimits.h>
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+/*
+ * filesystem statistics
+ */
+
+#define MFSNAMELEN	16		/* length of type name including null */
+#define MNAMELEN	88		/* size of on/from name bufs */
+
+struct statfs_fbsd5 {
+	uint32_t f_version;		/* structure version number */
+	uint32_t f_type;		/* type of filesystem */
+	uint64_t f_flags;		/* copy of mount exported flags */
+	uint64_t f_bsize;		/* filesystem fragment size */
+	uint64_t f_iosize;		/* optimal transfer block size */
+	uint64_t f_blocks;		/* total data blocks in filesystem */
+	uint64_t f_bfree;		/* free blocks in filesystem */
+	int64_t	 f_bavail;		/* free blocks avail to non-superuser */
+	uint64_t f_files;		/* total file nodes in filesystem */
+	int64_t	 f_ffree;		/* free nodes avail to non-superuser */
+	uint64_t f_syncwrites;		/* count of sync writes since mount */
+	uint64_t f_asyncwrites;		/* count of async writes since mount */
+	uint64_t f_syncreads;		/* count of sync reads since mount */
+	uint64_t f_asyncreads;		/* count of async reads since mount */
+	uint64_t f_spare[10];		/* unused spare */
+	uint32_t f_namemax;		/* maximum filename length */
+	__uid_t	 f_owner;		/* user that mounted the filesystem */
+	__fsid_t f_fsid;		/* filesystem id */
+	char	 f_charspare[80];	   /* spare string space */
+	char	 f_fstypename[MFSNAMELEN]; /* filesystem type name */
+	char	 f_mntfromname[MNAMELEN];  /* mounted filesystem */
+	char	 f_mntonname[MNAMELEN];	   /* directory on which mounted */
+};
+
+extern int __syscall_getfsstat(struct statfs_fbsd5 *buf, long bufsize, int flags);
+extern int __syscall_statfs(const char *path, struct statfs_fbsd5 *buf);
+extern int __syscall_fstatfs(int fd, struct statfs_fbsd5 *buf);
+extern int __syscall_fhstatfs(const struct fhandle *u_fhp, struct statfs_fbsd5 *buf);
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statfs structure.
+ */
+
+static inline void
+statfs5_to_statfs(const struct statfs_fbsd5 *pk, struct statfs *p32)
+{
+  memset(p32, 0, sizeof(*p32));
+
+  p32->f_version	= pk->f_version;
+  p32->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p32->f_iosize		= MIN(pk->f_iosize, ULONG_MAX);
+
+  p32->f_blocks		= MIN(pk->f_blocks, ULONG_MAX);
+  p32->f_bfree		= MIN(pk->f_bfree,  ULONG_MAX);
+  p32->f_bavail		= MIN(pk->f_bavail, ULONG_MAX);
+  p32->f_files		= MIN(pk->f_files,  ULONG_MAX);
+  p32->f_ffree		= MIN(pk->f_ffree,  ULONG_MAX);
+
+  p32->f_fsid		= pk->f_fsid;
+  p32->f_owner		= pk->f_owner;
+  p32->f_type		= pk->f_type;
+  p32->f_flags		= pk->f_flags;
+
+  p32->f_syncwrites	= MIN(pk->f_syncwrites,	 ULONG_MAX);
+  p32->f_asyncwrites	= MIN(pk->f_asyncwrites, ULONG_MAX);
+  p32->f_syncreads	= MIN(pk->f_syncreads,	 ULONG_MAX);
+  p32->f_asyncreads	= MIN(pk->f_asyncreads,	 ULONG_MAX);
+
+  p32->f_namemax	= MIN(pk->f_namemax, USHRT_MAX);
+
+  memcpy(p32->f_fstypename, pk->f_fstypename, sizeof (p32->f_fstypename));
+  memcpy(p32->f_mntonname,  pk->f_mntonname,  sizeof (p32->f_mntonname));
+  memcpy(p32->f_mntfromname,pk->f_mntfromname,sizeof (p32->f_mntfromname));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statfs64 structure.
+ */
+
+static inline void
+statfs5_to_statfs64(const struct statfs_fbsd5 *pk, struct statfs64 *p64)
+{
+  memset(p64, 0, sizeof(*p64));
+
+  p64->f_version	= pk->f_version;
+  p64->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p64->f_iosize		= MIN(pk->f_iosize, ULONG_MAX);
+
+  p64->f_blocks		= pk->f_blocks;
+  p64->f_bfree		= pk->f_bfree;
+  p64->f_bavail		= pk->f_bavail;
+  p64->f_files		= pk->f_files;
+  p64->f_ffree		= pk->f_ffree;
+
+  p64->f_fsid		= pk->f_fsid;
+  p64->f_owner		= pk->f_owner;
+  p64->f_type		= pk->f_type;
+  p64->f_flags		= pk->f_flags;
+
+  p64->f_syncwrites	= MIN(pk->f_syncwrites,	 ULONG_MAX);
+  p64->f_asyncwrites	= MIN(pk->f_asyncwrites, ULONG_MAX);
+  p64->f_syncreads	= MIN(pk->f_syncreads,	 ULONG_MAX);
+  p64->f_asyncreads	= MIN(pk->f_asyncreads,	 ULONG_MAX);
+
+  p64->f_namemax	= MIN(pk->f_namemax, USHRT_MAX);
+
+  memcpy(p64->f_fstypename, pk->f_fstypename, sizeof (p64->f_fstypename));
+  memcpy(p64->f_mntonname,  pk->f_mntonname,  sizeof (p64->f_mntonname));
+  memcpy(p64->f_mntfromname,pk->f_mntfromname,sizeof (p64->f_mntfromname));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statvfs structure.
+ */
+
+static inline void
+statfs5_to_statvfs (const struct statfs_fbsd5 *pk, struct statvfs *p32)
+{
+  /* FIXME: What is the difference between f_bsize and f_frsize ? */
+  p32->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p32->f_frsize		= MIN(pk->f_bsize,  ULONG_MAX);
+
+  p32->f_blocks		= MIN(pk->f_blocks, ULONG_MAX);
+  p32->f_bfree		= MIN(pk->f_bfree,  ULONG_MAX);
+  p32->f_bavail		= MIN(pk->f_bavail, ULONG_MAX);
+  p32->f_files		= MIN(pk->f_files,  ULONG_MAX);
+  p32->f_ffree		= MIN(pk->f_ffree,  ULONG_MAX);
+  p32->f_favail		= MIN(pk->f_ffree,  ULONG_MAX); /* Hmm.	 May be filesystem dependent.  */
+
+  memcpy(&(p32->f_fsid), &(pk->f_fsid), sizeof(__fsid_t));
+
+  p32->f_flag		=
+      (pk->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
+    | (pk->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
+    | (pk->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
+    | (pk->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0)
+    | (pk->f_flags & MNT_NOATIME ? ST_NOATIME : 0);
+  p32->f_namemax	= pk->f_namemax;
+
+  memset (p32->f_spare, '\0', sizeof (p32->f_spare));
+}
+
+
+/*
+ * Convert a FreeBSD 5.x format statfs structure to an glibc format statvfs64 structure.
+ */
+
+static inline void
+statfs5_to_statvfs64 (const struct statfs_fbsd5 *pk, struct statvfs64 *p64)
+{
+  /* FIXME: What is the difference between f_bsize and f_frsize ? */
+  p64->f_bsize		= MIN(pk->f_bsize,  ULONG_MAX);
+  p64->f_frsize		= MIN(pk->f_bsize,  ULONG_MAX);
+
+  p64->f_blocks		= pk->f_blocks;
+  p64->f_bfree		= pk->f_bfree;
+  p64->f_bavail		= pk->f_bavail;
+  p64->f_files		= pk->f_files;
+  p64->f_ffree		= pk->f_ffree;
+  p64->f_favail		= pk->f_ffree; /* Hmm.	May be filesystem dependent.  */
+
+  memcpy(&(p64->f_fsid), &(pk->f_fsid), sizeof(__fsid_t));
+
+  p64->f_flag		=
+      (pk->f_flags & MNT_RDONLY ? ST_RDONLY : 0)
+    | (pk->f_flags & MNT_NOSUID ? ST_NOSUID : 0)
+    | (pk->f_flags & MNT_NOEXEC ? ST_NOEXEC : 0)
+    | (pk->f_flags & MNT_SYNCHRONOUS ? ST_SYNCHRONOUS : 0)
+    | (pk->f_flags & MNT_NOATIME ? ST_NOATIME : 0);
+  p64->f_namemax	= pk->f_namemax;
+
+  memset (p64->f_spare, '\0', sizeof (p64->f_spare));
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs.c
@@ -0,0 +1,40 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+statvfs (const char *file, struct statvfs *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs'.  */
+  statfs5_to_statvfs (&kbuf, buf);
+
+  return 0;
+}
+libc_hidden_weak (statvfs)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/statvfs64.c
@@ -0,0 +1,41 @@
+/* Return information about the filesystem on which FILE resides.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/statvfs.h>
+#include <sys/statfs.h>
+
+#include "statfsconv.c"
+
+/* Return information about the filesystem on which FILE resides.  */
+int
+__statvfs64 (const char *file, struct statvfs64 *buf)
+{
+  struct statfs_fbsd5 kbuf;
+
+  if (__syscall_statfs (file, &kbuf) < 0)
+    return -1;
+
+  /* Convert a 'struct statfs' to 'struct statvfs64'.  */
+  statfs5_to_statvfs64 (&kbuf, buf);
+
+  return 0;
+}
+
+weak_alias (__statvfs64, statvfs64)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/stty.c
@@ -0,0 +1,2 @@
+/* use stub only variant */
+#include <misc/stty.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/kd.h
@@ -0,0 +1,25 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_KD_H
+#define _SYS_KD_H	1
+
+#include <sys/consio.h>
+#include <sys/kbio.h>
+
+#endif	/* sys/kd.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/mount.h
@@ -0,0 +1,521 @@
+/* Header file for handling mounted filesystems.  FreeBSD version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H	1
+
+#include <features.h>
+
+/* Retrieving the list of mounted filesystems.  */
+
+#include <sys/stat.h>
+#include <sys/statfs.h>
+#include <sys/ucred.h>
+#include <sys/queue.h>
+
+/* For getvfsbyname.  */
+#include <stddef.h>
+#include <sys/mount.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * File identifier.
+ * These are unique per filesystem on a single machine.
+ */
+#define	MAXFIDSZ	16
+
+struct fid {
+	__u_short	fid_len;		/* length of data in bytes */
+	__u_short	fid_reserved;		/* force longword alignment */
+	char		fid_data[MAXFIDSZ];	/* data (variable length) */
+};
+
+/*
+ * filesystem statistics
+ */
+#define	MFSNAMELEN	16		/* length of type name including null */
+#define	MNAMELEN	88		/* size of on/from name bufs */
+#define	STATFS_VERSION	0x20030518	/* current version number */
+
+
+/*
+ * User specifiable flags.
+ */
+#define	MNT_RDONLY	0x0000000000000001ULL /* read only filesystem */
+#define	MNT_SYNCHRONOUS	0x0000000000000002ULL /* fs written synchronously */
+#define	MNT_NOEXEC	0x0000000000000004ULL /* can't exec from filesystem */
+#define	MNT_NOSUID	0x0000000000000008ULL /* don't honor setuid fs bits */
+#define	MNT_NFS4ACLS	0x0000000000000010ULL /* enable NFS version 4 ACLs */
+#define	MNT_UNION	0x0000000000000020ULL /* union with underlying fs */
+#define	MNT_ASYNC	0x0000000000000040ULL /* fs written asynchronously */
+#define	MNT_SUIDDIR	0x0000000000100000ULL /* special SUID dir handling */
+#define	MNT_SOFTDEP	0x0000000000200000ULL /* using soft updates */
+#define	MNT_NOSYMFOLLOW	0x0000000000400000ULL /* do not follow symlinks */
+#define	MNT_GJOURNAL	0x0000000002000000ULL /* GEOM journal support enabled */
+#define	MNT_MULTILABEL	0x0000000004000000ULL /* MAC support for objects */
+#define	MNT_ACLS	0x0000000008000000ULL /* ACL support enabled */
+#define	MNT_NOATIME	0x0000000010000000ULL /* dont update file access time */
+#define	MNT_NOCLUSTERR	0x0000000040000000ULL /* disable cluster read */
+#define	MNT_NOCLUSTERW	0x0000000080000000ULL /* disable cluster write */
+#define	MNT_SUJ		0x0000000100000000ULL /* using journaled soft updates */
+
+/*
+ * NFS export related mount flags.
+ */
+#define	MNT_EXRDONLY	0x0000000000000080ULL	/* exported read only */
+#define	MNT_EXPORTED	0x0000000000000100ULL	/* filesystem is exported */
+#define	MNT_DEFEXPORTED	0x0000000000000200ULL	/* exported to the world */
+#define	MNT_EXPORTANON	0x0000000000000400ULL	/* anon uid mapping for all */
+#define	MNT_EXKERB	0x0000000000000800ULL	/* exported with Kerberos */
+#define	MNT_EXPUBLIC	0x0000000020000000ULL	/* public export (WebNFS) */
+
+/*
+ * Flags set by internal operations,
+ * but visible to the user.
+ * XXX some of these are not quite right.. (I've never seen the root flag set)
+ */
+#define	MNT_LOCAL	0x0000000000001000ULL /* filesystem is stored locally */
+#define	MNT_QUOTA	0x0000000000002000ULL /* quotas are enabled on fs */
+#define	MNT_ROOTFS	0x0000000000004000ULL /* identifies the root fs */
+#define	MNT_USER	0x0000000000008000ULL /* mounted by a user */
+#define	MNT_IGNORE	0x0000000000800000ULL /* do not show entry in df */
+
+/*
+ * Mask of flags that are visible to statfs().
+ * XXX I think that this could now become (~(MNT_CMDFLAGS))
+ * but the 'mount' program may need changing to handle this.
+ */
+#define	MNT_VISFLAGMASK	(MNT_RDONLY	| MNT_SYNCHRONOUS | MNT_NOEXEC	| \
+			MNT_NOSUID	| MNT_UNION	| MNT_SUJ	| \
+			MNT_ASYNC	| MNT_EXRDONLY	| MNT_EXPORTED	| \
+			MNT_DEFEXPORTED	| MNT_EXPORTANON| MNT_EXKERB	| \
+			MNT_LOCAL	| MNT_USER	| MNT_QUOTA	| \
+			MNT_ROOTFS	| MNT_NOATIME	| MNT_NOCLUSTERR| \
+			MNT_NOCLUSTERW	| MNT_SUIDDIR	| MNT_SOFTDEP	| \
+			MNT_IGNORE	| MNT_EXPUBLIC	| MNT_NOSYMFOLLOW | \
+			MNT_GJOURNAL	| MNT_MULTILABEL | MNT_ACLS	| \
+			MNT_NFS4ACLS)
+
+/* Mask of flags that can be updated. */
+#define	MNT_UPDATEMASK (MNT_NOSUID	| MNT_NOEXEC	| \
+			MNT_SYNCHRONOUS	| MNT_UNION	| MNT_ASYNC	| \
+			MNT_NOATIME | \
+			MNT_NOSYMFOLLOW	| MNT_IGNORE	| \
+			MNT_NOCLUSTERR	| MNT_NOCLUSTERW | MNT_SUIDDIR	| \
+			MNT_ACLS	| MNT_USER | MNT_NFS4ACLS)
+
+/*
+ * External filesystem command modifier flags.
+ * Unmount can use the MNT_FORCE flag.
+ * XXX These are not STATES and really should be somewhere else.
+ */
+#define	MNT_UPDATE	0x00010000	/* not a real mount, just an update */
+#define	MNT_DELEXPORT	0x00020000	/* delete export host lists */
+#define	MNT_RELOAD	0x00040000	/* reload filesystem data */
+#define	MNT_FORCE	0x00080000	/* force unmount or readonly change */
+#define	MNT_SNAPSHOT	0x01000000	/* snapshot the filesystem */
+#define	MNT_BYFSID	0x08000000	/* specify filesystem by ID. */
+#define MNT_CMDFLAGS   (MNT_UPDATE	| MNT_DELEXPORT	| MNT_RELOAD	| \
+			MNT_FORCE	| MNT_SNAPSHOT	| MNT_BYFSID)
+/*
+ * Internal filesystem control flags stored in mnt_kern_flag.
+ *
+ * MNTK_UNMOUNT locks the mount entry so that name lookup cannot proceed
+ * past the mount point.  This keeps the subtree stable during mounts
+ * and unmounts.
+ *
+ * MNTK_UNMOUNTF permits filesystems to detect a forced unmount while
+ * dounmount() is still waiting to lock the mountpoint. This allows
+ * the filesystem to cancel operations that might otherwise deadlock
+ * with the unmount attempt (used by NFS).
+ */
+#define MNTK_UNMOUNTF	0x00000001	/* forced unmount in progress */
+#define MNTK_ASYNC      0x00000002      /* filtered async flag */
+#define MNTK_SOFTDEP    0x00000004      /* async disabled by softdep */
+#define MNTK_NOINSMNTQ  0x00000008      /* insmntque is not allowed */
+#define MNTK_UNMOUNT	0x01000000	/* unmount in progress */
+#define	MNTK_MWAIT	0x02000000	/* waiting for unmount to finish */
+#define MNTK_WANTRDWR	0x04000000	/* upgrade to read/write requested */
+#define MNTK_SUSPEND2   0x04000000      /* block secondary writes */
+#define	MNTK_SUSPEND	0x08000000	/* request write suspension */
+#define	MNTK_SUSPENDED	0x10000000	/* write operations are suspended */
+#define MNTK_MPSAFE     0x20000000      /* Filesystem is MPSAFE. */
+#define MNTK_NOKNOTE    0x80000000      /* Don't send KNOTEs from VOP hooks */
+#define MNTK_LOOKUP_SHARED      0x40000000 /* FS supports shared lock lookups */
+
+/*
+ * Sysctl CTL_VFS definitions.
+ *
+ * Second level identifier specifies which filesystem. Second level
+ * identifier VFS_VFSCONF returns information about all filesystems.
+ * Second level identifier VFS_GENERIC is non-terminal.
+ */
+#define	VFS_VFSCONF		0	/* get configured filesystems */
+#define	VFS_GENERIC		0	/* generic filesystem information */
+/*
+ * Third level identifiers for VFS_GENERIC are given below; third
+ * level identifiers for specific filesystems are given in their
+ * mount specific header files.
+ */
+#define VFS_MAXTYPENUM	1	/* int: highest defined filesystem type */
+#define VFS_CONF	2	/* struct: vfsconf for filesystem given
+				   as next argument */
+
+/*
+ * Flags for various system call interfaces.
+ *
+ * waitfor flags to vfs_sync() and getfsstat()
+ */
+#define MNT_WAIT	1	/* synchronously wait for I/O to complete */
+#define MNT_NOWAIT	2	/* start all I/O, but do not wait for it */
+#define MNT_LAZY	3	/* push data not written by filesystem syncer */
+#define	MNT_SUSPEND	4	/* Suspend file system after sync */
+
+/*
+ * Generic file handle
+ */
+struct fhandle {
+	__fsid_t	fh_fsid;	/* Filesystem id of mount point */
+	struct		fid fh_fid;	/* Filesys specific id */
+};
+typedef struct fhandle	fhandle_t;
+
+/*
+ * Old export arguments without security flavor list
+ */
+struct oexport_args {
+	int	ex_flags;		/* export related flags */
+	uid_t	ex_root;		/* mapping for root uid */
+	struct	xucred ex_anon;		/* mapping for anonymous user */
+	struct	sockaddr *ex_addr;	/* net address to which exported */
+	__u_char ex_addrlen;		/* and the net address length */
+	struct	sockaddr *ex_mask;	/* mask of valid bits in saddr */
+	__u_char ex_masklen;		/* and the smask length */
+	char	*ex_indexfile;		/* index file for WebNFS URLs */
+};
+
+/*
+ * Export arguments for local filesystem mount calls.
+ */
+#define	MAXSECFLAVORS	5
+struct export_args {
+	int		ex_flags;		/* export related flags */
+	uid_t		ex_root;		/* mapping for root uid */
+	struct		xucred ex_anon;		/* mapping for anonymous user */
+	struct		sockaddr *ex_addr;	/* net address to which exported */
+	__u_char	ex_addrlen;		/* and the net address length */
+	struct		sockaddr *ex_mask;	/* mask of valid bits in saddr */
+	__u_char	ex_masklen;		/* and the smask length */
+	char		*ex_indexfile;		/* index file for WebNFS URLs */
+	int		ex_numsecflavors;	/* security flavor count */
+	int		ex_secflavors[MAXSECFLAVORS]; /* list of security flavors */
+};
+
+/*
+ * Structure holding information for a publicly exported filesystem
+ * (WebNFS). Currently the specs allow just for one such filesystem.
+ */
+struct nfs_public {
+	int		np_valid;	/* Do we hold valid information */
+	fhandle_t	np_handle;	/* Filehandle for pub fs (internal) */
+	struct mount	*np_mount;	/* Mountpoint of exported fs */
+	char		*np_index;	/* Index file */
+};
+
+/*
+ * Filesystem configuration information. One of these exists for each
+ * type of filesystem supported by the kernel. These are searched at
+ * mount time to identify the requested filesystem.
+ *
+ * XXX: Never change the first two arguments!
+ */
+struct vfsconf {
+	__u_int	vfc_version;		/* ABI version number */
+	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
+	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
+	int	vfc_typenum;		/* historic filesystem type number */
+	int	vfc_refcount;		/* number mounted of this type */
+	int	vfc_flags;		/* permanent flags */
+	struct	vfsoptdecl *vfc_opts;	/* mount options */
+	TAILQ_ENTRY(vfsconf) vfc_list;	/* list of vfscons */
+};
+
+/* Userland version of the struct vfsconf. */
+struct xvfsconf {
+	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
+	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
+	int	vfc_typenum;		/* historic filesystem type number */
+	int	vfc_refcount;		/* number mounted of this type */
+	int	vfc_flags;		/* permanent flags */
+	struct	vfsconf *vfc_next;	/* next in list */
+};
+
+#ifndef BURN_BRIDGES
+struct ovfsconf {
+	void	*vfc_vfsops;
+	char	vfc_name[32];
+	int	vfc_index;
+	int	vfc_refcount;
+	int	vfc_flags;
+};
+#endif
+
+/*
+ * NB: these flags refer to IMPLEMENTATION properties, not properties of
+ * any actual mounts; i.e., it does not make sense to change the flags.
+ */
+#define	VFCF_STATIC	0x00010000	/* statically compiled into kernel */
+#define	VFCF_NETWORK	0x00020000	/* may get data over the network */
+#define	VFCF_READONLY	0x00040000	/* writes are not implemented */
+#define VFCF_SYNTHETIC	0x00080000	/* data does not represent real files */
+#define	VFCF_LOOPBACK	0x00100000	/* aliases some other mounted FS */
+#define	VFCF_UNICODE	0x00200000	/* stores file names as Unicode*/
+#define VFCF_JAIL       0x00400000      /* can be mounted from within a jail */
+
+typedef u_int32_t fsctlop_t;
+
+struct vfsidctl {
+	int		vc_vers;	/* should be VFSIDCTL_VERS1 (below) */
+	__fsid_t	vc_fsid;	/* fsid to operate on. */
+	char		vc_fstypename[MFSNAMELEN];
+					/* type of fs 'nfs' or '*' */
+	fsctlop_t	vc_op;		/* operation VFS_CTL_* (below) */
+	void		*vc_ptr;	/* pointer to data structure. */
+	size_t		vc_len;		/* sizeof said structure. */
+	u_int32_t	vc_spare[12];	/* spare (must be zero). */
+};
+
+/* vfsidctl API version. */
+#define VFS_CTL_VERS1	0x01
+
+/*
+ * New style VFS sysctls, do not reuse/conflict with the namespace for
+ * private sysctls.
+ * All "global" sysctl ops have the 33rd bit set:
+ * 0x...1....
+ * Private sysctl ops should have the 33rd bit unset.
+ */
+#define VFS_CTL_QUERY	0x00010001	/* anything wrong? (vfsquery) */
+#define VFS_CTL_TIMEO	0x00010002	/* set timeout for vfs notification */
+#define VFS_CTL_NOLOCKS	0x00010003	/* disable file locking */
+
+struct vfsquery {
+	u_int32_t	vq_flags;
+	u_int32_t	vq_spare[31];
+};
+
+/* vfsquery flags */
+#define VQ_NOTRESP	0x0001	/* server down */
+#define VQ_NEEDAUTH	0x0002	/* server bad auth */
+#define VQ_LOWDISK	0x0004	/* we're low on space */
+#define VQ_MOUNT	0x0008	/* new filesystem arrived */
+#define VQ_UNMOUNT	0x0010	/* filesystem has left */
+#define VQ_DEAD		0x0020	/* filesystem is dead, needs force unmount */
+#define VQ_ASSIST	0x0040	/* filesystem needs assistance from external
+				   program */
+#define VQ_NOTRESPLOCK	0x0080	/* server lockd down */
+#define VQ_FLAG0100	0x0100	/* placeholder */
+#define VQ_FLAG0200	0x0200	/* placeholder */
+#define VQ_FLAG0400	0x0400	/* placeholder */
+#define VQ_FLAG0800	0x0800	/* placeholder */
+#define VQ_FLAG1000	0x1000	/* placeholder */
+#define VQ_FLAG2000	0x2000	/* placeholder */
+#define VQ_FLAG4000	0x4000	/* placeholder */
+#define VQ_FLAG8000	0x8000	/* placeholder */
+
+
+struct iovec;
+struct uio;
+
+__BEGIN_DECLS
+
+/* Mounting and unmounting filesystems.  */
+int	mount(const char *, const char *, int, void *);
+int	nmount(struct iovec *, unsigned int, int);
+int	unmount(const char *, int);
+
+/*
+ * Copyright (c) 1995
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Given a filesystem name, determine if it is resident in the kernel,
+ * and if it is resident, return its xvfsconf structure.
+ */
+static __inline int
+getvfsbyname(const char *fsname, struct xvfsconf *vfcp)
+{
+	struct xvfsconf *xvfsp;
+	size_t buflen;
+	int cnt, i;
+
+	if (sysctlbyname("vfs.conflist", NULL, &buflen, NULL, 0) < 0)
+		return (-1);
+	xvfsp = (struct xvfsconf *) malloc(buflen);
+	if (xvfsp == NULL)
+		return (-1);
+	if (sysctlbyname("vfs.conflist", xvfsp, &buflen, NULL, 0) < 0) {
+		free(xvfsp);
+		return (-1);
+	}
+	cnt = buflen / sizeof(struct xvfsconf);
+	for (i = 0; i < cnt; i++) {
+		if (strcmp(fsname, xvfsp[i].vfc_name) == 0) {
+			memcpy(vfcp, xvfsp + i, sizeof(struct xvfsconf));
+			free(xvfsp);
+			return (0);
+		}
+	}
+	free(xvfsp);
+	errno = ENOENT;
+	return (-1);
+}
+
+/* getfsstat() appears in BSD 4.4.  A variant of this API is found on OSF/1,
+   but on that system the user also needs to include <sys/fs_types.h>.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern int getfsstat (struct statfs *__buf, long __bufsize,
+		      int __flags) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (getfsstat,
+		       (struct statfs *__buf, long __bufsize, int __flags),
+		       getfsstat64);
+# else
+#  define getfsstat getfsstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getfsstat64 (struct statfs64 *__buf, long __bufsize,
+			int __flags) __THROW;
+#endif
+
+#ifdef _LIBC
+extern int __getfsstat (struct statfs *__buf, long __bufsize, int __flags);
+extern int __getfsstat64 (struct statfs64 *__buf, long __bufsize, int __flags);
+#endif
+
+/* getmntinfo() appears in BSD 4.4.  */
+
+#ifndef __USE_FILE_OFFSET64
+extern int getmntinfo (struct statfs **__mntbufp, int __flags) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (getmntinfo,
+		       (struct statfs **__mntbufp, int __flags),
+		       getmntinfo64);
+# else
+#  define getmntinfo getmntinfo64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int getmntinfo64 (struct statfs64 **__mntbufp, int __flags) __THROW;
+#endif
+
+#ifdef _LIBC
+extern int __getmntinfo (struct statfs **__mntbufp, int __flags);
+#endif
+
+__END_DECLS
+
+
+/* Opening files on specified mounted filesystems.
+   These system calls are reserved to the superuser, for security reasons.  */
+
+__BEGIN_DECLS
+
+/* Return in *FHP the file handle corresponding to the file or directory
+   PATH.  */
+extern int getfh (__const char *__path, fhandle_t *__fhp) __THROW;
+
+/* Return in *FHP the file handle corresponding to the file or directory
+   PATH.  */
+extern int lgetfh (__const char *__path, fhandle_t *__fhp) __THROW;
+
+/* Open a file handle *FHP, using the open() like FLAGS.  Return the
+   new file descriptor.  */
+extern int fhopen (__const fhandle_t *__fhp, int __flags) __THROW;
+
+/* Get file attributes for the file whose handle is *FHP, and return them
+   in *BUF.  Like fhopen + fstat + close.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fhstat (__const fhandle_t *__fhp, struct stat *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fhstat,
+		       (__const fhandle_t *__fhp, struct stat *__buf),
+		       fhstat64);
+# else
+#  define fhstat fhstat64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fhstat64 (__const fhandle_t *__fhp, struct stat64 *__buf) __THROW;
+#endif
+
+/* Return information about the filesystem on which the file resides whose
+   handle is *FHP.  Like fhopen + fstatfs + close.  */
+#ifndef __USE_FILE_OFFSET64
+extern int fhstatfs (__const fhandle_t *__fhp, struct statfs *__buf) __THROW;
+#else
+# ifdef __REDIRECT
+extern int __REDIRECT (fhstatfs,
+		       (__const fhandle_t *__fhp, struct statfs *__buf),
+		       fhstatfs64);
+# else
+#  define fhstatfs fhstatfs64
+# endif
+#endif
+#ifdef __USE_LARGEFILE64
+extern int fhstatfs64 (__const fhandle_t *__fhp,
+		       struct statfs64 *__buf) __THROW;
+#endif
+
+__END_DECLS
+
+#endif /* _SYS_MOUNT_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ptrace.h
@@ -0,0 +1,121 @@
+/*-
+ * Copyright (c) 1984, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ptrace.h	8.2 (Berkeley) 1/4/94
+ * $FreeBSD: src/sys/sys/ptrace.h,v 1.28.10.1.2.1 2009/10/25 01:10:29 kensmith Exp $
+ */
+ 
+#ifndef _SYS_PTRACE_H
+#define _SYS_PTRACE_H	1
+
+#include <features.h>
+
+#include <signal.h>
+#include <sys/kern/param.h>
+#include <machine/reg.h>
+
+__BEGIN_DECLS
+
+#define	PT_TRACE_ME	0	/* child declares it's being traced */
+#define	PT_READ_I	1	/* read word in child's I space */
+#define	PT_READ_D	2	/* read word in child's D space */
+/* was	PT_READ_U	3	 * read word in child's user structure */
+#define	PT_WRITE_I	4	/* write word in child's I space */
+#define	PT_WRITE_D	5	/* write word in child's D space */
+/* was	PT_WRITE_U	6	 * write word in child's user structure */
+#define	PT_CONTINUE	7	/* continue the child */
+#define	PT_KILL		8	/* kill the child process */
+#define	PT_STEP		9	/* single step the child */
+
+#define	PT_ATTACH	10	/* trace some running process */
+#define	PT_DETACH	11	/* stop tracing a process */
+#define PT_IO		12	/* do I/O to/from stopped process. */
+
+#define	PT_LWPINFO	13	/* Info about the LWP that stopped. */
+#define PT_GETNUMLWPS	14	/* get total number of threads */
+#define PT_GETLWPLIST	15	/* get thread list */
+
+#define PT_CLEARSTEP	16	/* turn off single step */
+#define PT_SETSTEP	17	/* turn on single step */
+#define PT_SUSPEND	18	/* suspend a thread */
+#define PT_RESUME	19	/* resume a thread */
+
+#define	PT_TO_SCE	20
+#define	PT_TO_SCX	21
+#define	PT_SYSCALL	22
+
+#define PT_GETREGS      33	/* get general-purpose registers */
+#define PT_SETREGS      34	/* set general-purpose registers */
+#define PT_GETFPREGS    35	/* get floating-point registers */
+#define PT_SETFPREGS    36	/* set floating-point registers */
+#define PT_GETDBREGS    37	/* get debugging registers */
+#define PT_SETDBREGS    38	/* set debugging registers */
+#define PT_FIRSTMACH    64	/* for machine-specific requests */
+
+struct ptrace_io_desc {
+	int	piod_op;	/* I/O operation */
+	void	*piod_offs;	/* child offset */
+	void	*piod_addr;	/* parent offset */
+	size_t	piod_len;	/* request length */
+};
+
+/*
+ * Operations in piod_op.
+ */
+#define PIOD_READ_D	1	/* Read from D space */
+#define PIOD_WRITE_D	2	/* Write to D space */
+#define PIOD_READ_I	3	/* Read from I space */
+#define PIOD_WRITE_I	4	/* Write to I space */
+
+/* Argument structure for PT_LWPINFO. */
+struct ptrace_lwpinfo {
+	__lwpid_t	pl_lwpid;	/* LWP described. */
+	int	pl_event;	/* Event that stopped the LWP. */
+#define	PL_EVENT_NONE	0
+#define	PL_EVENT_SIGNAL	1
+	int	pl_flags;	/* LWP flags. */
+#define	PL_FLAG_SA	0x01	/* M:N thread */
+#define	PL_FLAG_BOUND	0x02	/* M:N bound thread */
+#define	PL_FLAG_SCE	0x04	/* syscall enter point */
+#define	PL_FLAG_SCX	0x08	/* syscall leave point */
+#define	PL_FLAG_EXEC	0x10	/* exec(2) succeeded */
+#define	PL_FLAG_SI	0x20	/* siginfo is valid */
+#define	PL_FLAG_FORKED	0x40	/* new child */
+#define	PL_FLAG_CHILD	0x80	/* I am from child */
+	sigset_t	pl_sigmask;	/* LWP signal mask */
+	sigset_t	pl_siglist;	/* LWP pending signal */
+	struct siginfo	pl_siginfo;	/* siginfo for signal */
+	char		pl_tdname[MAXCOMLEN + 1]; /* LWP name */
+	int		pl_child_pid;	/* New child pid */
+};
+
+extern int ptrace(int _request, pid_t _pid, caddr_t _addr, int _data) __THROW;
+
+__END_DECLS
+
+#endif /* _SYS_PTRACE_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/reboot.h
@@ -0,0 +1,81 @@
+/*-
+ * Copyright (c) 1982, 1986, 1988, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)reboot.h	8.3 (Berkeley) 12/13/94
+ * $FreeBSD: src/sys/sys/reboot.h,v 1.26.18.1 2008/11/25 02:59:29 kensmith Exp $
+ */
+
+#ifndef _SYS_REBOOT_H_
+#define	_SYS_REBOOT_H_	1
+
+#include <features.h>
+
+/*
+ * Arguments to reboot system call.  These are passed to
+ * the boot program and on to init.
+ */
+#define	RB_AUTOBOOT	0	/* flags for system auto-booting itself */
+
+#define	RB_ASKNAME	0x001	/* ask for file name to reboot from */
+#define	RB_SINGLE	0x002	/* reboot to single user only */
+#define	RB_NOSYNC	0x004	/* dont sync before reboot */
+#define	RB_HALT		0x008	/* don't reboot, just halt */
+#define	RB_INITNAME	0x010	/* name given for /etc/init (unused) */
+#define	RB_DFLTROOT	0x020	/* use compiled-in rootdev */
+#define	RB_KDB		0x040	/* give control to kernel debugger */
+#define	RB_RDONLY	0x080	/* mount root fs read-only */
+#define	RB_DUMP		0x100	/* dump kernel memory before reboot */
+#define	RB_MINIROOT	0x200	/* mini-root present in memory at boot time */
+#define	RB_VERBOSE	0x800	/* print all potentially useful info */
+#define	RB_SERIAL	0x1000	/* use serial port as console */
+#define	RB_CDROM	0x2000	/* use cdrom as root */
+#define	RB_POWEROFF	0x4000	/* turn the power off if possible */
+#define	RB_GDB		0x8000	/* use GDB remote debugger instead of DDB */
+#define	RB_MUTE		0x10000	/* start up with the console muted */
+#define	RB_SELFTEST	0x20000	/* don't complete the boot; do selftest */
+#define	RB_RESERVED1	0x40000	/* reserved for internal use of boot blocks */
+#define	RB_RESERVED2	0x80000	/* reserved for internal use of boot blocks */
+#define	RB_PAUSE	0x100000 /* pause after each output line during probe */
+#define	RB_MULTIPLE	0x20000000	/* use multiple consoles */
+
+#define	RB_BOOTINFO	0x80000000	/* have `struct bootinfo *' arg */
+
+/* 
+ * Compatibility with Linux
+ */
+#define RB_HALT_SYSTEM	RB_HALT
+#define RB_POWER_OFF	RB_POWEROFF
+
+__BEGIN_DECLS
+
+/* Reboot or halt the system.  */
+extern int reboot (int __howto) __THROW;
+
+__END_DECLS
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/rfork.h
@@ -0,0 +1,98 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)unistd.h	8.2 (Berkeley) 1/7/94
+ * $FreeBSD: src/sys/sys/unistd.h,v 1.22.2.1 2000/03/18 23:20:12 jasone Exp $
+ */
+
+#ifndef _SYS_RFORK_H
+#define _SYS_RFORK_H
+
+#include <features.h>
+
+/*
+ * rfork() options.
+ *
+ * XXX currently, operations without RFPROC set are not supported.
+ */
+#define RFNAMEG		(1<<0)  /* UNIMPL new plan9 `name space' */
+#define RFENVG		(1<<1)  /* UNIMPL copy plan9 `env space' */
+#define RFFDG		(1<<2)  /* copy fd table */
+#define RFNOTEG		(1<<3)  /* UNIMPL create new plan9 `note group' */
+#define RFPROC		(1<<4)  /* change child (else changes curproc) */
+#define RFMEM		(1<<5)  /* share `address space' */
+#define RFNOWAIT	(1<<6)  /* parent need not wait() on child */
+#define RFCNAMEG	(1<<10) /* UNIMPL zero plan9 `name space' */
+#define RFCENVG		(1<<11) /* UNIMPL zero plan9 `env space' */
+#define RFCFDG		(1<<12) /* zero fd table */
+#define RFTHREAD	(1<<13)	/* enable kernel thread support */
+#define RFSIGSHARE	(1<<14)	/* share signal handlers */
+#define RFLINUXTHPN     (1<<16) /* do linux clone exit parent notification */
+#define	RFSTOPPED	(1<<17) /* leave child in a stopped state */
+#define	RFHIGHPID	(1<<18) /* use a pid higher than 10 (idleproc) */
+#define	RFTSIGZMB	(1<<19) /* select signal for exit parent notification */
+#define	RFTSIGSHIFT	20      /* selected signal number is in bits 20-27  */
+#define	RFTSIGMASK	0xFF
+#define	RFTSIGNUM(flags)	(((flags) >> RFTSIGSHIFT) & RFTSIGMASK)
+#define	RFTSIGFLAGS(signum)	((signum) << RFTSIGSHIFT)
+#define RFPPWAIT	(1<<31) /* parent sleeps until child exits (vfork) */
+
+#define RFTHPNSHIFT	24	/* reserve bits 24-30 */
+#define RFTHPNMASK	0x7F    /* for compatibility with linuxthreads/clone()   */
+				/* allow to specify  "clone exit parent notification" signal */
+#define RFTHPNSIGNUM(flags)	(((flags) >> RFTHPNSHIFT) & RFTHPNMASK)
+
+__BEGIN_DECLS
+
+extern int rfork (int __flags) __THROW;
+
+#ifdef _LIBC
+extern int __rfork (int __flags);
+#endif
+
+__END_DECLS
+
+#endif /* _SYS_RFORK_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/socketvar.h
@@ -0,0 +1,189 @@
+/* This header is used on many systems but for GNU we have 
+   almost everything defined in the standard header.  */
+
+#include <sys/socket.h>
+
+/*-
+ * Copyright (c) 1982, 1986, 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)socketvar.h	8.3 (Berkeley) 2/19/95
+ *
+ * $FreeBSD: src/sys/sys/socketvar.h,v 1.171.2.1.2.1 2009/10/25 01:10:29 kensmith Exp $
+ */
+
+#ifndef _SYS_SOCKETVAR_H_
+#define _SYS_SOCKETVAR_H_
+
+#include <sys/queue.h>			/* for TAILQ macros */
+#include <sys/selinfo.h>		/* for struct selinfo */
+#include <sys/_lock.h>
+#include <sys/_mutex.h>
+#include <sys/_sx.h>
+
+struct socket;
+struct vnet;
+
+struct	xsockbuf {
+	u_int	sb_cc;
+	u_int	sb_hiwat;
+	u_int	sb_mbcnt;
+	u_int   sb_mcnt;
+	u_int   sb_ccnt;
+	u_int	sb_mbmax;
+	int	sb_lowat;
+	int	sb_timeo;
+	short	sb_flags;
+};
+
+/*
+ * Variables for socket buffering.
+ */
+struct	sockbuf {
+	struct	selinfo sb_sel;	/* process selecting read/write */
+	struct	mtx sb_mtx;	/* sockbuf lock */
+	struct	sx sb_sx;	/* prevent I/O interlacing */
+	short	sb_state;	/* (c/d) socket state on sockbuf */
+#define	sb_startzero	sb_mb
+	struct	mbuf *sb_mb;	/* (c/d) the mbuf chain */
+	struct	mbuf *sb_mbtail; /* (c/d) the last mbuf in the chain */
+	struct	mbuf *sb_lastrecord;	/* (c/d) first mbuf of last
+					 * record in socket buffer */
+	struct	mbuf *sb_sndptr; /* (c/d) pointer into mbuf chain */
+	u_int	sb_sndptroff;	/* (c/d) byte offset of ptr into chain */
+	u_int	sb_cc;		/* (c/d) actual chars in buffer */
+	u_int	sb_hiwat;	/* (c/d) max actual char count */
+	u_int	sb_mbcnt;	/* (c/d) chars of mbufs used */
+	u_int   sb_mcnt;        /* (c/d) number of mbufs in buffer */
+	u_int   sb_ccnt;        /* (c/d) number of clusters in buffer */
+	u_int	sb_mbmax;	/* (c/d) max chars of mbufs to use */
+	u_int	sb_ctl;		/* (c/d) non-data chars in buffer */
+	int	sb_lowat;	/* (c/d) low water mark */
+	int	sb_timeo;	/* (c/d) timeout for read/write */
+	short	sb_flags;	/* (c/d) flags, see below */
+	int	(*sb_upcall)(struct socket *, void *, int); /* (c/d) */
+	void	*sb_upcallarg;	/* (c/d) */
+};
+
+
+/*
+ * Kernel structure per socket.
+ * Contains send and receive buffer queues,
+ * handle on protocol and pointer to protocol
+ * private data and error information.
+ */
+typedef	u_quad_t so_gen_t;
+
+
+/*-
+ * Locking key to struct socket:
+ * (a) constant after allocation, no locking required.
+ * (b) locked by SOCK_LOCK(so).
+ * (c) locked by SOCKBUF_LOCK(&so->so_rcv).
+ * (d) locked by SOCKBUF_LOCK(&so->so_snd).
+ * (e) locked by ACCEPT_LOCK().
+ * (f) not locked since integer reads/writes are atomic.
+ * (g) used only as a sleep/wakeup address, no value.
+ * (h) locked by global mutex so_global_mtx.
+ */
+struct socket {
+	int	so_count;		/* (b) reference count */
+	short	so_type;		/* (a) generic type, see socket.h */
+	short	so_options;		/* from socket call, see socket.h */
+	short	so_linger;		/* time to linger while closing */
+	short	so_state;		/* (b) internal state flags SS_* */
+	int	so_qstate;		/* (e) internal state flags SQ_* */
+	void	*so_pcb;		/* protocol control block */
+	struct	vnet *so_vnet;		/* network stack instance */
+	struct	protosw *so_proto;	/* (a) protocol handle */
+/*
+ * Variables for connection queuing.
+ * Socket where accepts occur is so_head in all subsidiary sockets.
+ * If so_head is 0, socket is not related to an accept.
+ * For head socket so_incomp queues partially completed connections,
+ * while so_comp is a queue of connections ready to be accepted.
+ * If a connection is aborted and it has so_head set, then
+ * it has to be pulled out of either so_incomp or so_comp.
+ * We allow connections to queue up based on current queue lengths
+ * and limit on number of queued connections for this socket.
+ */
+	struct	socket *so_head;	/* (e) back pointer to listen socket */
+	TAILQ_HEAD(, socket) so_incomp;	/* (e) queue of partial unaccepted connections */
+	TAILQ_HEAD(, socket) so_comp;	/* (e) queue of complete unaccepted connections */
+	TAILQ_ENTRY(socket) so_list;	/* (e) list of unaccepted connections */
+	u_short	so_qlen;		/* (e) number of unaccepted connections */
+	u_short	so_incqlen;		/* (e) number of unaccepted incomplete
+					   connections */
+	u_short	so_qlimit;		/* (e) max number queued connections */
+	short	so_timeo;		/* (g) connection timeout */
+	u_short	so_error;		/* (f) error affecting connection */
+	struct	sigio *so_sigio;	/* [sg] information for async I/O or
+					   out of band data (SIGURG) */
+	u_long	so_oobmark;		/* (c) chars to oob mark */
+	TAILQ_HEAD(, aiocblist) so_aiojobq; /* AIO ops waiting on socket */
+
+	struct sockbuf so_rcv, so_snd;
+
+	struct	ucred *so_cred;		/* (a) user credentials */
+	struct	label *so_label;	/* (b) MAC label for socket */
+	struct	label *so_peerlabel;	/* (b) cached MAC label for peer */
+	/* NB: generation count must not be first. */
+	so_gen_t so_gencnt;		/* (h) generation count */
+	void	*so_emuldata;		/* (b) private data for emulators */
+ 	struct so_accf {
+		struct	accept_filter *so_accept_filter;
+		void	*so_accept_filter_arg;	/* saved filter args */
+		char	*so_accept_filter_str;	/* saved user args */
+	} *so_accf;
+	int so_fibnum;		/* routing domain for this socket */
+};
+
+/*
+ * Externalized form of struct socket used by the sysctl(3) interface.
+ */
+struct xsocket {
+	size_t	xso_len;	/* length of this structure */
+	struct	socket *xso_so;	/* makes a convenient handle sometimes */
+	short	so_type;
+	short	so_options;
+	short	so_linger;
+	short	so_state;
+	caddr_t	so_pcb;		/* another convenient handle */
+	int	xso_protocol;
+	int	xso_family;
+	u_short	so_qlen;
+	u_short	so_incqlen;
+	u_short	so_qlimit;
+	short	so_timeo;
+	u_short	so_error;
+	pid_t	so_pgid;
+	u_long	so_oobmark;
+	struct xsockbuf so_rcv, so_snd;
+	uid_t	so_uid;		/* XXX */
+};
+
+#endif /* !_SYS_SOCKETVAR_H_ */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/swap.h
@@ -0,0 +1,37 @@
+/* Calls to enable swapping on specified locations.  FreeBSD version.
+   Copyright (C) 1996-1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __SYS_SWAP_H
+
+#define __SYS_SWAP_H	1
+#include <features.h>
+
+
+__BEGIN_DECLS
+
+/* Make the block special device PATH available to the system for swapping.
+   This call is restricted to the super-user.  */
+extern int swapon (__const char *__path) __THROW;
+
+/* Stop using block special device PATH for swapping.  */
+extern int swapoff (__const char *__path) __THROW;
+
+__END_DECLS
+
+#endif /* sys/swap.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/syscall.h
@@ -0,0 +1,502 @@
+#ifndef _SYSCALL_H
+#define _SYSCALL_H	1
+
+/*
+ * System call numbers.
+ *
+ * DO NOT EDIT-- this file is automatically generated.
+ * $FreeBSD$
+ * created from FreeBSD: head/sys/kern/syscalls.master 250853 2013-05-21 11:40:16Z kib 
+ */
+
+#define	SYS_syscall	0
+#define	SYS_exit	1
+#define	SYS_fork	2
+#define	SYS_read	3
+#define	SYS_write	4
+#define	SYS_open	5
+#define	SYS_close	6
+#define	SYS_wait4	7
+				/* 8 is old creat */
+#define	SYS_link	9
+#define	SYS_unlink	10
+				/* 11 is obsolete execv */
+#define	SYS_chdir	12
+#define	SYS_fchdir	13
+#define	SYS_mknod	14
+#define	SYS_chmod	15
+#define	SYS_chown	16
+#define	SYS_break	17
+#define	SYS_freebsd4_getfsstat	18
+				/* 19 is old lseek */
+#define	SYS_getpid	20
+#define	SYS_mount	21
+#define	SYS_unmount	22
+#define	SYS_setuid	23
+#define	SYS_getuid	24
+#define	SYS_geteuid	25
+#define	SYS_ptrace	26
+#define	SYS_recvmsg	27
+#define	SYS_sendmsg	28
+#define	SYS_recvfrom	29
+#define	SYS_accept	30
+#define	SYS_getpeername	31
+#define	SYS_getsockname	32
+#define	SYS_access	33
+#define	SYS_chflags	34
+#define	SYS_fchflags	35
+#define	SYS_sync	36
+#define	SYS_kill	37
+				/* 38 is old stat */
+#define	SYS_getppid	39
+				/* 40 is old lstat */
+#define	SYS_dup	41
+#define	SYS_pipe	42
+#define	SYS_getegid	43
+#define	SYS_profil	44
+#define	SYS_ktrace	45
+				/* 46 is old sigaction */
+#define	SYS_getgid	47
+				/* 48 is old sigprocmask */
+#define	SYS_getlogin	49
+#define	SYS_setlogin	50
+#define	SYS_acct	51
+				/* 52 is old sigpending */
+#define	SYS_sigaltstack	53
+#define	SYS_ioctl	54
+#define	SYS_reboot	55
+#define	SYS_revoke	56
+#define	SYS_symlink	57
+#define	SYS_readlink	58
+#define	SYS_execve	59
+#define	SYS_umask	60
+#define	SYS_chroot	61
+				/* 62 is old fstat */
+				/* 63 is old getkerninfo */
+				/* 64 is old getpagesize */
+#define	SYS_msync	65
+#define	SYS_vfork	66
+				/* 67 is obsolete vread */
+				/* 68 is obsolete vwrite */
+#define	SYS_sbrk	69
+#define	SYS_sstk	70
+				/* 71 is old mmap */
+#define	SYS_vadvise	72
+#define	SYS_munmap	73
+#define	SYS_mprotect	74
+#define	SYS_madvise	75
+				/* 76 is obsolete vhangup */
+				/* 77 is obsolete vlimit */
+#define	SYS_mincore	78
+#define	SYS_getgroups	79
+#define	SYS_setgroups	80
+#define	SYS_getpgrp	81
+#define	SYS_setpgid	82
+#define	SYS_setitimer	83
+				/* 84 is old wait */
+#define	SYS_swapon	85
+#define	SYS_getitimer	86
+				/* 87 is old gethostname */
+				/* 88 is old sethostname */
+#define	SYS_getdtablesize	89
+#define	SYS_dup2	90
+#define	SYS_fcntl	92
+#define	SYS_select	93
+#define	SYS_fsync	95
+#define	SYS_setpriority	96
+#define	SYS_socket	97
+#define	SYS_connect	98
+				/* 99 is old accept */
+#define	SYS_getpriority	100
+				/* 101 is old send */
+				/* 102 is old recv */
+				/* 103 is old sigreturn */
+#define	SYS_bind	104
+#define	SYS_setsockopt	105
+#define	SYS_listen	106
+				/* 107 is obsolete vtimes */
+				/* 108 is old sigvec */
+				/* 109 is old sigblock */
+				/* 110 is old sigsetmask */
+				/* 111 is old sigsuspend */
+				/* 112 is old sigstack */
+				/* 113 is old recvmsg */
+				/* 114 is old sendmsg */
+				/* 115 is obsolete vtrace */
+#define	SYS_gettimeofday	116
+#define	SYS_getrusage	117
+#define	SYS_getsockopt	118
+#define	SYS_readv	120
+#define	SYS_writev	121
+#define	SYS_settimeofday	122
+#define	SYS_fchown	123
+#define	SYS_fchmod	124
+				/* 125 is old recvfrom */
+#define	SYS_setreuid	126
+#define	SYS_setregid	127
+#define	SYS_rename	128
+				/* 129 is old truncate */
+				/* 130 is old ftruncate */
+#define	SYS_flock	131
+#define	SYS_mkfifo	132
+#define	SYS_sendto	133
+#define	SYS_shutdown	134
+#define	SYS_socketpair	135
+#define	SYS_mkdir	136
+#define	SYS_rmdir	137
+#define	SYS_utimes	138
+				/* 139 is obsolete 4.2 sigreturn */
+#define	SYS_adjtime	140
+				/* 141 is old getpeername */
+				/* 142 is old gethostid */
+				/* 143 is old sethostid */
+				/* 144 is old getrlimit */
+				/* 145 is old setrlimit */
+				/* 146 is old killpg */
+#define	SYS_setsid	147
+#define	SYS_quotactl	148
+				/* 149 is old quota */
+				/* 150 is old getsockname */
+#define	SYS_nlm_syscall	154
+#define	SYS_nfssvc	155
+				/* 156 is old getdirentries */
+#define	SYS_freebsd4_statfs	157
+#define	SYS_freebsd4_fstatfs	158
+#define	SYS_lgetfh	160
+#define	SYS_getfh	161
+#define	SYS_freebsd4_getdomainname	162
+#define	SYS_freebsd4_setdomainname	163
+#define	SYS_freebsd4_uname	164
+#define	SYS_sysarch	165
+#define	SYS_rtprio	166
+#define	SYS_semsys	169
+#define	SYS_msgsys	170
+#define	SYS_shmsys	171
+#define	SYS_freebsd6_pread	173
+#define	SYS_freebsd6_pwrite	174
+#define	SYS_setfib	175
+#define	SYS_ntp_adjtime	176
+#define	SYS_setgid	181
+#define	SYS_setegid	182
+#define	SYS_seteuid	183
+#define	SYS_stat	188
+#define	SYS_fstat	189
+#define	SYS_lstat	190
+#define	SYS_pathconf	191
+#define	SYS_fpathconf	192
+#define	SYS_getrlimit	194
+#define	SYS_setrlimit	195
+#define	SYS_getdirentries	196
+#define	SYS_freebsd6_mmap	197
+#define	SYS___syscall	198
+#define	SYS_freebsd6_lseek	199
+#define	SYS_freebsd6_truncate	200
+#define	SYS_freebsd6_ftruncate	201
+#define	SYS___sysctl	202
+#define	SYS_mlock	203
+#define	SYS_munlock	204
+#define	SYS_undelete	205
+#define	SYS_futimes	206
+#define	SYS_getpgid	207
+#define	SYS_poll	209
+#define	SYS_freebsd7___semctl	220
+#define	SYS_semget	221
+#define	SYS_semop	222
+#define	SYS_freebsd7_msgctl	224
+#define	SYS_msgget	225
+#define	SYS_msgsnd	226
+#define	SYS_msgrcv	227
+#define	SYS_shmat	228
+#define	SYS_freebsd7_shmctl	229
+#define	SYS_shmdt	230
+#define	SYS_shmget	231
+#define	SYS_clock_gettime	232
+#define	SYS_clock_settime	233
+#define	SYS_clock_getres	234
+#define	SYS_ktimer_create	235
+#define	SYS_ktimer_delete	236
+#define	SYS_ktimer_settime	237
+#define	SYS_ktimer_gettime	238
+#define	SYS_ktimer_getoverrun	239
+#define	SYS_nanosleep	240
+#define	SYS_ffclock_getcounter	241
+#define	SYS_ffclock_setestimate	242
+#define	SYS_ffclock_getestimate	243
+#define	SYS_clock_getcpuclockid2	247
+#define	SYS_ntp_gettime	248
+#define	SYS_minherit	250
+#define	SYS_rfork	251
+#define	SYS_openbsd_poll	252
+#define	SYS_issetugid	253
+#define	SYS_lchown	254
+#define	SYS_aio_read	255
+#define	SYS_aio_write	256
+#define	SYS_lio_listio	257
+#define	SYS_getdents	272
+#define	SYS_lchmod	274
+#define	SYS_netbsd_lchown	275
+#define	SYS_lutimes	276
+#define	SYS_netbsd_msync	277
+#define	SYS_nstat	278
+#define	SYS_nfstat	279
+#define	SYS_nlstat	280
+#define	SYS_preadv	289
+#define	SYS_pwritev	290
+#define	SYS_freebsd4_fhstatfs	297
+#define	SYS_fhopen	298
+#define	SYS_fhstat	299
+#define	SYS_modnext	300
+#define	SYS_modstat	301
+#define	SYS_modfnext	302
+#define	SYS_modfind	303
+#define	SYS_kldload	304
+#define	SYS_kldunload	305
+#define	SYS_kldfind	306
+#define	SYS_kldnext	307
+#define	SYS_kldstat	308
+#define	SYS_kldfirstmod	309
+#define	SYS_getsid	310
+#define	SYS_setresuid	311
+#define	SYS_setresgid	312
+				/* 313 is obsolete signanosleep */
+#define	SYS_aio_return	314
+#define	SYS_aio_suspend	315
+#define	SYS_aio_cancel	316
+#define	SYS_aio_error	317
+#define	SYS_oaio_read	318
+#define	SYS_oaio_write	319
+#define	SYS_olio_listio	320
+#define	SYS_yield	321
+				/* 322 is obsolete thr_sleep */
+				/* 323 is obsolete thr_wakeup */
+#define	SYS_mlockall	324
+#define	SYS_munlockall	325
+#define	SYS___getcwd	326
+#define	SYS_sched_setparam	327
+#define	SYS_sched_getparam	328
+#define	SYS_sched_setscheduler	329
+#define	SYS_sched_getscheduler	330
+#define	SYS_sched_yield	331
+#define	SYS_sched_get_priority_max	332
+#define	SYS_sched_get_priority_min	333
+#define	SYS_sched_rr_get_interval	334
+#define	SYS_utrace	335
+#define	SYS_freebsd4_sendfile	336
+#define	SYS_kldsym	337
+#define	SYS_jail	338
+#define	SYS_nnpfs_syscall	339
+#define	SYS_sigprocmask	340
+#define	SYS_sigsuspend	341
+#define	SYS_freebsd4_sigaction	342
+#define	SYS_sigpending	343
+#define	SYS_freebsd4_sigreturn	344
+#define	SYS_sigtimedwait	345
+#define	SYS_sigwaitinfo	346
+#define	SYS___acl_get_file	347
+#define	SYS___acl_set_file	348
+#define	SYS___acl_get_fd	349
+#define	SYS___acl_set_fd	350
+#define	SYS___acl_delete_file	351
+#define	SYS___acl_delete_fd	352
+#define	SYS___acl_aclcheck_file	353
+#define	SYS___acl_aclcheck_fd	354
+#define	SYS_extattrctl	355
+#define	SYS_extattr_set_file	356
+#define	SYS_extattr_get_file	357
+#define	SYS_extattr_delete_file	358
+#define	SYS_aio_waitcomplete	359
+#define	SYS_getresuid	360
+#define	SYS_getresgid	361
+#define	SYS_kqueue	362
+#define	SYS_kevent	363
+#define	SYS_extattr_set_fd	371
+#define	SYS_extattr_get_fd	372
+#define	SYS_extattr_delete_fd	373
+#define	SYS___setugid	374
+#define	SYS_eaccess	376
+#define	SYS_afs3_syscall	377
+#define	SYS_nmount	378
+#define	SYS___mac_get_proc	384
+#define	SYS___mac_set_proc	385
+#define	SYS___mac_get_fd	386
+#define	SYS___mac_get_file	387
+#define	SYS___mac_set_fd	388
+#define	SYS___mac_set_file	389
+#define	SYS_kenv	390
+#define	SYS_lchflags	391
+#define	SYS_uuidgen	392
+#define	SYS_sendfile	393
+#define	SYS_mac_syscall	394
+#define	SYS_getfsstat	395
+#define	SYS_statfs	396
+#define	SYS_fstatfs	397
+#define	SYS_fhstatfs	398
+#define	SYS_ksem_close	400
+#define	SYS_ksem_post	401
+#define	SYS_ksem_wait	402
+#define	SYS_ksem_trywait	403
+#define	SYS_ksem_init	404
+#define	SYS_ksem_open	405
+#define	SYS_ksem_unlink	406
+#define	SYS_ksem_getvalue	407
+#define	SYS_ksem_destroy	408
+#define	SYS___mac_get_pid	409
+#define	SYS___mac_get_link	410
+#define	SYS___mac_set_link	411
+#define	SYS_extattr_set_link	412
+#define	SYS_extattr_get_link	413
+#define	SYS_extattr_delete_link	414
+#define	SYS___mac_execve	415
+#define	SYS_sigaction	416
+#define	SYS_sigreturn	417
+#define	SYS_getcontext	421
+#define	SYS_setcontext	422
+#define	SYS_swapcontext	423
+#define	SYS_swapoff	424
+#define	SYS___acl_get_link	425
+#define	SYS___acl_set_link	426
+#define	SYS___acl_delete_link	427
+#define	SYS___acl_aclcheck_link	428
+#define	SYS_sigwait	429
+#define	SYS_thr_create	430
+#define	SYS_thr_exit	431
+#define	SYS_thr_self	432
+#define	SYS_thr_kill	433
+#define	SYS__umtx_lock	434
+#define	SYS__umtx_unlock	435
+#define	SYS_jail_attach	436
+#define	SYS_extattr_list_fd	437
+#define	SYS_extattr_list_file	438
+#define	SYS_extattr_list_link	439
+#define	SYS_ksem_timedwait	441
+#define	SYS_thr_suspend	442
+#define	SYS_thr_wake	443
+#define	SYS_kldunloadf	444
+#define	SYS_audit	445
+#define	SYS_auditon	446
+#define	SYS_getauid	447
+#define	SYS_setauid	448
+#define	SYS_getaudit	449
+#define	SYS_setaudit	450
+#define	SYS_getaudit_addr	451
+#define	SYS_setaudit_addr	452
+#define	SYS_auditctl	453
+#define	SYS__umtx_op	454
+#define	SYS_thr_new	455
+#define	SYS_sigqueue	456
+#define	SYS_kmq_open	457
+#define	SYS_kmq_setattr	458
+#define	SYS_kmq_timedreceive	459
+#define	SYS_kmq_timedsend	460
+#define	SYS_kmq_notify	461
+#define	SYS_kmq_unlink	462
+#define	SYS_abort2	463
+#define	SYS_thr_set_name	464
+#define	SYS_aio_fsync	465
+#define	SYS_rtprio_thread	466
+#define	SYS_sctp_peeloff	471
+#define	SYS_sctp_generic_sendmsg	472
+#define	SYS_sctp_generic_sendmsg_iov	473
+#define	SYS_sctp_generic_recvmsg	474
+#define	SYS_pread	475
+#define	SYS_pwrite	476
+#define	SYS_mmap	477
+#define	SYS_lseek	478
+#define	SYS_truncate	479
+#define	SYS_ftruncate	480
+#define	SYS_thr_kill2	481
+#define	SYS_shm_open	482
+#define	SYS_shm_unlink	483
+#define	SYS_cpuset	484
+#define	SYS_cpuset_setid	485
+#define	SYS_cpuset_getid	486
+#define	SYS_cpuset_getaffinity	487
+#define	SYS_cpuset_setaffinity	488
+#define	SYS_faccessat	489
+#define	SYS_fchmodat	490
+#define	SYS_fchownat	491
+#define	SYS_fexecve	492
+#define	SYS_fstatat	493
+#define	SYS_futimesat	494
+#define	SYS_linkat	495
+#define	SYS_mkdirat	496
+#define	SYS_mkfifoat	497
+#define	SYS_mknodat	498
+#define	SYS_openat	499
+#define	SYS_readlinkat	500
+#define	SYS_renameat	501
+#define	SYS_symlinkat	502
+#define	SYS_unlinkat	503
+#define	SYS_posix_openpt	504
+#define	SYS_gssd_syscall	505
+#define	SYS_jail_get	506
+#define	SYS_jail_set	507
+#define	SYS_jail_remove	508
+#define	SYS_closefrom	509
+#define	SYS___semctl	510
+#define	SYS_msgctl	511
+#define	SYS_shmctl	512
+#define	SYS_lpathconf	513
+#define	SYS_cap_new	514
+#define	SYS___cap_rights_get	515
+#define	SYS_cap_enter	516
+#define	SYS_cap_getmode	517
+#define	SYS_pdfork	518
+#define	SYS_pdkill	519
+#define	SYS_pdgetpid	520
+#define	SYS_pselect	522
+#define	SYS_getloginclass	523
+#define	SYS_setloginclass	524
+#define	SYS_rctl_get_racct	525
+#define	SYS_rctl_get_rules	526
+#define	SYS_rctl_get_limits	527
+#define	SYS_rctl_add_rule	528
+#define	SYS_rctl_remove_rule	529
+#define	SYS_posix_fallocate	530
+#define	SYS_posix_fadvise	531
+#define	SYS_wait6	532
+#define	SYS_cap_rights_limit	533
+#define	SYS_cap_ioctls_limit	534
+#define	SYS_cap_ioctls_get	535
+#define	SYS_cap_fcntls_limit	536
+#define	SYS_cap_fcntls_get	537
+#define	SYS_bindat	538
+#define	SYS_connectat	539
+#define	SYS_chflagsat	540
+#define	SYS_accept4	541
+#define	SYS_pipe2	542
+#define SYS_aio_mlock	543
+#define SYS_procctl	544
+#define	SYS_MAXSYSCALL	545
+
+#define SYS_obreak	SYS_break
+#define SYS_sysctl	SYS___sysctl
+#define SYS_getcwd	SYS___getcwd
+#define SYS_setugid	SYS___setugid
+#define SYS_semctl	SYS___semctl
+
+#define SYS_acl_get_file	SYS___acl_get_file
+#define SYS_acl_set_file	SYS___acl_set_file
+#define SYS_acl_get_fd		SYS___acl_get_fd
+#define SYS_acl_set_fd		SYS___acl_set_fd
+#define SYS_acl_delete_file	SYS___acl_delete_file
+#define SYS_acl_delete_fd	SYS___acl_delete_fd
+#define SYS_acl_aclcheck_file	SYS___acl_aclcheck_file
+#define SYS_acl_aclcheck_fd	SYS___acl_aclcheck_fd
+#define SYS_acl_get_link	SYS___acl_get_link
+#define SYS_acl_set_link	SYS___acl_set_link
+#define SYS_acl_delete_link	SYS___acl_delete_link
+#define SYS_acl_aclcheck_link	SYS___acl_aclcheck_link
+
+#define SYS_mac_get_proc	SYS___mac_get_proc
+#define SYS_mac_set_proc	SYS___mac_set_proc
+#define SYS_mac_get_fd		SYS___mac_get_fd
+#define SYS_mac_get_file	SYS___mac_get_file
+#define SYS_mac_set_fd		SYS___mac_set_fd
+#define SYS_mac_set_file	SYS___mac_set_file
+#define SYS_mac_get_pid		SYS___mac_get_pid
+#define SYS_mac_get_link	SYS___mac_get_link
+#define SYS_mac_set_link	SYS___mac_set_link
+#define SYS_mac_execve		SYS___mac_execve
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/sysmacros.h
@@ -0,0 +1,36 @@
+/* Definitions of macros to access `dev_t' values.  FreeBSD version.
+   Copyright (C) 1996-1997, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_SYSMACROS_H
+#define _SYS_SYSMACROS_H	1
+
+/* For compatibility we provide alternative names.
+
+   The problem here is that compilers other than GCC probably don't
+   have the `long long' type and so `dev_t' is actually an array.  */
+#define major(dev) ((int)(((unsigned int) (dev) >> 8) & 0xff))
+#define minor(dev) ((int)((dev) & 0xffff00ff))
+#define makedev(major, minor) (((major) << 8) | (minor))
+
+/* Access the functions with their new names.  */
+#define gnu_dev_major(dev) major (dev)
+#define gnu_dev_minor(dev) minor (dev)
+#define gnu_dev_makedev(maj, min) makedev (maj, min)
+
+#endif /* sys/sysmacros.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ttydefaults.h
@@ -0,0 +1,97 @@
+/*-
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)ttydefaults.h	8.4 (Berkeley) 1/21/94
+ */
+
+/*
+ * System wide defaults for terminal state.  FreeBSD version.
+ */
+#ifndef _SYS_TTYDEFAULTS_H_
+#define _SYS_TTYDEFAULTS_H_
+
+/*
+ * Defaults on "first" open.
+ */
+#define TTYDEF_IFLAG	(BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
+#define TTYDEF_OFLAG	(OPOST | ONLCR)
+#define TTYDEF_LFLAG	(ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
+#define TTYDEF_CFLAG	(CREAD | CS8 | HUPCL)
+#define TTYDEF_SPEED	(B9600)
+
+/*
+ * Control Character Defaults
+ */
+#define CTRL(x)	(x&037)
+#define CEOF		CTRL('d')
+#ifdef _POSIX_VDISABLE
+# define CEOL		_POSIX_VDISABLE
+#else
+# define CEOL		((unsigned char)'\377')	/* XXX avoid _POSIX_VDISABLE */
+#endif
+#define CERASE		0177
+#define CERASE2		CTRL('h')
+#define CINTR		CTRL('c')
+#define CSTATUS		CTRL('t')
+#define CKILL		CTRL('u')
+#define CMIN		1
+#define CQUIT		034		/* FS, ^\ */
+#define CSUSP		CTRL('z')
+#define CTIME		0
+#define CDSUSP		CTRL('y')
+#define CSTART		CTRL('q')
+#define CSTOP		CTRL('s')
+#define CLNEXT		CTRL('v')
+#define CDISCARD 	CTRL('o')
+#define CWERASE 	CTRL('w')
+#define CREPRINT 	CTRL('r')
+#define CEOT		CEOF
+/* compat */
+#define CBRK		CEOL
+#define CRPRNT		CREPRINT
+#define CFLUSH		CDISCARD
+
+/* PROTECTED INCLUSION ENDS HERE */
+#endif /* !_SYS_TTYDEFAULTS_H_ */
+
+/*
+ * #define TTYDEFCHARS to include an array of default control characters.
+ */
+#ifdef TTYDEFCHARS
+cc_t	ttydefchars[NCCS] = {
+	CEOF,	CEOL,	CEOL,	CERASE, CWERASE, CKILL, CREPRINT,
+	CERASE2, CINTR,	CQUIT,	CSUSP,	CDSUSP,	CSTART,	CSTOP,	CLNEXT,
+	CDISCARD, CMIN,	CTIME,  CSTATUS, _POSIX_VDISABLE
+};
+#undef TTYDEFCHARS
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/ucontext.h
@@ -0,0 +1,48 @@
+/* Data structures for user-level context switching.  Generic version.
+   Copyright (C) 1997-1999, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This file's definitions suffice for any platform where all
+   the machine-specific state is described in `struct sigcontext'.  */
+
+#ifndef _SYS_UCONTEXT_H
+#define _SYS_UCONTEXT_H	1
+
+#include <features.h>
+#include <signal.h>
+
+/* We need the signal context definitions even if they are not used
+   included in <signal.h>.  */
+#include <bits/sigcontext.h>
+
+/* This include file defines the type 'mcontext_t'.  */
+#include <bits/mcontext.h>
+
+/* Userlevel context.  */
+typedef struct ucontext
+  {
+    __sigset_t uc_sigmask;
+    mcontext_t uc_mcontext;
+    struct ucontext *uc_link;
+    stack_t uc_stack;
+    int     uc_flags;
+#define UCF_SWAPPED     0x00000001      /* Used by swapcontext(3). */
+    int __unused1[4];
+  } ucontext_t;
+
+#endif /* sys/ucontext.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sys/un.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 1991, 1995, 1996, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_UN_H
+#define	_SYS_UN_H	1
+
+#include <sys/cdefs.h>
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+__BEGIN_DECLS
+
+/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */
+struct sockaddr_un
+  {
+    __SOCKADDR_COMMON (sun_);
+    char sun_path[104];		/* Path name, the kernel restrict it to 104, */
+#if defined(__i386__) || defined(__amd64__)
+    char __sun_user_compat[4];  /* but former user header used 108 */
+#endif    
+  };
+
+
+#ifdef __USE_MISC
+# include <string.h>		/* For prototype of `strlen'.  */
+
+/* Evaluate to actual length of the `sockaddr_un' structure.  */
+# define SUN_LEN(ptr) ((size_t) (((struct sockaddr_un *) 0)->sun_path)	      \
+		      + strlen ((ptr)->sun_path))
+#endif
+
+__END_DECLS
+
+#endif	/* sys/un.h  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/syscalls-inline.h
@@ -0,0 +1,82 @@
+/* prototypes of generally used "inline syscalls"
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef KFREEBSD_INLINE_SYSCALLS_H
+#define KFREEBSD_INLINE_SYSCALLS_H
+
+#include <sys/types.h>
+#include <signal.h>
+#include <syscalls-internal.h>
+
+struct iovec;
+struct rusage;
+struct timespec;
+
+int __syscall_open(const char *path, int flags, ...);
+int __syscall_close(int fd);
+libc_hidden_proto (__syscall_open)
+libc_hidden_proto (__syscall_close)
+
+ssize_t __syscall_read(int fd, void *buf, size_t nbyte);
+ssize_t __syscall_write(int fd, const void *buf, size_t nbyte);
+ssize_t __syscall_writev(int fd, const struct iovec *iovp, int iovcnt);
+libc_hidden_proto (__syscall_read)
+libc_hidden_proto (__syscall_write)
+libc_hidden_proto (__syscall_writev)
+
+ssize_t __syscall_readlink(const char *path, char *buf, size_t bufsiz);
+libc_hidden_proto (__syscall_readlink)
+
+int __syscall_fcntl(int fd, int cmd, ...);
+int __syscall_fork(void);
+int __syscall_wait4(int pid, int *status, int options, struct rusage *rusage);
+int __syscall_sigsuspend (const sigset_t *set);
+int __syscall_sigprocmask (int how, const sigset_t *set, sigset_t *oldset);
+int __syscall_nanosleep (const struct timespec *requested_time, struct timespec *remaining);
+libc_hidden_proto (__syscall_fcntl)
+libc_hidden_proto (__syscall_fork)
+libc_hidden_proto (__syscall_wait4)
+libc_hidden_proto (__syscall_sigsuspend)
+libc_hidden_proto (__syscall_sigprocmask)
+libc_hidden_proto (__syscall_nanosleep)
+
+int __syscall_sigwait     (const sigset_t *set, int *sig);
+int __syscall_sigwaitinfo (const sigset_t *set, siginfo_t *info);
+int __syscall_sigtimedwait(const sigset_t *set, siginfo_t *info, const struct timespec *timeout);
+libc_hidden_proto (__syscall_sigwait)
+libc_hidden_proto (__syscall_sigwaitinfo)
+libc_hidden_proto (__syscall_sigtimedwait)
+
+int __syscall_clock_getcpuclockid2(int64_t id, int which, clockid_t *clock_id);
+libc_hidden_proto (__syscall_clock_getcpuclockid2)
+                           
+int __syscall_thr_exit(long *p);
+int __syscall_thr_kill(long id, int sig);
+int __syscall_thr_kill2(int pid, long id, int sig);
+int __syscall_thr_new(void *arg, int size);
+int __syscall_thr_self(long *id);
+int __syscall_thr_set_name(long id, const char *name);
+libc_hidden_proto (__syscall_thr_exit)
+libc_hidden_proto (__syscall_thr_kill)
+libc_hidden_proto (__syscall_thr_kill2)
+libc_hidden_proto (__syscall_thr_new)
+libc_hidden_proto (__syscall_thr_self)
+libc_hidden_proto (__syscall_thr_set_name)
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/syscalls.list
@@ -0,0 +1,214 @@
+# File name		Caller	Syscall name		# args		Strong name	Weak names
+accept4			-	accept4			Ci:iBNi		accept4
+sys_access		-	access			i:si		__syscall_access
+acl_aclcheck_fd		-	acl_aclcheck_fd		i:iip		__acl_aclcheck_fd
+acl_aclcheck_file	-	acl_aclcheck_file	i:sip		__acl_aclcheck_file
+acl_delete_fd		-	acl_delete_fd		i:ii		__acl_delete_fd
+acl_delete_file		-	acl_delete_file		i:si		__acl_delete_file
+acl_get_fd		-	acl_get_fd		i:iip		__acl_get_fd
+acl_get_file		-	acl_get_file		i:sip		__acl_get_file
+acl_set_fd		-	acl_set_fd		i:iip		__acl_set_fd
+acl_set_file		-	acl_set_file		i:sip		__acl_set_file
+sys_aio_cancel		-	aio_cancel		i:ip		__syscall_aio_cancel
+sys_aio_error		-	aio_error		i:p		__syscall_aio_error
+sys_aio_read		-	aio_read		i:p		__syscall_aio_read
+sys_aio_return		-	aio_return		i:p		__syscall_aio_return
+sys_aio_suspend		-	aio_suspend		i:bnP		__syscall_aio_suspend
+sys_aio_waitcomplete	-	aio_waitcomplete	i:pp		__syscall_aio_waitcomplete
+sys_aio_write		-	aio_write		i:p		__syscall_aio_write
+sys_bind		-	bind			i:ipi		__syscall_bind
+sys_clock_getcpuclockid2  -     clock_getcpuclockid2    Vi:iip		__syscall_clock_getcpuclockid2
+sys_clock_getres	-	clock_getres		i:ip		__syscall_clock_getres
+sys_clock_gettime	-	clock_gettime		i:ip		__syscall_clock_gettime
+sys_clock_settime	-	clock_settime		i:ip		__syscall_clock_settime
+sys_close		-	close			i:i		__syscall_close
+sys_closefrom		EXTRA	closefrom		i:i		__syscall_closefrom
+sys_connect		-	connect			i:ipi		__syscall_connect
+sys_cpuset_getaffinity	-	cpuset_getaffinity	i:iiiip		__syscall_cpuset_getaffinity
+sys_cpuset_setaffinity	-	cpuset_setaffinity	i:iiiip		__syscall_cpuset_setaffinity
+execve			-	execve			i:spp		__execve execve
+extattr_delete_file	-	extattr_delete_file	i:ss		extattr_delete_file
+extattr_get_file	-	extattr_get_file	i:ssbn		extattr_get_file
+extattr_set_file	-	extattr_set_file	i:ssbn		extattr_set_file
+extattrctl		-	extattrctl		i:sisI		extattrctl
+sys_faccessat		-	faccessat		i:isii		__syscall_faccessat
+fchmodat		-	fchmodat		i:isii		fchmodat
+fchownat		-	fchownat		i:isiii		fchownat
+sys_fcntl		-	fcntl			i:iiF		__syscall_fcntl
+fexecve			-	fexecve			i:ipp		fexecve
+fhopen			-	fhopen			i:pi		fhopen
+sys_fhstat		-	fhstat			i:pp		__syscall_fhstat
+sys_fhstatfs		-	fhstatfs		i:pp		__syscall_fhstatfs
+sys_fork		-	fork			i:		__syscall_fork	fork
+sys_fstat		-	fstat			i:ip		__syscall_fstat
+sys_fstatat		-	fstatat			i:ispi		__syscall_fstatat
+sys_fstatfs		-	fstatfs			i:ip		__syscall_fstatfs
+ftruncate		-	ftruncate		i:ii		__ftruncate !__ftruncate64 ftruncate ftruncate64
+futimes			-	futimes			i:ip		__futimes futimes
+sys_futimesat		-	futimesat		i:isp		__syscall_futimesat
+getcontext		-	getcontext		i:p		__getcontext getcontext
+sys_getcwd		-	getcwd			i:bn		__syscall_getcwd
+sys_getdents		-	getdents		i:ibn		__syscall_getdents getdents
+sys_getdirentries	-	getdirentries		i:ibnP		__syscall_getdirentries
+getegid			-	getegid			i:		__getegid getegid
+geteuid			-	geteuid			i:		__geteuid geteuid
+getfh			-	getfh			i:sp		getfh
+sys_getfsstat		-	getfsstat		i:pii		__syscall_getfsstat
+sys_getlogin		-	getlogin		i:bn		__syscall_getlogin
+getpgid			-	getpgid			i:i		__getpgid __getpgid_internal getpgid
+getpgrp			-	getpgrp			i:		getpgrp
+getppid			-	getppid			i:		__getppid getppid
+getresgid		-	getresgid		i:ppp		getresgid
+getresuid		-	getresuid		i:ppp		getresuid
+getrlimit		-	getrlimit		i:ip		__getrlimit getrlimit getrlimit64 __getrlimit64
+getsid			-	getsid			i:i		getsid
+issetugid		-	issetugid		i:		issetugid
+jail			-	jail			i:p		jail
+jail_attach		-	jail_attach		i:i		jail_attach
+jail_get		-	jail_get		i:pii		jail_get
+jail_remove		-	jail_remove		i:i		jail_remove
+jail_set		-	jail_set		i:pii		jail_set
+kenv			-	kenv			i:issi		kenv
+kevent			EXTRA	kevent			i:ipipip	__kevent kevent
+kldfind			-	kldfind			i:s		kldfind
+kldfirstmod		-	kldfirstmod		i:i		kldfirstmod
+kldload			-	kldload			i:s		kldload
+kldnext			-	kldnext			i:i		kldnext
+kldstat			-	kldstat			i:ip		kldstat
+kldsym			-	kldsym			i:iip		kldsym
+kldunload		-	kldunload		i:i		kldunload
+kldunloadf		-	kldunloadf		i:ii		kldunloadf
+kqueue			EXTRA	kqueue			i:		__kqueue kqueue
+sys_ktimer_create	-	ktimer_create		i:iPp		__syscall_ktimer_create
+sys_ktimer_delete	-	ktimer_delete		i:i		__syscall_ktimer_delete
+sys_ktimer_getoverrun	-	ktimer_getoverrun	i:i		__syscall_ktimer_getoverrun
+sys_ktimer_gettime	-	ktimer_gettime		i:ip		__syscall_ktimer_gettime
+sys_ktimer_settime	-	ktimer_settime		i:iipp		__syscall_ktimer_settime
+ktrace			-	ktrace			i:siii		ktrace
+lchflags		-	lchflags		i:si		lchflags
+lchmod			-	lchmod			i:si		__lchmod lchmod
+lchown			-	lchown			i:sii		__lchown lchown
+linkat			-	linkat			i:isisi		linkat
+sys_lio_listio		-	lio_listio		i:ibnP		__syscall_lio_listio
+lseek			-	lseek			i:iii		__libc_lseek !__lseek  lseek !__libc_lseek64 !__lseek64 lseek64 !__llseek llseek
+sys_lstat		-	lstat			i:sp		__syscall_lstat
+lutimes			-	lutimes			i:sp		__lutimes lutimes
+posix_madvise		-	madvise			i:pii		posix_madvise
+mincore			-	mincore			i:anV		mincore
+minherit		-	minherit		i:aii		minherit
+mkdirat			-	mkdirat			i:isi		mkdirat
+mkfifo			-	mkfifo			i:si		__mkfifo mkfifo
+sys_mkfifoat		-	mkfifoat		i:isi		__syscall_mkfifoat
+sys_mknod		-	mknod			i:sii		__syscall_mknod
+sys_mknodat		-	mknodat			i:isii		__syscall_mknodat
+mlock			-	mlock			i:bn		mlock
+mlockall		-	mlockall		i:i		mlockall
+sys_mmap		-	mmap			b:aniiii	__syscall_mmap
+modfind			-	modfind			i:s		modfind
+modfnext		-	modfnext		i:i		modfnext
+modnext			-	modnext			i:i		modnext
+modstat			-	modstat			i:ip		modstat
+mount			-	mount			i:ssiP		mount
+sys_msgctl		-	msgctl			i:iip		__syscall_msgctl
+msgget			-	msgget			i:ii		msgget
+msgrcv			-	msgrcv			Ci:ibnii	__libc_msgrcv msgrcv
+msgsnd			-	msgsnd			Ci:ibni		__libc_msgsnd msgsnd
+munlock			-	munlock			i:ai		munlock
+munlockall		-	munlockall		i:		munlockall
+sys_munmap		-	munmap			i:pi		__syscall_munmap
+nanosleep		-	nanosleep		Ci:pp		__libc_nanosleep __nanosleep nanosleep
+sys_nanosleep		EXTRA	nanosleep		i:pp		__syscall_nanosleep
+nfssvc			-	nfssvc			i:ip		nfssvc
+sys_nfstat		-	nfstat			i:ip		__syscall_nfstat
+nlm_syscall		-	nlm_syscall		i:iiip		nlm_syscall
+sys_nlstat		-	nlstat			i:sp		__syscall_nlstat
+nmount			-	nmount			i:pii		nmount
+sys_nstat		-	nstat			i:sp		__syscall_nstat
+ntp_adjtime		-	ntp_adjtime		i:p		ntp_adjtime
+ntp_gettime		-	ntp_gettime		i:p		ntp_gettime
+obreak			-	obreak			i:a		__syscall_obreak
+sys_open		-	open			i:siv		__syscall_open
+sys_openat		-	openat			i:isii		__syscall_openat !__openat_nocancel  !__openat64_nocancel
+poll			-	poll			Ci:pii		__poll poll
+sys_posix_fadvise	EXTRA	posix_fadvise		i:iiii		__syscall_posix_fadvise
+sys_posix_fallocate	EXTRA	posix_fallocate		i:iii		__syscall_posix_fallocate
+posix_openpt		getpt	posix_openpt		i:i		__syscall_posix_openpt
+pread			-	pread			Ci:ibni		__libc_pread !__pread pread !__libc_pread64 !__pread64 pread64
+preadv			-	preadv			Ci:ipii		__preadv  preadv  __preadv64  preadv64 
+pselect			-	pselect			Ci:iPPPPP	__pselect !__libc_pselect pselect
+pwrite			-	pwrite			Ci:ibni		__libc_pwrite !__pwrite pwrite !__libc_pwrite64 !__pwrite64 pwrite64
+pwritev			-	pwritev			Ci:ipii		__pwritev pwritev __pwritev64 pwritev64 
+quotactl		-	quotactl		i:siip		quotactl
+sys_read		-	read			i:ibn		__syscall_read
+readlink		-	readlink       		i:spi   	__syscall_readlink __readlink readlink
+readlinkat		-	readlinkat		i:issi		readlinkat
+sys_readv		-	readv			i:ipi		__syscall_readv
+renameat		-	renameat		i:isis		renameat
+rfork			-	rfork			i:i		__rfork rfork
+rtprio			-	rtprio			i:iip		__rtprio rtprio
+sched_primax		-	sched_get_priority_max	i:i		__sched_get_priority_max sched_get_priority_max
+sched_primin		-	sched_get_priority_min	i:i		__sched_get_priority_min sched_get_priority_min
+sched_gets		-	sched_getscheduler	i:i		__sched_getscheduler sched_getscheduler
+sched_rr_gi		-	sched_rr_get_interval	i:ip		__sched_rr_get_interval sched_rr_get_interval
+sched_setp		-	sched_setparam		i:ip		__sched_setparam sched_setparam
+sched_sets		-	sched_setscheduler	i:iip		__sched_setscheduler sched_setscheduler
+sched_yield		-	sched_yield		i:		__sched_yield sched_yield
+sys_semctl		-	semctl			i:iiip		__syscall_semctl
+semget			-	semget			i:iii		semget
+semop			-	semop			i:ipi		semop
+bsd_sendfile		-	sendfile		i:iiiippi	bsd_sendfile
+sys_sendto		-	sendto			i:ibnibn	__syscall_sendto
+setcontext		-	setcontext		i:p		__setcontext setcontext
+setegid			-	setegid			i:i		setegid
+seteuid			-	seteuid			i:i		seteuid
+setgid			-	setgid			i:i		__setgid setgid
+sys_setlogin		-	setlogin		i:s		__syscall_setlogin
+setpgid			-	setpgid			i:ii		__setpgid setpgid
+setresgid		-	setresgid		i:iii		setresgid
+setresuid		-	setresuid		i:iii		setresuid
+setrlimit		-	setrlimit		i:ip		__setrlimit setrlimit setrlimit64
+setsid			-	setsid			i:		__setsid setsid
+setuid			-	setuid			i:i		__setuid setuid
+sys_shm_open		-	shm_open		i:sii		__syscall_shm_open
+shm_unlink		-	shm_unlink		i:s		shm_unlink
+shmat			-	shmat			i:iai		shmat
+sys_shmctl		-	shmctl			i:iip		__syscall_shmctl
+shmdt			-	shmdt			i:a		shmdt
+shmget			-	shmget			i:iii		shmget
+sys_sigaction		-	sigaction		i:ipp		__syscall_sigaction
+sigpending		-	sigpending		i:p		sigpending
+sys_sigprocmask		EXTRA	sigprocmask		Vi:iPP		__syscall_sigprocmask
+sigprocmask		-	sigprocmask		i:iPP		__sigprocmask sigprocmask
+sigqueue		-	sigqueue		i:iii		__sigqueue sigqueue
+sigsuspend		-	sigsuspend		Ci:p		__sigsuspend sigsuspend
+sys_sigsuspend		EXTRA	sigsuspend		i:p		__syscall_sigsuspend
+sigtimedwait		-	sigtimedwait		Ci:ppP		__sigtimedwait sigtimedwait
+sys_sigtimedwait	-	sigtimedwait		i:ppP		__syscall_sigtimedwait
+sys_sigwait		-	sigwait			i:pp		__syscall_sigwait
+sigwaitinfo		-	sigwaitinfo		Ci:pp		__sigwaitinfo sigwaitinfo
+sys_sigwaitinfo		-	sigwaitinfo		i:pp		__syscall_sigwaitinfo
+sys_stat		-	stat			i:sp		__syscall_stat
+sys_statfs		-	statfs			i:sp		__syscall_statfs
+swapcontext		-	swapcontext		i:pp		__swapcontext swapcontext
+swapoff			-	swapoff			i:s		swapoff
+swapon			-	swapon			i:s		swapon
+symlinkat		-	symlinkat		i:sis		symlinkat
+sysarch			-	sysarch			i:ip		__sysarch sysarch
+sysctl			-	sysctl			i:pibNbn	__sysctl sysctl
+sys_thr_exit		-	thr_exit		Vi:P		__syscall_thr_exit
+sys_thr_kill		-	thr_kill		Vi:ii		__syscall_thr_kill
+sys_thr_kill2		-	thr_kill2		Vi:iii		__syscall_thr_kill2
+sys_thr_new		-	thr_new			Vi:pi		__syscall_thr_new
+sys_thr_self		-	thr_self		Vi:p		__syscall_thr_self
+sys_thr_set_name	-	thr_set_name		Vi:iP		__syscall_thr_set_name
+truncate		-	truncate		i:sii		__truncate !__truncate64 truncate truncate64
+sys_umtx		-	_umtx_op		Vi:piipp	__syscall__umtx_op
+undelete		-	undelete		i:s		undelete
+unlinkat		-	unlinkat		i:isi		unlinkat
+unmount			-	unmount			i:si		unmount
+utrace			-	utrace			i:bn		utrace
+wait4			-	wait4			i:iWiP		__syscall_wait4 __wait4	wait4
+sys_wait6		EXTRA	wait6			i:iiWiPP	__syscall_wait6
+sys_write		-	write			i:ibn		__syscall_write
+sys_writev		-	writev			i:ipi		__syscall_writev
+yield			-	yield			i:		__syscall_yield
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysconf.c
@@ -0,0 +1,69 @@
+/* Get file-specific information about a file.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sysdep.h>
+#include <time.h>
+#include <unistd.h>
+#include <hp-timing.h>
+#include <sys/sysctl.h>
+
+static long int posix_sysconf (int name);
+
+/* Get the value of the system variable NAME.  */
+long int
+__sysconf (int name)
+{
+  int request[2];
+  int value;
+  size_t len = sizeof(value);
+
+  switch(name)
+    {
+      case _SC_CPUTIME:
+      case _SC_THREAD_CPUTIME:
+#if HP_TIMING_AVAIL
+	// XXX We can add  here test for machines which cannot support a
+	// XXX usable TSC.
+	return 200809L;
+#else
+	return -1;
+#endif
+      case _SC_NGROUPS_MAX:
+	request[0] = CTL_KERN;
+	request[1] = KERN_NGROUPS;
+	if (__sysctl(request, 2, &value, &len, NULL, 0) == -1)
+	    return NGROUPS_MAX;
+	return (long)value;
+      case _SC_ARG_MAX:
+	request[0] = CTL_KERN;
+	request[1] = KERN_ARGMAX;
+	if (__sysctl(request, 2, &value, &len, NULL, 0) == -1)
+	    return ARG_MAX;
+	return (long)value;
+    }
+  return posix_sysconf (name);
+}
+
+/* Now the POSIX version.  */
+#undef __sysconf
+#define __sysconf static posix_sysconf
+#include <sysdeps/posix/sysconf.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlbyname.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/sysctl.h>
+#include <string.h>
+
+/* Read or write system parameters.  */
+int
+__sysctlbyname (const char *name, void *oldval, size_t *oldlenp, const void *newval, size_t newlen)
+{
+  int request[CTL_MAXNAME+2];
+  size_t requestlen = CTL_MAXNAME+2;
+
+  if (__sysctlnametomib(name, request, &requestlen) < 0)
+    return -1;
+
+  /* Now call sysctl using the binary encoded request.  */
+  return __sysctl (request, requestlen,
+		   oldval, oldlenp, (void *)newval, newlen);
+}
+
+weak_alias (__sysctlbyname, sysctlbyname)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/sysctlnametomib.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/types.h>
+#include <sys/sysctl.h>
+#include <string.h>
+
+int
+__sysctlnametomib (const char *name, int *mibp, size_t *sizep)
+{
+  /* Convert the string NAME to a binary encoded request.  The kernel
+     contains a routine for doing this, called "name2oid".  But the way
+     to call it is a little bit strange.  */
+  int name2oid_request[2] = { 0, 3 };
+  int retval;
+  
+  *sizep *= sizeof (int);
+  retval = __sysctl (name2oid_request, 2, mibp, sizep, (void *) name, strlen (name));
+  *sizep /= sizeof (int);
+  return retval;
+}
+
+weak_alias (__sysctlnametomib, sysctlnametomib)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/tcdrain.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 1995, 1996, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <termios.h>
+#include <sys/ioctl.h>
+#include <sysdep-cancel.h>
+#include <stddef.h>
+
+/* Wait for pending output to be written on FD.  */
+int
+__libc_tcdrain (int fd)
+{
+  if (SINGLE_THREAD_P)
+    return __ioctl (fd, TIOCDRAIN);
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = __ioctl (fd, TIOCDRAIN);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+weak_alias (__libc_tcdrain, tcdrain)
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/tcflow.c
@@ -0,0 +1,4 @@
+/* just use internal functions */
+#define tcgetattr __tcgetattr
+#define write __write
+#include <sysdeps/unix/bsd/tcflow.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/telldir.c
@@ -0,0 +1,2 @@
+/* Avoid <sysdeps/unix/bsd/telldir.c>, which doesn't pass the testsuite.  */
+#include <sysdeps/posix/telldir.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/testrtsig.h
@@ -0,0 +1,30 @@
+/* Test whether RT signals are really available.
+   Copyright (C) 2008 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <string.h>
+
+#include <kernel-features.h>
+#include <getosreldate.h>
+
+static int
+kernel_has_rtsig (void)
+{
+  return 1;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/times.c
@@ -0,0 +1,71 @@
+/* Copyright (C) 1991,92,93,95,96,97,1998,2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/resource.h>
+#include <sys/times.h>
+#include <sys/time.h>
+#include <time.h>
+
+
+/* Time the program started.  */
+extern time_t _posix_start_time;
+
+#ifdef __GNUC__
+__inline
+#endif
+static clock_t
+timeval_to_clock_t (const struct timeval *tv, clock_t clk_tck)
+{
+  return (clock_t) ((tv->tv_sec * clk_tck) +
+		    (tv->tv_usec * clk_tck / 1000000L));
+}
+
+/* Store the CPU time used by this process and all its
+   dead children (and their dead children) in BUFFER.
+   Return the elapsed real time, or (clock_t) -1 for errors.
+   All times are in CLK_TCKths of a second.  */
+clock_t
+__times (struct tms *buffer)
+{
+  struct rusage usage;
+  clock_t clk_tck;
+
+  if (buffer == NULL)
+    {
+      __set_errno (EINVAL);
+      return (clock_t) -1;
+    }
+
+  clk_tck = __getclktck ();
+  
+  if (__getrusage (RUSAGE_SELF, &usage) < 0)
+    return (clock_t) -1;
+  buffer->tms_utime = (clock_t) timeval_to_clock_t (&usage.ru_utime, clk_tck);
+  buffer->tms_stime = (clock_t) timeval_to_clock_t (&usage.ru_stime, clk_tck);
+
+  if (__getrusage (RUSAGE_CHILDREN, &usage) < 0)
+    return (clock_t) -1;
+  buffer->tms_cutime = (clock_t) timeval_to_clock_t (&usage.ru_utime, clk_tck);
+  buffer->tms_cstime = (clock_t) timeval_to_clock_t (&usage.ru_stime, clk_tck);
+
+  return (time ((time_t *) NULL) - _posix_start_time) * clk_tck;
+}
+
+weak_alias (__times, times)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/timespec_get.c
@@ -0,0 +1,47 @@
+/* Copyright (C) 2011-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <time.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+/* Set TS to calendar time based in time base BASE.  */
+
+/* if the timespec_get function is successful 
+   it returns the nonzero value base;
+   otherwise, it returns zero.
+ */
+
+int __syscall_clock_gettime(clockid_t clock_id, struct timespec *tp);
+libc_hidden_proto (__syscall_clock_gettime)
+
+int
+timespec_get (struct timespec *ts, int base)
+{
+  switch (base)
+    {
+    case TIME_UTC:
+      if ( 0 != INLINE_SYSCALL (clock_gettime, 2, CLOCK_REALTIME, ts))
+	return 0;
+      break;
+
+    default:
+      return 0;
+    }
+
+  return base;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/truncate64.c
@@ -0,0 +1 @@
+/* 'truncate64' is the same as 'truncate', because __off64_t == __off_t.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ttyname.c
@@ -0,0 +1,70 @@
+/* Copyright (C) 1991,92,93,96,97,98,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+/* Static buffer in `ttyname'.  */
+libc_freeres_ptr (static char *ttyname_buf);
+
+static const char dev[] = "/dev";
+
+/* Return the pathname of the terminal FD is open on, or NULL on errors.
+   The returned storage is good only until the next call to this function.  */
+char *
+ttyname (int fd)
+{
+  static size_t buflen;
+  struct fiodgname_arg fgn;
+
+  /* isatty check, tcgetattr is used because it sets the correct
+     errno (EBADF resp. ENOTTY) on error.  */
+  struct termios term;
+  if (__builtin_expect (__tcgetattr (fd, &term) < 0, 0))
+    return NULL;
+
+  if (buflen == 0)
+    {
+      buflen = 4095;
+      ttyname_buf = (char *) malloc (buflen + 1);
+      if (ttyname_buf == NULL)
+	{
+	  buflen = 0;
+	  return NULL;
+	}
+    }
+
+  /* Prepare the result buffer.  */
+  memcpy (ttyname_buf, dev, sizeof (dev) - 1);
+  ttyname_buf[sizeof (dev) - 1] = '/';
+
+  fgn.buf = ttyname_buf + sizeof (dev);
+  fgn.len = buflen - sizeof (dev);
+
+  if (__ioctl(fd, FIODGNAME, &fgn) == -1)
+    {
+      return NULL; 
+    }
+
+  return ttyname_buf;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ttyname_r.c
@@ -0,0 +1,75 @@
+/* Copyright (C) 1991,92,93,95,96,97,98,2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <termios.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+
+static const char dev[] = "/dev";
+
+/* Store at most BUFLEN character of the pathname of the terminal FD is
+   open on in BUF.  Return 0 on success,  otherwise an error number.  */
+int
+__ttyname_r (int fd, char *buf, size_t buflen)
+{
+  int ret;
+  struct fiodgname_arg fgn;
+
+  /* Test for the absolute minimal size.  This makes life easier inside
+     the loop.  */
+  if (!buf)
+    {
+      __set_errno (EINVAL);
+      return EINVAL;
+    }
+
+  if (buflen < (int) (sizeof (dev) + 1))
+    {
+      __set_errno (ERANGE);
+      return ERANGE;
+    }
+
+  /* isatty check, tcgetattr is used because it sets the correct
+     errno (EBADF resp. ENOTTY) on error.  */
+  struct termios term;
+  if (__builtin_expect (__tcgetattr (fd, &term) < 0, 0))
+    return errno;
+
+  /* Prepare the result buffer.  */
+  memcpy (buf, dev, sizeof (dev) - 1);
+  buf[sizeof (dev) - 1] = '/';
+
+  fgn.buf = buf + sizeof (dev);
+  fgn.len = buflen - sizeof (dev);
+
+  ret = __ioctl(fd, FIODGNAME, &fgn);
+  if (ret == -1)
+    {
+      __set_errno (EBADF);
+      return EBADF;
+    }
+
+  return 0;
+}
+
+weak_alias (__ttyname_r, ttyname_r)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/uname.c
@@ -0,0 +1,110 @@
+/* Copyright (C) 2002, 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/utsname.h>
+#include <sys/sysctl.h>
+#include <errno.h>
+#include <string.h>
+
+#define SYSNAME                "GNU/kFreeBSD"
+#define SYSNAME_LEN    13
+
+/* Check for bounds in pre-processor */
+#if SYSNAME_LEN > _UTSNAME_SYSNAME_LENGTH
+#error
+#endif
+
+/* Put information about the system in NAME.  */
+int
+__uname (struct utsname *name)
+{
+  int request[2] = { CTL_KERN };
+  size_t len;
+
+  /* Fill sysname: "uname -s". */
+  strcpy (name->sysname, SYSNAME);
+
+  /* Fill nodename: "uname -n".  Fetch sysctl "kern.hostname".  */
+  request[1] = KERN_HOSTNAME;
+  len = sizeof (name->nodename);
+  if (__sysctl (request, 2, name->nodename, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->nodename))
+	name->nodename[len] = '\0';
+    }
+
+  /* Fill release: "uname -r".  Fetch sysctl "kern.osrelease".  */
+  request[1] = KERN_OSRELEASE;
+  len = sizeof (name->release);
+  if (__sysctl (request, 2, name->release, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->release))
+        name->release[len] = '\0';
+    }
+
+  /* Fill version: "uname -v".  Fetch sysctl "kern.version".  */
+  request[1] = KERN_VERSION;
+  len = sizeof (name->version);
+  if (__sysctl (request, 2, name->version, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->version))
+        name->version[len] = '\0';
+    }
+
+  /* Remove trailing whitespace.  Turn non-trailing whitespace to
+     spaces.  */
+  {
+    char *p0 = name->version;
+    char *p = p0 + __strnlen (p0, sizeof (name->version));
+
+    while (p > p0 && (p[-1] == '\t' || p[-1] == '\n' || p[-1] == ' '))
+      *--p = '\0';
+
+    while (p > p0)
+      {
+        --p;
+        if (*p == '\t' || *p == '\n')
+          *p = ' ';
+      }
+  }
+
+#ifdef __x86_64__
+  /* Check for bounds in pre-processor */
+# if 7 > _UTSNAME_MACHINE_LENGTH
+#  error
+# endif
+  /* Pristine FreeBSD kernel would return "amd64".  Avoid that.  */
+  strcpy (name->machine, "x86_64");
+#else
+  /* Fill machine: "uname -m".  Fetch sysctl "hw.machine".  */
+  request[0] = CTL_HW;
+  request[1] = HW_MACHINE;
+  len = sizeof (name->machine);
+  if (__sysctl (request, 2, name->machine, &len, NULL, 0) >= 0)
+    {
+      if (len < sizeof (name->machine))
+        name->machine[len] = '\0';
+    }
+#endif
+
+  return 0;
+}
+libc_hidden_def (__uname)
+weak_alias (__uname, uname)
+libc_hidden_def (uname)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/unlockpt.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+extern int __isptymaster(int fd);
+
+int
+unlockpt (int fd)
+{
+  /* there is no need/way to do unlocking of slave pseudo-terminal device,
+     just check whether fd might be valid master pseudo-terminal device */
+  return __isptymaster(fd);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/usleep.c
@@ -0,0 +1,50 @@
+/* Implementation of the BSD usleep function using nanosleep.
+   Copyright (C) 1996-1997, 1999, 2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <time.h>
+#include <unistd.h>
+
+int
+usleep (useconds_t useconds)
+{
+  unsigned int sec;
+  unsigned int usec;
+  struct timespec ts;
+
+  /* POSIX:2001 says that useconds >= 1000000 is invalid; nevertheless let's
+     be forgiving.  */
+  if (__builtin_expect (useconds < 1000000, 1))
+    {
+      sec = 0;
+      usec = useconds;
+    }
+  else
+    {
+      sec = useconds / 1000000;
+      usec = useconds % 1000000;
+    }
+
+  ts.tv_sec = sec;
+  ts.tv_nsec = usec * 1000;	/* Multiply as 32-bit integers.  */
+
+  /* Note the usleep() is a cancellation point.  But since we call
+     nanosleep() which itself is a cancellation point we do not have
+     to do anything here.  */
+  return __nanosleep (&ts, NULL);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/ustat.c
@@ -0,0 +1,66 @@
+/* Return info on filesystem.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/ustat.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+int
+ustat (dev_t dev, struct ustat *ubuf)
+{
+  int mntcount;
+  struct statfs *mntlist;
+
+  /* Search for the device among the f_mntfromname fields of all mounted
+     filesystems.  */
+  mntcount = __getmntinfo (&mntlist, 0);
+  if (mntcount == 0 && errno != 0)
+    return -1;
+  if (mntcount > 0)
+    {
+      int i;
+
+      for (i = 0; i < mntcount; i++)
+	{
+	  struct statfs *mnt = &mntlist[i];
+	  struct stat statbuf;
+
+	  if ((__strnlen (mnt->f_mntfromname, sizeof (mnt->f_mntfromname))
+	       < sizeof (mnt->f_mntfromname))
+	      && __xstat (_STAT_VER, mnt->f_mntfromname, &statbuf) >= 0
+	      && S_ISBLK (statbuf.st_mode)
+	      && statbuf.st_rdev == dev)
+	    {
+	      /* Found the device.  Now produce the result.  */
+	      memset (ubuf, '\0', sizeof (struct ustat));
+	      ubuf->f_tfree = mnt->f_bfree;
+	      ubuf->f_tinode = mnt->f_ffree;
+	      return 0;
+	    }
+	}
+    }
+
+  /* DEV is not among the mounted devices.  */
+  __set_errno (EINVAL);
+  return -1;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/Makefile
@@ -0,0 +1,6 @@
+# Additional functions:
+
+ifeq ($(subdir),login)
+# For <utmpx.h>.
+sysdep_routines += utmpconv
+endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/bits/utmp.h
@@ -0,0 +1,50 @@
+/* The `struct utmp' type, describing entries in the utmp file.  For FreeBSD.
+   Copyright (C) 1993, 1996-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _UTMP_H
+# error "Never include <bits/utmp.h> directly; use <utmp.h> instead."
+#endif
+
+#include <paths.h>
+#include <time.h>
+
+
+#define	UT_NAMESIZE	16
+#define	UT_LINESIZE	8
+#define	UT_HOSTSIZE	16
+
+
+struct lastlog
+  {
+    time_t ll_time;
+    char ll_line[UT_LINESIZE];
+    char ll_host[UT_HOSTSIZE];
+  };
+
+struct utmp
+  {
+    char ut_line[UT_LINESIZE];
+    char ut_user[UT_NAMESIZE];
+#define ut_name ut_user
+    char ut_host[UT_HOSTSIZE];
+    __time_t ut_time;
+  };
+
+
+#define _HAVE_UT_HOST 1		/* We have the ut_host field.  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmp.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <string.h>
+
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+/* Copy the information in UTMPX to UTMP. */
+void
+getutmp (const struct utmpx *utmpx, struct utmp *utmp)
+{
+  if (__utmpx_to_utmp (utmpx, utmp) < 0)
+    memset (utmp, '\0', sizeof (struct utmp));
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutmpx.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <string.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+
+/* Copy the information in UTMP to UTMPX. */
+void
+getutmpx (const struct utmp *utmp, struct utmpx *utmpx)
+{
+  if (__utmp_to_utmpx (utmp, utmpx) < 0)
+    memset (utmpx, '\0', sizeof (struct utmpx));
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxent.c
@@ -0,0 +1,46 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <stddef.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+
+/* Static buffer to store the result.  */
+static struct utmpx buffer;
+
+struct utmpx *
+__getutxent (void)
+{
+  for (;;)
+    {
+      struct utmp *tmp = __getutent ();
+
+      if (tmp == NULL)
+	return NULL;
+
+      if (__utmp_to_utmpx (tmp, &buffer) >= 0)
+	return &buffer;
+
+      /* Skip entries that cannot be converted to utmpx.  */
+    }
+}
+
+weak_alias (__getutxent, getutxent)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxid.c
@@ -0,0 +1,68 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <stddef.h>
+#include <string.h>
+
+extern struct utmpx *__getutxent (void);
+
+struct utmpx *
+getutxid (const struct utmpx *id)
+{
+  switch (id->ut_type)
+    {
+    case INIT_PROCESS:
+    case LOGIN_PROCESS:
+    case USER_PROCESS:
+    case DEAD_PROCESS:
+      for (;;)
+	{
+	  struct utmpx *next = __getutxent ();
+
+	  if (next == NULL)
+	    return NULL;
+
+	  switch (next->ut_type)
+	    {
+	    case INIT_PROCESS:
+	    case LOGIN_PROCESS:
+	    case USER_PROCESS:
+	    case DEAD_PROCESS:
+	      if (strncmp (next->ut_id, id->ut_id, sizeof (id->ut_id)) == 0)
+		return next;
+	      break;
+	    default:
+	      break;
+	    }
+	}
+
+    default:
+      for (;;)
+	{
+	  struct utmpx *next = __getutxent ();
+
+	  if (next == NULL)
+	    return NULL;
+
+	  if (next->ut_type == id->ut_type)
+	    return next;
+	}
+    }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/getutxline.c
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <stddef.h>
+#include <string.h>
+
+extern struct utmpx *__getutxent (void);
+
+struct utmpx *
+getutxline (const struct utmpx *line)
+{
+  for (;;)
+    {
+      struct utmpx *next = __getutxent ();
+
+      if (next == NULL)
+	return NULL;
+
+      if ((next->ut_type == LOGIN_PROCESS || next->ut_type == USER_PROCESS)
+	  && strncmp (next->ut_line, line->ut_line, __UT_LINESIZE) == 0)
+	return next;
+    }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/pututxline.c
@@ -0,0 +1,50 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+#include <stddef.h>
+#include <string.h>
+
+extern int __utmp_to_utmpx (const struct utmp *, struct utmpx *);
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+/* Static buffer to store the result.  */
+static struct utmpx buffer;
+
+struct utmpx *
+pututxline (const struct utmpx *utmpx)
+{
+  struct utmp tmp;
+
+  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
+    {
+      struct utmp *tmpres = __pututline (&tmp);
+
+      if (tmpres != NULL)
+	{
+	  if (__utmp_to_utmpx (tmpres, &buffer) >= 0)
+	    return &buffer;
+
+	  /* Hmm.  We wrote a 'struct utmp' that we cannot convert back
+	     to 'struct utmpx'.  Shouldn't happen that often.  */
+	  return NULL;
+	}
+    }
+  return NULL;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/updwtmpx.c
@@ -0,0 +1,31 @@
+/* Copyright (C) 1998, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <utmpx.h>
+#include <utmp.h>
+
+extern int __utmpx_to_utmp (const struct utmpx *, struct utmp *);
+
+void
+updwtmpx (const char *wtmpx_file, const struct utmpx *utmpx)
+{
+  struct utmp tmp;
+
+  if (__utmpx_to_utmp (utmpx, &tmp) >= 0)
+    __updwtmp (wtmpx_file, &tmp);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp-equal.h
@@ -0,0 +1,50 @@
+/* Copyright (C) 1996-1999,2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <string.h>
+#include <utmp.h>
+
+#include <utmp-private.h>
+
+/* Test whether two entries match.  */
+static int
+__utmp_equal (const struct utmp *entry, const struct utmp *match)
+{
+  /* This implementation is consistent with the __utmp_to_utmpx function.  */
+  return
+    (!((entry->ut_line[0] == '\0' && entry->ut_name[0] == '\0'
+	&& entry->ut_host[0] == '\0')
+       || ((entry->ut_line[0] == '~' || entry->ut_line[0] == '{'
+	    || entry->ut_line[0] == '|')
+	   && entry->ut_line[1] == '\0'))
+     &&
+     !((match->ut_line[0] == '\0' && match->ut_name[0] == '\0'
+	&& match->ut_host[0] == '\0')
+       || ((match->ut_line[0] == '~' || match->ut_line[0] == '{'
+	    || match->ut_line[0] == '|')
+	   && match->ut_line[1] == '\0'))
+     &&
+#if _HAVE_UT_ID - 0
+     (entry->ut_id[0] && match->ut_id[0]
+      ? strncmp (entry->ut_id, match->ut_id, sizeof match->ut_id) == 0
+      : strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0)
+#else
+     strncmp (entry->ut_line, match->ut_line, sizeof match->ut_line) == 0
+#endif
+     );
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmp_file.c
@@ -0,0 +1 @@
+#include <login/utmp_file.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-compat/utmpconv.c
@@ -0,0 +1,227 @@
+/* Convert between 'struct utmp' and 'struct utmx'.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* We reuse the 'struct utmp' file format also for 'struct utmpx' records.
+   The mapping from 'struct utmp' to 'struct utmpx' is injective; the
+   reverse mapping succeeds only when common conventions are respected.  */
+
+#include <utmp.h>
+#include <utmpx.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+/* Compare two 'struct utmpx' records.  */
+int
+__utmpx_equal (const struct utmpx *u1, const struct utmpx *u2)
+{
+  return (u1->ut_type == u2->ut_type)
+	 && (u1->ut_pid == u2->ut_pid)
+	 && (strncmp (u1->ut_line, u2->ut_line, __UT_LINESIZE) == 0)
+	 && (strncmp (u1->ut_id, u2->ut_id, sizeof (u1->ut_id)) == 0)
+	 && (strncmp (u1->ut_user, u2->ut_user, __UT_NAMESIZE) == 0)
+	 && (strncmp (u1->ut_host, u2->ut_host, __UT_HOSTSIZE) == 0)
+	 && (u1->ut_exit.e_termination == u2->ut_exit.e_termination)
+	 && (u1->ut_exit.e_exit == u2->ut_exit.e_exit)
+	 && (u1->ut_session == u2->ut_session)
+	 && (u1->ut_tv.tv_sec == u2->ut_tv.tv_sec)
+	 && (u1->ut_tv.tv_usec == u2->ut_tv.tv_usec)
+	 && (memcmp (u1->ut_addr_v6, u2->ut_addr_v6, sizeof (u1->ut_addr_v6))
+	     == 0);
+}
+
+int
+__utmp_to_utmpx (const struct utmp *u, struct utmpx *ux)
+{
+  memset (ux, '\0', sizeof (struct utmpx));
+
+  if (u->ut_line[0] == '\0' && u->ut_name[0] == '\0' && u->ut_host[0] == '\0')
+    {
+      ux->ut_type = EMPTY;
+    }
+  else
+    {
+      if (u->ut_line[0] == '~' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "runlevel", UT_NAMESIZE) == 0)
+	    ux->ut_type = RUN_LVL;
+	  else if (strncmp (u->ut_name, "reboot", UT_NAMESIZE) == 0)
+	    ux->ut_type = BOOT_TIME;
+	  else if (strncmp (u->ut_name, "acct", UT_NAMESIZE) == 0)
+	    ux->ut_type = ACCOUNTING;
+	  else
+	    return -1;
+	}
+      else if (u->ut_line[0] == '{' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
+	    ux->ut_type = NEW_TIME;
+	  else
+	    return -1;
+	}
+      else if (u->ut_line[0] == '|' && u->ut_line[1] == '\0')
+	{
+	  if (strncmp (u->ut_name, "date", UT_NAMESIZE) == 0)
+	    ux->ut_type = OLD_TIME;
+	  else
+	    return -1;
+	}
+      else
+	{
+	  if (strncmp (u->ut_name, "INIT", UT_NAMESIZE) == 0)
+	    ux->ut_type = INIT_PROCESS;
+	  else if (strncmp (u->ut_name, "LOGIN", UT_NAMESIZE) == 0)
+	    ux->ut_type = LOGIN_PROCESS;
+	  else if (strncmp (u->ut_name, "", UT_NAMESIZE) == 0)
+	    ux->ut_type = DEAD_PROCESS;
+	  else
+	    ux->ut_type = USER_PROCESS;
+
+	  if (ux->ut_type == LOGIN_PROCESS || ux->ut_type == USER_PROCESS)
+	    strncpy (ux->ut_user, u->ut_name, UT_NAMESIZE);
+
+	  if (strncmp (u->ut_line, "tty", 3) == 0)
+	    {
+	      strncpy (ux->ut_line, u->ut_line, UT_LINESIZE);
+	      strncpy (ux->ut_id, u->ut_line + 3, sizeof (ux->ut_id));
+	    }
+	  else
+	    {
+	      strncpy (ux->ut_id, u->ut_line, sizeof (ux->ut_id));
+	    }
+	}
+
+      strncpy (ux->ut_host, u->ut_host, UT_HOSTSIZE);
+
+      /* Hack: Recover the ut_pid from the hidden place after the host.  */
+      if (__strnlen (u->ut_host, UT_HOSTSIZE) < UT_HOSTSIZE - 2)
+	{
+	  const char *hidden = u->ut_host + strlen (u->ut_host) + 1;
+
+	  if (hidden[0] != '\0')
+	    {
+	      size_t n = UT_HOSTSIZE - strlen (u->ut_host) - 1;
+	      char buf[UT_HOSTSIZE];
+	      unsigned long pid;
+	      char *endp;
+
+	      strncpy (buf, hidden, n);
+	      buf[n] = '\0';
+
+	      pid = strtoul (buf, &endp, 10);
+	      if (endp != buf && *endp == '\0')
+		ux->ut_pid = pid;
+	    }
+	}
+
+      ux->ut_tv.tv_sec = u->ut_time;
+      ux->ut_tv.tv_usec = 0;
+    }
+
+  return 0;
+}
+
+int
+__utmpx_to_utmp (const struct utmpx *ux, struct utmp *u)
+{
+  char buf[10+1];
+
+  switch (ux->ut_type)
+    {
+    case EMPTY:
+      strncpy (u->ut_line, "", UT_LINESIZE);
+      strncpy (u->ut_name, "", UT_NAMESIZE);
+      strncpy (u->ut_host, "", UT_HOSTSIZE);
+      break;
+
+    case RUN_LVL:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "runlevel", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case BOOT_TIME:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "reboot", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case NEW_TIME:
+      strncpy (u->ut_line, "{", UT_LINESIZE);
+      strncpy (u->ut_name, "date", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case OLD_TIME:
+      strncpy (u->ut_line, "|", UT_LINESIZE);
+      strncpy (u->ut_name, "date", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case INIT_PROCESS:
+    case LOGIN_PROCESS:
+    case USER_PROCESS:
+    case DEAD_PROCESS:
+      if (ux->ut_line[0] != '\0')
+	strncpy (u->ut_line, ux->ut_line, UT_LINESIZE);
+      else
+	strncpy (u->ut_line, ux->ut_id, sizeof (ux->ut_id));
+      switch (ux->ut_type)
+	{
+	case INIT_PROCESS:
+	  strncpy (u->ut_name, "INIT", UT_NAMESIZE);
+	  break;
+	case LOGIN_PROCESS:
+	  strncpy (u->ut_name, "LOGIN", UT_NAMESIZE);
+	  break;
+	case USER_PROCESS:
+	  strncpy (u->ut_name, ux->ut_user, UT_NAMESIZE);
+	  break;
+	case DEAD_PROCESS:
+	  strncpy (u->ut_name, "", UT_NAMESIZE);
+	  break;
+	}
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    case ACCOUNTING:
+      strncpy (u->ut_line, "~", UT_LINESIZE);
+      strncpy (u->ut_name, "acct", UT_NAMESIZE);
+      strncpy (u->ut_host, ux->ut_host, UT_HOSTSIZE);
+      break;
+
+    default:
+      return -1;
+    }
+
+  u->ut_time = ux->ut_tv.tv_sec;
+
+  /* Hack: Put the ut_pid at a hidden place where there is likely room.  */
+  if (ux->ut_pid != 0)
+    {
+      size_t room = UT_HOSTSIZE - strlen (u->ut_host) - 1;
+
+      sprintf (buf, "%lu", (unsigned long) ux->ut_pid);
+      if (strlen (buf) <= room)
+	strncpy (u->ut_host + strlen (u->ut_host) + 1, buf, room);
+    }
+
+  return 0;
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/utmp-utmpx/utmp_file.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/utmp_file.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/wait.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wait.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/wait3.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/wait3.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/waitid.c
@@ -0,0 +1,108 @@
+/* 
+   Copyright (C) 2004-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <shlib-compat.h>
+#include <stddef.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/wait.h>
+#include <sysdep.h>
+
+extern int __syscall_wait6 (idtype_t itype, int64_t id,
+			    int *status, int options,
+			    struct rusage *rusage, siginfo_t *infop);
+libc_hidden_proto (__syscall_wait6)
+
+
+#define DO_WAITID simulated_waitid
+static int simulated_waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options);
+
+
+#if !defined __ASSUME_WAIT6
+static int __have_wait6;
+#endif
+
+static inline int
+do_waitid (idtype_t idtype, id_t id, siginfo_t *infop, int options)
+{
+  int ret;
+  int status;
+#ifndef __ASSUME_WAIT6
+  if (__have_wait6 >= 0)
+#endif
+  {
+      ret = INLINE_SYSCALL (wait6, 6, idtype, id, &status, options, NULL, infop);
+      
+      if (ret == 0 && infop != NULL)
+      {
+          memset(infop, 0, sizeof(*infop));
+      }
+      if (ret >= 0)
+          return 0;
+#ifndef __ASSUME_WAIT6
+      if (errno == ENOSYS)
+      {
+          __have_wait6 = -1;
+      }
+      else
+#endif
+      {
+          return ret;
+      }
+   }
+   return simulated_waitid(idtype, id, infop, options);
+}
+
+ 
+#define waitid __unused_waitid_alias
+#include <sysdeps/posix/waitid.c>
+#undef waitid
+
+versioned_symbol (libc, __waitid, waitid, GLIBC_2_18);
+
+#if SHLIB_COMPAT (libc, GLIBC_2_1, GLIBC_2_18)
+
+/* it used to be: */
+
+#define OLD_P_ALL	0
+#define OLD_P_PID	1
+#define OLD_P_PGID	2
+
+int
+__waitid_old (idtype_t oldtype, id_t id, siginfo_t *infop, int options)
+{
+  idtype_t newtype;
+
+  switch (oldtype)
+  {
+      case OLD_P_ALL:
+          newtype = P_ALL;
+      break;
+      case OLD_P_PID:
+          newtype = P_PID;
+      break;
+      case OLD_P_PGID:
+          newtype = P_PGID;
+      break;
+      default:
+          newtype = oldtype;
+   }
+  return __waitid(newtype, id, infop, options);
+}
+compat_symbol (libc, __waitid_old, waitid, GLIBC_2_1);
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/waitpid.c
@@ -0,0 +1,56 @@
+/* Copyright (C) 1991,95,96,97,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/wait.h>
+#include <sys/types.h>
+#include <stddef.h>
+#include <sysdep-cancel.h>
+
+/* Wait for a child matching PID to die.
+   If PID is greater than 0, match any process whose process ID is PID.
+   If PID is (pid_t) -1, match any process.
+   If PID is (pid_t) 0, match any process with the
+   same process group as the current process.
+   If PID is less than -1, match any process whose
+   process group is the absolute value of PID.
+   If the WNOHANG bit is set in OPTIONS, and that child
+   is not already dead, return (pid_t) 0.  If successful,
+   return PID and store the dead child's status in STAT_LOC.
+   Return (pid_t) -1 for errors.  If the WUNTRACED bit is set in OPTIONS,
+   return status for stopped children; otherwise don't.  */
+pid_t
+__libc_waitpid (pid_t pid, int *stat_loc, int options)
+{
+  if (SINGLE_THREAD_P)
+  {
+      return INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+  }
+
+  int oldtype = LIBC_CANCEL_ASYNC ();
+
+  int result = INLINE_SYSCALL (wait4, 4, pid, stat_loc, options, NULL);
+
+  LIBC_CANCEL_RESET (oldtype);
+
+  return result;
+}
+
+weak_alias (__libc_waitpid, __waitpid)
+libc_hidden_weak (__waitpid)
+weak_alias (__libc_waitpid, waitpid)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/writev.c
@@ -0,0 +1,57 @@
+/* writev for FreeBSD.
+   Copyright (C) 1997-1998, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/param.h>
+#include <sys/uio.h>
+
+#include <sysdep.h>
+#include <sys/syscall.h>
+#include <sysdep-cancel.h>
+
+extern ssize_t __syscall_writev (int, const struct iovec *, int);
+
+static ssize_t __atomic_writev_replacement (int, const struct iovec *,
+					    int) internal_function;
+
+ssize_t
+__writev (int fd, const struct iovec *vector, int count)
+{
+  if (count <= UIO_MAXIOV)
+  {
+    if (SINGLE_THREAD_P)
+      return INLINE_SYSCALL (writev, 3, fd, vector, count);
+
+    int oldtype = LIBC_CANCEL_ASYNC ();
+    ssize_t result =  INLINE_SYSCALL (writev, 3, fd, vector, count);
+    LIBC_CANCEL_RESET (oldtype);
+    return result;
+
+  }
+  else
+    return __atomic_writev_replacement (fd, vector, count);
+}
+weak_alias (__writev, writev)
+
+#undef weak_alias
+#define weak_alias(a,b)
+#define __writev static internal_function __atomic_writev_replacement
+#include <sysdeps/posix/writev.c>
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86/Makefile
@@ -0,0 +1,9 @@
+# We don't need any header files.
+abi-includes :=
+
+abi-variants := 32 64
+
+abi-32-options := -D__i386__ -U__x86_64__
+abi-32-condition := !defined __x86_64__
+abi-64-options := -U__i386__ -D__x86_64__ -U__ILP32__ -D__LP64__
+abi-64-condition := defined __x86_64__ && defined __LP64__
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86/fbtl/bits/pthreadtypes.h
@@ -0,0 +1,240 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <bits/wordsize.h>
+
+#ifdef __x86_64__
+# if __WORDSIZE == 64
+#  define __SIZEOF_PTHREAD_ATTR_T 56
+#  define __SIZEOF_PTHREAD_MUTEX_T 40
+#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#  define __SIZEOF_PTHREAD_COND_T 48
+#  define __SIZEOF_PTHREAD_CONDATTR_T 4
+#  define __SIZEOF_PTHREAD_RWLOCK_T 56
+#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#  define __SIZEOF_PTHREAD_BARRIER_T 32
+#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+# else
+#  define __SIZEOF_PTHREAD_ATTR_T 32
+#  define __SIZEOF_PTHREAD_MUTEX_T 32
+#  define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#  define __SIZEOF_PTHREAD_COND_T 48
+#  define __SIZEOF_PTHREAD_CONDATTR_T 4
+#  define __SIZEOF_PTHREAD_RWLOCK_T 44
+#  define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#  define __SIZEOF_PTHREAD_BARRIER_T 20
+#  define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+# endif
+#else
+# define __SIZEOF_PTHREAD_ATTR_T 36
+# define __SIZEOF_PTHREAD_MUTEX_T 24
+# define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+# define __SIZEOF_PTHREAD_COND_T 48
+# define __SIZEOF_PTHREAD_CONDATTR_T 4
+# define __SIZEOF_PTHREAD_RWLOCK_T 32
+# define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+# define __SIZEOF_PTHREAD_BARRIER_T 20
+# define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+#endif
+
+
+/* Thread identifiers.  The structure of the attribute type is not
+   exposed on purpose.  */
+typedef unsigned long int pthread_t;
+
+
+union pthread_attr_t
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+};
+#ifndef __have_pthread_attr_t
+typedef union pthread_attr_t pthread_attr_t;
+# define __have_pthread_attr_t	1
+#endif
+
+
+#ifdef __x86_64__
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+#else
+typedef struct __pthread_internal_slist
+{
+  struct __pthread_internal_slist *__next;
+} __pthread_slist_t;
+#endif
+
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is not exposed on purpose.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+#ifdef __x86_64__
+    unsigned int __nusers;
+#endif
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+#ifdef __x86_64__
+    int __spins;
+    __pthread_list_t __list;
+# define __PTHREAD_MUTEX_HAVE_PREV	1
+#else
+    unsigned int __nusers;
+    __extension__ union
+    {
+      int __spins;
+      __pthread_slist_t __list;
+    };
+#endif
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is not exposed on purpose.  */
+typedef union
+{
+# ifdef __x86_64__
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+# define __PTHREAD_RWLOCK_INT_FLAGS_SHARED	1
+  } __data;
+# else
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned char __flags;
+    unsigned char __shared;
+    unsigned char __pad1;
+    unsigned char __pad2;
+    int __writer;
+  } __data;
+# endif
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+
+#ifndef __x86_64__
+/* Extra attributes for the cleanup functions.  */
+# define __cleanup_fct_attribute __attribute__ ((__regparm__ (1)))
+#endif
+
+#endif	/* bits/pthreadtypes.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86/fbtl/bits/semaphore.h
@@ -0,0 +1,40 @@
+/* Copyright (C) 2002-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+#include <bits/wordsize.h>
+
+#if __WORDSIZE == 64
+# define __SIZEOF_SEM_T	32
+#else
+# define __SIZEOF_SEM_T	16
+#endif
+
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86/fbtl/lowlevellock.h
@@ -0,0 +1,38 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include_next <lowlevellock.h>
+
+#ifndef __ASSEMBLER__
+  /* Delay in spinlock loop.  */
+# define BUSY_WAIT_NOP	asm ("rep; nop")
+# ifndef LOCK_INSTR
+#  ifdef UP
+#   define LOCK_INSTR	/* nothing */
+#  else
+#   define LOCK_INSTR "lock;"
+#  endif
+# endif
+#else
+# ifndef LOCK
+#  ifdef UP
+#   define LOCK
+#  else
+#   define LOCK lock
+#  endif
+# endif
+#endif  /* !__ASSEMBLER__ */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/Implies
@@ -0,0 +1 @@
+unix/bsd/bsd4.4/kfreebsd/x86
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/Makefile
@@ -0,0 +1,20 @@
+# The default ABI is 64.
+default-abi := 64
+
+32bit-predefine = __i386__
+64bit-predefine = __x86_64__
+
+# Additional header files to be installed in $prefix/include:
+
+ifeq ($(subdir),misc)
+sysdep_headers += \
+ sys/io.h \
+ sys/perm.h
+endif
+
+# Additional functions, and particular system calls:
+
+ifeq ($(subdir),misc)
+# For <sys/io.h> and <sys/perm.h>.
+sysdep_routines += iopl ioperm
+endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/Versions
@@ -0,0 +1,8 @@
+libc {
+  GLIBC_2.3.4 {
+    iopl;
+  }
+  GLIBC_2.10 {
+    ioperm;
+  }
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/____longjmp_chk.S
@@ -0,0 +1,7 @@
+/* Jump to the position specified by ENV, causing the
+   setjmp call there to return VAL, or 1 if VAL is 0.
+   void __longjmp (__jmp_buf env, int val).  */
+      
+#warning longjmp_chk unimplemented
+#define __longjmp ____longjmp_chk
+#include<__longjmp.S>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/bits/mcontext.h
@@ -0,0 +1,167 @@
+/* Machine-dependent processor state structure for FreeBSD.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.  x86_64 version.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SYS_UCONTEXT_H
+# error "Never use <bits/mcontext.h> directly; include <sys/ucontext.h> instead."
+#endif
+
+/*-
+ * Copyright (c) 2003 Peter Wemm
+ * Copyright (c) 1999 Marcel Moolenaar
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * based on $FreeBSD: src/sys/amd64/include/ucontext.h,v 1.18 2003/11/08 04:39:22 peter Exp $
+ */
+
+#ifdef __i386__
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+
+    int mc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    int mc_gs;
+    int mc_fs;
+    int mc_es;
+    int mc_ds;
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    int mc_edi;
+    int mc_esi;
+    int mc_ebp;
+    int mc_isp;			/* Not used; sc_esp is used instead.  */
+    int mc_ebx;
+    int mc_edx;
+    int mc_ecx;
+    int mc_eax;
+
+    int mc_trapno;
+    int mc_err;
+
+    int mc_eip;			/* Instruction pointer.  */
+    int mc_cs;			/* Code segment register.  */
+
+    int mc_efl;			/* Processor flags.  */
+
+    int mc_esp;			/* This stack pointer is used.  */
+    int mc_ss;			/* Stack segment register.  */
+
+    int mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_387		0x10001
+#define	_MC_FPFMT_XMM		0x10002
+    int mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    int mc_ownedfp;
+    int mc_spare1[1];		/* align next field to 16 bytes */
+    /*
+     * See <machine/npx.h> for the internals of mc_fpstate[].
+     */
+    int mc_fpstate[128] __attribute__((aligned(16)));
+    int mc_spare2[8];
+  } mcontext_t;
+
+#else
+
+/* Whole processor state.  */
+typedef struct
+  {
+    /*
+     * The first 20 fields must match the definition of
+     * sigcontext. So that we can support sigcontext
+     * and ucontext_t at the same time.
+     */
+    long mc_onstack;		/* XXX - sigcontext compat. */
+    long mc_rdi;			/* machine state (struct trapframe) */
+    long mc_rsi;
+    long mc_rdx;
+    long mc_rcx;
+    long mc_r8;
+    long mc_r9;
+    long mc_rax;
+    long mc_rbx;
+    long mc_rbp;
+    long mc_r10;
+    long mc_r11;
+    long mc_r12;
+    long mc_r13;
+    long mc_r14;
+    long mc_r15;
+    long mc_trapno;
+    long mc_addr;
+    long mc_flags;
+    long mc_err;
+    long mc_rip;
+    long mc_cs;
+    long mc_rflags;
+    long mc_rsp;
+    long mc_ss;
+
+    long mc_len;			/* sizeof(mcontext_t) */
+#define	_MC_FPFMT_NODEV		0x10000	/* device not present or configured */
+#define	_MC_FPFMT_XMM		0x10002
+    long mc_fpformat;
+#define	_MC_FPOWNED_NONE	0x20000	/* FP state not used */
+#define	_MC_FPOWNED_FPU		0x20001	/* FP state came from FPU */
+#define	_MC_FPOWNED_PCB		0x20002	/* FP state came from PCB */
+    long mc_ownedfp;
+     /*
+      * See <machine/fpu.h> for the internals of mc_fpstate[].
+      */
+    long mc_fpstate[64] __attribute__((aligned(16)));
+    long mc_spare[8];
+} mcontext_t;
+
+#endif
+
+/* Traditional BSD names for some members.  */
+#define mc_eflags	mc_efl
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/bits/sigcontext.h
@@ -0,0 +1,147 @@
+/* Machine-dependent signal context structure for FreeBSD.  i386 version.
+   Copyright (C) 1991-1992,1994,1997,2001-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#if !defined _SIGNAL_H && !defined _SYS_UCONTEXT_H
+# error "Never use <bits/sigcontext.h> directly; include <signal.h> instead."
+#endif
+
+#ifndef _BITS_SIGCONTEXT_H
+#define _BITS_SIGCONTEXT_H  1
+
+#ifdef __i386__
+
+/* State of this thread when the signal was taken.
+   The unions below are for compatibility with Linux (whose sigcontext
+   components don't have sc_ prefix) */
+__extension__ struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    int 	sc_onstack;		/* Nonzero if running on sigstack.  */
+
+    /* Segment registers.  */
+    union { int sc_gs; int gs; };
+    union { int sc_fs; int fs; };
+    union { int sc_es; int es; };
+    union { int sc_ds; int ds; };
+
+    /* "General" registers.  These members are in the order that the i386
+       `pusha' and `popa' instructions use (`popa' ignores %esp).  */
+    union { int sc_edi; int edi; };
+    union { int sc_esi; int esi; };
+    union { int sc_ebp; int ebp; };
+    union { int sc_isp; int isp; };		/* Not used; sc_esp is used instead.  */
+    union { int sc_ebx; int ebx; };
+    union { int sc_edx; int edx; };
+    union { int sc_ecx; int ecx; };
+    union { int sc_eax; int eax; };
+
+    union { int sc_trapno; int trapno; };
+    union { int sc_err; int err; };
+
+    union { int sc_eip; int eip; };		/* Instruction pointer.  */
+    union { int sc_cs; int cs; };		/* Code segment register.  */
+
+    union { int sc_efl; int eflags; }; 		/* Processor flags.  */
+
+    union { int sc_esp; int esp; };		/* This stack pointer is used.  */
+    union { int sc_ss; int ss; };		/* Stack segment register.  */
+
+    int     sc_len;                 /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/npx.h> for
+     *       the following fields.
+     */
+    int     sc_fpformat;
+    int     sc_ownedfp;
+    int     sc_spare1[1];
+    int     sc_fpstate[128] __attribute__((aligned(16)));
+    int     sc_spare2[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp		sc_esp		/* Stack pointer.  */
+#define sc_fp		sc_ebp		/* Frame pointer.  */
+#define sc_pc		sc_eip		/* Process counter.  */
+#define sc_ps		sc_efl
+#define sc_eflags	sc_efl
+
+#if 1 /* FIXME: These need verification.  */
+
+/* Codes for SIGILL.  */
+#define ILL_PRIVIN_FAULT	1
+#define ILL_ALIGN_FAULT		14
+#define ILL_FPOP_FAULT		24
+
+/* Codes for SIGBUS.  */
+#define BUS_PAGE_FAULT		12
+#define BUS_SEGNP_FAULT		26
+#define BUS_STK_FAULT		27
+#define BUS_SEGM_FAULT		29
+
+#endif
+
+#else
+
+__extension__ struct sigcontext
+  {
+    __sigset_t 	sc_mask;		/* Blocked signals to restore.  */
+    long 	sc_onstack;		/* Nonzero if running on sigstack.  */
+    union { long sc_rdi; long rdi;};
+    union { long sc_rsi; long rsi;};
+    union { long sc_rdx; long rdx;};
+    union { long sc_rcx; long rcx;};
+    union { long sc_r8; long r8;};
+    union { long sc_r9; long r9;};
+    union { long sc_rax; long rax;};
+    union { long sc_rbx; long rbx;};
+    union { long sc_rbp; long rbp;};
+    union { long sc_r10; long r10;};
+    union { long sc_r11; long r11;};
+    union { long sc_r12; long r12;};
+    union { long sc_r13; long r13;};
+    union { long sc_r14; long r14;};
+    union { long sc_r15; long r15;};
+    union { long sc_trapno; long trapno;};
+    union { long sc_addr; long addr;};
+    union { long sc_flags; long flags;};
+    union { long sc_err; long err;};
+    union { long sc_rip; long rip;};
+    union { long sc_cs; long cs;};
+    union { long sc_rflags; long rflags;};
+    union { long sc_rsp; long rsp;};
+    union { long sc_ss; long ss;};
+    long	sc_len;        /* sizeof(mcontext_t) */
+    /*
+     * XXX - See <machine/ucontext.h> and <machine/fpu.h> for
+     *       the following fields.
+     */
+    long	sc_fpformat;
+    long	sc_ownedfp;
+    long	sc_fpstate[64] __attribute__((aligned(16)));
+    long	sc_spare[8];
+  };
+
+/* Traditional BSD names for some members.  */
+#define sc_sp           sc_rsp          /* Stack pointer.  */
+#define sc_fp           sc_rbp          /* Frame pointer.  */
+#define sc_pc           sc_rip          /* Process counter.  */
+
+#endif
+
+#endif /* _BITS_SIGCONTEXT_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/c++-types.data
@@ -0,0 +1,67 @@
+blkcnt64_t:l
+blkcnt_t:l
+blksize_t:j
+caddr_t:Pc
+clockid_t:i
+clock_t:i
+daddr_t:l
+dev_t:j
+fd_mask:l
+fsblkcnt64_t:m
+fsblkcnt_t:m
+fsfilcnt64_t:m
+fsfilcnt_t:m
+fsid_t:8__fsid_t
+gid_t:j
+id_t:j
+ino64_t:m
+ino_t:j
+int16_t:s
+int32_t:i
+int64_t:l
+int8_t:a
+intptr_t:l
+key_t:l
+loff_t:l
+mode_t:t
+nlink_t:t
+off64_t:l
+off_t:l
+pid_t:i
+pthread_attr_t:14pthread_attr_t
+pthread_barrier_t:17pthread_barrier_t
+pthread_barrierattr_t:21pthread_barrierattr_t
+pthread_cond_t:14pthread_cond_t
+pthread_condattr_t:18pthread_condattr_t
+pthread_key_t:j
+pthread_mutex_t:15pthread_mutex_t
+pthread_mutexattr_t:19pthread_mutexattr_t
+pthread_once_t:i
+pthread_rwlock_t:16pthread_rwlock_t
+pthread_rwlockattr_t:20pthread_rwlockattr_t
+pthread_spinlock_t:i
+pthread_t:m
+quad_t:l
+register_t:l
+rlim64_t:l
+rlim_t:l
+sigset_t:10__sigset_t
+size_t:m
+socklen_t:j
+ssize_t:l
+suseconds_t:l
+time_t:l
+u_char:h
+uid_t:j
+uint:j
+u_int:j
+u_int16_t:t
+u_int32_t:j
+u_int64_t:m
+u_int8_t:h
+ulong:m
+u_long:m
+u_quad_t:m
+useconds_t:j
+ushort:t
+u_short:t
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-cache.h
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-cache.h>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-machine.h
@@ -0,0 +1,119 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  FreeBSD/amd64 version.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include_next <dl-machine.h>
+
+#undef RTLD_START
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+#define RTLD_START asm ("\n\
+.text\n\
+	.align 16\n\
+.globl _start\n\
+# we dont use it: .globl _dl_start_user\n\
+_start:\n\
+	# align stack.\n\
+	andq $-16, %rsp\n\
+	# save argument pointer.\n\
+	movq %rdi, %r13\n\
+	call _dl_start\n\
+# we dont use it: _dl_start_user:\n\
+	# Save the user entry point address in %r12.\n\
+	movq %rax, %r12\n\
+	# See if we were run as a command with the executable file\n\
+	# name as an extra leading argument.\n\
+	movl _dl_skip_args(%rip), %eax\n\
+	# get the original argument count.\n\
+	movq 0(%r13), %rdx\n\
+	# Adjust the pointer to skip _dl_skip_args words.\n\
+	leaq (%r13,%rax,8), %r13\n\
+	# Subtract _dl_skip_args from argc.\n\
+	subl %eax, %edx\n\
+	# Put argc on adjusted place\n\
+	movq %rdx, 0(%r13)\n\
+	# Call _dl_init (struct link_map *main_map, int argc, char **argv, char **env)\n\
+	# argc -> rsi\n\
+	movq %rdx, %rsi\n\
+	# _dl_loaded -> rdi\n\
+	movq _rtld_local(%rip), %rdi\n\
+	# env -> rcx\n\
+	leaq 16(%r13,%rdx,8), %rcx\n\
+	# argv -> rdx\n\
+	leaq 8(%r13), %rdx\n\
+	# Clear %rbp to mark outermost frame obviously even for constructors.\n\
+	xorl %ebp, %ebp\n\
+	# Call the function to run the initializers.\n\
+	call _dl_init@PLT\n\
+	# Pass our finalizer function to the user in %rdx, as per ELF ABI draft.\n\
+	leaq _dl_fini(%rip), %rdx\n\
+	# And make sure %rdi points to argc stored on the stack.\n\
+	movq %r13, %rdi\n\
+	# Pass finalizer function also in %rsi, as per C calling convention.\n\
+	movq %rdx, %rsi\n\
+	# Jump to the user's entry point.\n\
+	jmp *%r12\n\
+.previous\n\
+");
+
+#if 0
+Under FreeBSD:
+#define AT_EXECPATH     15      /* Path to the executable. */
+
+Under Linux:
+#define AT_PLATFORM     15      /* String identifying platform.  */
+
+Filled entries from kernel:
+
+        if (args->execfd != -1)
+                AUXARGS_ENTRY(pos, AT_EXECFD, args->execfd);
+        AUXARGS_ENTRY(pos, AT_PHDR, args->phdr);    
+        AUXARGS_ENTRY(pos, AT_PHENT, args->phent);  
+        AUXARGS_ENTRY(pos, AT_PHNUM, args->phnum);  
+        AUXARGS_ENTRY(pos, AT_PAGESZ, args->pagesz);
+        AUXARGS_ENTRY(pos, AT_FLAGS, args->flags);
+        AUXARGS_ENTRY(pos, AT_ENTRY, args->entry);
+        AUXARGS_ENTRY(pos, AT_BASE, args->base);
+        if (imgp->execpathp != 0)
+                AUXARGS_ENTRY(pos, AT_EXECPATH, imgp->execpathp);
+        AUXARGS_ENTRY(pos, AT_NULL, 0);
+                                                                                                                
+#endif
+
+#ifndef _DL_MACHINE_KFREEBSD
+#define _DL_MACHINE_KFREEBSD
+
+static inline void __attribute__ ((unused))
+dl_platform_kfreebsd_x86_64_init (void)
+{
+	/* This calls cpuid and and fills dl_x86_cpu_features */
+	DL_PLATFORM_INIT;
+
+	/* we don't have reasonable AT_PLATFORM from kernel
+	   use cpuid to guess AT_HWCAP */
+	GLRO(dl_hwcap) = GLRO(dl_x86_cpu_features).cpuid[COMMON_CPUID_INDEX_1].edx;
+	GLRO(dl_platform) = ELF_MACHINE_NAME;
+}
+
+#undef  DL_PLATFORM_INIT
+#define DL_PLATFORM_INIT dl_platform_kfreebsd_x86_64_init ()
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-procinfo.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/x86_64/dl-procinfo.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/dl-procinfo.h
@@ -0,0 +1,5 @@
+#if IS_IN (ldconfig)
+# include <sysdeps/unix/bsd/bsd4.4/kfreebsd/i386/dl-procinfo.h>
+#else
+# include <sysdeps/generic/dl-procinfo.h>
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/exit-thread.h
@@ -0,0 +1,49 @@
+/* Call to terminate the current thread.  GNU/kFreeBSD x86-64 version
+   Copyright (C) 2015 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* This causes the current thread to exit, without affecting other
+   threads in the process if there are any.  If there are no other
+   threads left, then this has the effect of _exit (0).  */
+
+static inline void __attribute__ ((noreturn, always_inline, unused))
+__exit_thread (void)
+{
+  /* Doing this in a loop is mostly just to satisfy the compiler that the
+     function really qualifies as noreturn.  It also means that in some
+     pathological situation where the system call does not get made or does
+     not work, the thread will simply spin rather than running off the end
+     of the caller and doing unexpectedly strange things.  */
+  while (1)
+    {
+      asm volatile (
+	  "movq %%fs:0, %%rdi\n\t"
+	  "addq %0, %%rdi\n\t"    /* should be KTID, but they are at the same place anyway */
+	  "movl %1, %%eax\n\t"
+	  "syscall\n\t"
+	  /* It does return only for last thread of process */
+	  "movl %2, %%eax\n\t"
+	  "xorl %%edi, %%edi\n\t"
+	  "syscall\n\t"
+	  :
+	  : "i" (TID), "i" (SYS_ify(thr_exit)), "i" (SYS_ify(exit))
+	  : "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11");
+    }
+}
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/Implies
@@ -0,0 +1 @@
+unix/bsd/bsd4.4/kfreebsd/x86/fbtl
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/asm/prctl.h
@@ -0,0 +1 @@
+/* placeholder to linuxish sysdeps/x86_64/pt-machine.h happy */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/cancellation.S
@@ -0,0 +1,119 @@
+/* Copyright (C) 2009, 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <tcb-offsets.h>
+#include <kernel-features.h>
+#include "lowlevellock.h"
+
+#if IS_IN (libpthread)
+# ifdef SHARED
+#  define __pthread_unwind __GI___pthread_unwind
+# endif
+#else
+# ifndef SHARED
+	.weak __pthread_unwind
+# endif
+#endif
+
+
+/* It is crucial that the functions in this file don't modify registers
+   other than %rax and %r11.  The syscall wrapper code depends on this
+   because it doesn't explicitly save the other registers which hold
+   relevant values.  */
+	.text
+
+	.hidden __pthread_enable_asynccancel
+ENTRY(__pthread_enable_asynccancel)
+	movl	%fs:CANCELHANDLING, %eax
+2:	movl	%eax, %r11d
+	orl	$TCB_CANCELTYPE_BITMASK, %r11d
+	cmpl	%eax, %r11d
+	je	1f
+
+	lock
+	cmpxchgl %r11d, %fs:CANCELHANDLING
+	jnz	2b
+
+	andl	$(TCB_CANCELSTATE_BITMASK|TCB_CANCELTYPE_BITMASK|TCB_CANCELED_BITMASK|TCB_EXITING_BITMASK|TCB_CANCEL_RESTMASK|TCB_TERMINATED_BITMASK), %r11d
+	cmpl	$(TCB_CANCELTYPE_BITMASK|TCB_CANCELED_BITMASK), %r11d
+	je	3f
+
+1:	ret
+
+3:	subq	$8, %rsp
+	cfi_adjust_cfa_offset(8)
+	LP_OP(mov) $TCB_PTHREAD_CANCELED, %fs:RESULT
+	lock
+	orl	$TCB_EXITING_BITMASK, %fs:CANCELHANDLING
+	mov	%fs:CLEANUP_JMP_BUF, %RDI_LP
+#ifdef SHARED
+	call	__pthread_unwind@PLT
+#else
+	call	__pthread_unwind
+#endif
+	hlt
+END(__pthread_enable_asynccancel)
+
+
+	.hidden __pthread_disable_asynccancel
+ENTRY(__pthread_disable_asynccancel)
+	testl	$TCB_CANCELTYPE_BITMASK, %edi
+	jnz	1f
+
+	movl	%fs:CANCELHANDLING, %eax
+2:	movl	%eax, %r11d
+	andl	$~TCB_CANCELTYPE_BITMASK, %r11d
+	lock
+	cmpxchgl %r11d, %fs:CANCELHANDLING
+	jnz	2b
+
+	movl	%r11d, %eax
+3:	andl	$(TCB_CANCELING_BITMASK|TCB_CANCELED_BITMASK), %eax
+	cmpl	$TCB_CANCELING_BITMASK, %eax
+	je	4f
+1:	ret
+
+# define UMTX_OP_WAIT_UINT_PRIVATE 15
+# define LOAD_PRIVATE_FUTEX_WAIT(reg) \
+	movl	$UMTX_OP_WAIT_UINT_PRIVATE, reg
+
+	/* Performance doesn't matter in this loop.  We will
+	   delay until the thread is canceled.  And we will unlikely
+	   enter the loop twice.  */
+
+# warning check this:
+	/* 
+           The C-code repeatedy does:
+           lll_futex_wait (&self->cancelhandling, newval, LLL_PRIVATE); 
+           newval = THREAD_GETMEM (self, cancelhandling);
+
+           but the original NPTL code does not fill rdx 
+           with the old value ... 
+        */
+
+4:	mov	%fs:0, %RDI_LP
+	movl	$SYS__umtx_op, %eax
+	xorq	%r8, %r8
+	xorq	%r10, %r10
+	addq	$CANCELHANDLING, %rdi
+	LOAD_PRIVATE_FUTEX_WAIT (%esi)
+	syscall
+	movl	%fs:CANCELHANDLING, %eax
+	jmp	3b
+END(__pthread_disable_asynccancel)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/libc-cancellation.S
@@ -0,0 +1,21 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __pthread_enable_asynccancel __libc_enable_asynccancel
+#define __pthread_disable_asynccancel __libc_disable_asynccancel
+#include "cancellation.S"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/librt-cancellation.S
@@ -0,0 +1,21 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@redhat.com>, 2009.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __pthread_enable_asynccancel __librt_enable_asynccancel
+#define __pthread_disable_asynccancel __librt_disable_asynccancel
+#include "cancellation.S"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/pt-vfork.S
@@ -0,0 +1,29 @@
+/* Copyright (C) 2004-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <tcb-offsets.h>
+
+#define SAVE_PID \
+	movl	%fs:PID, %esi;						      \
+	movl	%esi, %edx;						      \
+	negl	%edx;							      \
+	movl	%edx, %fs:PID
+
+#define RESTORE_PID_IN_PARENT \
+	movl	%esi, %fs:PID;						      \
+
+#include "../vfork.S"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/sysdep-cancel.h
@@ -0,0 +1,111 @@
+/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>, 2002.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <tls.h>
+#ifndef __ASSEMBLER__
+# include <fbtl/pthreadP.h>
+#endif
+
+/* Syscalls with more than 6 arguments are not supported here.  */
+
+#if IS_IN (libc) || IS_IN (libpthread) || IS_IN (librt)
+
+/* The code to disable cancellation depends on the fact that the called
+   functions are special.  They don't modify registers other than %rax
+   and %r11 if they return.  Therefore we don't have to preserve other
+   registers around these calls.  */
+# undef PSEUDO
+# define PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    SINGLE_THREAD_P;							      \
+    jne L(pseudo_cancel);						      \
+  .type __##syscall_name##_nocancel,@function;				      \
+  .globl __##syscall_name##_nocancel;					      \
+  __##syscall_name##_nocancel:						      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+    ret;								      \
+  .size __##syscall_name##_nocancel,.-__##syscall_name##_nocancel;	      \
+  L(pseudo_cancel):							      \
+    /* We always have to align the stack before calling a function.  */	      \
+    subq $8, %rsp; cfi_adjust_cfa_offset (8);				      \
+    CENABLE								      \
+    /* The return value from CENABLE is argument for CDISABLE.  */	      \
+    movq %rax, (%rsp);							      \
+    DO_CALL (syscall_name, args);					      \
+    popq %rdi; cfi_adjust_cfa_offset(-8);				      \
+    pushfq; cfi_adjust_cfa_offset(8);					      \
+    /* Save %rax since it's the error code from the syscall.  */	      \
+    movq %rax, %rsi;							      \
+    CDISABLE								      \
+    popfq; cfi_adjust_cfa_offset(-8);					      \
+    /* fetch the error code from the syscall.  */			      \
+    movq %rsi, %rax;							      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):							      \
+
+# if IS_IN (libpthread)
+#  define CENABLE	call __pthread_enable_asynccancel;
+#  define CDISABLE	call __pthread_disable_asynccancel;
+#  define __local_multiple_threads __pthread_multiple_threads
+# elif IS_IN (libc)
+#  define CENABLE	call __libc_enable_asynccancel;
+#  define CDISABLE	call __libc_disable_asynccancel;
+#  define __local_multiple_threads __libc_multiple_threads
+# elif IS_IN (librt)
+#  define CENABLE	call __librt_enable_asynccancel;
+#  define CDISABLE	call __librt_disable_asynccancel;
+# else
+#  error Unsupported library
+# endif
+
+# if IS_IN (libpthread) || IS_IN (libc)
+#  ifndef __ASSEMBLER__
+extern int __local_multiple_threads attribute_hidden;
+#   define SINGLE_THREAD_P \
+  __builtin_expect (__local_multiple_threads == 0, 1)
+#  else
+#   define SINGLE_THREAD_P cmpl $0, __local_multiple_threads(%rip)
+#  endif
+
+# else
+
+#  ifndef __ASSEMBLER__
+#   define SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#  else
+#   define SINGLE_THREAD_P cmpl $0, %fs:MULTIPLE_THREADS_OFFSET
+#  endif
+
+# endif
+
+#elif !defined __ASSEMBLER__
+
+# define SINGLE_THREAD_P (1)
+# define NO_CANCELLATION 1
+
+#endif
+
+#ifndef __ASSEMBLER__
+# define RTLD_SINGLE_THREAD_P \
+  __builtin_expect (THREAD_GETMEM (THREAD_SELF, \
+				   header.multiple_threads) == 0, 1)
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/tls.h
@@ -0,0 +1,73 @@
+/* Definitions for thread-local data handling.  fbtl/x86-64 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _FREEBSD_TLS_H
+#define _FREEBSD_TLS_H
+
+#include <fbtl/sysdeps/x86_64/tls.h>
+
+#ifndef __ASSEMBLER__
+
+#include <sysarch.h>
+#include <sys/syscall.h>
+
+#if 0
+/* in Linux one; */
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF_INCLUDE  <sys/reg.h> /* For the FS constant.  */
+# define DB_THREAD_SELF CONST_THREAD_AREA (64, FS)
+#else
+/* # warning proper FS constant needed */
+# undef DB_THREAD_SELF_INCLUDE
+# undef DB_THREAD_SELF
+# define DB_THREAD_SELF CONST_THREAD_AREA (64, 25)
+#endif
+
+/* Code to initially initialize the thread pointer.  This might need
+   special attention since 'errno' is not yet available and if the
+   operation can cause a failure 'errno' must not be touched.  */
+
+# undef TLS_INIT_TP
+# define TLS_INIT_TP(descr)						      \
+  ({									      \
+    void *_descr = (descr);						      \
+    tcbhead_t *head = _descr;						      \
+    long int _result;							      \
+									      \
+    head->tcb = _descr;							      \
+    /* For now the thread descriptor is at the same address.  */	      \
+    head->self = _descr;						      \
+									      \
+    asm volatile ("syscall"						      \
+		  : "=a" (_result)					      \
+		  : "0" ((unsigned long int) SYS_sysarch),		      \
+		    "D" ((unsigned long int) AMD64_SET_FSBASE),		      \
+		    "S" (&_descr)					      \
+		  : "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11");    \
+									      \
+    _result ? "cannot set %fs base address for thread-local storage" : 0;     \
+  })
+
+/* in fact this is OS-specific, but we do not have better header for it */
+#define NEED_STACK_SIZE_FOR_PTH_CREATE 1
+
+#endif /* __ASSEMBLER__ */
+
+#endif	/* tls.h */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fbtl/vfork.S
@@ -0,0 +1,31 @@
+/* Copyright (C) 2004-2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <tcb-offsets.h>
+
+#define SAVE_PID \
+	movl	%fs:PID, %esi;						      \
+	movl	$0x80000000, %ecx;					      \
+	movl	%esi, %edx;						      \
+	negl	%edx;							      \
+	cmove	%ecx, %edx;						      \
+	movl	%edx, %fs:PID
+
+#define RESTORE_PID_IN_PARENT \
+	movl	%esi, %fs:PID;						      \
+
+#include "../vfork.S"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fts.c
@@ -0,0 +1,3 @@
+/* On GNU/kFreeBSD x86_64, ino_t and ino64_t have different sizes, so
+   fts and fts64 have to be different functions.  */
+#include <io/fts.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/fts64.c
@@ -0,0 +1,3 @@
+/* On GNU/kFreeBSD x86_64, ino_t and ino64_t have different sizes, so
+   fts and fts64 have to be different functions.  */
+#include <io/fts64.c>
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/get_clockfreq.c
@@ -0,0 +1 @@
+#include "../i386/get_clockfreq.c"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/getcontext.S
@@ -0,0 +1,38 @@
+/* Save current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__getcontext)
+        clc
+        movq 0(%rsp), %rsi	/* save the return PC value */
+
+        DO_CALL (getcontext, 1)
+        jb SYSCALL_ERROR_LABEL
+
+        addq $8, %rsp		/* remove stale return address */
+        jmp  *%rsi
+
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__getcontext)
+
+weak_alias(__getcontext, getcontext)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ioperm.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sys/perm.h>
+#include <sysarch.h>
+
+int
+ioperm (unsigned long int from, unsigned long int num, int turn_on)
+{
+  struct i386_ioperm_args args;
+
+  args.start = from;
+  args.length = num;
+  args.enable = turn_on;
+
+  return __sysarch (I386_SET_IOPERM, &args);
+}
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/iopl.c
@@ -0,0 +1 @@
+#include "../i386/iopl.c"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ld.abilist
@@ -0,0 +1,11 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 __libc_memalign F
+GLIBC_2.3 __libc_stack_end D 0x8
+GLIBC_2.3 __tls_get_addr F
+GLIBC_2.3 _dl_mcount F
+GLIBC_2.3 _r_debug D 0x28
+GLIBC_2.3 calloc F
+GLIBC_2.3 free F
+GLIBC_2.3 malloc F
+GLIBC_2.3 realloc F
+GLIBC_2.4 GLIBC_2.4 A
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldconfig.h
@@ -0,0 +1,39 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdeps/generic/ldconfig.h>
+
+#define SYSDEP_KNOWN_INTERPRETER_NAMES \
+  { "/lib/ld.so.1", FLAG_ELF_LIBC6 },				\
+  { "/lib/ld-kfreebsd-x86-64.so.1", FLAG_ELF_LIBC6 },		\
+  { "/lib64/ld-kfreebsd-x86-64.so.1", FLAG_ELF_LIBC6 },		\
+  { "/libexec/ld-elf.so.1", FLAG_ELF_LIBC5 },
+
+#define SYSDEP_KNOWN_LIBRARY_NAMES \
+  { "libc.so.0.1", FLAG_ELF_LIBC6 },				\
+  { "libm.so.1", FLAG_ELF_LIBC6 },				\
+  { "libc.so.4", FLAG_ELF_LIBC5 },				\
+  { "libm.so.4", FLAG_ELF_LIBC5 },				\
+  { "libc.so.5", FLAG_ELF_LIBC5 },				\
+  { "libm.so.5", FLAG_ELF_LIBC5 },				\
+  { "libc.so.6", FLAG_ELF_LIBC5 },				\
+  { "libm.so.6", FLAG_ELF_LIBC5 },				\
+  { "libc.so.7", FLAG_ELF_LIBC5 },				\
+  { "libm.so.7", FLAG_ELF_LIBC5 },				\
+  { "libc.so.8", FLAG_ELF_LIBC5 },				\
+  { "libm.so.8", FLAG_ELF_LIBC5 },
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ldd-rewrite.sed
@@ -0,0 +1,3 @@
+/LD_TRACE_LOADED_OBJECTS=1/a\
+add_env="$add_env LD_LIBRARY_VERSION=\\$verify_out"
+s_^\(RTLDLIST=\)\(.*lib\)\(\|64\)\(/[^/]*\)\(-kfreebsd-x86-64\)\(\.so\.[0-9.]*\)[ 	]*$_\1"\2\4\6 \2\4\5\6"_
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libBrokenLocale.abilist
@@ -0,0 +1,2 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 __ctype_get_mb_cur_max F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libanl.abilist
@@ -0,0 +1,5 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 gai_cancel F
+GLIBC_2.3 gai_error F
+GLIBC_2.3 gai_suspend F
+GLIBC_2.3 getaddrinfo_a F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libc.abilist
@@ -0,0 +1,2142 @@
+GLIBC_2.10 GLIBC_2.10 A
+GLIBC_2.10 __cxa_at_quick_exit F
+GLIBC_2.10 __posix_getopt F
+GLIBC_2.10 accept4 F
+GLIBC_2.10 devname F
+GLIBC_2.10 devname_r F
+GLIBC_2.10 endsgent F
+GLIBC_2.10 fgetsgent F
+GLIBC_2.10 fgetsgent_r F
+GLIBC_2.10 getsgent F
+GLIBC_2.10 getsgent_r F
+GLIBC_2.10 getsgnam F
+GLIBC_2.10 getsgnam_r F
+GLIBC_2.10 ioperm F
+GLIBC_2.10 kenv F
+GLIBC_2.10 malloc_info F
+GLIBC_2.10 preadv F
+GLIBC_2.10 preadv64 F
+GLIBC_2.10 psiginfo F
+GLIBC_2.10 putsgent F
+GLIBC_2.10 pwritev F
+GLIBC_2.10 pwritev64 F
+GLIBC_2.10 quick_exit F
+GLIBC_2.10 register_printf_modifier F
+GLIBC_2.10 register_printf_specifier F
+GLIBC_2.10 register_printf_type F
+GLIBC_2.10 setsgent F
+GLIBC_2.10 sgetsgent F
+GLIBC_2.10 sgetsgent_r F
+GLIBC_2.10 sysctlnametomib F
+GLIBC_2.11 GLIBC_2.11 A
+GLIBC_2.11 __longjmp_chk F
+GLIBC_2.11 _sys_errlist D 0x2f0
+GLIBC_2.11 _sys_nerr D 0x4
+GLIBC_2.11 execvpe F
+GLIBC_2.11 lchflags F
+GLIBC_2.11 mkostemps F
+GLIBC_2.11 mkostemps64 F
+GLIBC_2.11 mkstemps F
+GLIBC_2.11 mkstemps64 F
+GLIBC_2.11 sys_errlist D 0x2f0
+GLIBC_2.11 sys_nerr D 0x4
+GLIBC_2.13 GLIBC_2.13 A
+GLIBC_2.13 __fentry__ F
+GLIBC_2.13 jail_attach F
+GLIBC_2.13 jail_get F
+GLIBC_2.13 jail_remove F
+GLIBC_2.13 jail_set F
+GLIBC_2.14 GLIBC_2.14 A
+GLIBC_2.14 memcpy F
+GLIBC_2.14 syncfs F
+GLIBC_2.15 GLIBC_2.15 A
+GLIBC_2.15 __fdelt_chk F
+GLIBC_2.15 __fdelt_warn F
+GLIBC_2.15 posix_spawn F
+GLIBC_2.15 posix_spawnp F
+GLIBC_2.15 scandirat F
+GLIBC_2.15 scandirat64 F
+GLIBC_2.16 GLIBC_2.16 A
+GLIBC_2.16 __getauxval F
+GLIBC_2.16 __poll_chk F
+GLIBC_2.16 __ppoll_chk F
+GLIBC_2.16 aligned_alloc F
+GLIBC_2.16 c16rtomb F
+GLIBC_2.16 c32rtomb F
+GLIBC_2.16 getauxval F
+GLIBC_2.16 mbrtoc16 F
+GLIBC_2.16 mbrtoc32 F
+GLIBC_2.16 timespec_get F
+GLIBC_2.17 GLIBC_2.17 A
+GLIBC_2.17 clock_getcpuclockid F
+GLIBC_2.17 clock_getres F
+GLIBC_2.17 clock_gettime F
+GLIBC_2.17 clock_nanosleep F
+GLIBC_2.17 clock_settime F
+GLIBC_2.17 recvmmsg F
+GLIBC_2.17 secure_getenv F
+GLIBC_2.17 sendmmsg F
+GLIBC_2.18 GLIBC_2.18 A
+GLIBC_2.18 __cxa_thread_atexit_impl F
+GLIBC_2.18 _sys_errlist D 0x308
+GLIBC_2.18 _sys_nerr D 0x4
+GLIBC_2.18 msgctl F
+GLIBC_2.18 semctl F
+GLIBC_2.18 shmctl F
+GLIBC_2.18 sys_errlist D 0x308
+GLIBC_2.18 sys_nerr D 0x4
+GLIBC_2.18 waitid F
+GLIBC_2.21 GLIBC_2.21 A
+GLIBC_2.21 __statfs F
+GLIBC_2.22 GLIBC_2.22 A
+GLIBC_2.22 fmemopen F
+GLIBC_2.23 GLIBC_2.23 A
+GLIBC_2.23 fts64_children F
+GLIBC_2.23 fts64_close F
+GLIBC_2.23 fts64_open F
+GLIBC_2.23 fts64_read F
+GLIBC_2.23 fts64_set F
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 _Exit F
+GLIBC_2.3 _IO_2_1_stderr_ D 0xe0
+GLIBC_2.3 _IO_2_1_stdin_ D 0xe0
+GLIBC_2.3 _IO_2_1_stdout_ D 0xe0
+GLIBC_2.3 _IO_adjust_column F
+GLIBC_2.3 _IO_adjust_wcolumn F
+GLIBC_2.3 _IO_default_doallocate F
+GLIBC_2.3 _IO_default_finish F
+GLIBC_2.3 _IO_default_pbackfail F
+GLIBC_2.3 _IO_default_uflow F
+GLIBC_2.3 _IO_default_xsgetn F
+GLIBC_2.3 _IO_default_xsputn F
+GLIBC_2.3 _IO_do_write F
+GLIBC_2.3 _IO_doallocbuf F
+GLIBC_2.3 _IO_fclose F
+GLIBC_2.3 _IO_fdopen F
+GLIBC_2.3 _IO_feof F
+GLIBC_2.3 _IO_ferror F
+GLIBC_2.3 _IO_fflush F
+GLIBC_2.3 _IO_fgetpos F
+GLIBC_2.3 _IO_fgetpos64 F
+GLIBC_2.3 _IO_fgets F
+GLIBC_2.3 _IO_file_attach F
+GLIBC_2.3 _IO_file_close F
+GLIBC_2.3 _IO_file_close_it F
+GLIBC_2.3 _IO_file_doallocate F
+GLIBC_2.3 _IO_file_finish F
+GLIBC_2.3 _IO_file_fopen F
+GLIBC_2.3 _IO_file_init F
+GLIBC_2.3 _IO_file_jumps D 0xa8
+GLIBC_2.3 _IO_file_open F
+GLIBC_2.3 _IO_file_overflow F
+GLIBC_2.3 _IO_file_read F
+GLIBC_2.3 _IO_file_seek F
+GLIBC_2.3 _IO_file_seekoff F
+GLIBC_2.3 _IO_file_setbuf F
+GLIBC_2.3 _IO_file_stat F
+GLIBC_2.3 _IO_file_sync F
+GLIBC_2.3 _IO_file_underflow F
+GLIBC_2.3 _IO_file_write F
+GLIBC_2.3 _IO_file_xsputn F
+GLIBC_2.3 _IO_flockfile F
+GLIBC_2.3 _IO_flush_all F
+GLIBC_2.3 _IO_flush_all_linebuffered F
+GLIBC_2.3 _IO_fopen F
+GLIBC_2.3 _IO_fprintf F
+GLIBC_2.3 _IO_fputs F
+GLIBC_2.3 _IO_fread F
+GLIBC_2.3 _IO_free_backup_area F
+GLIBC_2.3 _IO_free_wbackup_area F
+GLIBC_2.3 _IO_fsetpos F
+GLIBC_2.3 _IO_fsetpos64 F
+GLIBC_2.3 _IO_ftell F
+GLIBC_2.3 _IO_ftrylockfile F
+GLIBC_2.3 _IO_funlockfile F
+GLIBC_2.3 _IO_fwrite F
+GLIBC_2.3 _IO_getc F
+GLIBC_2.3 _IO_getline F
+GLIBC_2.3 _IO_getline_info F
+GLIBC_2.3 _IO_gets F
+GLIBC_2.3 _IO_init F
+GLIBC_2.3 _IO_init_marker F
+GLIBC_2.3 _IO_init_wmarker F
+GLIBC_2.3 _IO_iter_begin F
+GLIBC_2.3 _IO_iter_end F
+GLIBC_2.3 _IO_iter_file F
+GLIBC_2.3 _IO_iter_next F
+GLIBC_2.3 _IO_least_wmarker F
+GLIBC_2.3 _IO_link_in F
+GLIBC_2.3 _IO_list_all D 0x8
+GLIBC_2.3 _IO_list_lock F
+GLIBC_2.3 _IO_list_resetlock F
+GLIBC_2.3 _IO_list_unlock F
+GLIBC_2.3 _IO_marker_delta F
+GLIBC_2.3 _IO_marker_difference F
+GLIBC_2.3 _IO_padn F
+GLIBC_2.3 _IO_peekc_locked F
+GLIBC_2.3 _IO_popen F
+GLIBC_2.3 _IO_printf F
+GLIBC_2.3 _IO_proc_close F
+GLIBC_2.3 _IO_proc_open F
+GLIBC_2.3 _IO_putc F
+GLIBC_2.3 _IO_puts F
+GLIBC_2.3 _IO_remove_marker F
+GLIBC_2.3 _IO_seekmark F
+GLIBC_2.3 _IO_seekoff F
+GLIBC_2.3 _IO_seekpos F
+GLIBC_2.3 _IO_seekwmark F
+GLIBC_2.3 _IO_setb F
+GLIBC_2.3 _IO_setbuffer F
+GLIBC_2.3 _IO_setvbuf F
+GLIBC_2.3 _IO_sgetn F
+GLIBC_2.3 _IO_sprintf F
+GLIBC_2.3 _IO_sputbackc F
+GLIBC_2.3 _IO_sputbackwc F
+GLIBC_2.3 _IO_sscanf F
+GLIBC_2.3 _IO_str_init_readonly F
+GLIBC_2.3 _IO_str_init_static F
+GLIBC_2.3 _IO_str_overflow F
+GLIBC_2.3 _IO_str_pbackfail F
+GLIBC_2.3 _IO_str_seekoff F
+GLIBC_2.3 _IO_str_underflow F
+GLIBC_2.3 _IO_sungetc F
+GLIBC_2.3 _IO_sungetwc F
+GLIBC_2.3 _IO_switch_to_get_mode F
+GLIBC_2.3 _IO_switch_to_main_wget_area F
+GLIBC_2.3 _IO_switch_to_wbackup_area F
+GLIBC_2.3 _IO_switch_to_wget_mode F
+GLIBC_2.3 _IO_un_link F
+GLIBC_2.3 _IO_ungetc F
+GLIBC_2.3 _IO_unsave_markers F
+GLIBC_2.3 _IO_unsave_wmarkers F
+GLIBC_2.3 _IO_vfprintf F
+GLIBC_2.3 _IO_vfscanf F
+GLIBC_2.3 _IO_vsprintf F
+GLIBC_2.3 _IO_wdefault_doallocate F
+GLIBC_2.3 _IO_wdefault_finish F
+GLIBC_2.3 _IO_wdefault_pbackfail F
+GLIBC_2.3 _IO_wdefault_uflow F
+GLIBC_2.3 _IO_wdefault_xsgetn F
+GLIBC_2.3 _IO_wdefault_xsputn F
+GLIBC_2.3 _IO_wdo_write F
+GLIBC_2.3 _IO_wdoallocbuf F
+GLIBC_2.3 _IO_wfile_jumps D 0xa8
+GLIBC_2.3 _IO_wfile_overflow F
+GLIBC_2.3 _IO_wfile_seekoff F
+GLIBC_2.3 _IO_wfile_sync F
+GLIBC_2.3 _IO_wfile_underflow F
+GLIBC_2.3 _IO_wfile_xsputn F
+GLIBC_2.3 _IO_wmarker_delta F
+GLIBC_2.3 _IO_wsetb F
+GLIBC_2.3 __acl_aclcheck_fd F
+GLIBC_2.3 __acl_aclcheck_file F
+GLIBC_2.3 __acl_delete_fd F
+GLIBC_2.3 __acl_delete_file F
+GLIBC_2.3 __acl_get_fd F
+GLIBC_2.3 __acl_get_file F
+GLIBC_2.3 __acl_set_fd F
+GLIBC_2.3 __acl_set_file F
+GLIBC_2.3 __after_morecore_hook D 0x8
+GLIBC_2.3 __argz_count F
+GLIBC_2.3 __argz_next F
+GLIBC_2.3 __argz_stringify F
+GLIBC_2.3 __asprintf F
+GLIBC_2.3 __assert F
+GLIBC_2.3 __assert_fail F
+GLIBC_2.3 __assert_perror_fail F
+GLIBC_2.3 __backtrace F
+GLIBC_2.3 __backtrace_symbols F
+GLIBC_2.3 __backtrace_symbols_fd F
+GLIBC_2.3 __bsd_getpgrp F
+GLIBC_2.3 __bzero F
+GLIBC_2.3 __check_rhosts_file D 0x4
+GLIBC_2.3 __close F
+GLIBC_2.3 __cmsg_nxthdr F
+GLIBC_2.3 __connect F
+GLIBC_2.3 __ctype_b_loc F
+GLIBC_2.3 __ctype_get_mb_cur_max F
+GLIBC_2.3 __ctype_tolower_loc F
+GLIBC_2.3 __ctype_toupper_loc F
+GLIBC_2.3 __curbrk D 0x8
+GLIBC_2.3 __cxa_atexit F
+GLIBC_2.3 __cxa_finalize F
+GLIBC_2.3 __cyg_profile_func_enter F
+GLIBC_2.3 __cyg_profile_func_exit F
+GLIBC_2.3 __daylight D 0x4
+GLIBC_2.3 __dcgettext F
+GLIBC_2.3 __default_morecore F
+GLIBC_2.3 __dgettext F
+GLIBC_2.3 __dup2 F
+GLIBC_2.3 __duplocale F
+GLIBC_2.3 __environ D 0x8
+GLIBC_2.3 __errno_location F
+GLIBC_2.3 __fbufsize F
+GLIBC_2.3 __fcntl F
+GLIBC_2.3 __ffs F
+GLIBC_2.3 __finite F
+GLIBC_2.3 __finitef F
+GLIBC_2.3 __finitel F
+GLIBC_2.3 __flbf F
+GLIBC_2.3 __fork F
+GLIBC_2.3 __fpending F
+GLIBC_2.3 __fpu_control D 0x2
+GLIBC_2.3 __fpurge F
+GLIBC_2.3 __freadable F
+GLIBC_2.3 __freading F
+GLIBC_2.3 __free_hook D 0x8
+GLIBC_2.3 __freelocale F
+GLIBC_2.3 __fsetlocking F
+GLIBC_2.3 __fwritable F
+GLIBC_2.3 __fwriting F
+GLIBC_2.3 __fxstat F
+GLIBC_2.3 __fxstat64 F
+GLIBC_2.3 __getdelim F
+GLIBC_2.3 __getpagesize F
+GLIBC_2.3 __getpgid F
+GLIBC_2.3 __getpid F
+GLIBC_2.3 __gettimeofday F
+GLIBC_2.3 __gmtime_r F
+GLIBC_2.3 __h_errno_location F
+GLIBC_2.3 __isalnum_l F
+GLIBC_2.3 __isalpha_l F
+GLIBC_2.3 __isascii_l F
+GLIBC_2.3 __isblank_l F
+GLIBC_2.3 __iscntrl_l F
+GLIBC_2.3 __isctype F
+GLIBC_2.3 __isdigit_l F
+GLIBC_2.3 __isgraph_l F
+GLIBC_2.3 __isinf F
+GLIBC_2.3 __isinff F
+GLIBC_2.3 __isinfl F
+GLIBC_2.3 __islower_l F
+GLIBC_2.3 __isnan F
+GLIBC_2.3 __isnanf F
+GLIBC_2.3 __isnanl F
+GLIBC_2.3 __isprint_l F
+GLIBC_2.3 __ispunct_l F
+GLIBC_2.3 __isspace_l F
+GLIBC_2.3 __isupper_l F
+GLIBC_2.3 __iswalnum_l F
+GLIBC_2.3 __iswalpha_l F
+GLIBC_2.3 __iswblank_l F
+GLIBC_2.3 __iswcntrl_l F
+GLIBC_2.3 __iswctype F
+GLIBC_2.3 __iswctype_l F
+GLIBC_2.3 __iswdigit_l F
+GLIBC_2.3 __iswgraph_l F
+GLIBC_2.3 __iswlower_l F
+GLIBC_2.3 __iswprint_l F
+GLIBC_2.3 __iswpunct_l F
+GLIBC_2.3 __iswspace_l F
+GLIBC_2.3 __iswupper_l F
+GLIBC_2.3 __iswxdigit_l F
+GLIBC_2.3 __isxdigit_l F
+GLIBC_2.3 __ivaliduser F
+GLIBC_2.3 __key_decryptsession_pk_LOCAL D 0x8
+GLIBC_2.3 __key_encryptsession_pk_LOCAL D 0x8
+GLIBC_2.3 __key_gendes_LOCAL D 0x8
+GLIBC_2.3 __libc_allocate_rtsig F
+GLIBC_2.3 __libc_calloc F
+GLIBC_2.3 __libc_current_sigrtmax F
+GLIBC_2.3 __libc_current_sigrtmin F
+GLIBC_2.3 __libc_free F
+GLIBC_2.3 __libc_freeres F
+GLIBC_2.3 __libc_init_first F
+GLIBC_2.3 __libc_mallinfo F
+GLIBC_2.3 __libc_malloc F
+GLIBC_2.3 __libc_mallopt F
+GLIBC_2.3 __libc_memalign F
+GLIBC_2.3 __libc_pvalloc F
+GLIBC_2.3 __libc_realloc F
+GLIBC_2.3 __libc_start_main F
+GLIBC_2.3 __libc_valloc F
+GLIBC_2.3 __lseek F
+GLIBC_2.3 __lxstat F
+GLIBC_2.3 __lxstat64 F
+GLIBC_2.3 __malloc_hook D 0x8
+GLIBC_2.3 __malloc_initialize_hook D 0x8
+GLIBC_2.3 __mbrlen F
+GLIBC_2.3 __mbrtowc F
+GLIBC_2.3 __memalign_hook D 0x8
+GLIBC_2.3 __mempcpy F
+GLIBC_2.3 __mempcpy_small F
+GLIBC_2.3 __monstartup F
+GLIBC_2.3 __morecore D 0x8
+GLIBC_2.3 __nanosleep F
+GLIBC_2.3 __newlocale F
+GLIBC_2.3 __nl_langinfo_l F
+GLIBC_2.3 __nss_configure_lookup F
+GLIBC_2.3 __nss_database_lookup F
+GLIBC_2.3 __nss_group_lookup F
+GLIBC_2.3 __nss_hostname_digits_dots F
+GLIBC_2.3 __nss_hosts_lookup F
+GLIBC_2.3 __nss_next F
+GLIBC_2.3 __nss_passwd_lookup F
+GLIBC_2.3 __open F
+GLIBC_2.3 __overflow F
+GLIBC_2.3 __pipe F
+GLIBC_2.3 __poll F
+GLIBC_2.3 __pread64 F
+GLIBC_2.3 __printf_fp F
+GLIBC_2.3 __profile_frequency F
+GLIBC_2.3 __progname D 0x8
+GLIBC_2.3 __progname_full D 0x8
+GLIBC_2.3 __pwrite64 F
+GLIBC_2.3 __rawmemchr F
+GLIBC_2.3 __rcmd_errstr D 0x8
+GLIBC_2.3 __read F
+GLIBC_2.3 __realloc_hook D 0x8
+GLIBC_2.3 __res_init F
+GLIBC_2.3 __res_nclose F
+GLIBC_2.3 __res_ninit F
+GLIBC_2.3 __res_randomid F
+GLIBC_2.3 __res_state F
+GLIBC_2.3 __rpc_thread_createerr F
+GLIBC_2.3 __rpc_thread_svc_fdset F
+GLIBC_2.3 __rpc_thread_svc_max_pollfd F
+GLIBC_2.3 __rpc_thread_svc_pollfd F
+GLIBC_2.3 __sbrk F
+GLIBC_2.3 __sched_get_priority_max F
+GLIBC_2.3 __sched_get_priority_min F
+GLIBC_2.3 __sched_getparam F
+GLIBC_2.3 __sched_getscheduler F
+GLIBC_2.3 __sched_setscheduler F
+GLIBC_2.3 __sched_yield F
+GLIBC_2.3 __secure_getenv F
+GLIBC_2.3 __select F
+GLIBC_2.3 __send F
+GLIBC_2.3 __setpgid F
+GLIBC_2.3 __sigaction F
+GLIBC_2.3 __sigaddset F
+GLIBC_2.3 __sigdelset F
+GLIBC_2.3 __sigismember F
+GLIBC_2.3 __signbit F
+GLIBC_2.3 __signbitf F
+GLIBC_2.3 __signbitl F
+GLIBC_2.3 __sigpause F
+GLIBC_2.3 __sigsetjmp F
+GLIBC_2.3 __sigsuspend F
+GLIBC_2.3 __stpcpy F
+GLIBC_2.3 __stpcpy_small F
+GLIBC_2.3 __stpncpy F
+GLIBC_2.3 __strcasecmp F
+GLIBC_2.3 __strcasecmp_l F
+GLIBC_2.3 __strcasestr F
+GLIBC_2.3 __strcoll_l F
+GLIBC_2.3 __strcpy_small F
+GLIBC_2.3 __strcspn_c1 F
+GLIBC_2.3 __strcspn_c2 F
+GLIBC_2.3 __strcspn_c3 F
+GLIBC_2.3 __strdup F
+GLIBC_2.3 __strerror_r F
+GLIBC_2.3 __strfmon_l F
+GLIBC_2.3 __strftime_l F
+GLIBC_2.3 __strncasecmp_l F
+GLIBC_2.3 __strndup F
+GLIBC_2.3 __strpbrk_c2 F
+GLIBC_2.3 __strpbrk_c3 F
+GLIBC_2.3 __strsep_1c F
+GLIBC_2.3 __strsep_2c F
+GLIBC_2.3 __strsep_3c F
+GLIBC_2.3 __strsep_g F
+GLIBC_2.3 __strspn_c1 F
+GLIBC_2.3 __strspn_c2 F
+GLIBC_2.3 __strspn_c3 F
+GLIBC_2.3 __strtod_internal F
+GLIBC_2.3 __strtod_l F
+GLIBC_2.3 __strtof_internal F
+GLIBC_2.3 __strtof_l F
+GLIBC_2.3 __strtok_r F
+GLIBC_2.3 __strtok_r_1c F
+GLIBC_2.3 __strtol_internal F
+GLIBC_2.3 __strtol_l F
+GLIBC_2.3 __strtold_internal F
+GLIBC_2.3 __strtold_l F
+GLIBC_2.3 __strtoll_internal F
+GLIBC_2.3 __strtoll_l F
+GLIBC_2.3 __strtoul_internal F
+GLIBC_2.3 __strtoul_l F
+GLIBC_2.3 __strtoull_internal F
+GLIBC_2.3 __strtoull_l F
+GLIBC_2.3 __strverscmp F
+GLIBC_2.3 __strxfrm_l F
+GLIBC_2.3 __syscall_aio_cancel F
+GLIBC_2.3 __syscall_aio_error F
+GLIBC_2.3 __syscall_aio_read F
+GLIBC_2.3 __syscall_aio_return F
+GLIBC_2.3 __syscall_aio_suspend F
+GLIBC_2.3 __syscall_aio_waitcomplete F
+GLIBC_2.3 __syscall_aio_write F
+GLIBC_2.3 __syscall_lio_listio F
+GLIBC_2.3 __syscall_obreak F
+GLIBC_2.3 __syscall_yield F
+GLIBC_2.3 __sysconf F
+GLIBC_2.3 __sysctl F
+GLIBC_2.3 __sysv_signal F
+GLIBC_2.3 __timezone D 0x8
+GLIBC_2.3 __toascii_l F
+GLIBC_2.3 __tolower_l F
+GLIBC_2.3 __toupper_l F
+GLIBC_2.3 __towctrans F
+GLIBC_2.3 __towctrans_l F
+GLIBC_2.3 __towlower_l F
+GLIBC_2.3 __towupper_l F
+GLIBC_2.3 __tzname D 0x10
+GLIBC_2.3 __uflow F
+GLIBC_2.3 __underflow F
+GLIBC_2.3 __uselocale F
+GLIBC_2.3 __vfork F
+GLIBC_2.3 __vfscanf F
+GLIBC_2.3 __vsnprintf F
+GLIBC_2.3 __vsscanf F
+GLIBC_2.3 __wait F
+GLIBC_2.3 __waitpid F
+GLIBC_2.3 __wcscasecmp_l F
+GLIBC_2.3 __wcscoll_l F
+GLIBC_2.3 __wcsftime_l F
+GLIBC_2.3 __wcsncasecmp_l F
+GLIBC_2.3 __wcstod_internal F
+GLIBC_2.3 __wcstod_l F
+GLIBC_2.3 __wcstof_internal F
+GLIBC_2.3 __wcstof_l F
+GLIBC_2.3 __wcstol_internal F
+GLIBC_2.3 __wcstol_l F
+GLIBC_2.3 __wcstold_internal F
+GLIBC_2.3 __wcstold_l F
+GLIBC_2.3 __wcstoll_internal F
+GLIBC_2.3 __wcstoll_l F
+GLIBC_2.3 __wcstoul_internal F
+GLIBC_2.3 __wcstoul_l F
+GLIBC_2.3 __wcstoull_internal F
+GLIBC_2.3 __wcstoull_l F
+GLIBC_2.3 __wcsxfrm_l F
+GLIBC_2.3 __wctrans_l F
+GLIBC_2.3 __wctype_l F
+GLIBC_2.3 __woverflow F
+GLIBC_2.3 __write F
+GLIBC_2.3 __wuflow F
+GLIBC_2.3 __wunderflow F
+GLIBC_2.3 __xmknod F
+GLIBC_2.3 __xpg_basename F
+GLIBC_2.3 __xpg_sigpause F
+GLIBC_2.3 __xstat F
+GLIBC_2.3 __xstat64 F
+GLIBC_2.3 _authenticate F
+GLIBC_2.3 _dl_mcount_wrapper F
+GLIBC_2.3 _dl_mcount_wrapper_check F
+GLIBC_2.3 _environ D 0x8
+GLIBC_2.3 _exit F
+GLIBC_2.3 _flushlbf F
+GLIBC_2.3 _libc_intl_domainname D 0x5
+GLIBC_2.3 _longjmp F
+GLIBC_2.3 _mcleanup F
+GLIBC_2.3 _mcount F
+GLIBC_2.3 _nl_default_dirname D 0x12
+GLIBC_2.3 _nl_domain_bindings D 0x8
+GLIBC_2.3 _nl_msg_cat_cntr D 0x4
+GLIBC_2.3 _null_auth D 0x18
+GLIBC_2.3 _obstack D 0x8
+GLIBC_2.3 _obstack_allocated_p F
+GLIBC_2.3 _obstack_begin F
+GLIBC_2.3 _obstack_begin_1 F
+GLIBC_2.3 _obstack_free F
+GLIBC_2.3 _obstack_memory_used F
+GLIBC_2.3 _obstack_newchunk F
+GLIBC_2.3 _res D 0x238
+GLIBC_2.3 _res_hconf D 0x48
+GLIBC_2.3 _rpc_dtablesize F
+GLIBC_2.3 _seterr_reply F
+GLIBC_2.3 _setjmp F
+GLIBC_2.3 _sys_errlist D 0x2b8
+GLIBC_2.3 _sys_nerr D 0x4
+GLIBC_2.3 _sys_siglist D 0x408
+GLIBC_2.3 _tolower F
+GLIBC_2.3 _toupper F
+GLIBC_2.3 a64l F
+GLIBC_2.3 abort F
+GLIBC_2.3 abs F
+GLIBC_2.3 accept F
+GLIBC_2.3 access F
+GLIBC_2.3 acct F
+GLIBC_2.3 addmntent F
+GLIBC_2.3 addseverity F
+GLIBC_2.3 adjtime F
+GLIBC_2.3 advance F
+GLIBC_2.3 alarm F
+GLIBC_2.3 alphasort F
+GLIBC_2.3 alphasort64 F
+GLIBC_2.3 argp_err_exit_status D 0x4
+GLIBC_2.3 argp_error F
+GLIBC_2.3 argp_failure F
+GLIBC_2.3 argp_help F
+GLIBC_2.3 argp_parse F
+GLIBC_2.3 argp_program_bug_address D 0x8
+GLIBC_2.3 argp_program_version D 0x8
+GLIBC_2.3 argp_program_version_hook D 0x8
+GLIBC_2.3 argp_state_help F
+GLIBC_2.3 argp_usage F
+GLIBC_2.3 argz_add F
+GLIBC_2.3 argz_add_sep F
+GLIBC_2.3 argz_append F
+GLIBC_2.3 argz_count F
+GLIBC_2.3 argz_create F
+GLIBC_2.3 argz_create_sep F
+GLIBC_2.3 argz_delete F
+GLIBC_2.3 argz_extract F
+GLIBC_2.3 argz_insert F
+GLIBC_2.3 argz_next F
+GLIBC_2.3 argz_replace F
+GLIBC_2.3 argz_stringify F
+GLIBC_2.3 asctime F
+GLIBC_2.3 asctime_r F
+GLIBC_2.3 asprintf F
+GLIBC_2.3 atof F
+GLIBC_2.3 atoi F
+GLIBC_2.3 atol F
+GLIBC_2.3 atoll F
+GLIBC_2.3 authdes_create F
+GLIBC_2.3 authdes_getucred F
+GLIBC_2.3 authdes_pk_create F
+GLIBC_2.3 authnone_create F
+GLIBC_2.3 authunix_create F
+GLIBC_2.3 authunix_create_default F
+GLIBC_2.3 backtrace F
+GLIBC_2.3 backtrace_symbols F
+GLIBC_2.3 backtrace_symbols_fd F
+GLIBC_2.3 basename F
+GLIBC_2.3 bcmp F
+GLIBC_2.3 bcopy F
+GLIBC_2.3 bind F
+GLIBC_2.3 bind_textdomain_codeset F
+GLIBC_2.3 bindresvport F
+GLIBC_2.3 bindtextdomain F
+GLIBC_2.3 brk F
+GLIBC_2.3 bsd_signal F
+GLIBC_2.3 bsearch F
+GLIBC_2.3 btowc F
+GLIBC_2.3 bzero F
+GLIBC_2.3 calloc F
+GLIBC_2.3 callrpc F
+GLIBC_2.3 canonicalize_file_name F
+GLIBC_2.3 catclose F
+GLIBC_2.3 catgets F
+GLIBC_2.3 catopen F
+GLIBC_2.3 cbc_crypt F
+GLIBC_2.3 cfgetispeed F
+GLIBC_2.3 cfgetospeed F
+GLIBC_2.3 cfmakeraw F
+GLIBC_2.3 cfree F
+GLIBC_2.3 cfsetispeed F
+GLIBC_2.3 cfsetospeed F
+GLIBC_2.3 cfsetspeed F
+GLIBC_2.3 chdir F
+GLIBC_2.3 chflags F
+GLIBC_2.3 chmod F
+GLIBC_2.3 chown F
+GLIBC_2.3 chroot F
+GLIBC_2.3 clearenv F
+GLIBC_2.3 clearerr F
+GLIBC_2.3 clearerr_unlocked F
+GLIBC_2.3 clnt_broadcast F
+GLIBC_2.3 clnt_create F
+GLIBC_2.3 clnt_pcreateerror F
+GLIBC_2.3 clnt_perrno F
+GLIBC_2.3 clnt_perror F
+GLIBC_2.3 clnt_spcreateerror F
+GLIBC_2.3 clnt_sperrno F
+GLIBC_2.3 clnt_sperror F
+GLIBC_2.3 clntraw_create F
+GLIBC_2.3 clnttcp_create F
+GLIBC_2.3 clntudp_bufcreate F
+GLIBC_2.3 clntudp_create F
+GLIBC_2.3 clntunix_create F
+GLIBC_2.3 clock F
+GLIBC_2.3 clone F
+GLIBC_2.3 close F
+GLIBC_2.3 closedir F
+GLIBC_2.3 closelog F
+GLIBC_2.3 confstr F
+GLIBC_2.3 connect F
+GLIBC_2.3 copysign F
+GLIBC_2.3 copysignf F
+GLIBC_2.3 copysignl F
+GLIBC_2.3 creat F
+GLIBC_2.3 creat64 F
+GLIBC_2.3 ctermid F
+GLIBC_2.3 ctime F
+GLIBC_2.3 ctime_r F
+GLIBC_2.3 cuserid F
+GLIBC_2.3 daemon F
+GLIBC_2.3 daylight D 0x4
+GLIBC_2.3 dcgettext F
+GLIBC_2.3 dcngettext F
+GLIBC_2.3 des_setparity F
+GLIBC_2.3 dgettext F
+GLIBC_2.3 difftime F
+GLIBC_2.3 dirfd F
+GLIBC_2.3 dirname F
+GLIBC_2.3 div F
+GLIBC_2.3 dl_iterate_phdr F
+GLIBC_2.3 dngettext F
+GLIBC_2.3 dprintf F
+GLIBC_2.3 drand48 F
+GLIBC_2.3 drand48_r F
+GLIBC_2.3 dup F
+GLIBC_2.3 dup2 F
+GLIBC_2.3 duplocale F
+GLIBC_2.3 dysize F
+GLIBC_2.3 ecb_crypt F
+GLIBC_2.3 ecvt F
+GLIBC_2.3 ecvt_r F
+GLIBC_2.3 endaliasent F
+GLIBC_2.3 endfsent F
+GLIBC_2.3 endgrent F
+GLIBC_2.3 endhostent F
+GLIBC_2.3 endmntent F
+GLIBC_2.3 endnetent F
+GLIBC_2.3 endnetgrent F
+GLIBC_2.3 endprotoent F
+GLIBC_2.3 endpwent F
+GLIBC_2.3 endrpcent F
+GLIBC_2.3 endservent F
+GLIBC_2.3 endspent F
+GLIBC_2.3 endttyent F
+GLIBC_2.3 endusershell F
+GLIBC_2.3 endutent F
+GLIBC_2.3 endutxent F
+GLIBC_2.3 environ D 0x8
+GLIBC_2.3 envz_add F
+GLIBC_2.3 envz_entry F
+GLIBC_2.3 envz_get F
+GLIBC_2.3 envz_merge F
+GLIBC_2.3 envz_remove F
+GLIBC_2.3 envz_strip F
+GLIBC_2.3 erand48 F
+GLIBC_2.3 erand48_r F
+GLIBC_2.3 err F
+GLIBC_2.3 error F
+GLIBC_2.3 error_at_line F
+GLIBC_2.3 error_message_count D 0x4
+GLIBC_2.3 error_one_per_line D 0x4
+GLIBC_2.3 error_print_progname D 0x8
+GLIBC_2.3 errx F
+GLIBC_2.3 ether_aton F
+GLIBC_2.3 ether_aton_r F
+GLIBC_2.3 ether_hostton F
+GLIBC_2.3 ether_line F
+GLIBC_2.3 ether_ntoa F
+GLIBC_2.3 ether_ntoa_r F
+GLIBC_2.3 ether_ntohost F
+GLIBC_2.3 euidaccess F
+GLIBC_2.3 execl F
+GLIBC_2.3 execle F
+GLIBC_2.3 execlp F
+GLIBC_2.3 execv F
+GLIBC_2.3 execve F
+GLIBC_2.3 execvp F
+GLIBC_2.3 exit F
+GLIBC_2.3 extattr_delete_file F
+GLIBC_2.3 extattr_get_file F
+GLIBC_2.3 extattr_set_file F
+GLIBC_2.3 extattrctl F
+GLIBC_2.3 fattach F
+GLIBC_2.3 fchdir F
+GLIBC_2.3 fchflags F
+GLIBC_2.3 fchmod F
+GLIBC_2.3 fchown F
+GLIBC_2.3 fclose F
+GLIBC_2.3 fcloseall F
+GLIBC_2.3 fcntl F
+GLIBC_2.3 fcvt F
+GLIBC_2.3 fcvt_r F
+GLIBC_2.3 fdatasync F
+GLIBC_2.3 fdetach F
+GLIBC_2.3 fdopen F
+GLIBC_2.3 feof F
+GLIBC_2.3 feof_unlocked F
+GLIBC_2.3 ferror F
+GLIBC_2.3 ferror_unlocked F
+GLIBC_2.3 fexecve F
+GLIBC_2.3 fflush F
+GLIBC_2.3 fflush_unlocked F
+GLIBC_2.3 ffs F
+GLIBC_2.3 ffsl F
+GLIBC_2.3 ffsll F
+GLIBC_2.3 fgetc F
+GLIBC_2.3 fgetc_unlocked F
+GLIBC_2.3 fgetgrent F
+GLIBC_2.3 fgetgrent_r F
+GLIBC_2.3 fgetpos F
+GLIBC_2.3 fgetpos64 F
+GLIBC_2.3 fgetpwent F
+GLIBC_2.3 fgetpwent_r F
+GLIBC_2.3 fgets F
+GLIBC_2.3 fgets_unlocked F
+GLIBC_2.3 fgetspent F
+GLIBC_2.3 fgetspent_r F
+GLIBC_2.3 fgetwc F
+GLIBC_2.3 fgetwc_unlocked F
+GLIBC_2.3 fgetws F
+GLIBC_2.3 fgetws_unlocked F
+GLIBC_2.3 fgetxattr F
+GLIBC_2.3 fhopen F
+GLIBC_2.3 fhstat F
+GLIBC_2.3 fhstatfs F
+GLIBC_2.3 fileno F
+GLIBC_2.3 fileno_unlocked F
+GLIBC_2.3 finite F
+GLIBC_2.3 finitef F
+GLIBC_2.3 finitel F
+GLIBC_2.3 flistxattr F
+GLIBC_2.3 flock F
+GLIBC_2.3 flockfile F
+GLIBC_2.3 fmemopen F
+GLIBC_2.3 fmtmsg F
+GLIBC_2.3 fnmatch F
+GLIBC_2.3 fopen F
+GLIBC_2.3 fopen64 F
+GLIBC_2.3 fopencookie F
+GLIBC_2.3 fork F
+GLIBC_2.3 fpathconf F
+GLIBC_2.3 fprintf F
+GLIBC_2.3 fputc F
+GLIBC_2.3 fputc_unlocked F
+GLIBC_2.3 fputs F
+GLIBC_2.3 fputs_unlocked F
+GLIBC_2.3 fputwc F
+GLIBC_2.3 fputwc_unlocked F
+GLIBC_2.3 fputws F
+GLIBC_2.3 fputws_unlocked F
+GLIBC_2.3 fread F
+GLIBC_2.3 fread_unlocked F
+GLIBC_2.3 free F
+GLIBC_2.3 freeaddrinfo F
+GLIBC_2.3 freeifaddrs F
+GLIBC_2.3 freelocale F
+GLIBC_2.3 fremovexattr F
+GLIBC_2.3 freopen F
+GLIBC_2.3 freopen64 F
+GLIBC_2.3 frexp F
+GLIBC_2.3 frexpf F
+GLIBC_2.3 frexpl F
+GLIBC_2.3 fscanf F
+GLIBC_2.3 fseek F
+GLIBC_2.3 fseeko F
+GLIBC_2.3 fseeko64 F
+GLIBC_2.3 fsetpos F
+GLIBC_2.3 fsetpos64 F
+GLIBC_2.3 fsetxattr F
+GLIBC_2.3 fstatfs F
+GLIBC_2.3 fstatfs64 F
+GLIBC_2.3 fstatvfs F
+GLIBC_2.3 fstatvfs64 F
+GLIBC_2.3 fsync F
+GLIBC_2.3 ftell F
+GLIBC_2.3 ftello F
+GLIBC_2.3 ftello64 F
+GLIBC_2.3 ftime F
+GLIBC_2.3 ftok F
+GLIBC_2.3 ftruncate F
+GLIBC_2.3 ftruncate64 F
+GLIBC_2.3 ftrylockfile F
+GLIBC_2.3 fts_children F
+GLIBC_2.3 fts_close F
+GLIBC_2.3 fts_open F
+GLIBC_2.3 fts_read F
+GLIBC_2.3 fts_set F
+GLIBC_2.3 ftw F
+GLIBC_2.3 ftw64 F
+GLIBC_2.3 funlockfile F
+GLIBC_2.3 futimes F
+GLIBC_2.3 fwide F
+GLIBC_2.3 fwprintf F
+GLIBC_2.3 fwrite F
+GLIBC_2.3 fwrite_unlocked F
+GLIBC_2.3 fwscanf F
+GLIBC_2.3 gai_strerror F
+GLIBC_2.3 gcvt F
+GLIBC_2.3 get_avphys_pages F
+GLIBC_2.3 get_current_dir_name F
+GLIBC_2.3 get_myaddress F
+GLIBC_2.3 get_nprocs F
+GLIBC_2.3 get_nprocs_conf F
+GLIBC_2.3 get_phys_pages F
+GLIBC_2.3 getaddrinfo F
+GLIBC_2.3 getaliasbyname F
+GLIBC_2.3 getaliasbyname_r F
+GLIBC_2.3 getaliasent F
+GLIBC_2.3 getaliasent_r F
+GLIBC_2.3 getc F
+GLIBC_2.3 getc_unlocked F
+GLIBC_2.3 getchar F
+GLIBC_2.3 getchar_unlocked F
+GLIBC_2.3 getcontext F
+GLIBC_2.3 getcwd F
+GLIBC_2.3 getdate F
+GLIBC_2.3 getdate_err D 0x4
+GLIBC_2.3 getdate_r F
+GLIBC_2.3 getdelim F
+GLIBC_2.3 getdents F
+GLIBC_2.3 getdirentries F
+GLIBC_2.3 getdirentries64 F
+GLIBC_2.3 getdomainname F
+GLIBC_2.3 getdtablesize F
+GLIBC_2.3 getegid F
+GLIBC_2.3 getenv F
+GLIBC_2.3 geteuid F
+GLIBC_2.3 getfh F
+GLIBC_2.3 getfsent F
+GLIBC_2.3 getfsfile F
+GLIBC_2.3 getfsspec F
+GLIBC_2.3 getfsstat F
+GLIBC_2.3 getfsstat64 F
+GLIBC_2.3 getgid F
+GLIBC_2.3 getgrent F
+GLIBC_2.3 getgrent_r F
+GLIBC_2.3 getgrgid F
+GLIBC_2.3 getgrgid_r F
+GLIBC_2.3 getgrnam F
+GLIBC_2.3 getgrnam_r F
+GLIBC_2.3 getgrouplist F
+GLIBC_2.3 getgroups F
+GLIBC_2.3 gethostbyaddr F
+GLIBC_2.3 gethostbyaddr_r F
+GLIBC_2.3 gethostbyname F
+GLIBC_2.3 gethostbyname2 F
+GLIBC_2.3 gethostbyname2_r F
+GLIBC_2.3 gethostbyname_r F
+GLIBC_2.3 gethostent F
+GLIBC_2.3 gethostent_r F
+GLIBC_2.3 gethostid F
+GLIBC_2.3 gethostname F
+GLIBC_2.3 getifaddrs F
+GLIBC_2.3 getitimer F
+GLIBC_2.3 getline F
+GLIBC_2.3 getloadavg F
+GLIBC_2.3 getlogin F
+GLIBC_2.3 getlogin_r F
+GLIBC_2.3 getmntent F
+GLIBC_2.3 getmntent_r F
+GLIBC_2.3 getmntinfo F
+GLIBC_2.3 getmntinfo64 F
+GLIBC_2.3 getmsg F
+GLIBC_2.3 getnameinfo F
+GLIBC_2.3 getnetbyaddr F
+GLIBC_2.3 getnetbyaddr_r F
+GLIBC_2.3 getnetbyname F
+GLIBC_2.3 getnetbyname_r F
+GLIBC_2.3 getnetent F
+GLIBC_2.3 getnetent_r F
+GLIBC_2.3 getnetgrent F
+GLIBC_2.3 getnetgrent_r F
+GLIBC_2.3 getnetname F
+GLIBC_2.3 getopt F
+GLIBC_2.3 getopt_long F
+GLIBC_2.3 getopt_long_only F
+GLIBC_2.3 getpagesize F
+GLIBC_2.3 getpass F
+GLIBC_2.3 getpeername F
+GLIBC_2.3 getpgid F
+GLIBC_2.3 getpgrp F
+GLIBC_2.3 getpid F
+GLIBC_2.3 getpmsg F
+GLIBC_2.3 getppid F
+GLIBC_2.3 getpriority F
+GLIBC_2.3 getprotobyname F
+GLIBC_2.3 getprotobyname_r F
+GLIBC_2.3 getprotobynumber F
+GLIBC_2.3 getprotobynumber_r F
+GLIBC_2.3 getprotoent F
+GLIBC_2.3 getprotoent_r F
+GLIBC_2.3 getpt F
+GLIBC_2.3 getpublickey F
+GLIBC_2.3 getpw F
+GLIBC_2.3 getpwent F
+GLIBC_2.3 getpwent_r F
+GLIBC_2.3 getpwnam F
+GLIBC_2.3 getpwnam_r F
+GLIBC_2.3 getpwuid F
+GLIBC_2.3 getpwuid_r F
+GLIBC_2.3 getresgid F
+GLIBC_2.3 getresuid F
+GLIBC_2.3 getrlimit F
+GLIBC_2.3 getrlimit64 F
+GLIBC_2.3 getrpcbyname F
+GLIBC_2.3 getrpcbyname_r F
+GLIBC_2.3 getrpcbynumber F
+GLIBC_2.3 getrpcbynumber_r F
+GLIBC_2.3 getrpcent F
+GLIBC_2.3 getrpcent_r F
+GLIBC_2.3 getrpcport F
+GLIBC_2.3 getrusage F
+GLIBC_2.3 gets F
+GLIBC_2.3 getsecretkey F
+GLIBC_2.3 getservbyname F
+GLIBC_2.3 getservbyname_r F
+GLIBC_2.3 getservbyport F
+GLIBC_2.3 getservbyport_r F
+GLIBC_2.3 getservent F
+GLIBC_2.3 getservent_r F
+GLIBC_2.3 getsid F
+GLIBC_2.3 getsockname F
+GLIBC_2.3 getsockopt F
+GLIBC_2.3 getspent F
+GLIBC_2.3 getspent_r F
+GLIBC_2.3 getspnam F
+GLIBC_2.3 getspnam_r F
+GLIBC_2.3 getsubopt F
+GLIBC_2.3 gettext F
+GLIBC_2.3 gettimeofday F
+GLIBC_2.3 getttyent F
+GLIBC_2.3 getttynam F
+GLIBC_2.3 getuid F
+GLIBC_2.3 getusershell F
+GLIBC_2.3 getutent F
+GLIBC_2.3 getutent_r F
+GLIBC_2.3 getutid F
+GLIBC_2.3 getutid_r F
+GLIBC_2.3 getutline F
+GLIBC_2.3 getutline_r F
+GLIBC_2.3 getutmp F
+GLIBC_2.3 getutmpx F
+GLIBC_2.3 getutxent F
+GLIBC_2.3 getutxid F
+GLIBC_2.3 getutxline F
+GLIBC_2.3 getw F
+GLIBC_2.3 getwc F
+GLIBC_2.3 getwc_unlocked F
+GLIBC_2.3 getwchar F
+GLIBC_2.3 getwchar_unlocked F
+GLIBC_2.3 getwd F
+GLIBC_2.3 getxattr F
+GLIBC_2.3 glob F
+GLIBC_2.3 glob64 F
+GLIBC_2.3 glob_pattern_p F
+GLIBC_2.3 globfree F
+GLIBC_2.3 globfree64 F
+GLIBC_2.3 gmtime F
+GLIBC_2.3 gmtime_r F
+GLIBC_2.3 gnu_get_libc_release F
+GLIBC_2.3 gnu_get_libc_version F
+GLIBC_2.3 grantpt F
+GLIBC_2.3 group_member F
+GLIBC_2.3 gsignal F
+GLIBC_2.3 gtty F
+GLIBC_2.3 h_errlist D 0x28
+GLIBC_2.3 h_nerr D 0x4
+GLIBC_2.3 hasmntopt F
+GLIBC_2.3 hcreate F
+GLIBC_2.3 hcreate_r F
+GLIBC_2.3 hdestroy F
+GLIBC_2.3 hdestroy_r F
+GLIBC_2.3 herror F
+GLIBC_2.3 host2netname F
+GLIBC_2.3 hsearch F
+GLIBC_2.3 hsearch_r F
+GLIBC_2.3 hstrerror F
+GLIBC_2.3 htonl F
+GLIBC_2.3 htons F
+GLIBC_2.3 iconv F
+GLIBC_2.3 iconv_close F
+GLIBC_2.3 iconv_open F
+GLIBC_2.3 if_freenameindex F
+GLIBC_2.3 if_indextoname F
+GLIBC_2.3 if_nameindex F
+GLIBC_2.3 if_nametoindex F
+GLIBC_2.3 imaxabs F
+GLIBC_2.3 imaxdiv F
+GLIBC_2.3 in6addr_any D 0x10
+GLIBC_2.3 in6addr_loopback D 0x10
+GLIBC_2.3 index F
+GLIBC_2.3 inet_addr F
+GLIBC_2.3 inet_aton F
+GLIBC_2.3 inet_lnaof F
+GLIBC_2.3 inet_makeaddr F
+GLIBC_2.3 inet_netof F
+GLIBC_2.3 inet_network F
+GLIBC_2.3 inet_nsap_addr F
+GLIBC_2.3 inet_nsap_ntoa F
+GLIBC_2.3 inet_ntoa F
+GLIBC_2.3 inet_ntop F
+GLIBC_2.3 inet_pton F
+GLIBC_2.3 initgroups F
+GLIBC_2.3 initstate F
+GLIBC_2.3 initstate_r F
+GLIBC_2.3 innetgr F
+GLIBC_2.3 insque F
+GLIBC_2.3 ioctl F
+GLIBC_2.3 iruserok F
+GLIBC_2.3 iruserok_af F
+GLIBC_2.3 isalnum F
+GLIBC_2.3 isalnum_l F
+GLIBC_2.3 isalpha F
+GLIBC_2.3 isalpha_l F
+GLIBC_2.3 isascii F
+GLIBC_2.3 isastream F
+GLIBC_2.3 isatty F
+GLIBC_2.3 isblank F
+GLIBC_2.3 isblank_l F
+GLIBC_2.3 iscntrl F
+GLIBC_2.3 iscntrl_l F
+GLIBC_2.3 isctype F
+GLIBC_2.3 isdigit F
+GLIBC_2.3 isdigit_l F
+GLIBC_2.3 isfdtype F
+GLIBC_2.3 isgraph F
+GLIBC_2.3 isgraph_l F
+GLIBC_2.3 isinf F
+GLIBC_2.3 isinff F
+GLIBC_2.3 isinfl F
+GLIBC_2.3 islower F
+GLIBC_2.3 islower_l F
+GLIBC_2.3 isnan F
+GLIBC_2.3 isnanf F
+GLIBC_2.3 isnanl F
+GLIBC_2.3 isprint F
+GLIBC_2.3 isprint_l F
+GLIBC_2.3 ispunct F
+GLIBC_2.3 ispunct_l F
+GLIBC_2.3 issetugid F
+GLIBC_2.3 isspace F
+GLIBC_2.3 isspace_l F
+GLIBC_2.3 isupper F
+GLIBC_2.3 isupper_l F
+GLIBC_2.3 iswalnum F
+GLIBC_2.3 iswalnum_l F
+GLIBC_2.3 iswalpha F
+GLIBC_2.3 iswalpha_l F
+GLIBC_2.3 iswblank F
+GLIBC_2.3 iswblank_l F
+GLIBC_2.3 iswcntrl F
+GLIBC_2.3 iswcntrl_l F
+GLIBC_2.3 iswctype F
+GLIBC_2.3 iswctype_l F
+GLIBC_2.3 iswdigit F
+GLIBC_2.3 iswdigit_l F
+GLIBC_2.3 iswgraph F
+GLIBC_2.3 iswgraph_l F
+GLIBC_2.3 iswlower F
+GLIBC_2.3 iswlower_l F
+GLIBC_2.3 iswprint F
+GLIBC_2.3 iswprint_l F
+GLIBC_2.3 iswpunct F
+GLIBC_2.3 iswpunct_l F
+GLIBC_2.3 iswspace F
+GLIBC_2.3 iswspace_l F
+GLIBC_2.3 iswupper F
+GLIBC_2.3 iswupper_l F
+GLIBC_2.3 iswxdigit F
+GLIBC_2.3 iswxdigit_l F
+GLIBC_2.3 isxdigit F
+GLIBC_2.3 isxdigit_l F
+GLIBC_2.3 jail F
+GLIBC_2.3 jrand48 F
+GLIBC_2.3 jrand48_r F
+GLIBC_2.3 key_decryptsession F
+GLIBC_2.3 key_decryptsession_pk F
+GLIBC_2.3 key_encryptsession F
+GLIBC_2.3 key_encryptsession_pk F
+GLIBC_2.3 key_gendes F
+GLIBC_2.3 key_get_conv F
+GLIBC_2.3 key_secretkey_is_set F
+GLIBC_2.3 key_setnet F
+GLIBC_2.3 key_setsecret F
+GLIBC_2.3 kill F
+GLIBC_2.3 killpg F
+GLIBC_2.3 kldfind F
+GLIBC_2.3 kldfirstmod F
+GLIBC_2.3 kldload F
+GLIBC_2.3 kldnext F
+GLIBC_2.3 kldstat F
+GLIBC_2.3 kldsym F
+GLIBC_2.3 kldunload F
+GLIBC_2.3 kldunloadf F
+GLIBC_2.3 ktrace F
+GLIBC_2.3 l64a F
+GLIBC_2.3 labs F
+GLIBC_2.3 lchmod F
+GLIBC_2.3 lchown F
+GLIBC_2.3 lckpwdf F
+GLIBC_2.3 lcong48 F
+GLIBC_2.3 lcong48_r F
+GLIBC_2.3 ldexp F
+GLIBC_2.3 ldexpf F
+GLIBC_2.3 ldexpl F
+GLIBC_2.3 ldiv F
+GLIBC_2.3 lfind F
+GLIBC_2.3 lgetxattr F
+GLIBC_2.3 link F
+GLIBC_2.3 listen F
+GLIBC_2.3 listxattr F
+GLIBC_2.3 llabs F
+GLIBC_2.3 lldiv F
+GLIBC_2.3 llistxattr F
+GLIBC_2.3 loc1 D 0x8
+GLIBC_2.3 loc2 D 0x8
+GLIBC_2.3 localeconv F
+GLIBC_2.3 localtime F
+GLIBC_2.3 localtime_r F
+GLIBC_2.3 lockf F
+GLIBC_2.3 lockf64 F
+GLIBC_2.3 locs D 0x8
+GLIBC_2.3 longjmp F
+GLIBC_2.3 lrand48 F
+GLIBC_2.3 lrand48_r F
+GLIBC_2.3 lremovexattr F
+GLIBC_2.3 lsearch F
+GLIBC_2.3 lseek F
+GLIBC_2.3 lseek64 F
+GLIBC_2.3 lsetxattr F
+GLIBC_2.3 lutimes F
+GLIBC_2.3 madvise F
+GLIBC_2.3 makecontext F
+GLIBC_2.3 mallinfo F
+GLIBC_2.3 malloc F
+GLIBC_2.3 malloc_get_state F
+GLIBC_2.3 malloc_set_state F
+GLIBC_2.3 malloc_stats F
+GLIBC_2.3 malloc_trim F
+GLIBC_2.3 malloc_usable_size F
+GLIBC_2.3 mallopt F
+GLIBC_2.3 mallwatch D 0x8
+GLIBC_2.3 mblen F
+GLIBC_2.3 mbrlen F
+GLIBC_2.3 mbrtowc F
+GLIBC_2.3 mbsinit F
+GLIBC_2.3 mbsnrtowcs F
+GLIBC_2.3 mbsrtowcs F
+GLIBC_2.3 mbstowcs F
+GLIBC_2.3 mbtowc F
+GLIBC_2.3 mcheck F
+GLIBC_2.3 mcheck_check_all F
+GLIBC_2.3 mcheck_pedantic F
+GLIBC_2.3 mcount F
+GLIBC_2.3 memalign F
+GLIBC_2.3 memccpy F
+GLIBC_2.3 memchr F
+GLIBC_2.3 memcmp F
+GLIBC_2.3 memcpy F
+GLIBC_2.3 memfrob F
+GLIBC_2.3 memmem F
+GLIBC_2.3 memmove F
+GLIBC_2.3 mempcpy F
+GLIBC_2.3 memrchr F
+GLIBC_2.3 memset F
+GLIBC_2.3 mincore F
+GLIBC_2.3 minherit F
+GLIBC_2.3 mkdir F
+GLIBC_2.3 mkdtemp F
+GLIBC_2.3 mkfifo F
+GLIBC_2.3 mkstemp F
+GLIBC_2.3 mkstemp64 F
+GLIBC_2.3 mktemp F
+GLIBC_2.3 mktime F
+GLIBC_2.3 mlock F
+GLIBC_2.3 mlockall F
+GLIBC_2.3 mmap F
+GLIBC_2.3 mmap64 F
+GLIBC_2.3 modf F
+GLIBC_2.3 modff F
+GLIBC_2.3 modfind F
+GLIBC_2.3 modfl F
+GLIBC_2.3 modfnext F
+GLIBC_2.3 modnext F
+GLIBC_2.3 modstat F
+GLIBC_2.3 moncontrol F
+GLIBC_2.3 monstartup F
+GLIBC_2.3 mount F
+GLIBC_2.3 mprobe F
+GLIBC_2.3 mprotect F
+GLIBC_2.3 mrand48 F
+GLIBC_2.3 mrand48_r F
+GLIBC_2.3 msgctl F
+GLIBC_2.3 msgget F
+GLIBC_2.3 msgrcv F
+GLIBC_2.3 msgsnd F
+GLIBC_2.3 msync F
+GLIBC_2.3 mtrace F
+GLIBC_2.3 munlock F
+GLIBC_2.3 munlockall F
+GLIBC_2.3 munmap F
+GLIBC_2.3 muntrace F
+GLIBC_2.3 nanosleep F
+GLIBC_2.3 netname2host F
+GLIBC_2.3 netname2user F
+GLIBC_2.3 newlocale F
+GLIBC_2.3 nftw F
+GLIBC_2.3 nftw64 F
+GLIBC_2.3 ngettext F
+GLIBC_2.3 nice F
+GLIBC_2.3 nl_langinfo F
+GLIBC_2.3 nl_langinfo_l F
+GLIBC_2.3 nmount F
+GLIBC_2.3 nrand48 F
+GLIBC_2.3 nrand48_r F
+GLIBC_2.3 ntohl F
+GLIBC_2.3 ntohs F
+GLIBC_2.3 ntp_adjtime F
+GLIBC_2.3 ntp_gettime F
+GLIBC_2.3 obstack_alloc_failed_handler D 0x8
+GLIBC_2.3 obstack_exit_failure D 0x4
+GLIBC_2.3 obstack_free F
+GLIBC_2.3 obstack_printf F
+GLIBC_2.3 obstack_vprintf F
+GLIBC_2.3 on_exit F
+GLIBC_2.3 open F
+GLIBC_2.3 open64 F
+GLIBC_2.3 open_memstream F
+GLIBC_2.3 opendir F
+GLIBC_2.3 openlog F
+GLIBC_2.3 optarg D 0x8
+GLIBC_2.3 opterr D 0x4
+GLIBC_2.3 optind D 0x4
+GLIBC_2.3 optopt D 0x4
+GLIBC_2.3 parse_printf_format F
+GLIBC_2.3 passwd2des F
+GLIBC_2.3 pathconf F
+GLIBC_2.3 pause F
+GLIBC_2.3 pclose F
+GLIBC_2.3 perror F
+GLIBC_2.3 pipe F
+GLIBC_2.3 pmap_getmaps F
+GLIBC_2.3 pmap_getport F
+GLIBC_2.3 pmap_rmtcall F
+GLIBC_2.3 pmap_set F
+GLIBC_2.3 pmap_unset F
+GLIBC_2.3 poll F
+GLIBC_2.3 popen F
+GLIBC_2.3 posix_fadvise F
+GLIBC_2.3 posix_fadvise64 F
+GLIBC_2.3 posix_fallocate F
+GLIBC_2.3 posix_fallocate64 F
+GLIBC_2.3 posix_madvise F
+GLIBC_2.3 posix_memalign F
+GLIBC_2.3 posix_openpt F
+GLIBC_2.3 posix_spawn F
+GLIBC_2.3 posix_spawn_file_actions_addclose F
+GLIBC_2.3 posix_spawn_file_actions_adddup2 F
+GLIBC_2.3 posix_spawn_file_actions_addopen F
+GLIBC_2.3 posix_spawn_file_actions_destroy F
+GLIBC_2.3 posix_spawn_file_actions_init F
+GLIBC_2.3 posix_spawnattr_destroy F
+GLIBC_2.3 posix_spawnattr_getflags F
+GLIBC_2.3 posix_spawnattr_getpgroup F
+GLIBC_2.3 posix_spawnattr_getschedparam F
+GLIBC_2.3 posix_spawnattr_getschedpolicy F
+GLIBC_2.3 posix_spawnattr_getsigdefault F
+GLIBC_2.3 posix_spawnattr_getsigmask F
+GLIBC_2.3 posix_spawnattr_init F
+GLIBC_2.3 posix_spawnattr_setflags F
+GLIBC_2.3 posix_spawnattr_setpgroup F
+GLIBC_2.3 posix_spawnattr_setschedparam F
+GLIBC_2.3 posix_spawnattr_setschedpolicy F
+GLIBC_2.3 posix_spawnattr_setsigdefault F
+GLIBC_2.3 posix_spawnattr_setsigmask F
+GLIBC_2.3 posix_spawnp F
+GLIBC_2.3 pread F
+GLIBC_2.3 pread64 F
+GLIBC_2.3 printf F
+GLIBC_2.3 printf_size F
+GLIBC_2.3 printf_size_info F
+GLIBC_2.3 profil F
+GLIBC_2.3 program_invocation_name D 0x8
+GLIBC_2.3 program_invocation_short_name D 0x8
+GLIBC_2.3 pselect F
+GLIBC_2.3 psignal F
+GLIBC_2.3 pthread_attr_destroy F
+GLIBC_2.3 pthread_attr_getdetachstate F
+GLIBC_2.3 pthread_attr_getinheritsched F
+GLIBC_2.3 pthread_attr_getschedparam F
+GLIBC_2.3 pthread_attr_getschedpolicy F
+GLIBC_2.3 pthread_attr_getscope F
+GLIBC_2.3 pthread_attr_init F
+GLIBC_2.3 pthread_attr_setdetachstate F
+GLIBC_2.3 pthread_attr_setinheritsched F
+GLIBC_2.3 pthread_attr_setschedparam F
+GLIBC_2.3 pthread_attr_setschedpolicy F
+GLIBC_2.3 pthread_attr_setscope F
+GLIBC_2.3 pthread_cond_broadcast F
+GLIBC_2.3 pthread_cond_destroy F
+GLIBC_2.3 pthread_cond_init F
+GLIBC_2.3 pthread_cond_signal F
+GLIBC_2.3 pthread_cond_timedwait F
+GLIBC_2.3 pthread_cond_wait F
+GLIBC_2.3 pthread_condattr_destroy F
+GLIBC_2.3 pthread_condattr_init F
+GLIBC_2.3 pthread_equal F
+GLIBC_2.3 pthread_exit F
+GLIBC_2.3 pthread_getschedparam F
+GLIBC_2.3 pthread_mutex_destroy F
+GLIBC_2.3 pthread_mutex_init F
+GLIBC_2.3 pthread_mutex_lock F
+GLIBC_2.3 pthread_mutex_unlock F
+GLIBC_2.3 pthread_self F
+GLIBC_2.3 pthread_setcancelstate F
+GLIBC_2.3 pthread_setcanceltype F
+GLIBC_2.3 pthread_setschedparam F
+GLIBC_2.3 ptrace F
+GLIBC_2.3 ptsname F
+GLIBC_2.3 ptsname_r F
+GLIBC_2.3 putc F
+GLIBC_2.3 putc_unlocked F
+GLIBC_2.3 putchar F
+GLIBC_2.3 putchar_unlocked F
+GLIBC_2.3 putenv F
+GLIBC_2.3 putgrent F
+GLIBC_2.3 putmsg F
+GLIBC_2.3 putpmsg F
+GLIBC_2.3 putpwent F
+GLIBC_2.3 puts F
+GLIBC_2.3 putspent F
+GLIBC_2.3 pututline F
+GLIBC_2.3 pututxline F
+GLIBC_2.3 putw F
+GLIBC_2.3 putwc F
+GLIBC_2.3 putwc_unlocked F
+GLIBC_2.3 putwchar F
+GLIBC_2.3 putwchar_unlocked F
+GLIBC_2.3 pvalloc F
+GLIBC_2.3 pwrite F
+GLIBC_2.3 pwrite64 F
+GLIBC_2.3 qecvt F
+GLIBC_2.3 qecvt_r F
+GLIBC_2.3 qfcvt F
+GLIBC_2.3 qfcvt_r F
+GLIBC_2.3 qgcvt F
+GLIBC_2.3 qsort F
+GLIBC_2.3 quotactl F
+GLIBC_2.3 raise F
+GLIBC_2.3 rand F
+GLIBC_2.3 rand_r F
+GLIBC_2.3 random F
+GLIBC_2.3 random_r F
+GLIBC_2.3 rawmemchr F
+GLIBC_2.3 rcmd F
+GLIBC_2.3 rcmd_af F
+GLIBC_2.3 re_comp F
+GLIBC_2.3 re_compile_fastmap F
+GLIBC_2.3 re_compile_pattern F
+GLIBC_2.3 re_exec F
+GLIBC_2.3 re_match F
+GLIBC_2.3 re_match_2 F
+GLIBC_2.3 re_search F
+GLIBC_2.3 re_search_2 F
+GLIBC_2.3 re_set_registers F
+GLIBC_2.3 re_set_syntax F
+GLIBC_2.3 re_syntax_options D 0x8
+GLIBC_2.3 read F
+GLIBC_2.3 readdir F
+GLIBC_2.3 readdir64 F
+GLIBC_2.3 readdir64_r F
+GLIBC_2.3 readdir_r F
+GLIBC_2.3 readlink F
+GLIBC_2.3 readv F
+GLIBC_2.3 realloc F
+GLIBC_2.3 realpath F
+GLIBC_2.3 reboot F
+GLIBC_2.3 recv F
+GLIBC_2.3 recvfrom F
+GLIBC_2.3 recvmsg F
+GLIBC_2.3 regcomp F
+GLIBC_2.3 regerror F
+GLIBC_2.3 regexec F
+GLIBC_2.3 regfree F
+GLIBC_2.3 register_printf_function F
+GLIBC_2.3 registerrpc F
+GLIBC_2.3 remove F
+GLIBC_2.3 removexattr F
+GLIBC_2.3 remque F
+GLIBC_2.3 rename F
+GLIBC_2.3 revoke F
+GLIBC_2.3 rewind F
+GLIBC_2.3 rewinddir F
+GLIBC_2.3 rexec F
+GLIBC_2.3 rexec_af F
+GLIBC_2.3 rexecoptions D 0x4
+GLIBC_2.3 rfork F
+GLIBC_2.3 rindex F
+GLIBC_2.3 rmdir F
+GLIBC_2.3 rpc_createerr D 0x20
+GLIBC_2.3 rpmatch F
+GLIBC_2.3 rresvport F
+GLIBC_2.3 rresvport_af F
+GLIBC_2.3 rtime F
+GLIBC_2.3 rtprio F
+GLIBC_2.3 ruserok F
+GLIBC_2.3 ruserok_af F
+GLIBC_2.3 ruserpass F
+GLIBC_2.3 sbrk F
+GLIBC_2.3 scalbn F
+GLIBC_2.3 scalbnf F
+GLIBC_2.3 scalbnl F
+GLIBC_2.3 scandir F
+GLIBC_2.3 scandir64 F
+GLIBC_2.3 scanf F
+GLIBC_2.3 sched_get_priority_max F
+GLIBC_2.3 sched_get_priority_min F
+GLIBC_2.3 sched_getparam F
+GLIBC_2.3 sched_getscheduler F
+GLIBC_2.3 sched_rr_get_interval F
+GLIBC_2.3 sched_setparam F
+GLIBC_2.3 sched_setscheduler F
+GLIBC_2.3 sched_yield F
+GLIBC_2.3 seed48 F
+GLIBC_2.3 seed48_r F
+GLIBC_2.3 seekdir F
+GLIBC_2.3 select F
+GLIBC_2.3 semctl F
+GLIBC_2.3 semget F
+GLIBC_2.3 semop F
+GLIBC_2.3 send F
+GLIBC_2.3 sendfile F
+GLIBC_2.3 sendfile64 F
+GLIBC_2.3 sendmsg F
+GLIBC_2.3 sendto F
+GLIBC_2.3 setaliasent F
+GLIBC_2.3 setbuf F
+GLIBC_2.3 setbuffer F
+GLIBC_2.3 setcontext F
+GLIBC_2.3 setdomainname F
+GLIBC_2.3 setegid F
+GLIBC_2.3 setenv F
+GLIBC_2.3 seteuid F
+GLIBC_2.3 setfsent F
+GLIBC_2.3 setgid F
+GLIBC_2.3 setgrent F
+GLIBC_2.3 setgroups F
+GLIBC_2.3 sethostent F
+GLIBC_2.3 sethostid F
+GLIBC_2.3 sethostname F
+GLIBC_2.3 setitimer F
+GLIBC_2.3 setjmp F
+GLIBC_2.3 setlinebuf F
+GLIBC_2.3 setlocale F
+GLIBC_2.3 setlogin F
+GLIBC_2.3 setlogmask F
+GLIBC_2.3 setmntent F
+GLIBC_2.3 setnetent F
+GLIBC_2.3 setnetgrent F
+GLIBC_2.3 setpgid F
+GLIBC_2.3 setpgrp F
+GLIBC_2.3 setpriority F
+GLIBC_2.3 setprotoent F
+GLIBC_2.3 setpwent F
+GLIBC_2.3 setregid F
+GLIBC_2.3 setresgid F
+GLIBC_2.3 setresuid F
+GLIBC_2.3 setreuid F
+GLIBC_2.3 setrlimit F
+GLIBC_2.3 setrlimit64 F
+GLIBC_2.3 setrpcent F
+GLIBC_2.3 setservent F
+GLIBC_2.3 setsid F
+GLIBC_2.3 setsockopt F
+GLIBC_2.3 setspent F
+GLIBC_2.3 setstate F
+GLIBC_2.3 setstate_r F
+GLIBC_2.3 settimeofday F
+GLIBC_2.3 setttyent F
+GLIBC_2.3 setuid F
+GLIBC_2.3 setusershell F
+GLIBC_2.3 setutent F
+GLIBC_2.3 setutxent F
+GLIBC_2.3 setvbuf F
+GLIBC_2.3 setxattr F
+GLIBC_2.3 sgetspent F
+GLIBC_2.3 sgetspent_r F
+GLIBC_2.3 shmat F
+GLIBC_2.3 shmctl F
+GLIBC_2.3 shmdt F
+GLIBC_2.3 shmget F
+GLIBC_2.3 shutdown F
+GLIBC_2.3 sigaction F
+GLIBC_2.3 sigaddset F
+GLIBC_2.3 sigaltstack F
+GLIBC_2.3 sigandset F
+GLIBC_2.3 sigblock F
+GLIBC_2.3 sigdelset F
+GLIBC_2.3 sigemptyset F
+GLIBC_2.3 sigfillset F
+GLIBC_2.3 siggetmask F
+GLIBC_2.3 sighold F
+GLIBC_2.3 sigignore F
+GLIBC_2.3 siginterrupt F
+GLIBC_2.3 sigisemptyset F
+GLIBC_2.3 sigismember F
+GLIBC_2.3 siglongjmp F
+GLIBC_2.3 signal F
+GLIBC_2.3 sigorset F
+GLIBC_2.3 sigpause F
+GLIBC_2.3 sigpending F
+GLIBC_2.3 sigprocmask F
+GLIBC_2.3 sigqueue F
+GLIBC_2.3 sigrelse F
+GLIBC_2.3 sigreturn F
+GLIBC_2.3 sigset F
+GLIBC_2.3 sigsetmask F
+GLIBC_2.3 sigstack F
+GLIBC_2.3 sigsuspend F
+GLIBC_2.3 sigtimedwait F
+GLIBC_2.3 sigvec F
+GLIBC_2.3 sigwait F
+GLIBC_2.3 sigwaitinfo F
+GLIBC_2.3 sleep F
+GLIBC_2.3 snprintf F
+GLIBC_2.3 sockatmark F
+GLIBC_2.3 socket F
+GLIBC_2.3 socketpair F
+GLIBC_2.3 sprintf F
+GLIBC_2.3 sprofil F
+GLIBC_2.3 srand F
+GLIBC_2.3 srand48 F
+GLIBC_2.3 srand48_r F
+GLIBC_2.3 srandom F
+GLIBC_2.3 srandom_r F
+GLIBC_2.3 sscanf F
+GLIBC_2.3 ssignal F
+GLIBC_2.3 sstk F
+GLIBC_2.3 statfs F
+GLIBC_2.3 statfs64 F
+GLIBC_2.3 statvfs F
+GLIBC_2.3 statvfs64 F
+GLIBC_2.3 stderr D 0x8
+GLIBC_2.3 stdin D 0x8
+GLIBC_2.3 stdout D 0x8
+GLIBC_2.3 step F
+GLIBC_2.3 stime F
+GLIBC_2.3 stpcpy F
+GLIBC_2.3 stpncpy F
+GLIBC_2.3 strcasecmp F
+GLIBC_2.3 strcasecmp_l F
+GLIBC_2.3 strcasestr F
+GLIBC_2.3 strcat F
+GLIBC_2.3 strchr F
+GLIBC_2.3 strchrnul F
+GLIBC_2.3 strcmp F
+GLIBC_2.3 strcoll F
+GLIBC_2.3 strcoll_l F
+GLIBC_2.3 strcpy F
+GLIBC_2.3 strcspn F
+GLIBC_2.3 strdup F
+GLIBC_2.3 strerror F
+GLIBC_2.3 strerror_r F
+GLIBC_2.3 strfmon F
+GLIBC_2.3 strfmon_l F
+GLIBC_2.3 strfry F
+GLIBC_2.3 strftime F
+GLIBC_2.3 strftime_l F
+GLIBC_2.3 strlen F
+GLIBC_2.3 strncasecmp F
+GLIBC_2.3 strncasecmp_l F
+GLIBC_2.3 strncat F
+GLIBC_2.3 strncmp F
+GLIBC_2.3 strncpy F
+GLIBC_2.3 strndup F
+GLIBC_2.3 strnlen F
+GLIBC_2.3 strpbrk F
+GLIBC_2.3 strptime F
+GLIBC_2.3 strrchr F
+GLIBC_2.3 strsep F
+GLIBC_2.3 strsignal F
+GLIBC_2.3 strspn F
+GLIBC_2.3 strstr F
+GLIBC_2.3 strtod F
+GLIBC_2.3 strtod_l F
+GLIBC_2.3 strtof F
+GLIBC_2.3 strtof_l F
+GLIBC_2.3 strtoimax F
+GLIBC_2.3 strtok F
+GLIBC_2.3 strtok_r F
+GLIBC_2.3 strtol F
+GLIBC_2.3 strtol_l F
+GLIBC_2.3 strtold F
+GLIBC_2.3 strtold_l F
+GLIBC_2.3 strtoll F
+GLIBC_2.3 strtoq F
+GLIBC_2.3 strtoul F
+GLIBC_2.3 strtoul_l F
+GLIBC_2.3 strtoull F
+GLIBC_2.3 strtoumax F
+GLIBC_2.3 strtouq F
+GLIBC_2.3 strverscmp F
+GLIBC_2.3 strxfrm F
+GLIBC_2.3 strxfrm_l F
+GLIBC_2.3 stty F
+GLIBC_2.3 svc_exit F
+GLIBC_2.3 svc_fdset D 0x80
+GLIBC_2.3 svc_getreq F
+GLIBC_2.3 svc_getreq_common F
+GLIBC_2.3 svc_getreq_poll F
+GLIBC_2.3 svc_getreqset F
+GLIBC_2.3 svc_max_pollfd D 0x4
+GLIBC_2.3 svc_pollfd D 0x8
+GLIBC_2.3 svc_register F
+GLIBC_2.3 svc_run F
+GLIBC_2.3 svc_sendreply F
+GLIBC_2.3 svc_unregister F
+GLIBC_2.3 svcauthdes_stats D 0x18
+GLIBC_2.3 svcerr_auth F
+GLIBC_2.3 svcerr_decode F
+GLIBC_2.3 svcerr_noproc F
+GLIBC_2.3 svcerr_noprog F
+GLIBC_2.3 svcerr_progvers F
+GLIBC_2.3 svcerr_systemerr F
+GLIBC_2.3 svcerr_weakauth F
+GLIBC_2.3 svcfd_create F
+GLIBC_2.3 svcraw_create F
+GLIBC_2.3 svctcp_create F
+GLIBC_2.3 svcudp_bufcreate F
+GLIBC_2.3 svcudp_create F
+GLIBC_2.3 svcudp_enablecache F
+GLIBC_2.3 svcunix_create F
+GLIBC_2.3 svcunixfd_create F
+GLIBC_2.3 swab F
+GLIBC_2.3 swapcontext F
+GLIBC_2.3 swapoff F
+GLIBC_2.3 swapon F
+GLIBC_2.3 swprintf F
+GLIBC_2.3 swscanf F
+GLIBC_2.3 symlink F
+GLIBC_2.3 sync F
+GLIBC_2.3 sys_errlist D 0x2b8
+GLIBC_2.3 sys_nerr D 0x4
+GLIBC_2.3 sys_sigabbrev D 0x408
+GLIBC_2.3 sys_siglist D 0x408
+GLIBC_2.3 sysarch F
+GLIBC_2.3 syscall F
+GLIBC_2.3 sysconf F
+GLIBC_2.3 sysctl F
+GLIBC_2.3 sysctlbyname F
+GLIBC_2.3 syslog F
+GLIBC_2.3 system F
+GLIBC_2.3 sysv_signal F
+GLIBC_2.3 tcdrain F
+GLIBC_2.3 tcflow F
+GLIBC_2.3 tcflush F
+GLIBC_2.3 tcgetattr F
+GLIBC_2.3 tcgetpgrp F
+GLIBC_2.3 tcgetsid F
+GLIBC_2.3 tcsendbreak F
+GLIBC_2.3 tcsetattr F
+GLIBC_2.3 tcsetpgrp F
+GLIBC_2.3 tdelete F
+GLIBC_2.3 tdestroy F
+GLIBC_2.3 telldir F
+GLIBC_2.3 tempnam F
+GLIBC_2.3 textdomain F
+GLIBC_2.3 tfind F
+GLIBC_2.3 time F
+GLIBC_2.3 timegm F
+GLIBC_2.3 timelocal F
+GLIBC_2.3 times F
+GLIBC_2.3 timezone D 0x8
+GLIBC_2.3 tmpfile F
+GLIBC_2.3 tmpfile64 F
+GLIBC_2.3 tmpnam F
+GLIBC_2.3 tmpnam_r F
+GLIBC_2.3 toascii F
+GLIBC_2.3 tolower F
+GLIBC_2.3 tolower_l F
+GLIBC_2.3 toupper F
+GLIBC_2.3 toupper_l F
+GLIBC_2.3 towctrans F
+GLIBC_2.3 towctrans_l F
+GLIBC_2.3 towlower F
+GLIBC_2.3 towlower_l F
+GLIBC_2.3 towupper F
+GLIBC_2.3 towupper_l F
+GLIBC_2.3 tr_break F
+GLIBC_2.3 truncate F
+GLIBC_2.3 truncate64 F
+GLIBC_2.3 tsearch F
+GLIBC_2.3 ttyname F
+GLIBC_2.3 ttyname_r F
+GLIBC_2.3 ttyslot F
+GLIBC_2.3 twalk F
+GLIBC_2.3 tzname D 0x10
+GLIBC_2.3 tzset F
+GLIBC_2.3 ualarm F
+GLIBC_2.3 ulckpwdf F
+GLIBC_2.3 ulimit F
+GLIBC_2.3 umask F
+GLIBC_2.3 uname F
+GLIBC_2.3 undelete F
+GLIBC_2.3 ungetc F
+GLIBC_2.3 ungetwc F
+GLIBC_2.3 unlink F
+GLIBC_2.3 unlockpt F
+GLIBC_2.3 unmount F
+GLIBC_2.3 unsetenv F
+GLIBC_2.3 updwtmp F
+GLIBC_2.3 updwtmpx F
+GLIBC_2.3 uselocale F
+GLIBC_2.3 user2netname F
+GLIBC_2.3 usleep F
+GLIBC_2.3 ustat F
+GLIBC_2.3 utime F
+GLIBC_2.3 utimes F
+GLIBC_2.3 utmpname F
+GLIBC_2.3 utmpxname F
+GLIBC_2.3 utrace F
+GLIBC_2.3 valloc F
+GLIBC_2.3 vasprintf F
+GLIBC_2.3 vdprintf F
+GLIBC_2.3 verr F
+GLIBC_2.3 verrx F
+GLIBC_2.3 versionsort F
+GLIBC_2.3 versionsort64 F
+GLIBC_2.3 vfork F
+GLIBC_2.3 vfprintf F
+GLIBC_2.3 vfscanf F
+GLIBC_2.3 vfwprintf F
+GLIBC_2.3 vfwscanf F
+GLIBC_2.3 vhangup F
+GLIBC_2.3 vlimit F
+GLIBC_2.3 vprintf F
+GLIBC_2.3 vscanf F
+GLIBC_2.3 vsnprintf F
+GLIBC_2.3 vsprintf F
+GLIBC_2.3 vsscanf F
+GLIBC_2.3 vswprintf F
+GLIBC_2.3 vswscanf F
+GLIBC_2.3 vsyslog F
+GLIBC_2.3 vtimes F
+GLIBC_2.3 vwarn F
+GLIBC_2.3 vwarnx F
+GLIBC_2.3 vwprintf F
+GLIBC_2.3 vwscanf F
+GLIBC_2.3 wait F
+GLIBC_2.3 wait3 F
+GLIBC_2.3 wait4 F
+GLIBC_2.3 waitid F
+GLIBC_2.3 waitpid F
+GLIBC_2.3 warn F
+GLIBC_2.3 warnx F
+GLIBC_2.3 wcpcpy F
+GLIBC_2.3 wcpncpy F
+GLIBC_2.3 wcrtomb F
+GLIBC_2.3 wcscasecmp F
+GLIBC_2.3 wcscasecmp_l F
+GLIBC_2.3 wcscat F
+GLIBC_2.3 wcschr F
+GLIBC_2.3 wcschrnul F
+GLIBC_2.3 wcscmp F
+GLIBC_2.3 wcscoll F
+GLIBC_2.3 wcscoll_l F
+GLIBC_2.3 wcscpy F
+GLIBC_2.3 wcscspn F
+GLIBC_2.3 wcsdup F
+GLIBC_2.3 wcsftime F
+GLIBC_2.3 wcsftime_l F
+GLIBC_2.3 wcslen F
+GLIBC_2.3 wcsncasecmp F
+GLIBC_2.3 wcsncasecmp_l F
+GLIBC_2.3 wcsncat F
+GLIBC_2.3 wcsncmp F
+GLIBC_2.3 wcsncpy F
+GLIBC_2.3 wcsnlen F
+GLIBC_2.3 wcsnrtombs F
+GLIBC_2.3 wcspbrk F
+GLIBC_2.3 wcsrchr F
+GLIBC_2.3 wcsrtombs F
+GLIBC_2.3 wcsspn F
+GLIBC_2.3 wcsstr F
+GLIBC_2.3 wcstod F
+GLIBC_2.3 wcstod_l F
+GLIBC_2.3 wcstof F
+GLIBC_2.3 wcstof_l F
+GLIBC_2.3 wcstoimax F
+GLIBC_2.3 wcstok F
+GLIBC_2.3 wcstol F
+GLIBC_2.3 wcstol_l F
+GLIBC_2.3 wcstold F
+GLIBC_2.3 wcstold_l F
+GLIBC_2.3 wcstoll F
+GLIBC_2.3 wcstoll_l F
+GLIBC_2.3 wcstombs F
+GLIBC_2.3 wcstoq F
+GLIBC_2.3 wcstoul F
+GLIBC_2.3 wcstoul_l F
+GLIBC_2.3 wcstoull F
+GLIBC_2.3 wcstoull_l F
+GLIBC_2.3 wcstoumax F
+GLIBC_2.3 wcstouq F
+GLIBC_2.3 wcswcs F
+GLIBC_2.3 wcswidth F
+GLIBC_2.3 wcsxfrm F
+GLIBC_2.3 wcsxfrm_l F
+GLIBC_2.3 wctob F
+GLIBC_2.3 wctomb F
+GLIBC_2.3 wctrans F
+GLIBC_2.3 wctrans_l F
+GLIBC_2.3 wctype F
+GLIBC_2.3 wctype_l F
+GLIBC_2.3 wcwidth F
+GLIBC_2.3 wmemchr F
+GLIBC_2.3 wmemcmp F
+GLIBC_2.3 wmemcpy F
+GLIBC_2.3 wmemmove F
+GLIBC_2.3 wmempcpy F
+GLIBC_2.3 wmemset F
+GLIBC_2.3 wordexp F
+GLIBC_2.3 wordfree F
+GLIBC_2.3 wprintf F
+GLIBC_2.3 write F
+GLIBC_2.3 writev F
+GLIBC_2.3 wscanf F
+GLIBC_2.3 xdecrypt F
+GLIBC_2.3 xdr_accepted_reply F
+GLIBC_2.3 xdr_array F
+GLIBC_2.3 xdr_authdes_cred F
+GLIBC_2.3 xdr_authdes_verf F
+GLIBC_2.3 xdr_authunix_parms F
+GLIBC_2.3 xdr_bool F
+GLIBC_2.3 xdr_bytes F
+GLIBC_2.3 xdr_callhdr F
+GLIBC_2.3 xdr_callmsg F
+GLIBC_2.3 xdr_char F
+GLIBC_2.3 xdr_cryptkeyarg F
+GLIBC_2.3 xdr_cryptkeyarg2 F
+GLIBC_2.3 xdr_cryptkeyres F
+GLIBC_2.3 xdr_des_block F
+GLIBC_2.3 xdr_double F
+GLIBC_2.3 xdr_enum F
+GLIBC_2.3 xdr_float F
+GLIBC_2.3 xdr_free F
+GLIBC_2.3 xdr_getcredres F
+GLIBC_2.3 xdr_hyper F
+GLIBC_2.3 xdr_int F
+GLIBC_2.3 xdr_int16_t F
+GLIBC_2.3 xdr_int32_t F
+GLIBC_2.3 xdr_int64_t F
+GLIBC_2.3 xdr_int8_t F
+GLIBC_2.3 xdr_key_netstarg F
+GLIBC_2.3 xdr_key_netstres F
+GLIBC_2.3 xdr_keybuf F
+GLIBC_2.3 xdr_keystatus F
+GLIBC_2.3 xdr_long F
+GLIBC_2.3 xdr_longlong_t F
+GLIBC_2.3 xdr_netnamestr F
+GLIBC_2.3 xdr_netobj F
+GLIBC_2.3 xdr_opaque F
+GLIBC_2.3 xdr_opaque_auth F
+GLIBC_2.3 xdr_pmap F
+GLIBC_2.3 xdr_pmaplist F
+GLIBC_2.3 xdr_pointer F
+GLIBC_2.3 xdr_reference F
+GLIBC_2.3 xdr_rejected_reply F
+GLIBC_2.3 xdr_replymsg F
+GLIBC_2.3 xdr_rmtcall_args F
+GLIBC_2.3 xdr_rmtcallres F
+GLIBC_2.3 xdr_short F
+GLIBC_2.3 xdr_sizeof F
+GLIBC_2.3 xdr_string F
+GLIBC_2.3 xdr_u_char F
+GLIBC_2.3 xdr_u_hyper F
+GLIBC_2.3 xdr_u_int F
+GLIBC_2.3 xdr_u_long F
+GLIBC_2.3 xdr_u_longlong_t F
+GLIBC_2.3 xdr_u_short F
+GLIBC_2.3 xdr_uint16_t F
+GLIBC_2.3 xdr_uint32_t F
+GLIBC_2.3 xdr_uint64_t F
+GLIBC_2.3 xdr_uint8_t F
+GLIBC_2.3 xdr_union F
+GLIBC_2.3 xdr_unixcred F
+GLIBC_2.3 xdr_vector F
+GLIBC_2.3 xdr_void F
+GLIBC_2.3 xdr_wrapstring F
+GLIBC_2.3 xdrmem_create F
+GLIBC_2.3 xdrrec_create F
+GLIBC_2.3 xdrrec_endofrecord F
+GLIBC_2.3 xdrrec_eof F
+GLIBC_2.3 xdrrec_skiprecord F
+GLIBC_2.3 xdrstdio_create F
+GLIBC_2.3 xencrypt F
+GLIBC_2.3 xprt_register F
+GLIBC_2.3 xprt_unregister F
+GLIBC_2.3.2 GLIBC_2.3.2 A
+GLIBC_2.3.2 __register_atfork F
+GLIBC_2.3.2 pthread_cond_broadcast F
+GLIBC_2.3.2 pthread_cond_destroy F
+GLIBC_2.3.2 pthread_cond_init F
+GLIBC_2.3.2 pthread_cond_signal F
+GLIBC_2.3.2 pthread_cond_timedwait F
+GLIBC_2.3.2 pthread_cond_wait F
+GLIBC_2.3.2 strptime_l F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 inet6_option_alloc F
+GLIBC_2.3.3 inet6_option_append F
+GLIBC_2.3.3 inet6_option_find F
+GLIBC_2.3.3 inet6_option_init F
+GLIBC_2.3.3 inet6_option_next F
+GLIBC_2.3.3 inet6_option_space F
+GLIBC_2.3.3 nftw F
+GLIBC_2.3.3 nftw64 F
+GLIBC_2.3.3 remap_file_pages F
+GLIBC_2.3.3 sched_getaffinity F
+GLIBC_2.3.3 sched_setaffinity F
+GLIBC_2.3.3 semtimedop F
+GLIBC_2.3.3 strtoll_l F
+GLIBC_2.3.3 strtoull_l F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 __chk_fail F
+GLIBC_2.3.4 __fprintf_chk F
+GLIBC_2.3.4 __gets_chk F
+GLIBC_2.3.4 __libc_sa_len F
+GLIBC_2.3.4 __memcpy_chk F
+GLIBC_2.3.4 __memmove_chk F
+GLIBC_2.3.4 __mempcpy_chk F
+GLIBC_2.3.4 __memset_chk F
+GLIBC_2.3.4 __printf_chk F
+GLIBC_2.3.4 __snprintf_chk F
+GLIBC_2.3.4 __sprintf_chk F
+GLIBC_2.3.4 __stpcpy_chk F
+GLIBC_2.3.4 __strcat_chk F
+GLIBC_2.3.4 __strcpy_chk F
+GLIBC_2.3.4 __strncat_chk F
+GLIBC_2.3.4 __strncpy_chk F
+GLIBC_2.3.4 __vfprintf_chk F
+GLIBC_2.3.4 __vprintf_chk F
+GLIBC_2.3.4 __vsnprintf_chk F
+GLIBC_2.3.4 __vsprintf_chk F
+GLIBC_2.3.4 __xpg_strerror_r F
+GLIBC_2.3.4 _sys_errlist D 0x2e8
+GLIBC_2.3.4 _sys_nerr D 0x4
+GLIBC_2.3.4 fhstat64 F
+GLIBC_2.3.4 fhstatfs64 F
+GLIBC_2.3.4 getipv4sourcefilter F
+GLIBC_2.3.4 getsourcefilter F
+GLIBC_2.3.4 iopl F
+GLIBC_2.3.4 kevent F
+GLIBC_2.3.4 kqueue F
+GLIBC_2.3.4 regexec F
+GLIBC_2.3.4 setipv4sourcefilter F
+GLIBC_2.3.4 setsourcefilter F
+GLIBC_2.3.4 sys_errlist D 0x2e8
+GLIBC_2.3.4 sys_nerr D 0x4
+GLIBC_2.3.4 xdr_quad_t F
+GLIBC_2.3.4 xdr_u_quad_t F
+GLIBC_2.4 GLIBC_2.4 A
+GLIBC_2.4 __confstr_chk F
+GLIBC_2.4 __fgets_chk F
+GLIBC_2.4 __fgets_unlocked_chk F
+GLIBC_2.4 __fgetws_chk F
+GLIBC_2.4 __fgetws_unlocked_chk F
+GLIBC_2.4 __fwprintf_chk F
+GLIBC_2.4 __fxstatat F
+GLIBC_2.4 __fxstatat64 F
+GLIBC_2.4 __getcwd_chk F
+GLIBC_2.4 __getdomainname_chk F
+GLIBC_2.4 __getgroups_chk F
+GLIBC_2.4 __gethostname_chk F
+GLIBC_2.4 __getlogin_r_chk F
+GLIBC_2.4 __getwd_chk F
+GLIBC_2.4 __mbsnrtowcs_chk F
+GLIBC_2.4 __mbsrtowcs_chk F
+GLIBC_2.4 __mbstowcs_chk F
+GLIBC_2.4 __pread64_chk F
+GLIBC_2.4 __pread_chk F
+GLIBC_2.4 __ptsname_r_chk F
+GLIBC_2.4 __read_chk F
+GLIBC_2.4 __readlink_chk F
+GLIBC_2.4 __realpath_chk F
+GLIBC_2.4 __recv_chk F
+GLIBC_2.4 __recvfrom_chk F
+GLIBC_2.4 __stack_chk_fail F
+GLIBC_2.4 __stpncpy_chk F
+GLIBC_2.4 __swprintf_chk F
+GLIBC_2.4 __syslog_chk F
+GLIBC_2.4 __ttyname_r_chk F
+GLIBC_2.4 __vfwprintf_chk F
+GLIBC_2.4 __vswprintf_chk F
+GLIBC_2.4 __vsyslog_chk F
+GLIBC_2.4 __vwprintf_chk F
+GLIBC_2.4 __wcpcpy_chk F
+GLIBC_2.4 __wcpncpy_chk F
+GLIBC_2.4 __wcrtomb_chk F
+GLIBC_2.4 __wcscat_chk F
+GLIBC_2.4 __wcscpy_chk F
+GLIBC_2.4 __wcsncat_chk F
+GLIBC_2.4 __wcsncpy_chk F
+GLIBC_2.4 __wcsnrtombs_chk F
+GLIBC_2.4 __wcsrtombs_chk F
+GLIBC_2.4 __wcstombs_chk F
+GLIBC_2.4 __wctomb_chk F
+GLIBC_2.4 __wmemcpy_chk F
+GLIBC_2.4 __wmemmove_chk F
+GLIBC_2.4 __wmempcpy_chk F
+GLIBC_2.4 __wmemset_chk F
+GLIBC_2.4 __wprintf_chk F
+GLIBC_2.4 __xmknodat F
+GLIBC_2.4 eaccess F
+GLIBC_2.4 faccessat F
+GLIBC_2.4 fchmodat F
+GLIBC_2.4 fchownat F
+GLIBC_2.4 fdopendir F
+GLIBC_2.4 futimesat F
+GLIBC_2.4 linkat F
+GLIBC_2.4 mkdirat F
+GLIBC_2.4 mkfifoat F
+GLIBC_2.4 open_wmemstream F
+GLIBC_2.4 openat F
+GLIBC_2.4 openat64 F
+GLIBC_2.4 ppoll F
+GLIBC_2.4 readlinkat F
+GLIBC_2.4 renameat F
+GLIBC_2.4 symlinkat F
+GLIBC_2.4 unlinkat F
+GLIBC_2.5 GLIBC_2.5 A
+GLIBC_2.5 __readlinkat_chk F
+GLIBC_2.5 inet6_opt_append F
+GLIBC_2.5 inet6_opt_find F
+GLIBC_2.5 inet6_opt_finish F
+GLIBC_2.5 inet6_opt_get_val F
+GLIBC_2.5 inet6_opt_init F
+GLIBC_2.5 inet6_opt_next F
+GLIBC_2.5 inet6_opt_set_val F
+GLIBC_2.5 inet6_rth_add F
+GLIBC_2.5 inet6_rth_getaddr F
+GLIBC_2.5 inet6_rth_init F
+GLIBC_2.5 inet6_rth_reverse F
+GLIBC_2.5 inet6_rth_segments F
+GLIBC_2.5 inet6_rth_space F
+GLIBC_2.6 GLIBC_2.6 A
+GLIBC_2.6 __sched_cpucount F
+GLIBC_2.6 futimens F
+GLIBC_2.6 strerror_l F
+GLIBC_2.6 utimensat F
+GLIBC_2.7 GLIBC_2.7 A
+GLIBC_2.7 __fread_chk F
+GLIBC_2.7 __fread_unlocked_chk F
+GLIBC_2.7 __isoc99_fscanf F
+GLIBC_2.7 __isoc99_fwscanf F
+GLIBC_2.7 __isoc99_scanf F
+GLIBC_2.7 __isoc99_sscanf F
+GLIBC_2.7 __isoc99_swscanf F
+GLIBC_2.7 __isoc99_vfscanf F
+GLIBC_2.7 __isoc99_vfwscanf F
+GLIBC_2.7 __isoc99_vscanf F
+GLIBC_2.7 __isoc99_vsscanf F
+GLIBC_2.7 __isoc99_vswscanf F
+GLIBC_2.7 __isoc99_vwscanf F
+GLIBC_2.7 __isoc99_wscanf F
+GLIBC_2.7 __open64_2 F
+GLIBC_2.7 __open_2 F
+GLIBC_2.7 __openat64_2 F
+GLIBC_2.7 __openat_2 F
+GLIBC_2.7 __sched_cpualloc F
+GLIBC_2.7 __sched_cpufree F
+GLIBC_2.7 mkostemp F
+GLIBC_2.7 mkostemp64 F
+GLIBC_2.8 GLIBC_2.8 A
+GLIBC_2.8 __asprintf_chk F
+GLIBC_2.8 __dprintf_chk F
+GLIBC_2.8 __obstack_printf_chk F
+GLIBC_2.8 __obstack_vprintf_chk F
+GLIBC_2.8 __vasprintf_chk F
+GLIBC_2.8 __vdprintf_chk F
+GLIBC_2.8 qsort_r F
+GLIBC_2.9 GLIBC_2.9 A
+GLIBC_2.9 dup3 F
+GLIBC_2.9 pipe2 F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libcrypt.abilist
@@ -0,0 +1,8 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 crypt F
+GLIBC_2.3 crypt_r F
+GLIBC_2.3 encrypt F
+GLIBC_2.3 encrypt_r F
+GLIBC_2.3 fcrypt F
+GLIBC_2.3 setkey F
+GLIBC_2.3 setkey_r F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libdl.abilist
@@ -0,0 +1,12 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 dladdr F
+GLIBC_2.3 dlclose F
+GLIBC_2.3 dlerror F
+GLIBC_2.3 dlopen F
+GLIBC_2.3 dlsym F
+GLIBC_2.3 dlvsym F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 dladdr1 F
+GLIBC_2.3.3 dlinfo F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 dlmopen F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libm.abilist
@@ -0,0 +1,407 @@
+GLIBC_2.15 GLIBC_2.15 A
+GLIBC_2.15 __acos_finite F
+GLIBC_2.15 __acosf_finite F
+GLIBC_2.15 __acosh_finite F
+GLIBC_2.15 __acoshf_finite F
+GLIBC_2.15 __acoshl_finite F
+GLIBC_2.15 __acosl_finite F
+GLIBC_2.15 __asin_finite F
+GLIBC_2.15 __asinf_finite F
+GLIBC_2.15 __asinl_finite F
+GLIBC_2.15 __atan2_finite F
+GLIBC_2.15 __atan2f_finite F
+GLIBC_2.15 __atan2l_finite F
+GLIBC_2.15 __atanh_finite F
+GLIBC_2.15 __atanhf_finite F
+GLIBC_2.15 __atanhl_finite F
+GLIBC_2.15 __cosh_finite F
+GLIBC_2.15 __coshf_finite F
+GLIBC_2.15 __coshl_finite F
+GLIBC_2.15 __exp10_finite F
+GLIBC_2.15 __exp10f_finite F
+GLIBC_2.15 __exp10l_finite F
+GLIBC_2.15 __exp2_finite F
+GLIBC_2.15 __exp2f_finite F
+GLIBC_2.15 __exp2l_finite F
+GLIBC_2.15 __exp_finite F
+GLIBC_2.15 __expf_finite F
+GLIBC_2.15 __expl_finite F
+GLIBC_2.15 __fmod_finite F
+GLIBC_2.15 __fmodf_finite F
+GLIBC_2.15 __fmodl_finite F
+GLIBC_2.15 __gamma_r_finite F
+GLIBC_2.15 __gammaf_r_finite F
+GLIBC_2.15 __gammal_r_finite F
+GLIBC_2.15 __hypot_finite F
+GLIBC_2.15 __hypotf_finite F
+GLIBC_2.15 __hypotl_finite F
+GLIBC_2.15 __j0_finite F
+GLIBC_2.15 __j0f_finite F
+GLIBC_2.15 __j0l_finite F
+GLIBC_2.15 __j1_finite F
+GLIBC_2.15 __j1f_finite F
+GLIBC_2.15 __j1l_finite F
+GLIBC_2.15 __jn_finite F
+GLIBC_2.15 __jnf_finite F
+GLIBC_2.15 __jnl_finite F
+GLIBC_2.15 __lgamma_r_finite F
+GLIBC_2.15 __lgammaf_r_finite F
+GLIBC_2.15 __lgammal_r_finite F
+GLIBC_2.15 __log10_finite F
+GLIBC_2.15 __log10f_finite F
+GLIBC_2.15 __log10l_finite F
+GLIBC_2.15 __log2_finite F
+GLIBC_2.15 __log2f_finite F
+GLIBC_2.15 __log2l_finite F
+GLIBC_2.15 __log_finite F
+GLIBC_2.15 __logf_finite F
+GLIBC_2.15 __logl_finite F
+GLIBC_2.15 __pow_finite F
+GLIBC_2.15 __powf_finite F
+GLIBC_2.15 __powl_finite F
+GLIBC_2.15 __remainder_finite F
+GLIBC_2.15 __remainderf_finite F
+GLIBC_2.15 __remainderl_finite F
+GLIBC_2.15 __scalb_finite F
+GLIBC_2.15 __scalbf_finite F
+GLIBC_2.15 __scalbl_finite F
+GLIBC_2.15 __sinh_finite F
+GLIBC_2.15 __sinhf_finite F
+GLIBC_2.15 __sinhl_finite F
+GLIBC_2.15 __sqrt_finite F
+GLIBC_2.15 __sqrtf_finite F
+GLIBC_2.15 __sqrtl_finite F
+GLIBC_2.15 __y0_finite F
+GLIBC_2.15 __y0f_finite F
+GLIBC_2.15 __y0l_finite F
+GLIBC_2.15 __y1_finite F
+GLIBC_2.15 __y1f_finite F
+GLIBC_2.15 __y1l_finite F
+GLIBC_2.15 __yn_finite F
+GLIBC_2.15 __ynf_finite F
+GLIBC_2.15 __ynl_finite F
+GLIBC_2.18 GLIBC_2.18 A
+GLIBC_2.18 __issignaling F
+GLIBC_2.18 __issignalingf F
+GLIBC_2.18 __issignalingl F
+GLIBC_2.23 GLIBC_2.23 A
+GLIBC_2.23 __signgam D 0x4
+GLIBC_2.23 lgamma F
+GLIBC_2.23 lgammaf F
+GLIBC_2.23 lgammal F
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 _LIB_VERSION D 0x4
+GLIBC_2.3 __clog10 F
+GLIBC_2.3 __clog10f F
+GLIBC_2.3 __clog10l F
+GLIBC_2.3 __finite F
+GLIBC_2.3 __finitef F
+GLIBC_2.3 __finitel F
+GLIBC_2.3 __fpclassify F
+GLIBC_2.3 __fpclassifyf F
+GLIBC_2.3 __fpclassifyl F
+GLIBC_2.3 __signbit F
+GLIBC_2.3 __signbitf F
+GLIBC_2.3 __signbitl F
+GLIBC_2.3 acos F
+GLIBC_2.3 acosf F
+GLIBC_2.3 acosh F
+GLIBC_2.3 acoshf F
+GLIBC_2.3 acoshl F
+GLIBC_2.3 acosl F
+GLIBC_2.3 asin F
+GLIBC_2.3 asinf F
+GLIBC_2.3 asinh F
+GLIBC_2.3 asinhf F
+GLIBC_2.3 asinhl F
+GLIBC_2.3 asinl F
+GLIBC_2.3 atan F
+GLIBC_2.3 atan2 F
+GLIBC_2.3 atan2f F
+GLIBC_2.3 atan2l F
+GLIBC_2.3 atanf F
+GLIBC_2.3 atanh F
+GLIBC_2.3 atanhf F
+GLIBC_2.3 atanhl F
+GLIBC_2.3 atanl F
+GLIBC_2.3 cabs F
+GLIBC_2.3 cabsf F
+GLIBC_2.3 cabsl F
+GLIBC_2.3 cacos F
+GLIBC_2.3 cacosf F
+GLIBC_2.3 cacosh F
+GLIBC_2.3 cacoshf F
+GLIBC_2.3 cacoshl F
+GLIBC_2.3 cacosl F
+GLIBC_2.3 carg F
+GLIBC_2.3 cargf F
+GLIBC_2.3 cargl F
+GLIBC_2.3 casin F
+GLIBC_2.3 casinf F
+GLIBC_2.3 casinh F
+GLIBC_2.3 casinhf F
+GLIBC_2.3 casinhl F
+GLIBC_2.3 casinl F
+GLIBC_2.3 catan F
+GLIBC_2.3 catanf F
+GLIBC_2.3 catanh F
+GLIBC_2.3 catanhf F
+GLIBC_2.3 catanhl F
+GLIBC_2.3 catanl F
+GLIBC_2.3 cbrt F
+GLIBC_2.3 cbrtf F
+GLIBC_2.3 cbrtl F
+GLIBC_2.3 ccos F
+GLIBC_2.3 ccosf F
+GLIBC_2.3 ccosh F
+GLIBC_2.3 ccoshf F
+GLIBC_2.3 ccoshl F
+GLIBC_2.3 ccosl F
+GLIBC_2.3 ceil F
+GLIBC_2.3 ceilf F
+GLIBC_2.3 ceill F
+GLIBC_2.3 cexp F
+GLIBC_2.3 cexpf F
+GLIBC_2.3 cexpl F
+GLIBC_2.3 cimag F
+GLIBC_2.3 cimagf F
+GLIBC_2.3 cimagl F
+GLIBC_2.3 clog F
+GLIBC_2.3 clog10 F
+GLIBC_2.3 clog10f F
+GLIBC_2.3 clog10l F
+GLIBC_2.3 clogf F
+GLIBC_2.3 clogl F
+GLIBC_2.3 conj F
+GLIBC_2.3 conjf F
+GLIBC_2.3 conjl F
+GLIBC_2.3 copysign F
+GLIBC_2.3 copysignf F
+GLIBC_2.3 copysignl F
+GLIBC_2.3 cos F
+GLIBC_2.3 cosf F
+GLIBC_2.3 cosh F
+GLIBC_2.3 coshf F
+GLIBC_2.3 coshl F
+GLIBC_2.3 cosl F
+GLIBC_2.3 cpow F
+GLIBC_2.3 cpowf F
+GLIBC_2.3 cpowl F
+GLIBC_2.3 cproj F
+GLIBC_2.3 cprojf F
+GLIBC_2.3 cprojl F
+GLIBC_2.3 creal F
+GLIBC_2.3 crealf F
+GLIBC_2.3 creall F
+GLIBC_2.3 csin F
+GLIBC_2.3 csinf F
+GLIBC_2.3 csinh F
+GLIBC_2.3 csinhf F
+GLIBC_2.3 csinhl F
+GLIBC_2.3 csinl F
+GLIBC_2.3 csqrt F
+GLIBC_2.3 csqrtf F
+GLIBC_2.3 csqrtl F
+GLIBC_2.3 ctan F
+GLIBC_2.3 ctanf F
+GLIBC_2.3 ctanh F
+GLIBC_2.3 ctanhf F
+GLIBC_2.3 ctanhl F
+GLIBC_2.3 ctanl F
+GLIBC_2.3 drem F
+GLIBC_2.3 dremf F
+GLIBC_2.3 dreml F
+GLIBC_2.3 erf F
+GLIBC_2.3 erfc F
+GLIBC_2.3 erfcf F
+GLIBC_2.3 erfcl F
+GLIBC_2.3 erff F
+GLIBC_2.3 erfl F
+GLIBC_2.3 exp F
+GLIBC_2.3 exp10 F
+GLIBC_2.3 exp10f F
+GLIBC_2.3 exp10l F
+GLIBC_2.3 exp2 F
+GLIBC_2.3 exp2f F
+GLIBC_2.3 exp2l F
+GLIBC_2.3 expf F
+GLIBC_2.3 expl F
+GLIBC_2.3 expm1 F
+GLIBC_2.3 expm1f F
+GLIBC_2.3 expm1l F
+GLIBC_2.3 fabs F
+GLIBC_2.3 fabsf F
+GLIBC_2.3 fabsl F
+GLIBC_2.3 fdim F
+GLIBC_2.3 fdimf F
+GLIBC_2.3 fdiml F
+GLIBC_2.3 feclearexcept F
+GLIBC_2.3 fedisableexcept F
+GLIBC_2.3 feenableexcept F
+GLIBC_2.3 fegetenv F
+GLIBC_2.3 fegetexcept F
+GLIBC_2.3 fegetexceptflag F
+GLIBC_2.3 fegetround F
+GLIBC_2.3 feholdexcept F
+GLIBC_2.3 feraiseexcept F
+GLIBC_2.3 fesetenv F
+GLIBC_2.3 fesetexceptflag F
+GLIBC_2.3 fesetround F
+GLIBC_2.3 fetestexcept F
+GLIBC_2.3 feupdateenv F
+GLIBC_2.3 finite F
+GLIBC_2.3 finitef F
+GLIBC_2.3 finitel F
+GLIBC_2.3 floor F
+GLIBC_2.3 floorf F
+GLIBC_2.3 floorl F
+GLIBC_2.3 fma F
+GLIBC_2.3 fmaf F
+GLIBC_2.3 fmal F
+GLIBC_2.3 fmax F
+GLIBC_2.3 fmaxf F
+GLIBC_2.3 fmaxl F
+GLIBC_2.3 fmin F
+GLIBC_2.3 fminf F
+GLIBC_2.3 fminl F
+GLIBC_2.3 fmod F
+GLIBC_2.3 fmodf F
+GLIBC_2.3 fmodl F
+GLIBC_2.3 frexp F
+GLIBC_2.3 frexpf F
+GLIBC_2.3 frexpl F
+GLIBC_2.3 gamma F
+GLIBC_2.3 gammaf F
+GLIBC_2.3 gammal F
+GLIBC_2.3 hypot F
+GLIBC_2.3 hypotf F
+GLIBC_2.3 hypotl F
+GLIBC_2.3 ilogb F
+GLIBC_2.3 ilogbf F
+GLIBC_2.3 ilogbl F
+GLIBC_2.3 j0 F
+GLIBC_2.3 j0f F
+GLIBC_2.3 j0l F
+GLIBC_2.3 j1 F
+GLIBC_2.3 j1f F
+GLIBC_2.3 j1l F
+GLIBC_2.3 jn F
+GLIBC_2.3 jnf F
+GLIBC_2.3 jnl F
+GLIBC_2.3 ldexp F
+GLIBC_2.3 ldexpf F
+GLIBC_2.3 ldexpl F
+GLIBC_2.3 lgamma F
+GLIBC_2.3 lgamma_r F
+GLIBC_2.3 lgammaf F
+GLIBC_2.3 lgammaf_r F
+GLIBC_2.3 lgammal F
+GLIBC_2.3 lgammal_r F
+GLIBC_2.3 llrint F
+GLIBC_2.3 llrintf F
+GLIBC_2.3 llrintl F
+GLIBC_2.3 llround F
+GLIBC_2.3 llroundf F
+GLIBC_2.3 llroundl F
+GLIBC_2.3 log F
+GLIBC_2.3 log10 F
+GLIBC_2.3 log10f F
+GLIBC_2.3 log10l F
+GLIBC_2.3 log1p F
+GLIBC_2.3 log1pf F
+GLIBC_2.3 log1pl F
+GLIBC_2.3 log2 F
+GLIBC_2.3 log2f F
+GLIBC_2.3 log2l F
+GLIBC_2.3 logb F
+GLIBC_2.3 logbf F
+GLIBC_2.3 logbl F
+GLIBC_2.3 logf F
+GLIBC_2.3 logl F
+GLIBC_2.3 lrint F
+GLIBC_2.3 lrintf F
+GLIBC_2.3 lrintl F
+GLIBC_2.3 lround F
+GLIBC_2.3 lroundf F
+GLIBC_2.3 lroundl F
+GLIBC_2.3 matherr F
+GLIBC_2.3 modf F
+GLIBC_2.3 modff F
+GLIBC_2.3 modfl F
+GLIBC_2.3 nan F
+GLIBC_2.3 nanf F
+GLIBC_2.3 nanl F
+GLIBC_2.3 nearbyint F
+GLIBC_2.3 nearbyintf F
+GLIBC_2.3 nearbyintl F
+GLIBC_2.3 nextafter F
+GLIBC_2.3 nextafterf F
+GLIBC_2.3 nextafterl F
+GLIBC_2.3 nexttoward F
+GLIBC_2.3 nexttowardf F
+GLIBC_2.3 nexttowardl F
+GLIBC_2.3 pow F
+GLIBC_2.3 pow10 F
+GLIBC_2.3 pow10f F
+GLIBC_2.3 pow10l F
+GLIBC_2.3 powf F
+GLIBC_2.3 powl F
+GLIBC_2.3 remainder F
+GLIBC_2.3 remainderf F
+GLIBC_2.3 remainderl F
+GLIBC_2.3 remquo F
+GLIBC_2.3 remquof F
+GLIBC_2.3 remquol F
+GLIBC_2.3 rint F
+GLIBC_2.3 rintf F
+GLIBC_2.3 rintl F
+GLIBC_2.3 round F
+GLIBC_2.3 roundf F
+GLIBC_2.3 roundl F
+GLIBC_2.3 scalb F
+GLIBC_2.3 scalbf F
+GLIBC_2.3 scalbl F
+GLIBC_2.3 scalbln F
+GLIBC_2.3 scalblnf F
+GLIBC_2.3 scalblnl F
+GLIBC_2.3 scalbn F
+GLIBC_2.3 scalbnf F
+GLIBC_2.3 scalbnl F
+GLIBC_2.3 signgam D 0x4
+GLIBC_2.3 significand F
+GLIBC_2.3 significandf F
+GLIBC_2.3 significandl F
+GLIBC_2.3 sin F
+GLIBC_2.3 sincos F
+GLIBC_2.3 sincosf F
+GLIBC_2.3 sincosl F
+GLIBC_2.3 sinf F
+GLIBC_2.3 sinh F
+GLIBC_2.3 sinhf F
+GLIBC_2.3 sinhl F
+GLIBC_2.3 sinl F
+GLIBC_2.3 sqrt F
+GLIBC_2.3 sqrtf F
+GLIBC_2.3 sqrtl F
+GLIBC_2.3 tan F
+GLIBC_2.3 tanf F
+GLIBC_2.3 tanh F
+GLIBC_2.3 tanhf F
+GLIBC_2.3 tanhl F
+GLIBC_2.3 tanl F
+GLIBC_2.3 tgamma F
+GLIBC_2.3 tgammaf F
+GLIBC_2.3 tgammal F
+GLIBC_2.3 trunc F
+GLIBC_2.3 truncf F
+GLIBC_2.3 truncl F
+GLIBC_2.3 y0 F
+GLIBC_2.3 y0f F
+GLIBC_2.3 y0l F
+GLIBC_2.3 y1 F
+GLIBC_2.3 y1f F
+GLIBC_2.3 y1l F
+GLIBC_2.3 yn F
+GLIBC_2.3 ynf F
+GLIBC_2.3 ynl F
+GLIBC_2.4 GLIBC_2.4 A
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libnsl.abilist
@@ -0,0 +1,122 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 __free_fdresult F
+GLIBC_2.3 __nis_default_access F
+GLIBC_2.3 __nis_default_group F
+GLIBC_2.3 __nis_default_owner F
+GLIBC_2.3 __nis_default_ttl F
+GLIBC_2.3 __nis_finddirectory F
+GLIBC_2.3 __nis_hash F
+GLIBC_2.3 __nisbind_connect F
+GLIBC_2.3 __nisbind_create F
+GLIBC_2.3 __nisbind_destroy F
+GLIBC_2.3 __nisbind_next F
+GLIBC_2.3 __yp_check F
+GLIBC_2.3 nis_add F
+GLIBC_2.3 nis_add_entry F
+GLIBC_2.3 nis_addmember F
+GLIBC_2.3 nis_checkpoint F
+GLIBC_2.3 nis_clone_directory F
+GLIBC_2.3 nis_clone_object F
+GLIBC_2.3 nis_clone_result F
+GLIBC_2.3 nis_creategroup F
+GLIBC_2.3 nis_destroy_object F
+GLIBC_2.3 nis_destroygroup F
+GLIBC_2.3 nis_dir_cmp F
+GLIBC_2.3 nis_domain_of F
+GLIBC_2.3 nis_domain_of_r F
+GLIBC_2.3 nis_first_entry F
+GLIBC_2.3 nis_free_directory F
+GLIBC_2.3 nis_free_object F
+GLIBC_2.3 nis_free_request F
+GLIBC_2.3 nis_freenames F
+GLIBC_2.3 nis_freeresult F
+GLIBC_2.3 nis_freeservlist F
+GLIBC_2.3 nis_freetags F
+GLIBC_2.3 nis_getnames F
+GLIBC_2.3 nis_getservlist F
+GLIBC_2.3 nis_ismember F
+GLIBC_2.3 nis_leaf_of F
+GLIBC_2.3 nis_leaf_of_r F
+GLIBC_2.3 nis_lerror F
+GLIBC_2.3 nis_list F
+GLIBC_2.3 nis_local_directory F
+GLIBC_2.3 nis_local_group F
+GLIBC_2.3 nis_local_host F
+GLIBC_2.3 nis_local_principal F
+GLIBC_2.3 nis_lookup F
+GLIBC_2.3 nis_mkdir F
+GLIBC_2.3 nis_modify F
+GLIBC_2.3 nis_modify_entry F
+GLIBC_2.3 nis_name_of F
+GLIBC_2.3 nis_name_of_r F
+GLIBC_2.3 nis_next_entry F
+GLIBC_2.3 nis_perror F
+GLIBC_2.3 nis_ping F
+GLIBC_2.3 nis_print_directory F
+GLIBC_2.3 nis_print_entry F
+GLIBC_2.3 nis_print_group F
+GLIBC_2.3 nis_print_group_entry F
+GLIBC_2.3 nis_print_link F
+GLIBC_2.3 nis_print_object F
+GLIBC_2.3 nis_print_result F
+GLIBC_2.3 nis_print_rights F
+GLIBC_2.3 nis_print_table F
+GLIBC_2.3 nis_read_obj F
+GLIBC_2.3 nis_remove F
+GLIBC_2.3 nis_remove_entry F
+GLIBC_2.3 nis_removemember F
+GLIBC_2.3 nis_rmdir F
+GLIBC_2.3 nis_servstate F
+GLIBC_2.3 nis_sperrno F
+GLIBC_2.3 nis_sperror F
+GLIBC_2.3 nis_sperror_r F
+GLIBC_2.3 nis_stats F
+GLIBC_2.3 nis_verifygroup F
+GLIBC_2.3 nis_write_obj F
+GLIBC_2.3 readColdStartFile F
+GLIBC_2.3 writeColdStartFile F
+GLIBC_2.3 xdr_cback_data F
+GLIBC_2.3 xdr_domainname F
+GLIBC_2.3 xdr_keydat F
+GLIBC_2.3 xdr_mapname F
+GLIBC_2.3 xdr_obj_p F
+GLIBC_2.3 xdr_peername F
+GLIBC_2.3 xdr_valdat F
+GLIBC_2.3 xdr_yp_buf F
+GLIBC_2.3 xdr_ypall F
+GLIBC_2.3 xdr_ypbind_binding F
+GLIBC_2.3 xdr_ypbind_resp F
+GLIBC_2.3 xdr_ypbind_resptype F
+GLIBC_2.3 xdr_ypbind_setdom F
+GLIBC_2.3 xdr_ypdelete_args F
+GLIBC_2.3 xdr_ypmap_parms F
+GLIBC_2.3 xdr_ypmaplist F
+GLIBC_2.3 xdr_yppush_status F
+GLIBC_2.3 xdr_yppushresp_xfr F
+GLIBC_2.3 xdr_ypreq_key F
+GLIBC_2.3 xdr_ypreq_nokey F
+GLIBC_2.3 xdr_ypreq_xfr F
+GLIBC_2.3 xdr_ypresp_all F
+GLIBC_2.3 xdr_ypresp_key_val F
+GLIBC_2.3 xdr_ypresp_maplist F
+GLIBC_2.3 xdr_ypresp_master F
+GLIBC_2.3 xdr_ypresp_order F
+GLIBC_2.3 xdr_ypresp_val F
+GLIBC_2.3 xdr_ypresp_xfr F
+GLIBC_2.3 xdr_ypstat F
+GLIBC_2.3 xdr_ypupdate_args F
+GLIBC_2.3 xdr_ypxfrstat F
+GLIBC_2.3 yp_all F
+GLIBC_2.3 yp_bind F
+GLIBC_2.3 yp_first F
+GLIBC_2.3 yp_get_default_domain F
+GLIBC_2.3 yp_maplist F
+GLIBC_2.3 yp_master F
+GLIBC_2.3 yp_match F
+GLIBC_2.3 yp_next F
+GLIBC_2.3 yp_order F
+GLIBC_2.3 yp_unbind F
+GLIBC_2.3 yp_update F
+GLIBC_2.3 ypbinderr_string F
+GLIBC_2.3 yperr_string F
+GLIBC_2.3 ypprot_err F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libpthread.abilist
@@ -0,0 +1,227 @@
+GLIBC_2.12 GLIBC_2.12 A
+GLIBC_2.12 pthread_getname_np F
+GLIBC_2.12 pthread_setname_np F
+GLIBC_2.18 GLIBC_2.18 A
+GLIBC_2.18 pthread_getattr_default_np F
+GLIBC_2.18 pthread_setattr_default_np F
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 _IO_flockfile F
+GLIBC_2.3 _IO_ftrylockfile F
+GLIBC_2.3 _IO_funlockfile F
+GLIBC_2.3 __close F
+GLIBC_2.3 __connect F
+GLIBC_2.3 __errno_location F
+GLIBC_2.3 __fcntl F
+GLIBC_2.3 __fork F
+GLIBC_2.3 __h_errno_location F
+GLIBC_2.3 __libc_allocate_rtsig F
+GLIBC_2.3 __libc_current_sigrtmax F
+GLIBC_2.3 __libc_current_sigrtmin F
+GLIBC_2.3 __lseek F
+GLIBC_2.3 __nanosleep F
+GLIBC_2.3 __open F
+GLIBC_2.3 __open64 F
+GLIBC_2.3 __pread64 F
+GLIBC_2.3 __pthread_getspecific F
+GLIBC_2.3 __pthread_key_create F
+GLIBC_2.3 __pthread_mutex_destroy F
+GLIBC_2.3 __pthread_mutex_init F
+GLIBC_2.3 __pthread_mutex_lock F
+GLIBC_2.3 __pthread_mutex_trylock F
+GLIBC_2.3 __pthread_mutex_unlock F
+GLIBC_2.3 __pthread_mutexattr_destroy F
+GLIBC_2.3 __pthread_mutexattr_init F
+GLIBC_2.3 __pthread_mutexattr_settype F
+GLIBC_2.3 __pthread_once F
+GLIBC_2.3 __pthread_rwlock_destroy F
+GLIBC_2.3 __pthread_rwlock_init F
+GLIBC_2.3 __pthread_rwlock_rdlock F
+GLIBC_2.3 __pthread_rwlock_tryrdlock F
+GLIBC_2.3 __pthread_rwlock_trywrlock F
+GLIBC_2.3 __pthread_rwlock_unlock F
+GLIBC_2.3 __pthread_rwlock_wrlock F
+GLIBC_2.3 __pthread_setspecific F
+GLIBC_2.3 __pwrite64 F
+GLIBC_2.3 __read F
+GLIBC_2.3 __res_state F
+GLIBC_2.3 __send F
+GLIBC_2.3 __sigaction F
+GLIBC_2.3 __vfork F
+GLIBC_2.3 __wait F
+GLIBC_2.3 __write F
+GLIBC_2.3 _pthread_cleanup_pop F
+GLIBC_2.3 _pthread_cleanup_pop_restore F
+GLIBC_2.3 _pthread_cleanup_push F
+GLIBC_2.3 _pthread_cleanup_push_defer F
+GLIBC_2.3 accept F
+GLIBC_2.3 close F
+GLIBC_2.3 connect F
+GLIBC_2.3 fcntl F
+GLIBC_2.3 flockfile F
+GLIBC_2.3 fork F
+GLIBC_2.3 fsync F
+GLIBC_2.3 ftrylockfile F
+GLIBC_2.3 funlockfile F
+GLIBC_2.3 longjmp F
+GLIBC_2.3 lseek F
+GLIBC_2.3 lseek64 F
+GLIBC_2.3 msync F
+GLIBC_2.3 nanosleep F
+GLIBC_2.3 open F
+GLIBC_2.3 open64 F
+GLIBC_2.3 pause F
+GLIBC_2.3 pread F
+GLIBC_2.3 pread64 F
+GLIBC_2.3 pthread_atfork F
+GLIBC_2.3 pthread_attr_destroy F
+GLIBC_2.3 pthread_attr_getdetachstate F
+GLIBC_2.3 pthread_attr_getguardsize F
+GLIBC_2.3 pthread_attr_getinheritsched F
+GLIBC_2.3 pthread_attr_getschedparam F
+GLIBC_2.3 pthread_attr_getschedpolicy F
+GLIBC_2.3 pthread_attr_getscope F
+GLIBC_2.3 pthread_attr_getstack F
+GLIBC_2.3 pthread_attr_getstackaddr F
+GLIBC_2.3 pthread_attr_getstacksize F
+GLIBC_2.3 pthread_attr_init F
+GLIBC_2.3 pthread_attr_setdetachstate F
+GLIBC_2.3 pthread_attr_setguardsize F
+GLIBC_2.3 pthread_attr_setinheritsched F
+GLIBC_2.3 pthread_attr_setschedparam F
+GLIBC_2.3 pthread_attr_setschedpolicy F
+GLIBC_2.3 pthread_attr_setscope F
+GLIBC_2.3 pthread_attr_setstack F
+GLIBC_2.3 pthread_attr_setstackaddr F
+GLIBC_2.3 pthread_attr_setstacksize F
+GLIBC_2.3 pthread_barrier_destroy F
+GLIBC_2.3 pthread_barrier_init F
+GLIBC_2.3 pthread_barrier_wait F
+GLIBC_2.3 pthread_barrierattr_destroy F
+GLIBC_2.3 pthread_barrierattr_init F
+GLIBC_2.3 pthread_barrierattr_setpshared F
+GLIBC_2.3 pthread_cancel F
+GLIBC_2.3 pthread_cond_broadcast F
+GLIBC_2.3 pthread_cond_destroy F
+GLIBC_2.3 pthread_cond_init F
+GLIBC_2.3 pthread_cond_signal F
+GLIBC_2.3 pthread_cond_timedwait F
+GLIBC_2.3 pthread_cond_wait F
+GLIBC_2.3 pthread_condattr_destroy F
+GLIBC_2.3 pthread_condattr_getpshared F
+GLIBC_2.3 pthread_condattr_init F
+GLIBC_2.3 pthread_condattr_setpshared F
+GLIBC_2.3 pthread_create F
+GLIBC_2.3 pthread_detach F
+GLIBC_2.3 pthread_equal F
+GLIBC_2.3 pthread_exit F
+GLIBC_2.3 pthread_getattr_np F
+GLIBC_2.3 pthread_getconcurrency F
+GLIBC_2.3 pthread_getcpuclockid F
+GLIBC_2.3 pthread_getschedparam F
+GLIBC_2.3 pthread_getspecific F
+GLIBC_2.3 pthread_join F
+GLIBC_2.3 pthread_key_create F
+GLIBC_2.3 pthread_key_delete F
+GLIBC_2.3 pthread_kill F
+GLIBC_2.3 pthread_kill_other_threads_np F
+GLIBC_2.3 pthread_mutex_destroy F
+GLIBC_2.3 pthread_mutex_init F
+GLIBC_2.3 pthread_mutex_lock F
+GLIBC_2.3 pthread_mutex_timedlock F
+GLIBC_2.3 pthread_mutex_trylock F
+GLIBC_2.3 pthread_mutex_unlock F
+GLIBC_2.3 pthread_mutexattr_destroy F
+GLIBC_2.3 pthread_mutexattr_getkind_np F
+GLIBC_2.3 pthread_mutexattr_getpshared F
+GLIBC_2.3 pthread_mutexattr_gettype F
+GLIBC_2.3 pthread_mutexattr_init F
+GLIBC_2.3 pthread_mutexattr_setkind_np F
+GLIBC_2.3 pthread_mutexattr_setpshared F
+GLIBC_2.3 pthread_mutexattr_settype F
+GLIBC_2.3 pthread_once F
+GLIBC_2.3 pthread_rwlock_destroy F
+GLIBC_2.3 pthread_rwlock_init F
+GLIBC_2.3 pthread_rwlock_rdlock F
+GLIBC_2.3 pthread_rwlock_timedrdlock F
+GLIBC_2.3 pthread_rwlock_timedwrlock F
+GLIBC_2.3 pthread_rwlock_tryrdlock F
+GLIBC_2.3 pthread_rwlock_trywrlock F
+GLIBC_2.3 pthread_rwlock_unlock F
+GLIBC_2.3 pthread_rwlock_wrlock F
+GLIBC_2.3 pthread_rwlockattr_destroy F
+GLIBC_2.3 pthread_rwlockattr_getkind_np F
+GLIBC_2.3 pthread_rwlockattr_getpshared F
+GLIBC_2.3 pthread_rwlockattr_init F
+GLIBC_2.3 pthread_rwlockattr_setkind_np F
+GLIBC_2.3 pthread_rwlockattr_setpshared F
+GLIBC_2.3 pthread_self F
+GLIBC_2.3 pthread_setcancelstate F
+GLIBC_2.3 pthread_setcanceltype F
+GLIBC_2.3 pthread_setconcurrency F
+GLIBC_2.3 pthread_setschedparam F
+GLIBC_2.3 pthread_setspecific F
+GLIBC_2.3 pthread_sigmask F
+GLIBC_2.3 pthread_spin_destroy F
+GLIBC_2.3 pthread_spin_init F
+GLIBC_2.3 pthread_spin_lock F
+GLIBC_2.3 pthread_spin_trylock F
+GLIBC_2.3 pthread_spin_unlock F
+GLIBC_2.3 pthread_testcancel F
+GLIBC_2.3 pthread_yield F
+GLIBC_2.3 pwrite F
+GLIBC_2.3 pwrite64 F
+GLIBC_2.3 raise F
+GLIBC_2.3 read F
+GLIBC_2.3 recv F
+GLIBC_2.3 recvfrom F
+GLIBC_2.3 recvmsg F
+GLIBC_2.3 sem_close F
+GLIBC_2.3 sem_destroy F
+GLIBC_2.3 sem_getvalue F
+GLIBC_2.3 sem_init F
+GLIBC_2.3 sem_open F
+GLIBC_2.3 sem_post F
+GLIBC_2.3 sem_timedwait F
+GLIBC_2.3 sem_trywait F
+GLIBC_2.3 sem_unlink F
+GLIBC_2.3 sem_wait F
+GLIBC_2.3 send F
+GLIBC_2.3 sendmsg F
+GLIBC_2.3 sendto F
+GLIBC_2.3 sigaction F
+GLIBC_2.3 siglongjmp F
+GLIBC_2.3 sigwait F
+GLIBC_2.3 system F
+GLIBC_2.3 tcdrain F
+GLIBC_2.3 vfork F
+GLIBC_2.3 wait F
+GLIBC_2.3 waitpid F
+GLIBC_2.3 write F
+GLIBC_2.3.2 GLIBC_2.3.2 A
+GLIBC_2.3.2 pthread_cond_broadcast F
+GLIBC_2.3.2 pthread_cond_destroy F
+GLIBC_2.3.2 pthread_cond_init F
+GLIBC_2.3.2 pthread_cond_signal F
+GLIBC_2.3.2 pthread_cond_timedwait F
+GLIBC_2.3.2 pthread_cond_wait F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 __pthread_cleanup_routine F
+GLIBC_2.3.3 __pthread_register_cancel F
+GLIBC_2.3.3 __pthread_register_cancel_defer F
+GLIBC_2.3.3 __pthread_unregister_cancel F
+GLIBC_2.3.3 __pthread_unregister_cancel_restore F
+GLIBC_2.3.3 __pthread_unwind_next F
+GLIBC_2.3.3 pthread_attr_getaffinity_np F
+GLIBC_2.3.3 pthread_attr_setaffinity_np F
+GLIBC_2.3.3 pthread_barrierattr_getpshared F
+GLIBC_2.3.3 pthread_condattr_getclock F
+GLIBC_2.3.3 pthread_condattr_setclock F
+GLIBC_2.3.3 pthread_getaffinity_np F
+GLIBC_2.3.3 pthread_setaffinity_np F
+GLIBC_2.3.3 pthread_timedjoin_np F
+GLIBC_2.3.3 pthread_tryjoin_np F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 pthread_attr_getaffinity_np F
+GLIBC_2.3.4 pthread_attr_setaffinity_np F
+GLIBC_2.3.4 pthread_getaffinity_np F
+GLIBC_2.3.4 pthread_setaffinity_np F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libresolv.abilist
@@ -0,0 +1,94 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 __b64_ntop F
+GLIBC_2.3 __b64_pton F
+GLIBC_2.3 __dn_comp F
+GLIBC_2.3 __dn_count_labels F
+GLIBC_2.3 __dn_expand F
+GLIBC_2.3 __dn_skipname F
+GLIBC_2.3 __fp_nquery F
+GLIBC_2.3 __fp_query F
+GLIBC_2.3 __fp_resstat F
+GLIBC_2.3 __hostalias F
+GLIBC_2.3 __loc_aton F
+GLIBC_2.3 __loc_ntoa F
+GLIBC_2.3 __p_cdname F
+GLIBC_2.3 __p_cdnname F
+GLIBC_2.3 __p_class F
+GLIBC_2.3 __p_class_syms D 0xa8
+GLIBC_2.3 __p_fqname F
+GLIBC_2.3 __p_fqnname F
+GLIBC_2.3 __p_option F
+GLIBC_2.3 __p_query F
+GLIBC_2.3 __p_secstodate F
+GLIBC_2.3 __p_time F
+GLIBC_2.3 __p_type F
+GLIBC_2.3 __p_type_syms D 0x450
+GLIBC_2.3 __putlong F
+GLIBC_2.3 __putshort F
+GLIBC_2.3 __res_close F
+GLIBC_2.3 __res_dnok F
+GLIBC_2.3 __res_hnok F
+GLIBC_2.3 __res_hostalias F
+GLIBC_2.3 __res_isourserver F
+GLIBC_2.3 __res_mailok F
+GLIBC_2.3 __res_mkquery F
+GLIBC_2.3 __res_nameinquery F
+GLIBC_2.3 __res_nmkquery F
+GLIBC_2.3 __res_nquery F
+GLIBC_2.3 __res_nquerydomain F
+GLIBC_2.3 __res_nsearch F
+GLIBC_2.3 __res_nsend F
+GLIBC_2.3 __res_ownok F
+GLIBC_2.3 __res_queriesmatch F
+GLIBC_2.3 __res_query F
+GLIBC_2.3 __res_querydomain F
+GLIBC_2.3 __res_search F
+GLIBC_2.3 __res_send F
+GLIBC_2.3 __sym_ntop F
+GLIBC_2.3 __sym_ntos F
+GLIBC_2.3 __sym_ston F
+GLIBC_2.3 _gethtbyaddr F
+GLIBC_2.3 _gethtbyname F
+GLIBC_2.3 _gethtbyname2 F
+GLIBC_2.3 _gethtent F
+GLIBC_2.3 _getlong F
+GLIBC_2.3 _getshort F
+GLIBC_2.3 _res_opcodes D 0x80
+GLIBC_2.3 _sethtent F
+GLIBC_2.3 inet_net_ntop F
+GLIBC_2.3 inet_net_pton F
+GLIBC_2.3 inet_neta F
+GLIBC_2.3 res_gethostbyaddr F
+GLIBC_2.3 res_gethostbyname F
+GLIBC_2.3 res_gethostbyname2 F
+GLIBC_2.3 res_send_setqhook F
+GLIBC_2.3 res_send_setrhook F
+GLIBC_2.3.2 GLIBC_2.3.2 A
+GLIBC_2.3.2 __p_rcode F
+GLIBC_2.9 GLIBC_2.9 A
+GLIBC_2.9 ns_datetosecs F
+GLIBC_2.9 ns_format_ttl F
+GLIBC_2.9 ns_get16 F
+GLIBC_2.9 ns_get32 F
+GLIBC_2.9 ns_initparse F
+GLIBC_2.9 ns_makecanon F
+GLIBC_2.9 ns_msg_getflag F
+GLIBC_2.9 ns_name_compress F
+GLIBC_2.9 ns_name_ntol F
+GLIBC_2.9 ns_name_ntop F
+GLIBC_2.9 ns_name_pack F
+GLIBC_2.9 ns_name_pton F
+GLIBC_2.9 ns_name_rollback F
+GLIBC_2.9 ns_name_skip F
+GLIBC_2.9 ns_name_uncompress F
+GLIBC_2.9 ns_name_unpack F
+GLIBC_2.9 ns_parse_ttl F
+GLIBC_2.9 ns_parserr F
+GLIBC_2.9 ns_put16 F
+GLIBC_2.9 ns_put32 F
+GLIBC_2.9 ns_samedomain F
+GLIBC_2.9 ns_samename F
+GLIBC_2.9 ns_skiprr F
+GLIBC_2.9 ns_sprintrr F
+GLIBC_2.9 ns_sprintrrf F
+GLIBC_2.9 ns_subdomain F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/librt.abilist
@@ -0,0 +1,46 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 aio_cancel F
+GLIBC_2.3 aio_cancel64 F
+GLIBC_2.3 aio_error F
+GLIBC_2.3 aio_error64 F
+GLIBC_2.3 aio_fsync F
+GLIBC_2.3 aio_fsync64 F
+GLIBC_2.3 aio_init F
+GLIBC_2.3 aio_read F
+GLIBC_2.3 aio_read64 F
+GLIBC_2.3 aio_return F
+GLIBC_2.3 aio_return64 F
+GLIBC_2.3 aio_suspend F
+GLIBC_2.3 aio_suspend64 F
+GLIBC_2.3 aio_write F
+GLIBC_2.3 aio_write64 F
+GLIBC_2.3 clock_getcpuclockid F
+GLIBC_2.3 clock_getres F
+GLIBC_2.3 clock_gettime F
+GLIBC_2.3 clock_nanosleep F
+GLIBC_2.3 clock_settime F
+GLIBC_2.3 lio_listio F
+GLIBC_2.3 lio_listio64 F
+GLIBC_2.3 shm_open F
+GLIBC_2.3 shm_unlink F
+GLIBC_2.3 timer_create F
+GLIBC_2.3 timer_delete F
+GLIBC_2.3 timer_getoverrun F
+GLIBC_2.3 timer_gettime F
+GLIBC_2.3 timer_settime F
+GLIBC_2.3.4 GLIBC_2.3.4 A
+GLIBC_2.3.4 mq_close F
+GLIBC_2.3.4 mq_getattr F
+GLIBC_2.3.4 mq_notify F
+GLIBC_2.3.4 mq_open F
+GLIBC_2.3.4 mq_receive F
+GLIBC_2.3.4 mq_send F
+GLIBC_2.3.4 mq_setattr F
+GLIBC_2.3.4 mq_timedreceive F
+GLIBC_2.3.4 mq_timedsend F
+GLIBC_2.3.4 mq_unlink F
+GLIBC_2.4 GLIBC_2.4 A
+GLIBC_2.4 lio_listio F
+GLIBC_2.4 lio_listio64 F
+GLIBC_2.7 GLIBC_2.7 A
+GLIBC_2.7 __mq_open_2 F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libthread_db.abilist
@@ -0,0 +1,42 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 td_init F
+GLIBC_2.3 td_log F
+GLIBC_2.3 td_symbol_list F
+GLIBC_2.3 td_ta_clear_event F
+GLIBC_2.3 td_ta_delete F
+GLIBC_2.3 td_ta_enable_stats F
+GLIBC_2.3 td_ta_event_addr F
+GLIBC_2.3 td_ta_event_getmsg F
+GLIBC_2.3 td_ta_get_nthreads F
+GLIBC_2.3 td_ta_get_ph F
+GLIBC_2.3 td_ta_get_stats F
+GLIBC_2.3 td_ta_map_id2thr F
+GLIBC_2.3 td_ta_map_lwp2thr F
+GLIBC_2.3 td_ta_new F
+GLIBC_2.3 td_ta_reset_stats F
+GLIBC_2.3 td_ta_set_event F
+GLIBC_2.3 td_ta_setconcurrency F
+GLIBC_2.3 td_ta_thr_iter F
+GLIBC_2.3 td_ta_tsd_iter F
+GLIBC_2.3 td_thr_clear_event F
+GLIBC_2.3 td_thr_dbresume F
+GLIBC_2.3 td_thr_dbsuspend F
+GLIBC_2.3 td_thr_event_enable F
+GLIBC_2.3 td_thr_event_getmsg F
+GLIBC_2.3 td_thr_get_info F
+GLIBC_2.3 td_thr_getfpregs F
+GLIBC_2.3 td_thr_getgregs F
+GLIBC_2.3 td_thr_getxregs F
+GLIBC_2.3 td_thr_getxregsize F
+GLIBC_2.3 td_thr_set_event F
+GLIBC_2.3 td_thr_setfpregs F
+GLIBC_2.3 td_thr_setgregs F
+GLIBC_2.3 td_thr_setprio F
+GLIBC_2.3 td_thr_setsigpending F
+GLIBC_2.3 td_thr_setxregs F
+GLIBC_2.3 td_thr_sigsetmask F
+GLIBC_2.3 td_thr_tls_get_addr F
+GLIBC_2.3 td_thr_tsd F
+GLIBC_2.3 td_thr_validate F
+GLIBC_2.3.3 GLIBC_2.3.3 A
+GLIBC_2.3.3 td_thr_tlsbase F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/libutil.abilist
@@ -0,0 +1,7 @@
+GLIBC_2.3 GLIBC_2.3 A
+GLIBC_2.3 forkpty F
+GLIBC_2.3 login F
+GLIBC_2.3 login_tty F
+GLIBC_2.3 logout F
+GLIBC_2.3 logwtmp F
+GLIBC_2.3 openpty F
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/makecontext.S
@@ -0,0 +1,146 @@
+/* makecontext() for FreeBSD/amd64.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#include <ucontext_i.h>
+
+/*
+   void makecontext(ucontext_t *ucp, void *func(), int argc, ...);
+
+
+   input parameters:
+
+   rdi		ucp
+   rsi		func
+   edx		argc
+   rcx		arg1	-> ucp.rdi
+   r8		arg2	-> ucp.rsi
+   r9		arg3	-> ucp.rdx
+    8(%rsp)	arg4	-> ucp.rcx
+   16(%rsp)	arg5	-> ucp.r8
+   24(%rsp)	arg6	-> ucp.r9
+   i*8+24(%rsp) arg(6+i)-> future stack
+
+*/
+
+ENTRY(__makecontext)
+
+	/* Compute the address of the stack.
+	   The information comes from us_stack element. */
+	movq	oSS_SP(%rdi), %rax
+	addq	oSS_SIZE(%rdi), %rax
+
+	/* Put start addr into ucp */
+	movq	%rsi, oRIP(%rdi)
+
+	/* properly align future stack */
+	andq $-16, %rax
+	subq   $8, %rax
+
+	/* Put the next context into preserved ucp.rbx
+	   (from the uc_link element).  */
+	movq	oLINK(%rdi), %rsi
+	movq	%rsi, oRBX(%rdi)
+
+	/* save future registers arguments */
+
+	orl %edx, %edx
+	jz L(param_done)
+
+	decl %edx
+	movq %rcx, oRDI(%rdi)
+	jz L(param_done)
+
+	decl %edx
+	movq %r8,  oRSI(%rdi)
+	jz L(param_done)
+
+	decl %edx
+	movq %r9,  oRDX(%rdi)
+	jz L(param_done)
+
+	movq 8(%rsp), %rsi
+	decl %edx
+	movq %rsi, oRCX(%rdi)
+	jz L(param_done)
+
+	movq 16(%rsp), %rcx
+	decl %edx
+	movq %rcx, oR8(%rdi)
+	jz L(param_done)
+
+	movq 24(%rsp), %rsi
+	decl %edx
+	movq %rsi, oR9(%rdi)
+	jz L(param_done)
+
+	/* we have to copy some arguments also on the future stack */
+	movl %edx, %ecx
+	negq %rdx
+	leaq -16(%rax,%rdx,8), %rax /* we a litle bit waste stack space */
+	orq  $8, %rax
+
+1:	movq 24(%rsp,%rcx,8), %rsi
+	movq %rsi,(%rax,%rcx,8)
+	loop 1b
+
+L(param_done):
+
+	/* Store the future stack pointer and chain helper code. */
+	leaq	L(exitcode)(%rip), %rdx
+	movq	%rax, oRSP(%rdi)
+	movq	%rdx, (%rax)
+
+	/* 'makecontext' returns no value.  */
+	ret
+
+/***************************************************************************/
+
+	/* This is the helper code which gets called if a function which
+	   is registered with 'makecontext' returns.  In this case we
+	   have to install the context listed in the uc_link element of
+	   the context 'makecontext' manipulated at the time of the
+	   'makecontext' call.  If the pointer is NULL the process must
+	   terminate.  */
+
+L(exitcode):
+	/* we don't bother with extra arguments left on the stack
+		- more than 6 arguments is rare
+		- setcontext changes stacks immediately
+		- exit will call _exit in near future
+	*/
+
+	movq %rbx, %rdi		/* argument for either syscall */
+	testq %rbx, %rbx	/* If it is zero exit.  */
+	jz 2f
+
+	call	JUMPTARGET(__setcontext)
+	/* If this returns (which can happen if the syscall fails) we'll
+	   exit the program with the return error value (-1).  */
+
+	movq %rax, %rdi
+2:	call	HIDDEN_JUMPTARGET(exit)
+	/* The 'exit' call should never return.  In case it does cause
+	   the process to terminate.  */
+	hlt
+END(__makecontext)
+
+weak_alias(__makecontext, makecontext)
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/pipe.S
@@ -0,0 +1,32 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY (__pipe)
+	DO_CALL (pipe, 1)
+	jb SYSCALL_ERROR_LABEL
+        movl %eax, 0(%rdi)
+        movl %edx, 4(%rdi)
+        xorl %eax, %eax
+L(pseudo_end):
+	ret
+PSEUDO_END (__pipe)
+libc_hidden_def (__pipe)
+weak_alias (__pipe, pipe)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/readelflib.c
@@ -0,0 +1,62 @@
+/* Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 1999 and
+		  Jakub Jelinek <jakub@redhat.com>, 1999.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+
+int process_elf32_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+int process_elf64_file (const char *file_name, const char *lib, int *flag,
+			unsigned int *osversion, char **soname,
+			void *file_contents, size_t file_length);
+
+/* Returns 0 if everything is ok, != 0 in case of error.  */
+int
+process_elf_file (const char *file_name, const char *lib, int *flag,
+		  unsigned int *osversion, char **soname, void *file_contents,
+		  size_t file_length)
+{
+  ElfW(Ehdr) *elf_header = (ElfW(Ehdr) *) file_contents;
+  int ret;
+
+  if (elf_header->e_ident [EI_CLASS] == ELFCLASS32)
+    return process_elf32_file (file_name, lib, flag, osversion, soname,
+			       file_contents, file_length);
+  else
+    {
+      ret = process_elf64_file (file_name, lib, flag, osversion, soname,
+				file_contents, file_length);
+      /* x86-64 64bit libraries are always LIBC6.  */
+      if (!ret)
+	*flag = FLAG_X8664_LIB64|FLAG_ELF_LIBC6;
+      return ret;
+    }
+}
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf32_file
+#define __ELF_NATIVE_CLASS 32
+#include "elf/readelflib.c"
+
+#undef __ELF_NATIVE_CLASS
+#undef process_elf_file
+#define process_elf_file process_elf64_file
+#define __ELF_NATIVE_CLASS 64
+#include "elf/readelflib.c"
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/rfork.S
@@ -0,0 +1,44 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__rfork)
+	/* save the return PC value into RSI */
+	movq 0(%rsp), %rsi;
+	DO_CALL (rfork, 1)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+	decq %rdx
+	andq %rdx, %rax
+
+	popq %rdx
+	cfi_adjust_cfa_offset(-8)
+
+	jmp  *%rsi
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__rfork)
+
+weak_alias (__rfork, rfork)
+
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/shlib-versions
@@ -0,0 +1 @@
+ld=ld-kfreebsd-x86-64.so.1
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sigcontextinfo.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/*
+native FreeBSD:
+        sighandler(int signum, int code,       struct sigcontext * sg, void * fault_ip)
+posix like:
+        sighandler(int signum, siginfo_t * si, struct sigcontext * sg, void * fault_ip)
+*/
+
+#define SIGCONTEXT long _code, struct sigcontext * _sg, void *
+#define SIGCONTEXT_EXTRA_ARGS _code, _sg,
+
+/* really, really, rest of glibc expects that struct sigcontext is the last argument */
+#define GET_PC(ctx)	((void *) (_sg)->sc_rip)
+#define GET_FRAME(ctx)	((void *) (_sg)->sc_rbp)
+#define GET_STACK(ctx)	((void *) (_sg)->sc_rsp)
+
+#define CALL_SIGHANDLER(handler, signo, ctx) \
+  (handler)((signo), SIGCONTEXT_EXTRA_ARGS (ctx))
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/start.S
@@ -0,0 +1,156 @@
+/* Startup code for FreeBSD/amd64 ABI.
+   Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Andreas Jaeger <aj@suse.de>, 2001.
+   FreeBSD modification by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.  The SVR4/i386 ABI (pages 3-31, 3-32) says that when the entry
+   point runs, most registers' values are unspecified, except for a few.
+   Blindly applied on amd64:
+
+   %rdx		Contains a function pointer to be registered with `atexit'.
+		This is how the dynamic linker arranges to have DT_FINI
+		functions called for shared libraries that have been loaded
+		before this code runs.
+
+   %rsp		The stack contains the arguments and environment:
+		0(%rsp)			argc
+		8(%rsp)			argv[0]
+		...
+		(8*argc)(%rsp)		NULL
+		(8*(argc+1))(%rsp)	envp[0]
+		...
+					NULL
+
+   But on amd64 %rsp also have to be 16-byte aligned,
+   standard C calling convention already passes arguments in registers.
+
+   FreeBSD uses %edi as pointer to arguments and environment, %rsp is passed aligned.
+   On entry from kernel, %rsp=%rdi or %rsp=%rdi-8,
+   on entry from ld.so, glibc might set up it slightly differently.
+
+   On FreeBSD, we use %rsi for passing function pointer to rtld_fini().
+   On entry from FreeBSD kernel, %rsi is cleared, %rdx is not cleared,
+   on entry from ld.so, glibc sets both %rsi and %rdx to point to rtld_fini().
+
+   Used interface (via %rdi, %rsi) is equal to standard C calling interface for
+
+   void _start(void *arg, void *rtld_fini());
+
+*/
+
+#include <sysdep.h>
+#include <libc-symbols.h>
+
+	weak_extern (_end)
+
+	.text
+	.globl _start
+	.type _start,@function
+_start:
+	cfi_startproc
+	cfi_undefined (rip)
+	/* Clear the frame pointer.  The ABI suggests this be done, to mark
+	   the outermost frame obviously.  */
+	xorl %ebp, %ebp		/* zero extending clears whole rbp */
+
+	/* Extract the arguments as encoded on the stack and set up
+	   the arguments for __libc_start_main (int (*main) (int, char **, char **),
+		   int argc, char *argv,
+		   void (*init) (void), void (*fini) (void),
+		   void (*rtld_fini) (void), void *stack_end).
+	   The arguments are passed via registers and on the stack:
+	main:		%rdi
+	argc:		%rsi
+	argv:		%rdx
+	init:		%rcx
+	fini:		%r8
+	rtld_fini:	%r9
+	stack_end:	stack.	*/
+
+	movq %rsi, %r9		/* Address of the shared library termination
+				   function.  */
+	movq 0(%rdi), %rsi	/* argument count.  */
+	leaq 8(%rdi), %rdx      /* argv starts just at above argc.  */
+
+	/* Align the stack to a 16 byte boundary to follow the ABI.  */
+	andq  $~15, %rsp
+
+	pushq %rax		/* Push garbage because we push 8 more bytes.  */
+
+	/* Provide the highest stack address to the user code (for stacks
+	   which grow downwards).  */
+	pushq %rsp
+
+#ifdef SHARED
+	/* Pass address of our own entry points to .fini and .init.  */
+	movq __libc_csu_fini@GOTPCREL(%rip), %r8
+	movq __libc_csu_init@GOTPCREL(%rip), %rcx
+
+	movq main@GOTPCREL(%rip), %rdi
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.	  */
+	call __libc_start_main@PLT
+#else
+	/* Pass address of our own entry points to .fini and .init.  */
+	movq $__libc_csu_fini, %r8
+	movq $__libc_csu_init, %rcx
+
+	movq $main, %rdi
+
+	/* Call the user's main function, and exit with its value.
+	   But let the libc call main.	  */
+	call __libc_start_main
+#endif
+
+	hlt			/* Crash if somehow `exit' does return.	 */
+	/* just reference _end, 
+	   it is needed as global symbol for brk() usage,
+	   it is a dead code on purpose.  */
+#ifdef SHARED
+	movq _end@GOTPCREL(%rip), %rax
+#else
+	movq $_end, %rax
+#endif
+	cfi_endproc
+/* Define a symbol for the first piece of initialized data.  */
+	.data
+	.globl __data_start
+__data_start:
+	.long 0
+	.weak data_start
+	data_start = __data_start
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/start_thread.S
@@ -0,0 +1,196 @@
+/* Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Bruno Haible <bruno@clisp.org>, 2002.
+   Modification for amd64 contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* __start_thread (flags, stack, func, arg)
+   calls __rfork (flags), and in the child sets the stack pointer and then
+   calls _exit (func (arg)).
+   It cannot be done in portable C.  */
+
+/*
+   The parameters are passed in registers:
+   rdi: flags for rfork
+   rsi: child_stack
+   rdx: func
+   rcx: arg
+*/
+
+#include <sysdep.h>
+#include <asm-syntax.h>
+
+#define SIG_SETMASK	3
+
+/* There is a window of a few instructions, right after the rfork
+   system call, where the handling of a signal would write garbage
+   into the stack shared by the parent and the child (assuming
+   RFMEM is set in flags).  To solve this: 1. We block all signals
+   around the rfork system call and unblock them afterwards in
+   the parent and in the child (but only after changing the stack
+   pointer).  2. The child accesses only values passed in registers
+   and on its own stack.  This way, if the parent is scheduled to
+   run first, and handles a signal, it will not affect the child;
+   and if the child runs first, and handles a signal, it will use
+   the child's stack and not affect the parent.
+*/
+
+	.text
+ENTRY (__start_thread)
+
+        /* Insert the argument onto the new aligned stack.  */
+        andq	$-16,%rsi
+        subq    $16,%rsi
+        movq    %rcx,8(%rsi)
+
+        /* Save the function pointer.  It will be popped off in the child */
+        movq    %rdx,0(%rsi)
+
+	testq	$32, %rdi	/* flags & RFMEM */
+	jnz	L(complex)
+
+        /* Do the system call.  */
+	movl    $SYS_ify(rfork),%eax
+        /* End FDE now, because in the child the unwind info will be
+           wrong.  */
+        cfi_endproc;
+        syscall			/* rdi and rsi are extra preserved */
+
+        jb SYSCALL_ERROR_LABEL
+
+	testq   %rdx,%rdx	/*  0 for the parent and 1 for the child */
+	jz     L(pseudo_end)	/* just return in parent */
+
+L(thread_start):
+
+	/* set up stack */
+	movq	%rsi, %rsp
+
+        /* Clear the frame pointer.  The ABI suggests this be done, to mark
+           the outermost frame obviously.  */
+        xorl    %ebp, %ebp
+
+L(thread_start2):
+
+        /* Set up arguments for the function call.  */
+        popq    %rax            /* Function to call.  */
+        popq    %rdi            /* Argument.  */
+        call    *%rax
+
+        /* Call exit with return value from function call. */
+        movq    %rax, %rdi
+        call    HIDDEN_JUMPTARGET (_exit)
+
+
+/******************************************************************************************************
+ *
+ * and now the complex one ...
+ *
+ ******************************************************************************************************/
+
+L(complex):
+
+        subq    $32, %rsp
+
+        /* save arguments - flags and stack */
+        movq    %rdi,0(%rsp)
+        movq    %rsi,8(%rsp)
+
+        /* Block all signals.  */
+        orq     $-1, %rax
+        movq    %rax, 16(%rsp)
+        movq    %rax, 24(%rsp)
+
+        leaq    16(%rsp), %rsi
+        movl    $SIG_SETMASK, %edi
+        movq    %rsi,%rdx
+        DO_CALL (sigprocmask, 3)
+        jb      L(error)
+
+        /* restore arguments - flags and stack */
+        movq    0(%rsp),%rdi
+        movq    8(%rsp),%rsi
+
+        /* Copy mask info into the child's stack.  */
+
+        subq    $16,%rsi
+        movq    16(%rsp),%rcx
+        movq    24(%rsp),%rdx
+        movq    %rcx, 0(%rsi)
+        movq    %rdx, 8(%rsi)
+
+        /* Perform the rfork system call.  */
+        DO_CALL (rfork, 1)
+        jb      L(error_unmask)
+
+        /* %rdx is now 0 for the parent and 1 for the child.  */
+        testq   %rdx, %rdx
+        jnz     L(child)
+
+        /* Save the child pid, currently in %rax.  */
+        movq    %rax, 0(%rsp)
+
+        /* Restore the previous signal mask.  */
+        movl    $SIG_SETMASK, %edi
+        leaq    16(%rsp), %rsi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+        /* Return the child pid, saved on stack.  */
+        movq    0(%rsp), %rax
+        addq    $32, %rsp
+L(pseudo_end):
+        ret
+
+L(error_unmask):
+
+        /* Save the error code, currently in %rax.  */
+        movq    %rax, 0(%rsp)
+
+        /* Restore the previous signal mask.  */
+        movq    $SIG_SETMASK, %rdi
+        leaq    16(%rsp), %rsi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+	/* load saved error code */
+        movq    0(%rsp), %rax
+
+L(error):
+        addq    $32, %rsp
+        jmp     SYSCALL_ERROR_LABEL
+
+L(child):/* Here we are in the child thread.  */
+
+        /* set up stack */
+        movq    %rsi, %rsp
+
+        /* Clear the frame pointer.  The ABI suggests this be done, to mark
+           the outermost frame obviously.  */
+        xorl    %ebp, %ebp
+
+        /* Restore the previous signal mask.  */
+        movq    $SIG_SETMASK, %rdi
+        xorl    %edx,%edx
+        DO_CALL (sigprocmask, 3)
+
+        addq    $16, %rsp
+        jmp     L(thread_start2)
+
+        cfi_startproc;
+
+PSEUDO_END (__start_thread)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/swapcontext.S
@@ -0,0 +1,32 @@
+/* swap current context.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text
+ENTRY(__swapcontext)
+        clc
+        DO_CALL (swapcontext, 2)
+        jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+
+PSEUDO_END(__swapcontext)
+
+weak_alias(__swapcontext, swapcontext)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys/io.h
@@ -0,0 +1,184 @@
+/* Copyright (C) 1996, 2000, 2002, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef	_SYS_IO_H
+#define	_SYS_IO_H	1
+
+#ifdef _MACHINE_CPUFUNC_H_
+#error "This header must not be used in combination with <machine/cpufunc.h>."
+#endif
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* If TURN_ON is TRUE, request for permission to do direct i/o on the
+   port numbers in the range [FROM,FROM+NUM-1].  Otherwise, turn I/O
+   permission off for that range.  This call requires root privileges.
+
+   Portability note: not all kFreeBSD platforms support this call.  Most
+   platforms based on the PC I/O architecture probably will, however. */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+                   int __turn_on) __THROW;
+
+/* Set the I/O privilege level to LEVEL.  If LEVEL>3, permission to
+   access any I/O port is granted.  This call requires root
+   privileges. */
+extern int iopl (int __level) __THROW;
+
+#if defined __GNUC__ && __GNUC__ >= 2
+
+static __inline unsigned char
+inb (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned char
+inb_p (unsigned short int port)
+{
+  unsigned char _v;
+
+  __asm__ __volatile__ ("inb %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw (unsigned short int port)
+{
+  unsigned short _v;
+
+  __asm__ __volatile__ ("inw %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned short int
+inw_p (unsigned short int port)
+{
+  unsigned short int _v;
+
+  __asm__ __volatile__ ("inw %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl (unsigned short int port)
+{
+  unsigned int _v;
+
+  __asm__ __volatile__ ("inl %w1,%0":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline unsigned int
+inl_p (unsigned short int port)
+{
+  unsigned int _v;
+  __asm__ __volatile__ ("inl %w1,%0\noutb %%al,$0x80":"=a" (_v):"Nd" (port));
+  return _v;
+}
+
+static __inline void
+outb (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outb_p (unsigned char value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outb %b0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outw (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1": :"a" (value), "Nd" (port));
+
+}
+
+static __inline void
+outw_p (unsigned short int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outw %w0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+outl (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1": :"a" (value), "Nd" (port));
+}
+
+static __inline void
+outl_p (unsigned int value, unsigned short int port)
+{
+  __asm__ __volatile__ ("outl %0,%w1\noutb %%al,$0x80": :"a" (value),
+			"Nd" (port));
+}
+
+static __inline void
+insb (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insb":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insw (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insw":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+insl (unsigned short int port, void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; insl":"=D" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsb (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsb":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsw (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsw":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+static __inline void
+outsl (unsigned short int port, const void *addr, unsigned long int count)
+{
+  __asm__ __volatile__ ("cld ; rep ; outsl":"=S" (addr),
+			"=c" (count):"d" (port), "0" (addr), "1" (count));
+}
+
+#endif	/* GNU C */
+
+__END_DECLS
+#endif /* _SYS_IO_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys/perm.h
@@ -0,0 +1,36 @@
+/* Copyright (C) 1996, 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYS_PERM_H
+#define _SYS_PERM_H	1
+
+#include <features.h>
+
+__BEGIN_DECLS
+
+/* Set port input/output permissions.  */
+extern int ioperm (unsigned long int __from, unsigned long int __num,
+		   int __turn_on) __THROW;
+
+
+/* Change I/O privilege level.  */
+extern int iopl (int __level) __THROW;
+
+__END_DECLS
+
+#endif	/* _SYS_PERM_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sys_fork.S
@@ -0,0 +1,36 @@
+/* Copyright (C) 1991-1992, 1994-1995, 1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+.text;
+ENTRY (__syscall_fork)
+	DO_CALL (fork, 0)
+	jb SYSCALL_ERROR_LABEL;
+	/* R1 is now 0 for the parent and 1 for the child.  Decrement it to
+	   make it -1 (all bits set) for the parent, and 0 (no bits set)
+	   for the child.  Then AND it with R0, so the parent gets
+	   R0&-1==R0, and the child gets R0&0==0.  */
+
+	decq	%rdx
+	andq	%rdx, %rax
+
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall_fork)
+libc_hidden_def (__syscall_fork)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysarch.h
@@ -0,0 +1,72 @@
+/* Parameters for the architecture specific system call.  amd64 version.
+   Copyright (C) 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _SYSARCH_H
+#define _SYSARCH_H	1
+
+#include <features.h>
+
+/* Function that can be used as first argument to 'sysarch'.  */
+enum
+  {
+    I386_GET_LDT = 0,
+#define I386_GET_LDT I386_GET_LDT
+    I386_SET_LDT = 1,
+#define I386_SET_LDT I386_SET_LDT
+    I386_GET_IOPERM = 3,
+#define I386_GET_IOPERM I386_GET_IOPERM
+    I386_SET_IOPERM = 4,
+#define I386_SET_IOPERM I386_SET_IOPERM
+    I386_GET_FSBASE = 7,
+#define I386_GET_FSBASE I386_GET_FSBASE
+    I386_SET_FSBASE = 8,
+#define I386_SET_FSBASE I386_SET_FSBASE
+    I386_GET_GSBASE = 9,
+#define I386_GET_GSBASE I386_GET_GSBASE
+    I386_SET_GSBASE = 10,
+#define I386_SET_GSBASE I386_SET_GSBASE
+    AMD64_GET_FSBASE = 128,
+#define	AMD64_GET_FSBASE AMD64_GET_FSBASE
+    AMD64_SET_FSBASE = 129,
+#define	AMD64_SET_FSBASE AMD64_SET_FSBASE
+    AMD64_GET_GSBASE = 130,
+#define	AMD64_GET_GSBASE AMD64_GET_GSBASE
+    AMD64_SET_GSBASE = 131
+#define	AMD64_SET_GSBASE AMD64_SET_GSBASE
+  };
+
+/* Argument struct for I386_GET_IOPERM and I386_SET_IOPERM.  */
+struct i386_ioperm_args
+  {
+    unsigned int start;
+    unsigned int length;
+    int enable;
+  };
+
+__BEGIN_DECLS
+
+extern int sysarch (int __cmd, void *__arg);
+
+#ifdef _LIBC
+extern int __sysarch (int __cmd, void *__arg);
+#endif
+
+__END_DECLS
+
+#endif /* _SYSARCH_H */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/syscall.S
@@ -0,0 +1,31 @@
+/* Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+	.text
+ENTRY (__syscall)
+	movq %rcx, %r10
+	movl $SYS_ify (syscall), %eax
+	syscall
+	jb SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__syscall)
+weak_alias (__syscall, syscall)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/syscalls-internal.h
@@ -0,0 +1,129 @@
+/* generally used "internal syscalls"
+   Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef KFREEBSD_INTERNAL_SYSCALLS_H
+#define KFREEBSD_INTERNAL_SYSCALLS_H
+
+#include <sys/syscall.h>
+
+/* 
+   for now, we do not care whether syscall succeeded,
+   we do not have defined 
+   INTERNAL_SYSCALL_ERROR_P and INTERNAL_SYSCALL_ERRNO
+   we do not store errno at all
+   to be sure, we return void
+*/
+
+#undef INTERNAL_SYSCALL_DECL
+#undef INTERNAL_SYSCALL_NCS
+#undef INTERNAL_SYSCALL
+#undef INTERNAL_SYSCALL_ERROR_P
+#undef INTERNAL_SYSCALL_ERRNO
+
+#define INTERNAL_SYSCALL_DECL(err)		\
+  do { } while (0)
+
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+  INTERNAL_SYSCALL_##name(name, err, nr, ##args)
+
+
+#define INTERNAL_SYSCALL_clock_gettime(name, err, nr, clkid, ts) \
+(void)({                                        \
+  register long int _a1 = (long int) (clkid);	\
+  register long int _a2 = (long int) (ts);	\
+  register long int result;			\
+  asm volatile (				\
+	"syscall"				\
+        : "=a" (result)				\
+        : "0" ((long int) SYS_##name),		\
+	  "D" (_a1),				\
+	  "S" (_a2)				\
+	: "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11"); \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_close(name, err, nr, fd) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int result;			\
+  asm volatile (				\
+	"syscall"				\
+        : "=a" (result)				\
+        : "0" ((long int) SYS_##name),		\
+	  "D" (_a1)				\
+	: "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11"); \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_kill(name, err, nr, pid, sig) \
+(void)({                                        \
+  register long int _a1 = (long int) (pid);	\
+  register long int _a2 = (long int) (sig);	\
+  register long int result;			\
+  asm volatile (				\
+	"syscall"				\
+        : "=a" (result)				\
+        : "0" ((long int) SYS_##name),		\
+	  "D" (_a1),				\
+	  "S" (_a2)				\
+	: "memory", "cc", "cx", "dx", "r8", "r9", "r10", "r11"); \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_write(name, err, nr, fd, buf, cnt) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int _a2 = (long int) (buf);	\
+  register long int _a3 = (long int) (cnt);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (				\
+	"syscall"				\
+        : "=a" (result),			\
+          "=d" (_trash)				\
+        : "0" ((long int) SYS_##name),		\
+	  "D" (_a1),				\
+	  "S" (_a2),				\
+	  "d" (_a3)				\
+          /*  beware rdx is not preserved after syscall */ \
+	: "memory", "cc", "cx", "r8", "r9", "r10", "r11"); \
+  result;                                       \
+})
+
+#define INTERNAL_SYSCALL_writev(name, err, nr, fd, iov, cnt) \
+(void)({                                        \
+  register long int _a1 = (long int) (fd);	\
+  register long int _a2 = (long int) (iov);	\
+  register long int _a3 = (long int) (cnt);	\
+  register long int result;			\
+  register long int _trash;			\
+  asm volatile (				\
+	"syscall"				\
+        : "=a" (result),			\
+          "=d" (_trash)				\
+        : "0" ((long int) SYS_##name),		\
+	  "D" (_a1),				\
+	  "S" (_a2),				\
+	  "d" (_a3)				\
+          /*  beware rdx is not preserved after syscall */ \
+	: "memory", "cc", "cx", "r8", "r9", "r10", "r11"); \
+  result;                                       \
+})
+
+#endif
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysdep.S
@@ -0,0 +1,40 @@
+/* Copyright (C) 2001, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* The following code is only used in the shared library when we
+   compile the reentrant version.  Otherwise each system call defines
+   each own version.  */
+
+#ifndef PIC
+
+/* The syscall stubs jump here when they detect an error.
+   The code for Linux is almost identical to the canonical Unix
+   code, except that the error number in %rax is negated.  */
+
+#undef CALL_MCOUNT
+#define CALL_MCOUNT /* Don't insert the profiling call, it clobbers %rax.  */
+
+	.text
+ENTRY (__syscall_error)
+
+#define __syscall_error __syscall_error_1
+#include <sysdeps/unix/x86_64/sysdep.S>
+
+#endif	/* !PIC */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/sysdep.h
@@ -0,0 +1,204 @@
+/* Copyright (C) 2001,02,03,04 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Modification for FreeBSD contributed by Petr Salinger, 2006.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef _KFREEBSD_X86_64_SYSDEP_H
+#define _KFREEBSD_X86_64_SYSDEP_H 1
+
+/* There is some commonality.  */
+#include <sysdeps/unix/x86_64/sysdep.h>
+/* Defines RTLD_PRIVATE_ERRNO and USE_DL_SYSINFO.  */
+#include <dl-sysdep.h>
+#include <tls.h>
+
+#ifdef __ASSEMBLER__
+
+/* We don't want the label for the error handle to be global when we define
+   it here.  */
+#ifdef PIC
+# define SYSCALL_ERROR_LABEL 0f
+#else
+# define SYSCALL_ERROR_LABEL syscall_error
+#endif
+
+#undef	PSEUDO
+#define	PSEUDO(name, syscall_name, args)				      \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+    jb SYSCALL_ERROR_LABEL;						      \
+  L(pseudo_end):
+
+#undef	PSEUDO_END
+#define	PSEUDO_END(name)						      \
+  SYSCALL_ERROR_HANDLER							      \
+  END (name)
+
+#undef	PSEUDO_NOERRNO
+#define	PSEUDO_NOERRNO(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args)
+
+#undef	PSEUDO_END_NOERRNO
+#define	PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+#define ret_NOERRNO ret
+
+#undef	PSEUDO_ERRVAL
+#define	PSEUDO_ERRVAL(name, syscall_name, args) \
+  .text;								      \
+  ENTRY (name)								      \
+    DO_CALL (syscall_name, args);					      \
+
+#undef	PSEUDO_END_ERRVAL
+#define	PSEUDO_END_ERRVAL(name) \
+  END (name)
+
+#define ret_ERRVAL ret
+
+#ifndef PIC
+#define SYSCALL_ERROR_HANDLER	/* Nothing here; code in sysdep.S is used.  */
+#elif RTLD_PRIVATE_ERRNO
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  leaq rtld_errno(%rip), %rcx;			\
+  movl %eax, (%rcx);				\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#else
+# if IS_IN (libc)
+#  define SYSCALL_ERROR_ERRNO __libc_errno
+# else
+#  define SYSCALL_ERROR_ERRNO errno
+# endif
+# define SYSCALL_ERROR_HANDLER			\
+0:						\
+  movq SYSCALL_ERROR_ERRNO@GOTTPOFF(%rip), %rcx;\
+  movl %eax, %fs:(%rcx);			\
+  orq $-1, %rax;				\
+  jmp L(pseudo_end);
+#endif	/* PIC */
+
+/* The FreeBSD/amd64 kernel expects the system call parameters in
+   registers according to the following table:
+
+    syscall number	rax
+    arg 1		rdi
+    arg 2		rsi
+    arg 3		rdx
+    arg 4		r10
+    arg 5		r8
+    arg 6		r9
+
+    The FreeBSD kernel internal syscall usage of registers:
+
+    preserved:
+	stack pointer			rsp
+	C preserved			rbx, rbp, r12-r15
+	some input params		rdi, rsi
+
+    destroyed:
+	return value(s)			rax, rdx, eflags
+	return address from syscall	rcx
+	eflags from syscall		r11
+	used internally			r8-r10
+
+    Normal function call, including calls to the system call stub
+    functions in the libc, get the first six parameters passed in
+    registers and the seventh parameter and later on the stack.  The
+    register use is as follows:
+
+     system call number	in the DO_CALL macro
+     arg 1		rdi
+     arg 2		rsi
+     arg 3		rdx
+     arg 4		rcx
+     arg 5		r8
+     arg 6		r9
+
+    We have to take care that the stack is aligned to 16 bytes.  When
+    called the stack is not aligned since the return address has just
+    been pushed.
+
+*/
+
+#undef	DO_CALL
+#define DO_CALL(syscall_name, args)		\
+    DOARGS_##args				\
+    movl $SYS_ify (syscall_name), %eax;		\
+    syscall;
+
+#define DOARGS_0 /* nothing */
+#define DOARGS_1 /* nothing */
+#define DOARGS_2 /* nothing */
+#define DOARGS_3 /* nothing */
+#define DOARGS_4 movq %rcx, %r10;
+#define DOARGS_5 DOARGS_4
+#define DOARGS_6 DOARGS_5
+#define DOARGS_7 DOARGS_6
+#define DOARGS_8 DOARGS_7
+
+#else   /* !__ASSEMBLER__ */
+
+#include <syscalls-inline.h>
+
+#endif	/* __ASSEMBLER__ */
+
+
+/* Pointer mangling support.  */
+#if IS_IN (rtld)
+/* We cannot use the thread descriptor because in ld.so we use setjmp
+   earlier than the descriptor is initialized.  */
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorq __pointer_chk_guard_local(%rip), reg;    \
+				rolq $17, reg
+#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
+				xorq __pointer_chk_guard_local(%rip), reg
+# else
+#  define PTR_MANGLE(reg)	asm ("xorq __pointer_chk_guard_local(%%rip), %0\n" \
+				     "rolq $17, %0"			      \
+				     : "=r" (reg) : "0" (reg))
+#  define PTR_DEMANGLE(reg)	asm ("rorq $17, %0\n"			      \
+				     "xorq __pointer_chk_guard_local(%%rip), %0" \
+				     : "=r" (reg) : "0" (reg))
+# endif
+#else
+# ifdef __ASSEMBLER__
+#  define PTR_MANGLE(reg)	xorq %fs:POINTER_GUARD, reg;		      \
+				rolq $17, reg
+#  define PTR_DEMANGLE(reg)	rorq $17, reg;				      \
+				xorq %fs:POINTER_GUARD, reg
+# else
+#  define PTR_MANGLE(var)	asm ("xorq %%fs:%c2, %0\n"		      \
+				     "rolq $17, %0"			      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+#  define PTR_DEMANGLE(var)	asm ("rorq $17, %0\n"			      \
+				     "xorq %%fs:%c2, %0"		      \
+				     : "=r" (var)			      \
+				     : "0" (var),			      \
+				       "i" (offsetof (tcbhead_t,	      \
+						      pointer_guard)))
+# endif
+#endif
+
+#endif /* _KFREEBSD_X86_64_SYSDEP_H  */
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/ucontext_i.h
@@ -0,0 +1,38 @@
+/* Offsets  needed in the makecontext() function implementation.
+   Copyright (C) 2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Offsets of the fields in the ucontext_t structure. */
+
+#define oRDI		24
+#define oRSI		32
+#define oRDX		40
+#define oRCX		48
+#define oR8		56
+#define oR9		64
+
+#define oRAX		72
+#define oRBX		80
+#define oRBP		88
+
+#define oRIP		176
+#define oRSP		200
+
+#define oLINK		816
+#define oSS_SP		824
+#define oSS_SIZE	832
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/x86_64/vfork.S
@@ -0,0 +1,70 @@
+/* Copyright (C) 1999, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+
+/* Clone the calling process, but without copying the whole address space.
+   The calling process is suspended until the new process exits or is
+   replaced by a call to `execve'.  Return -1 for errors, 0 to the new process,
+   and the process ID of the new process to the old process.  */
+
+ENTRY (__vfork)
+
+	/* Pop the return PC value into RDI.  */
+	popq	%rdi
+	cfi_adjust_cfa_offset(-8)
+	cfi_register(%rip, %rdi)
+
+#ifdef SAVE_PID
+        SAVE_PID
+#endif
+	/* Perform the system call.  */
+	DO_CALL (vfork, 0)
+	jb	L(error)	/* Branch forward if it failed.  */
+
+	/* In the parent process, %rdx == 0, %rax == child pid.  */
+	/* In the child process, %rdx == 1, %rax == parent pid.  */
+
+	/* Change %rax to be 0 in the child process.  */
+	decq	%rdx
+	andq	%rdx, %rax
+
+#ifdef RESTORE_PID_IN_PARENT
+	jz L(norestore)
+        RESTORE_PID_IN_PARENT
+L(norestore):
+#endif
+
+	/* Jump to the return PC.  */
+	jmp	*%rdi
+
+L(error):
+	/* Push back the return PC.  */
+	pushq	%rdi
+	cfi_adjust_cfa_offset(8)
+#ifdef RESTORE_PID_IN_PARENT
+        RESTORE_PID_IN_PARENT
+#endif
+	/* Branch to the error handler, hidden in PSEUDO_END.  */
+	jmp	SYSCALL_ERROR_LABEL
+L(pseudo_end):
+	ret
+PSEUDO_END (__vfork)
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknod.c
@@ -0,0 +1,48 @@
+/* xmknod call using old-style Unix mknod and mkfifo system calls.
+   Copyright (C) 1991, 1993, 1995-1997, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+extern int __syscall_mknod (const char *, mode_t, dev_t);
+extern int __mkfifo (const char *, mode_t);
+
+/* Create a device file named PATH, with permission and special bits MODE
+   and device number DEV (which can be constructed from major and minor
+   device numbers with the `makedev' macro above).  */
+int
+__xmknod (int vers, const char *path, mode_t mode, dev_t *dev)
+{
+  if (vers != _MKNOD_VER)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+  /* The FreeBSD mknod() system call cannot be used to create FIFOs; we
+     must use the mkfifo() system call for this purpose.  */
+  if (S_ISFIFO (mode))
+    return __mkfifo (path, mode & ~S_IFMT);
+
+  return __syscall_mknod (path, mode, *dev);
+}
+libc_hidden_def (__xmknod)
+
+weak_alias (__xmknod, _xmknod)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/xmknodat.c
@@ -0,0 +1,59 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sysdep.h>
+#include <sys/stat.h>
+#include <sys/user.h>
+#include <kernel-features.h>
+
+extern int __syscall_mknodat (int fd, const char *path,
+			      mode_t mode, dev_t dev);
+libc_hidden_proto (__syscall_mknodat)
+
+extern int __syscall_mkfifoat (int fd, const char *path,
+			       mode_t mode);
+libc_hidden_proto (__syscall_mkfifoat)
+
+/* Create a device file named PATH relative to FD, with permission and
+   special bits MODE and device number DEV (which can be constructed
+   from major and minor device numbers with the `makedev' macro above).  */
+int
+__xmknodat (int vers, int fd, const char *file, mode_t mode, dev_t * dev)
+{
+  if (vers != _MKNOD_VER)
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+
+      /* The FreeBSD mknod() system call cannot be used to create FIFOs; we
+         must use the mkfifo() system call for this purpose.  */
+      if (S_ISFIFO (mode))
+	return INLINE_SYSCALL (mkfifoat, 3, fd, file, mode);
+      else
+	return INLINE_SYSCALL (mknodat, 4, fd, file, mode, *dev);
+}
+
+libc_hidden_def (__xmknodat)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat.c
@@ -0,0 +1,47 @@
+/* xstat using FreeBSD stat, nstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include "stat16conv.c"
+
+int
+__xstat (int vers, const char *file, struct stat *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_stat (file, &buf16);
+      if (result == 0)
+	stat16_to_stat (&buf16, buf);
+      return result;
+    }
+  else if (__builtin_expect (vers == _STAT_VER_stat, 1))
+    return __syscall_stat (file, (struct stat16 *) buf);
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__xstat)
+
+weak_alias (__xstat, _xstat)
--- /dev/null
+++ b/sysdeps/unix/bsd/bsd4.4/kfreebsd/xstat64.c
@@ -0,0 +1,43 @@
+/* xstat using FreeBSD stat, nstat system calls.
+   Copyright (C) 1991,1995-1997,2000,2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <errno.h>
+#include <stddef.h>
+#include <sys/stat.h>
+
+#include "stat16conv.c"
+
+int
+__xstat64 (int vers, const char *file, struct stat64 *buf)
+{
+  if (__builtin_expect (vers == _STAT_VER, 1))
+    {
+      struct stat16 buf16;
+      int result = __syscall_stat (file, &buf16);
+      if (result == 0)
+	stat16_to_stat64 (&buf16, buf);
+      return result;
+    }
+  else
+    {
+      __set_errno (EINVAL);
+      return -1;
+    }
+}
+hidden_def (__xstat64)
